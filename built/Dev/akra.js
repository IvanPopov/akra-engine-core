var akra;
(function (akra) {
    (function (EAjaxDataTypes) {
        EAjaxDataTypes[EAjaxDataTypes["TEXT"] = 0] = "TEXT";
        EAjaxDataTypes[EAjaxDataTypes["JSON"] = 1] = "JSON";
        EAjaxDataTypes[EAjaxDataTypes["BLOB"] = 2] = "BLOB";
        EAjaxDataTypes[EAjaxDataTypes["ARRAY_BUFFER"] = 3] = "ARRAY_BUFFER";
        EAjaxDataTypes[EAjaxDataTypes["DOCUMENT"] = 4] = "DOCUMENT";
    })(akra.EAjaxDataTypes || (akra.EAjaxDataTypes = {}));
    var EAjaxDataTypes = akra.EAjaxDataTypes;

    (function (EAjaxHttpMethods) {
        EAjaxHttpMethods[EAjaxHttpMethods["GET"] = 1] = "GET";
        EAjaxHttpMethods[EAjaxHttpMethods["POST"] = 2] = "POST";
    })(akra.EAjaxHttpMethods || (akra.EAjaxHttpMethods = {}));
    var EAjaxHttpMethods = akra.EAjaxHttpMethods;
    (function (EAjaxHttpCodes) {
        EAjaxHttpCodes[EAjaxHttpCodes["OK"] = 200] = "OK";
        EAjaxHttpCodes[EAjaxHttpCodes["CREATED"] = 201] = "CREATED";
        EAjaxHttpCodes[EAjaxHttpCodes["ACCEPTED"] = 202] = "ACCEPTED";
        EAjaxHttpCodes[EAjaxHttpCodes["PARTIAL_INFORMATION"] = 203] = "PARTIAL_INFORMATION";
        EAjaxHttpCodes[EAjaxHttpCodes["MOVED"] = 301] = "MOVED";
        EAjaxHttpCodes[EAjaxHttpCodes["FOUND"] = 302] = "FOUND";
        EAjaxHttpCodes[EAjaxHttpCodes["METHOD"] = 303] = "METHOD";
        EAjaxHttpCodes[EAjaxHttpCodes["NOT_MODIFIED"] = 304] = "NOT_MODIFIED";
        EAjaxHttpCodes[EAjaxHttpCodes["BAD_REQUEST"] = 400] = "BAD_REQUEST";
        EAjaxHttpCodes[EAjaxHttpCodes["UNAUTHORIZED"] = 401] = "UNAUTHORIZED";
        EAjaxHttpCodes[EAjaxHttpCodes["PAYMENT_REQUIRED"] = 402] = "PAYMENT_REQUIRED";
        EAjaxHttpCodes[EAjaxHttpCodes["FORBIDDEN"] = 403] = "FORBIDDEN";
        EAjaxHttpCodes[EAjaxHttpCodes["NOT_FOUND"] = 404] = "NOT_FOUND";
        EAjaxHttpCodes[EAjaxHttpCodes["INTERNAL_ERROR"] = 500] = "INTERNAL_ERROR";
        EAjaxHttpCodes[EAjaxHttpCodes["NOT_IMPLEMENTED"] = 501] = "NOT_IMPLEMENTED";
        EAjaxHttpCodes[EAjaxHttpCodes["SERVICE_TEMPORARILY_OVERLOADED"] = 502] = "SERVICE_TEMPORARILY_OVERLOADED";
        EAjaxHttpCodes[EAjaxHttpCodes["GATEWAY_TIMEOUT"] = 503] = "GATEWAY_TIMEOUT";
    })(akra.EAjaxHttpCodes || (akra.EAjaxHttpCodes = {}));
    var EAjaxHttpCodes = akra.EAjaxHttpCodes;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EDataTypes) {
        EDataTypes[EDataTypes["BYTE"] = 0x1400] = "BYTE";
        EDataTypes[EDataTypes["UNSIGNED_BYTE"] = 0x1401] = "UNSIGNED_BYTE";
        EDataTypes[EDataTypes["SHORT"] = 0x1402] = "SHORT";
        EDataTypes[EDataTypes["UNSIGNED_SHORT"] = 0x1403] = "UNSIGNED_SHORT";
        EDataTypes[EDataTypes["INT"] = 0x1404] = "INT";
        EDataTypes[EDataTypes["UNSIGNED_INT"] = 0x1405] = "UNSIGNED_INT";
        EDataTypes[EDataTypes["FLOAT"] = 0x1406] = "FLOAT";
    })(akra.EDataTypes || (akra.EDataTypes = {}));
    var EDataTypes = akra.EDataTypes;

    (function (EDataTypeSizes) {
        EDataTypeSizes[EDataTypeSizes["BYTES_PER_BYTE"] = 1] = "BYTES_PER_BYTE";
        EDataTypeSizes[EDataTypeSizes["BYTES_PER_UNSIGNED_BYTE"] = 1] = "BYTES_PER_UNSIGNED_BYTE";
        EDataTypeSizes[EDataTypeSizes["BYTES_PER_UBYTE"] = 1] = "BYTES_PER_UBYTE";

        EDataTypeSizes[EDataTypeSizes["BYTES_PER_SHORT"] = 2] = "BYTES_PER_SHORT";
        EDataTypeSizes[EDataTypeSizes["BYTES_PER_UNSIGNED_SHORT"] = 2] = "BYTES_PER_UNSIGNED_SHORT";
        EDataTypeSizes[EDataTypeSizes["BYTES_PER_USHORT"] = 2] = "BYTES_PER_USHORT";

        EDataTypeSizes[EDataTypeSizes["BYTES_PER_INT"] = 4] = "BYTES_PER_INT";
        EDataTypeSizes[EDataTypeSizes["BYTES_PER_UNSIGNED_INT"] = 4] = "BYTES_PER_UNSIGNED_INT";
        EDataTypeSizes[EDataTypeSizes["BYTES_PER_UINT"] = 4] = "BYTES_PER_UINT";

        EDataTypeSizes[EDataTypeSizes["BYTES_PER_FLOAT"] = 4] = "BYTES_PER_FLOAT";
    })(akra.EDataTypeSizes || (akra.EDataTypeSizes = {}));
    var EDataTypeSizes = akra.EDataTypeSizes;
})(akra || (akra = {}));
/// <reference path="../idl/IConverter.ts" />
/// <reference path="../idl/EDataTypes.ts" />
/// <reference path="../idl/3d-party/fixes.d.ts" />
/// <reference path="../common.ts" />
var akra;
(function (akra) {
    (function (conv) {
        conv.conversionFormats;

        function parseBool(sValue) {
            return (sValue === "true");
        }
        conv.parseBool = parseBool;

        function parseString(sValue) {
            return String(sValue);
        }
        conv.parseString = parseString;

        function parseJSON(sJSON) {
            return eval('(' + sJSON + ')');
        }
        conv.parseJSON = parseJSON;

        /**
        * Convert text/html into Dom object.
        */
        function parseHTML(sHTML) {
            var pDivEl = document.createElement('div');

            pDivEl.innerHTML = sHTML;

            return pDivEl.childNodes;
        }
        conv.parseHTML = parseHTML;

        function parseHTMLDocument(sHtml) {
            var pDocFrag;
            var pNodes = parseHTML(sHtml);

            pDocFrag = document.createDocumentFragment();

            for (var i = 0, len = pNodes.length; i < len; ++i) {
                if (!akra.isDef(pNodes[i])) {
                    continue;
                }

                pDocFrag.appendChild(pNodes[i]);
            }

            return pDocFrag;
        }
        conv.parseHTMLDocument = parseHTMLDocument;

        function retrieve(pSrc, pDst, iStride, iFrom, iCount, iOffset, iLen) {
            if (typeof iStride === "undefined") { iStride = 1; }
            if (typeof iFrom === "undefined") { iFrom = 0; }
            if (typeof iOffset === "undefined") { iOffset = 0; }
            if (typeof iLen === "undefined") { iLen = iStride - iOffset; }
            if (!akra.isDef(iCount)) {
                iCount = (pSrc.length / iStride - iFrom);
            }

            if (iOffset + iLen > iStride) {
                iLen = iStride - iOffset;
            }

            var iBegin = iFrom * iStride;
            var n = 0;

            for (var i = 0; i < iCount; ++i) {
                for (var j = 0; j < iLen; ++j) {
                    pDst[n++] = (pSrc[iBegin + i * iStride + iOffset + j]);
                }
            }

            return n;
        }
        conv.retrieve = retrieve;

        function string2Array(sData, ppData, fnConv, iFrom) {
            if (typeof iFrom === "undefined") { iFrom = 0; }
            var pData = sData.split(/[\s]+/g);

            for (var i = 0, n = pData.length, j = 0; i < n; ++i) {
                if (pData[i] != "") {
                    ppData[iFrom + j] = fnConv(pData[i]);
                    j++;
                }
            }

            return j;
        }
        conv.string2Array = string2Array;
        function stoia(sData, ppData, iFrom) {
            return string2Array(sData, ppData, parseInt, iFrom);
        }
        conv.stoia = stoia;
        function stofa(sData, ppData, iFrom) {
            return string2Array(sData, ppData, parseFloat, iFrom);
        }
        conv.stofa = stofa;
        function stoba(sData, ppData, iFrom) {
            return string2Array(sData, ppData, parseBool, iFrom);
        }
        conv.stoba = stoba;
        function stosa(sData, ppData, iFrom) {
            return string2Array(sData, ppData, parseString, iFrom);
        }
        conv.stosa = stosa;

        function stoa(sData, n, sType, isArray) {
            if (typeof isArray === "undefined") { isArray = false; }
            var pRow = conv.conversionFormats[sType];
            var ppData = new (pRow.type)(n);
            pRow.converter(sData, ppData);

            if (n == 1 && !isArray) {
                return ppData[0];
            }

            return ppData;
        }
        conv.stoa = stoa;

        // data convertion
        conv.conversionFormats = {
            "int": { type: Int32Array, converter: stoia },
            "float": { type: Float32Array, converter: stofa },
            "boolean": { type: Array, converter: stoba },
            "string": { type: Array, converter: stosa }
        };

        //////////////////
        /**
        * Convert string to ArrayBuffer.
        */
        function stoab(s) {
            var len = s.length;
            var pCodeList = new Uint8Array(len);

            for (var i = 0; i < len; ++i) {
                pCodeList[i] = s.charCodeAt(i); /*& 0xFF;*/
            }

            return pCodeList.buffer;
        }
        conv.stoab = stoab;

        /**
        * Convert ArrayBuffer to string.
        */
        function abtos(pBuf, iByteOffset, iByteLength) {
            if (typeof iByteOffset === "undefined") { iByteOffset = 0; }
            if (typeof iByteLength === "undefined") { iByteLength = pBuf.byteLength; }
            var pData = new Uint8Array(pBuf, iByteOffset, iByteLength);
            var s = "";

            for (var n = 0; n < pData.length; ++n) {
                s += String.fromCharCode(pData[n]);
            }

            return s;
            // return String.fromCharCode.apply(null, Array.prototype.slice.call(new Uint8Array(pBuf), 0));
        }
        conv.abtos = abtos;

        /**
        * Convert ArrayBuffer to string via BlobReader.
        */
        function abtosAsync(pBuffer, callback) {
            var bb = new Blob([pBuffer]);
            var f = new FileReader();

            f.onload = function (e) {
                callback(e.target.result);
            };

            f.readAsText(bb);
        }
        conv.abtosAsync = abtosAsync;

        /**
        * Convert ArrayBuffer to typed array.
        */
        function abtota(pBuffer, eType) {
            switch (eType) {
                case 5126 /* FLOAT */:
                    return new Float32Array(pBuffer);
                case 5122 /* SHORT */:
                    return new Int16Array(pBuffer);
                case 5123 /* UNSIGNED_SHORT */:
                    return new Uint16Array(pBuffer);
                case 5124 /* INT */:
                    return new Int32Array(pBuffer);
                case 5125 /* UNSIGNED_INT */:
                    return new Uint32Array(pBuffer);
                case 5120 /* BYTE */:
                    return new Int8Array(pBuffer);
                default:
                case 5121 /* UNSIGNED_BYTE */:
                    return new Uint8Array(pBuffer);
            }
        }
        conv.abtota = abtota;

        /**
        * Blob to ArrayBuffer async.
        */
        function btoaAsync(pBlob, fn) {
            var pReader = new FileReader();

            pReader.onload = function (e) {
                fn(null, e.target.result);
            };

            pReader.onerror = function (e) {
                fn(e, null);
            };

            pReader.readAsArrayBuffer(pBlob);
        }
        conv.btoaAsync = btoaAsync;

        //DataURL to Blob object async.
        function dutobAsync(sBlobURL, fn) {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", sBlobURL, true);
            xhr.responseType = "blob";

            xhr.onload = function (e) {
                if (xhr.status == 200) {
                    fn(xhr.response);
                }
            };

            xhr.send();
        }
        conv.dutobAsync = dutobAsync;

        /**
        * Data URL to JSON.
        */
        function dutojAsync(sBlobURL, fn) {
            var xhr = new XMLHttpRequest();

            xhr.open("GET", sBlobURL, true);
            xhr.overrideMimeType('application/json');
            xhr.responseType = "json";

            xhr.onload = function (e) {
                if (xhr.status === 200) {
                    fn(xhr.response);
                }
            };

            xhr.send();
        }
        conv.dutojAsync = dutojAsync;

        /**
        * Data URL to Blob object.
        */
        function dutob(dataURI) {
            // convert base64 to raw binary data held in a string
            // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
            var byteString = atob(dataURI.split(',')[1]);

            // separate out the mime component
            var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];

            // write the bytes of the string to an ArrayBuffer
            var ab = new ArrayBuffer(byteString.length);
            var ia = new Uint8Array(ab);
            for (var i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }

            // write the ArrayBuffer to a blob, and you're done
            var bb = new Blob([ab], { type: mimeString });
            return bb;
        }
        conv.dutob = dutob;

        //TODO: remove this
        function toURL(data, mime) {
            if (typeof mime === "undefined") { mime = "text/plain"; }
            var blob;

            try  {
                blob = new Blob([data], { type: mime });
            } catch (e) {
                // Backwards-compatibility
                var bb = new BlobBuilder();
                bb.append(data);
                blob = bb.getBlob(mime);
            }

            return URL.createObjectURL(blob);
        }
        conv.toURL = toURL;

        /** Convert UTF8 string to Base64 string*/
        function utf8tob64(s) {
            return window.btoa(unescape(encodeURIComponent(s)));
        }
        conv.utf8tob64 = utf8tob64;

        function toUTF8(argString) {
            // Encodes an ISO-8859-1 string to UTF-8
            //
            // version: 1109.2015
            // discuss at: http://phpjs.org/functions/utf8_encode
            // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   improved by: sowberry
            // +    tweaked by: Jack
            // +   bugfixed by: Onno Marsman
            // +   improved by: Yves Sucaet
            // +   bugfixed by: Onno Marsman
            // +   bugfixed by: Ulrich
            // +   bugfixed by: Rafal Kukawski
            // *     example 1: utf8_encode('Kevin van Zonneveld');
            // *     returns 1: 'Kevin van Zonneveld'
            if (argString === null || typeof argString === "undefined") {
                return "";
            }

            // .replace(/\r\n/g, "\n").replace(/\r/g, "\n");
            var string = (argString + "");
            var utftext = "", start, end, stringl = 0;

            start = end = 0;
            stringl = string.length;
            for (var n = 0; n < stringl; n++) {
                var c1 = string.charCodeAt(n);
                var enc = null;

                if (c1 < 128) {
                    end++;
                } else if (c1 > 127 && c1 < 2048) {
                    enc = String.fromCharCode((c1 >> 6) | 192) + String.fromCharCode((c1 & 63) | 128);
                } else {
                    enc = String.fromCharCode((c1 >> 12) | 224) + String.fromCharCode(((c1 >> 6) & 63) | 128) + String.fromCharCode((c1 & 63) | 128);
                }
                if (enc !== null) {
                    if (end > start) {
                        utftext += string.slice(start, end);
                    }
                    utftext += enc;
                    start = end = n + 1;
                }
            }

            if (end > start) {
                utftext += string.slice(start, stringl);
            }

            return utftext;
        }
        conv.toUTF8 = toUTF8;

        function fromUTF8(str_data) {
            // http://kevin.vanzonneveld.net
            // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
            // +      input by: Aman Gupta
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   improved by: Norman "zEh" Fuchs
            // +   bugfixed by: hitwork
            // +   bugfixed by: Onno Marsman
            // +      input by: Brett Zamir (http://brett-zamir.me)
            // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // *     example 1: utf8_decode('Kevin van Zonneveld');
            // *     returns 1: 'Kevin van Zonneveld'
            var tmp_arr = [], i = 0, ac = 0, c1 = 0, c2 = 0, c3 = 0;

            str_data += "";

            while (i < str_data.length) {
                c1 = str_data.charCodeAt(i);
                if (c1 < 128) {
                    tmp_arr[ac++] = String.fromCharCode(c1);
                    i++;
                } else if (c1 > 191 && c1 < 224) {
                    c2 = str_data.charCodeAt(i + 1);
                    tmp_arr[ac++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
                    i += 2;
                } else {
                    c2 = str_data.charCodeAt(i + 1);
                    c3 = str_data.charCodeAt(i + 2);
                    tmp_arr[ac++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                    i += 3;
                }
            }

            return tmp_arr.join("");
        }
        conv.fromUTF8 = fromUTF8;
    })(akra.conv || (akra.conv = {}));
    var conv = akra.conv;
})(akra || (akra = {}));
/// <reference path="../conv/conv.ts" />
var akra;
(function (akra) {
    (function (crypto) {
        function sha1(str) {
            // http://kevin.vanzonneveld.net
            // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
            // + namespaced by: Michael White (http://getsprink.com)
            // +      input by: Brett Zamir (http://brett-zamir.me)
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // -    depends on: utf8_encode
            // *     example 1: sha1('Kevin van Zonneveld');
            // *     returns 1: '54916d2e62f65b3afa6e192e6a601cdbe5cb5897'
            var rotate_left = function (n, s) {
                var t4 = (n << s) | (n >>> (32 - s));
                return t4;
            };

            /*var lsb_hex = function (val) {
            var str="";
            var i;
            var vh;
            var vl;
            
            for ( i=0; i<=6; i+=2 ) {
            vh = (val>>>(i*4+4))&0x0f;
            vl = (val>>>(i*4))&0x0f;
            str += vh.toString(16) + vl.toString(16);
            }
            return str;
            };*/
            var cvt_hex = function (val) {
                var str = "";
                var i;
                var v;

                for (i = 7; i >= 0; i--) {
                    v = (val >>> (i * 4)) & 0x0f;
                    str += v.toString(16);
                }
                return str;
            };

            var blockstart;
            var i, j;
            var W = new Array(80);
            var H0 = 0x67452301;
            var H1 = 0xEFCDAB89;
            var H2 = 0x98BADCFE;
            var H3 = 0x10325476;
            var H4 = 0xC3D2E1F0;
            var A, B, C, D, E;
            var temp;

            str = akra.conv.toUTF8(str);
            var str_len = str.length;

            var word_array = [];
            for (i = 0; i < str_len - 3; i += 4) {
                j = str.charCodeAt(i) << 24 | str.charCodeAt(i + 1) << 16 | str.charCodeAt(i + 2) << 8 | str.charCodeAt(i + 3);
                word_array.push(j);
            }

            switch (str_len % 4) {
                case 0:
                    i = 0x080000000;
                    break;
                case 1:
                    i = str.charCodeAt(str_len - 1) << 24 | 0x0800000;
                    break;
                case 2:
                    i = str.charCodeAt(str_len - 2) << 24 | str.charCodeAt(str_len - 1) << 16 | 0x08000;
                    break;
                case 3:
                    i = str.charCodeAt(str_len - 3) << 24 | str.charCodeAt(str_len - 2) << 16 | str.charCodeAt(str_len - 1) << 8 | 0x80;
                    break;
            }

            word_array.push(i);

            while ((word_array.length % 16) != 14) {
                word_array.push(0);
            }

            word_array.push(str_len >>> 29);
            word_array.push((str_len << 3) & 0x0ffffffff);

            for (blockstart = 0; blockstart < word_array.length; blockstart += 16) {
                for (i = 0; i < 16; i++) {
                    W[i] = word_array[blockstart + i];
                }
                for (i = 16; i <= 79; i++) {
                    W[i] = rotate_left(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
                }

                A = H0;
                B = H1;
                C = H2;
                D = H3;
                E = H4;

                for (i = 0; i <= 19; i++) {
                    temp = (rotate_left(A, 5) + ((B & C) | (~B & D)) + E + W[i] + 0x5A827999) & 0x0ffffffff;
                    E = D;
                    D = C;
                    C = rotate_left(B, 30);
                    B = A;
                    A = temp;
                }

                for (i = 20; i <= 39; i++) {
                    temp = (rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + 0x6ED9EBA1) & 0x0ffffffff;
                    E = D;
                    D = C;
                    C = rotate_left(B, 30);
                    B = A;
                    A = temp;
                }

                for (i = 40; i <= 59; i++) {
                    temp = (rotate_left(A, 5) + ((B & C) | (B & D) | (C & D)) + E + W[i] + 0x8F1BBCDC) & 0x0ffffffff;
                    E = D;
                    D = C;
                    C = rotate_left(B, 30);
                    B = A;
                    A = temp;
                }

                for (i = 60; i <= 79; i++) {
                    temp = (rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + 0xCA62C1D6) & 0x0ffffffff;
                    E = D;
                    D = C;
                    C = rotate_left(B, 30);
                    B = A;
                    A = temp;
                }

                H0 = (H0 + A) & 0x0ffffffff;
                H1 = (H1 + B) & 0x0ffffffff;
                H2 = (H2 + C) & 0x0ffffffff;
                H3 = (H3 + D) & 0x0ffffffff;
                H4 = (H4 + E) & 0x0ffffffff;
            }

            temp = cvt_hex(H0) + cvt_hex(H1) + cvt_hex(H2) + cvt_hex(H3) + cvt_hex(H4);
            return temp.toLowerCase();
        }
        crypto.sha1 = sha1;
    })(akra.crypto || (akra.crypto = {}));
    var crypto = akra.crypto;
})(akra || (akra = {}));
/// <reference path="../conv/conv.ts" />
var akra;
(function (akra) {
    (function (crypto) {
        function md5(str) {
            // http://kevin.vanzonneveld.net
            // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
            // + namespaced by: Michael White (http://getsprink.com)
            // +    tweaked by: Jack
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +      input by: Brett Zamir (http://brett-zamir.me)
            // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // -    depends on: utf8_encode
            // *     example 1: md5('Kevin van Zonneveld');
            // *     returns 1: '6e658d4bfcb59cc13f96c14450ac40b9'
            var xl, a, b, c, d, e;

            var rotateLeft = function (lValue, iShiftBits) {
                return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
            };

            var addUnsigned = function (lX, lY) {
                var lX4, lY4, lX8, lY8, lResult;
                lX8 = (lX & 0x80000000);
                lY8 = (lY & 0x80000000);
                lX4 = (lX & 0x40000000);
                lY4 = (lY & 0x40000000);
                lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
                if (lX4 & lY4) {
                    return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
                }
                if (lX4 | lY4) {
                    if (lResult & 0x40000000) {
                        return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
                    } else {
                        return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
                    }
                } else {
                    return (lResult ^ lX8 ^ lY8);
                }
            };

            var _F = function (x, y, z) {
                return (x & y) | ((~x) & z);
            };
            var _G = function (x, y, z) {
                return (x & z) | (y & (~z));
            };
            var _H = function (x, y, z) {
                return (x ^ y ^ z);
            };
            var _I = function (x, y, z) {
                return (y ^ (x | (~z)));
            };

            var _FF = function (a, b, c, d, x, s, ac) {
                a = addUnsigned(a, addUnsigned(addUnsigned(_F(b, c, d), x), ac));
                return addUnsigned(rotateLeft(a, s), b);
            };

            var _GG = function (a, b, c, d, x, s, ac) {
                a = addUnsigned(a, addUnsigned(addUnsigned(_G(b, c, d), x), ac));
                return addUnsigned(rotateLeft(a, s), b);
            };

            var _HH = function (a, b, c, d, x, s, ac) {
                a = addUnsigned(a, addUnsigned(addUnsigned(_H(b, c, d), x), ac));
                return addUnsigned(rotateLeft(a, s), b);
            };

            var _II = function (a, b, c, d, x, s, ac) {
                a = addUnsigned(a, addUnsigned(addUnsigned(_I(b, c, d), x), ac));
                return addUnsigned(rotateLeft(a, s), b);
            };

            var convertToWordArray = function (str) {
                var lWordCount;
                var lMessageLength = str.length;
                var lNumberOfWords_temp1 = lMessageLength + 8;
                var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
                var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
                var lWordArray = new Array(lNumberOfWords - 1);
                var lBytePosition = 0;
                var lByteCount = 0;
                while (lByteCount < lMessageLength) {
                    lWordCount = (lByteCount - (lByteCount % 4)) / 4;
                    lBytePosition = (lByteCount % 4) * 8;
                    lWordArray[lWordCount] = (lWordArray[lWordCount] | (str.charCodeAt(lByteCount) << lBytePosition));
                    lByteCount++;
                }
                lWordCount = (lByteCount - (lByteCount % 4)) / 4;
                lBytePosition = (lByteCount % 4) * 8;
                lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
                lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
                lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
                return lWordArray;
            };

            var wordToHex = function (lValue) {
                var wordToHexValue = "", wordToHexValue_temp = "", lByte, lCount;
                for (lCount = 0; lCount <= 3; lCount++) {
                    lByte = (lValue >>> (lCount * 8)) & 255;
                    wordToHexValue_temp = "0" + lByte.toString(16);
                    wordToHexValue = wordToHexValue + wordToHexValue_temp.substr(wordToHexValue_temp.length - 2, 2);
                }
                return wordToHexValue;
            };

            var x = [], k, AA, BB, CC, DD, a, b, c, d, S11 = 7, S12 = 12, S13 = 17, S14 = 22, S21 = 5, S22 = 9, S23 = 14, S24 = 20, S31 = 4, S32 = 11, S33 = 16, S34 = 23, S41 = 6, S42 = 10, S43 = 15, S44 = 21;

            str = akra.conv.toUTF8(str);
            x = convertToWordArray(str);
            a = 0x67452301;
            b = 0xEFCDAB89;
            c = 0x98BADCFE;
            d = 0x10325476;

            xl = x.length;
            for (k = 0; k < xl; k += 16) {
                AA = a;
                BB = b;
                CC = c;
                DD = d;
                a = _FF(a, b, c, d, x[k + 0], S11, 0xD76AA478);
                d = _FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
                c = _FF(c, d, a, b, x[k + 2], S13, 0x242070DB);
                b = _FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
                a = _FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
                d = _FF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
                c = _FF(c, d, a, b, x[k + 6], S13, 0xA8304613);
                b = _FF(b, c, d, a, x[k + 7], S14, 0xFD469501);
                a = _FF(a, b, c, d, x[k + 8], S11, 0x698098D8);
                d = _FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
                c = _FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
                b = _FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
                a = _FF(a, b, c, d, x[k + 12], S11, 0x6B901122);
                d = _FF(d, a, b, c, x[k + 13], S12, 0xFD987193);
                c = _FF(c, d, a, b, x[k + 14], S13, 0xA679438E);
                b = _FF(b, c, d, a, x[k + 15], S14, 0x49B40821);
                a = _GG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
                d = _GG(d, a, b, c, x[k + 6], S22, 0xC040B340);
                c = _GG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
                b = _GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
                a = _GG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
                d = _GG(d, a, b, c, x[k + 10], S22, 0x2441453);
                c = _GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
                b = _GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
                a = _GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
                d = _GG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
                c = _GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
                b = _GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
                a = _GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
                d = _GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
                c = _GG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
                b = _GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
                a = _HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
                d = _HH(d, a, b, c, x[k + 8], S32, 0x8771F681);
                c = _HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
                b = _HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
                a = _HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
                d = _HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
                c = _HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
                b = _HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
                a = _HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
                d = _HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
                c = _HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
                b = _HH(b, c, d, a, x[k + 6], S34, 0x4881D05);
                a = _HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
                d = _HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
                c = _HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
                b = _HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
                a = _II(a, b, c, d, x[k + 0], S41, 0xF4292244);
                d = _II(d, a, b, c, x[k + 7], S42, 0x432AFF97);
                c = _II(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
                b = _II(b, c, d, a, x[k + 5], S44, 0xFC93A039);
                a = _II(a, b, c, d, x[k + 12], S41, 0x655B59C3);
                d = _II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
                c = _II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
                b = _II(b, c, d, a, x[k + 1], S44, 0x85845DD1);
                a = _II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
                d = _II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
                c = _II(c, d, a, b, x[k + 6], S43, 0xA3014314);
                b = _II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
                a = _II(a, b, c, d, x[k + 4], S41, 0xF7537E82);
                d = _II(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
                c = _II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
                b = _II(b, c, d, a, x[k + 9], S44, 0xEB86D391);
                a = addUnsigned(a, AA);
                b = addUnsigned(b, BB);
                c = addUnsigned(c, CC);
                d = addUnsigned(d, DD);
            }

            var temp = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);

            return temp.toLowerCase();
        }
        crypto.md5 = md5;
    })(akra.crypto || (akra.crypto = {}));
    var crypto = akra.crypto;
})(akra || (akra = {}));
/// <reference path="../conv/conv.ts" />
var akra;
(function (akra) {
    (function (crypto) {
        function crc32(str) {
            // http://kevin.vanzonneveld.net
            // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
            // +   improved by: T0bsn
            // -    depends on: utf8_encode
            // *     example 1: crc32('Kevin van Zonneveld');
            // *     returns 1: 1249991249
            str = akra.conv.toUTF8(str);
            var table = "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D";

            var crc = 0;
            var x = 0;
            var y = 0;

            crc = crc ^ (-1);
            for (var i = 0, iTop = str.length; i < iTop; i++) {
                y = (crc ^ str.charCodeAt(i)) & 0xFF;
                x = parseInt("0x" + table.substr(y * 9, 8), 10);
                crc = (crc >>> 8) ^ x;
            }

            return String(crc ^ (-1));
        }
        crypto.crc32 = crc32;
    })(akra.crypto || (akra.crypto = {}));
    var crypto = akra.crypto;
})(akra || (akra = {}));
/// <reference path="conv/conv.ts" />
/// <reference path="crypto/sha-1.ts" />
/// <reference path="crypto/md5.ts" />
/// <reference path="crypto/crc32.ts" />

var akra;
(function (akra) {
    akra.typeOf = function (x) {
        var s = typeof x;

        if (s === "object") {
            if (x) {
                if (x instanceof Array) {
                    return "array";
                } else if (x instanceof Object) {
                    return s;
                }

                var sClassName = Object.prototype.toString.call(x);

                if (sClassName === "[object Window]") {
                    return "object";
                }

                if ((sClassName === "[object Array]" || (typeof x.length) === "number" && (typeof x.splice) !== "undefined" && (typeof x.propertyIsEnumerable) !== "undefined" && !x.propertyIsEnumerable("splice"))) {
                    return "array";
                }

                if ((sClassName === "[object Function]" || (typeof x.call) !== "undefined" && (typeof x.propertyIsEnumerable) !== "undefined" && !x.propertyIsEnumerable("call"))) {
                    return "function";
                }
            } else {
                return "null";
            }
        } else if (s === "function" && (typeof x.call) === "undefined") {
            return "object";
        }

        return s;
    };

    akra.isDef = function (x) {
        return x !== undefined;
    };
    akra.isDefAndNotNull = function (x) {
        return x != null;
    };
    akra.isEmpty = function (x) {
        return x.length === 0;
    };
    akra.isNull = function (x) {
        return x === null;
    };
    akra.isBoolean = function (x) {
        return typeof x === "boolean";
    };
    akra.isString = function (x) {
        return typeof x === "string";
    };
    akra.isNumber = function (x) {
        return typeof x === "number";
    };
    akra.isFloat = akra.isNumber;

    //export var isInt = isNumber;
    //export var isUint = isNumber;
    akra.isInt = function (x) {
        return akra.isNumber(x) && (~~x === x);
    };
    akra.isUint = function (x) {
        return akra.isInt(x) && x > 0;
    };
    akra.isFunction = function (x) {
        return akra.typeOf(x) === "function";
    };
    akra.isObject = function (x) {
        var type = akra.typeOf(x);
        return type === "object" || type === "array" || type === "function";
    };
    akra.isArrayBuffer = function (x) {
        return x instanceof ArrayBuffer;
    };
    akra.isTypedArray = function (x) {
        return x !== null && typeof x === "object" && typeof x.byteOffset === "number";
    };
    akra.isBlob = function (x) {
        return x instanceof Blob;
    };
    akra.isArray = function (x) {
        return akra.typeOf(x) === "array";
    };

    String.prototype.replaceAt = function (n, chr) {
        return this.substr(0, n) + chr + this.substr(n + chr.length);
    };

    /** @expose */
    Array.prototype.first;
    Object.defineProperty(Array.prototype, 'first', {
        enumerable: false,
        configurable: true,
        get: function () {
            return this[0];
        }
    });

    /** @expose */
    Array.prototype.last;
    Object.defineProperty(Array.prototype, 'last', {
        enumerable: false,
        configurable: true,
        get: function () {
            return this[this.length - 1];
        }
    });

    /** @expose */
    Array.prototype.el;
    Object.defineProperty(Array.prototype, 'el', {
        enumerable: false,
        configurable: true,
        value: function (i) {
            i = i || 0;
            return this[i < 0 ? this.length + i : i];
        }
    });

    /** @expose */
    Array.prototype.clear;
    Object.defineProperty(Array.prototype, 'clear', {
        enumerable: false,
        configurable: true,
        value: function () {
            this.length = 0;
        }
    });

    /** @expose */
    Array.prototype.swap;
    Object.defineProperty(Array.prototype, 'swap', {
        enumerable: false,
        configurable: true,
        value: function (i, j) {
            if (i < this.length && j < this.length) {
                var t = this[i];
                this[i] = this[j];
                this[j] = t;
            }
        }
    });

    /** @expose */
    Array.prototype.insert;
    Object.defineProperty(Array.prototype, 'insert', {
        enumerable: false,
        configurable: true,
        value: function (pElement) {
            if (typeof pElement.length === 'number') {
                for (var i = 0, n = pElement.length; i < n; ++i) {
                    this.push(pElement[i]);
                }
                ;
            } else {
                this.push(pElement);
            }

            return this;
        }
    });

    Number.prototype.toHex = function (iLength) {
        var sValue = this.toString(16);

        for (var i = 0; i < iLength - sValue.length; ++i) {
            sValue = '0' + sValue;
        }

        return sValue;
    };

    Number.prototype.printBinary = function (isPretty) {
        if (typeof isPretty === "undefined") { isPretty = true; }
        var res = "";
        for (var i = 0; i < 32; ++i) {
            if (i && (i % 4) == 0 && isPretty) {
                res = ' ' + res;
            }
            (this >> i & 0x1 ? res = '1' + res : res = '0' + res);
        }
        return res;
    };
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (ELogLevel) {
        ELogLevel[ELogLevel["NONE"] = 0x0000] = "NONE";
        ELogLevel[ELogLevel["LOG"] = 0x0001] = "LOG";
        ELogLevel[ELogLevel["INFORMATION"] = 0x0002] = "INFORMATION";
        ELogLevel[ELogLevel["WARNING"] = 0x0004] = "WARNING";
        ELogLevel[ELogLevel["ERROR"] = 0x0008] = "ERROR";
        ELogLevel[ELogLevel["CRITICAL"] = 0x0010] = "CRITICAL";
        ELogLevel[ELogLevel["ALL"] = 0x001F] = "ALL";
    })(akra.ELogLevel || (akra.ELogLevel = {}));
    var ELogLevel = akra.ELogLevel;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (bf) {
        /**
        * Сдвиг единицы на @a x позиций влево.
        */
        bf.flag = function (x) {
            return (1 << (x));
        };

        /**
        * Проверка того что у @a value бит под номером @a bit равен единице.
        */
        bf.testBit = function (value, bit) {
            return ((value & bf.flag(bit)) != 0);
        };

        /**
        * Проверка того что у @a value равны единице все биты,
        * которые равны единице у @a set.
        */
        bf.testAll = function (value, set) {
            return (((value) & (set)) == (set));
        };

        /**
        * Проверка того что у @a value равны единице хотя бы какие то из битов,
        * которые равны единице у @a set.
        */
        bf.testAny = function (value, set) {
            return (((value) & (set)) != 0);
        };

        /**
        * Выставляет бит под номером @a bit у числа @a value равным единице
        */
        bf.setBit = function (value, bit, setting) {
            if (typeof setting === "undefined") { setting = true; }
            return (setting ? ((value) |= bf.flag((bit))) : bf.clearBit(value, bit));
        };

        /**
        *
        */
        bf.clearBit = function (value, bit) {
            return ((value) &= ~bf.flag((bit)));
        };

        /**
        * Выставляет бит под номером @a bit у числа @a value равным нулю
        */
        bf.setAll = function (value, set, setting) {
            if (typeof setting === "undefined") { setting = true; }
            return (setting ? ((value) |= (set)) : ((value) &= ~(set)));
        };

        /**
        * Выставляет все биты у числа @a value равными единице,
        * которые равны единице у числа @a set
        */
        bf.clearAll = function (value, set) {
            return ((value) &= ~(set));
        };

        /**
        * Выставляет все биты у числа @a value равными нулю,
        * которые равны единице у числа @a set
        */
        bf.equal = function (value, src) {
            value = src;
        };

        /**
        * Прирасваивает числу @a value число @a src
        */
        bf.isEqual = function (value, src) {
            return value == src;
        };

        /**
        * Если число @a value равно числу @a src возвращается true
        */
        bf.isNotEqaul = function (value, src) {
            return value != src;
        };

        /**
        * Прирасваивает числу @a value число @a src
        */
        bf.set = function (value, src) {
            value = src;
        };

        /**
        * Обнуляет число @a value
        */
        bf.clear = function (value) {
            value = 0;
        };

        /**
        * Выставляет все биты у числа @a value равными единице,
        * которые равны единице у числа @a src
        */
        bf.setFlags = function (value, src) {
            return (value |= src);
        };

        /**
        * Выставляет все биты у числа @a value равными нулю,
        * которые равны единице у числа @a src
        */
        bf.clearFlags = function (value, src) {
            return value &= ~src;
        };

        /**
        * Проверяет равно ли число @a value нулю. Если равно возвращает true.
        * Если не равно возвращает false.
        */
        bf.isEmpty = function (value) {
            return (value == 0);
        };

        /**
        * Возвращает общее количество бит числа @a value.
        * На самом деле возвращает всегда 32.
        */
        bf.totalBits = function (value) {
            return 32;
        };

        /**
        * Возвращает общее количество ненулевых бит числа @a value.
        */
        bf.totalSet = function (value) {
            var count = 0;
            var total = bf.totalBits(value);

            for (var i = total; i; --i) {
                count += (value & 1);
                value >>= 1;
            }

            return (count);
        };

        /**
        * Convert N bit colour channel value to P bits. It fills P bits with the
        * bit pattern repeated. (this is /((1<<n)-1) in fixed point)
        */
        function fixedToFixed(value, n, p) {
            if (n > p) {
                // Less bits required than available; this is easy
                value >>= n - p;
            } else if (n < p) {
                // More bits required than are there, do the fill
                // Use old fashioned division, probably better than a loop
                if (value == 0)
                    value = 0;
                else if (value == ((1) << n) - 1)
                    value = (1 << p) - 1;
                else
                    value = value * (1 << p) / ((1 << n) - 1);
            }
            return value;
        }
        bf.fixedToFixed = fixedToFixed;

        /**
        * Convert floating point colour channel value between 0.0 and 1.0 (otherwise clamped)
        * to integer of a certain number of bits. Works for any value of bits between 0 and 31.
        */
        function floatToFixed(value, bits) {
            if (value <= 0.0)
                return 0;
            else if (value >= 1.0)
                return (1 << bits) - 1;
            else
                return (value * (1 << bits));
        }
        bf.floatToFixed = floatToFixed;

        /**
        * Fixed point to float
        */
        function fixedToFloat(value, bits) {
            return (value & ((1 << bits) - 1)) / ((1 << bits) - 1);
        }
        bf.fixedToFloat = fixedToFloat;

        /**
        * Write a n*8 bits integer value to memory in native endian.
        */
        function intWrite(pDest, n, value) {
            switch (n) {
                case 1:
                    pDest[0] = value;
                    break;
                case 2:
                    pDest[1] = ((value >> 8) & 0xFF);
                    pDest[0] = (value & 0xFF);
                    break;
                case 3:
                    pDest[2] = ((value >> 16) & 0xFF);
                    pDest[1] = ((value >> 8) & 0xFF);
                    pDest[0] = (value & 0xFF);
                    break;
                case 4:
                    pDest[3] = ((value >> 24) & 0xFF);
                    pDest[2] = ((value >> 16) & 0xFF);
                    pDest[1] = ((value >> 8) & 0xFF);
                    pDest[0] = (value & 0xFF);
                    break;
            }

            return;
        }
        bf.intWrite = intWrite;

        /**
        * Read a n*8 bits integer value to memory in native endian.
        */
        function intRead(pSrc, n) {
            switch (n) {
                case 1:
                    return pSrc[0];
                case 2:
                    return pSrc[0] | pSrc[1] << 8;
                case 3:
                    return pSrc[0] | pSrc[1] << 8 | pSrc[2] << 16;
                case 4:
                    return (pSrc[0]) | (pSrc[1] << 8) | (pSrc[2] << 16) | (pSrc[3] << 24);
            }
            return 0;
        }
        bf.intRead = intRead;

        //float32/uint32 union
        var _u32 = new Uint32Array(1);
        var _f32 = new Float32Array(_u32.buffer);

        function floatToHalf(f) {
            _f32[0] = f;
            return floatToHalfI(_u32[0]);
        }
        bf.floatToHalf = floatToHalf;

        function floatToHalfI(i) {
            var s = (i >> 16) & 0x00008000;
            var e = ((i >> 23) & 0x000000ff) - (127 - 15);
            var m = i & 0x007fffff;

            if (e <= 0) {
                if (e < -10) {
                    return 0;
                }
                m = (m | 0x00800000) >> (1 - e);

                return (s | (m >> 13));
            } else if (e == 0xff - (127 - 15)) {
                // Inf
                if (m == 0) {
                    return (s | 0x7c00);
                } else {
                    m >>= 13;
                    return (s | 0x7c00 | m | (m == 0));
                }
            } else {
                // Overflow
                if (e > 30) {
                    return (s | 0x7c00);
                }

                return (s | (e << 10) | (m >> 13));
            }
        }
        bf.floatToHalfI = floatToHalfI;

        /**
        * Convert a float16 (NV_half_float) to a float32
        * Courtesy of OpenEXR
        */
        function halfToFloat(y) {
            _u32[0] = halfToFloatI(y);
            return _f32[0];
        }
        bf.halfToFloat = halfToFloat;

        /** Converts a half in uint16 format to a float
        in uint32 format
        */
        function halfToFloatI(y) {
            var s = (y >> 15) & 0x00000001;
            var e = (y >> 10) & 0x0000001f;
            var m = y & 0x000003ff;

            if (e == 0) {
                // Plus or minus zero
                if (m == 0) {
                    return s << 31;
                } else {
                    while (!(m & 0x00000400)) {
                        m <<= 1;
                        e -= 1;
                    }

                    e += 1;
                    m &= ~0x00000400;
                }
            } else if (e == 31) {
                //Inf
                if (m == 0) {
                    return (s << 31) | 0x7f800000;
                } else {
                    return (s << 31) | 0x7f800000 | (m << 13);
                }
            }

            e = e + (127 - 15);
            m = m << 13;

            return (s << 31) | (e << 23) | m;
        }
        bf.halfToFloatI = halfToFloatI;
    })(akra.bf || (akra.bf = {}));
    var bf = akra.bf;
})(akra || (akra = {}));
/// <reference path="../common.ts" />
var akra;
(function (akra) {
    (function (util) {
        var Singleton = (function () {
            function Singleton() {
                var _this = this;
                var _constructor = _this.constructor;

                if (_constructor._instance != null) {
                    throw new Error("Singleton class may be created only one time.");
                }

                _constructor._instance = this;
            }
            Singleton._instance = null;
            return Singleton;
        })();
        util.Singleton = Singleton;
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
/// <reference path="../idl/ILogger.ts" />
/// <reference path="../common.ts" />
/// <reference path="../bf/bf.ts" />
/// <reference path="../util/Singleton.ts" />
var akra;
(function (akra) {
    (function (util) {
        var Logger = (function () {
            function Logger() {
                this._eUnknownCode = 0;
                this._sUnknownMessage = "Unknown code";

                this._eLogLevel = 31 /* ALL */;
                this._pGeneralRoutineMap = {};

                this._pCurrentSourceLocation = {
                    file: "",
                    line: 0
                };

                this._pLastLogEntity = {
                    code: this._eUnknownCode,
                    location: this._pCurrentSourceLocation,
                    message: this._sUnknownMessage,
                    info: null
                };

                this._pCodeFamilyMap = {};
                this._pCodeFamilyList = [];
                this._pCodeInfoMap = {};

                this._pCodeFamilyRoutineDMap = {};

                this._nFamilyGenerator = 0;
            }
            Logger.prototype.init = function () {
                //TODO: Load file
                return true;
            };

            Logger.prototype.setLogLevel = function (eLevel) {
                this._eLogLevel = eLevel;
            };

            Logger.prototype.getLogLevel = function () {
                return this._eLogLevel;
            };

            Logger.prototype.registerCode = function (eCode, sMessage) {
                if (typeof sMessage === "undefined") { sMessage = this._sUnknownMessage; }
                if (this.isUsedCode(eCode)) {
                    //debug.error("Error code " + String(eCode) + " already in use.");
                    return false;
                }

                var sFamilyName = this.getFamilyName(eCode);
                if (akra.isNull(sFamilyName)) {
                    return false;
                }

                var pCodeInfo = {
                    code: eCode,
                    message: sMessage,
                    familyName: sFamilyName
                };

                this._pCodeInfoMap[eCode] = pCodeInfo;

                return true;
            };

            Logger.prototype.setUnknownCode = function (eCode, sMessage) {
                this._eUnknownCode = eCode;
                this._sUnknownMessage = sMessage;
            };

            Logger.prototype.registerCodeFamily = function (eCodeMin, eCodeMax, sFamilyName) {
                if (typeof sFamilyName === "undefined") { sFamilyName = this.generateFamilyName(); }
                if (this.isUsedFamilyName(sFamilyName)) {
                    return false;
                }

                if (!this.isValidCodeInterval(eCodeMin, eCodeMax)) {
                    return false;
                }

                var pCodeFamily = {
                    familyName: sFamilyName,
                    codeMin: eCodeMin,
                    codeMax: eCodeMax
                };

                this._pCodeFamilyMap[sFamilyName] = pCodeFamily;
                this._pCodeFamilyList.push(pCodeFamily);

                return true;
            };

            Logger.prototype.getFamilyName = function (eCode) {
                var i = 0;
                var pCodeFamilyList = this._pCodeFamilyList;
                var pCodeFamily;

                for (i = 0; i < pCodeFamilyList.length; i++) {
                    pCodeFamily = pCodeFamilyList[i];

                    if (pCodeFamily.codeMin <= eCode && pCodeFamily.codeMax >= eCode) {
                        return pCodeFamily.familyName;
                    }
                }

                return "";
            };

            Logger.prototype.setCodeFamilyRoutine = function () {
                var sFamilyName = "";
                var fnLogRoutine = null;
                var eLevel = 1 /* LOG */;

                if (akra.isInt(arguments[0])) {
                    sFamilyName = this.getFamilyName(arguments[0]);
                    fnLogRoutine = arguments[1];
                    eLevel = arguments[2];

                    if (sFamilyName === "") {
                        return false;
                    }
                } else if (akra.isString(arguments[0])) {
                    sFamilyName = arguments[0];
                    fnLogRoutine = arguments[1];
                    eLevel = arguments[2];
                }

                if (!this.isUsedFamilyName(sFamilyName)) {
                    return false;
                }

                var pCodeFamilyRoutineMap = this._pCodeFamilyRoutineDMap[sFamilyName];

                if (!akra.isDef(pCodeFamilyRoutineMap)) {
                    pCodeFamilyRoutineMap = this._pCodeFamilyRoutineDMap[sFamilyName] = {};
                }

                if (akra.bf.testAll(eLevel, 1 /* LOG */)) {
                    pCodeFamilyRoutineMap[1 /* LOG */] = fnLogRoutine;
                }
                if (akra.bf.testAll(eLevel, 2 /* INFORMATION */)) {
                    pCodeFamilyRoutineMap[2 /* INFORMATION */] = fnLogRoutine;
                }
                if (akra.bf.testAll(eLevel, 4 /* WARNING */)) {
                    pCodeFamilyRoutineMap[4 /* WARNING */] = fnLogRoutine;
                }
                if (akra.bf.testAll(eLevel, 8 /* ERROR */)) {
                    pCodeFamilyRoutineMap[8 /* ERROR */] = fnLogRoutine;
                }
                if (akra.bf.testAll(eLevel, 16 /* CRITICAL */)) {
                    pCodeFamilyRoutineMap[16 /* CRITICAL */] = fnLogRoutine;
                }

                return true;
            };

            Logger.prototype.setLogRoutine = function (fnLogRoutine, eLevel) {
                if (akra.bf.testAll(eLevel, 1 /* LOG */)) {
                    this._pGeneralRoutineMap[1 /* LOG */] = fnLogRoutine;
                }
                if (akra.bf.testAll(eLevel, 2 /* INFORMATION */)) {
                    this._pGeneralRoutineMap[2 /* INFORMATION */] = fnLogRoutine;
                }
                if (akra.bf.testAll(eLevel, 4 /* WARNING */)) {
                    this._pGeneralRoutineMap[4 /* WARNING */] = fnLogRoutine;
                }
                if (akra.bf.testAll(eLevel, 8 /* ERROR */)) {
                    this._pGeneralRoutineMap[8 /* ERROR */] = fnLogRoutine;
                }
                if (akra.bf.testAll(eLevel, 16 /* CRITICAL */)) {
                    this._pGeneralRoutineMap[16 /* CRITICAL */] = fnLogRoutine;
                }
            };

            Logger.prototype.setSourceLocation = function () {
                var sFile;
                var iLine;

                if (arguments.length === 2) {
                    sFile = arguments[0];
                    iLine = arguments[1];
                } else {
                    if (akra.isDef(arguments[0]) && !(akra.isNull(arguments[0]))) {
                        sFile = arguments[0].file;
                        iLine = arguments[0].line;
                    } else {
                        sFile = "";
                        iLine = 0;
                    }
                }

                this._pCurrentSourceLocation.file = sFile;
                this._pCurrentSourceLocation.line = iLine;
            };

            Logger.prototype.time = function (sLabel) {
                console.time(sLabel);
            };

            Logger.prototype.timeEnd = function (sLabel) {
                console.timeEnd(sLabel);
            };

            Logger.prototype.group = function () {
                var pArgs = [];
                for (var _i = 0; _i < (arguments.length - 0); _i++) {
                    pArgs[_i] = arguments[_i + 0];
                }
                console.group.apply(console, arguments);
            };

            Logger.prototype.groupEnd = function () {
                console.groupEnd();
            };

            Logger.prototype.log = function () {
                var pArgs = [];
                for (var _i = 0; _i < (arguments.length - 0); _i++) {
                    pArgs[_i] = arguments[_i + 0];
                }
                if (!akra.bf.testAll(this._eLogLevel, 1 /* LOG */)) {
                    return;
                }

                var fnLogRoutine = this._pGeneralRoutineMap[1 /* LOG */];
                if (!akra.isDef(fnLogRoutine)) {
                    return;
                }

                var pLogEntity = this._pLastLogEntity;

                pLogEntity.code = this._eUnknownCode;
                pLogEntity.location = this._pCurrentSourceLocation;
                pLogEntity.info = pArgs;
                pLogEntity.message = this._sUnknownMessage;

                fnLogRoutine.call(null, pLogEntity);
            };

            Logger.prototype.info = function () {
                if (!akra.bf.testAll(this._eLogLevel, 2 /* INFORMATION */)) {
                    return;
                }

                var pLogEntity;
                var fnLogRoutine;

                pLogEntity = this.prepareLogEntity.apply(this, arguments);
                fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, 2 /* INFORMATION */);

                if (akra.isNull(fnLogRoutine)) {
                    return;
                }

                fnLogRoutine.call(null, pLogEntity);
            };

            Logger.prototype.warn = function () {
                if (!akra.bf.testAll(this._eLogLevel, 4 /* WARNING */)) {
                    return;
                }

                var pLogEntity;
                var fnLogRoutine;

                pLogEntity = this.prepareLogEntity.apply(this, arguments);
                fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, 4 /* WARNING */);

                if (akra.isNull(fnLogRoutine)) {
                    return;
                }

                fnLogRoutine.call(null, pLogEntity);
            };

            Logger.prototype.error = function () {
                if (!akra.bf.testAll(this._eLogLevel, 8 /* ERROR */)) {
                    return;
                }

                var pLogEntity;
                var fnLogRoutine;

                pLogEntity = this.prepareLogEntity.apply(this, arguments);
                fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, 8 /* ERROR */);

                if (akra.isNull(fnLogRoutine)) {
                    return;
                }

                fnLogRoutine.call(null, pLogEntity);
            };

            Logger.prototype.critical = function () {
                var pLogEntity;
                var fnLogRoutine;

                pLogEntity = this.prepareLogEntity.apply(this, arguments);
                fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, 16 /* CRITICAL */);

                var sSystemMessage = "A Critical error has occured! Code: " + pLogEntity.code.toString();

                if (akra.bf.testAll(this._eLogLevel, 16 /* CRITICAL */) && !akra.isNull(fnLogRoutine)) {
                    fnLogRoutine.call(null, pLogEntity);
                }

                alert(sSystemMessage);
                throw new Error(sSystemMessage);
            };

            Logger.prototype.assert = function () {
                var bCondition = arguments[0];

                if (!bCondition) {
                    var pLogEntity;
                    var fnLogRoutine;

                    var pArgs = [];

                    for (var i = 1; i < arguments.length; i++) {
                        pArgs[i - 1] = arguments[i];
                    }

                    pLogEntity = this.prepareLogEntity.apply(this, pArgs);
                    fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, 16 /* CRITICAL */);

                    var sSystemMessage = "A error has occured! Code: " + pLogEntity.code.toString() + "\n Accept to exit, refuse to continue.";

                    if (akra.bf.testAll(this._eLogLevel, 16 /* CRITICAL */) && !akra.isNull(fnLogRoutine)) {
                        fnLogRoutine.call(null, pLogEntity);
                    }

                    if (confirm(sSystemMessage)) {
                        throw new Error(sSystemMessage);
                    }
                }
            };

            Logger.prototype.generateFamilyName = function () {
                var sSuffix = (this._nFamilyGenerator++);
                var sName = Logger._sDefaultFamilyName + sSuffix;

                if (this.isUsedFamilyName(sName)) {
                    return this.generateFamilyName();
                } else {
                    return sName;
                }
            };

            Logger.prototype.isValidCodeInterval = function (eCodeMin, eCodeMax) {
                if (eCodeMin > eCodeMax) {
                    return false;
                }

                var i = 0;
                var pCodeFamilyList = this._pCodeFamilyList;
                var pCodeFamily;

                for (i = 0; i < pCodeFamilyList.length; i++) {
                    pCodeFamily = pCodeFamilyList[i];

                    if ((pCodeFamily.codeMin <= eCodeMin && pCodeFamily.codeMax >= eCodeMin) || (pCodeFamily.codeMin <= eCodeMax && pCodeFamily.codeMax >= eCodeMax)) {
                        return false;
                    }
                }

                return true;
            };

            Logger.prototype.isUsedFamilyName = function (sFamilyName) {
                return akra.isDef(this._pCodeFamilyMap[sFamilyName]);
            };

            Logger.prototype.isUsedCode = function (eCode) {
                return akra.isDef(this._pCodeInfoMap[eCode]);
            };

            Logger.prototype.isLogEntity = function (pObj) {
                if (akra.isObject(pObj) && akra.isDef(pObj.code) && akra.isDef(pObj.location)) {
                    return true;
                }

                return false;
            };

            Logger.prototype.isLogCode = function (eCode) {
                return akra.isInt(eCode);
            };

            Logger.prototype.prepareLogEntity = function () {
                var eCode = this._eUnknownCode;
                var sMessage = this._sUnknownMessage;
                var pInfo = null;

                if (arguments.length === 1 && this.isLogEntity(arguments[0])) {
                    var pEntity = arguments[0];

                    eCode = pEntity.code;
                    pInfo = pEntity.info;
                    this.setSourceLocation(pEntity.location);

                    if (!akra.isDef(pEntity.message)) {
                        var pCodeInfo = this._pCodeInfoMap[eCode];
                        if (akra.isDef(pCodeInfo)) {
                            sMessage = pCodeInfo.message;
                        }
                    }
                } else {
                    if (this.isLogCode(arguments[0])) {
                        eCode = arguments[0];
                        if (arguments.length > 1) {
                            pInfo = new Array(arguments.length - 1);

                            for (var i = 0; i < pInfo.length; i++) {
                                pInfo[i] = arguments[i + 1];
                            }
                        }
                    } else {
                        eCode = this._eUnknownCode;

                        // if(arguments.length > 0){
                        pInfo = new Array(arguments.length);

                        for (var i = 0; i < pInfo.length; i++) {
                            pInfo[i] = arguments[i];
                        }
                        // }
                        // else {
                        //     pInfo = null;
                        // }
                    }

                    var pCodeInfo = this._pCodeInfoMap[eCode];
                    if (akra.isDef(pCodeInfo)) {
                        sMessage = pCodeInfo.message;
                    }
                }

                var pLogEntity = this._pLastLogEntity;

                pLogEntity.code = eCode;
                pLogEntity.location = this._pCurrentSourceLocation;
                pLogEntity.message = sMessage;
                pLogEntity.info = pInfo;

                return pLogEntity;
            };

            Logger.prototype.getCodeRoutineFunc = function (eCode, eLevel) {
                var pCodeInfo = this._pCodeInfoMap[eCode];
                var fnLogRoutine;

                if (!akra.isDef(pCodeInfo)) {
                    fnLogRoutine = this._pGeneralRoutineMap[eLevel];
                    return akra.isDef(fnLogRoutine) ? fnLogRoutine : null;
                }

                var pCodeFamilyRoutineMap = this._pCodeFamilyRoutineDMap[pCodeInfo.familyName];

                if (!akra.isDef(pCodeFamilyRoutineMap) || !akra.isDef(pCodeFamilyRoutineMap[eLevel])) {
                    fnLogRoutine = this._pGeneralRoutineMap[eLevel];
                    return akra.isDef(fnLogRoutine) ? fnLogRoutine : null;
                }

                fnLogRoutine = pCodeFamilyRoutineMap[eLevel];

                return fnLogRoutine;
            };
            Logger._sDefaultFamilyName = "CodeFamily";
            return Logger;
        })();
        util.Logger = Logger;
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
/// <reference path="common.ts" />
/// <reference path="util/Logger.ts" />

var akra;
(function (akra) {
    //export var logger: ILogger = util.Logger.getInstance();
    akra.logger = new akra.util.Logger();

    akra.logger.init();
    akra.logger.setUnknownCode(0, "unknown");
    akra.logger.setLogLevel(31 /* ALL */);

    akra.logger.registerCodeFamily(0, 100, "SystemCodes");

    //Default log routines
    function logRoutine(pLogEntity) {
        var pArgs = pLogEntity.info;

        console.log.apply(console, pArgs);
    }

    function warningRoutine(pLogEntity) {
        var pArgs = pLogEntity.info || [];

        if (true) {
            var sCodeInfo = "%cwarning" + (pLogEntity.code != 0 ? " AE" + pLogEntity.code.toString() : "") + ":";
            pArgs.unshift(sCodeInfo, "color: red;");
        }

        console.warn.apply(console, pArgs);
    }

    function errorRoutine(pLogEntity) {
        var pArgs = pLogEntity.info || [];

        if (true) {
            var sMessage = pLogEntity.message;
            var sCodeInfo = "error" + (pLogEntity.code != 0 ? " AE" + pLogEntity.code.toString() : "") + ":";

            pArgs.unshift("%c " + sCodeInfo, "color: red;", sMessage);
        } else {
            pArgs.unshift(sMessage);
        }

        console.error.apply(console, pArgs);
    }

    akra.logger.setLogRoutine(logRoutine, 1 /* LOG */ | 2 /* INFORMATION */);
    akra.logger.setLogRoutine(warningRoutine, 4 /* WARNING */);
    akra.logger.setLogRoutine(errorRoutine, 8 /* ERROR */ | 16 /* CRITICAL */);
})(akra || (akra = {}));
/// <reference path="IUnique.ts" />
var akra;
(function (akra) {
    (function (EEventTypes) {
        EEventTypes[EEventTypes["UNICAST"] = 0] = "UNICAST";
        EEventTypes[EEventTypes["BROADCAST"] = 1] = "BROADCAST";
    })(akra.EEventTypes || (akra.EEventTypes = {}));
    var EEventTypes = akra.EEventTypes;
})(akra || (akra = {}));
/// <reference path="IEventProvider.ts" />
/// <reference path="ISceneManager.ts" />
var akra;
(function (akra) {
    (function (ESceneTypes) {
        ESceneTypes[ESceneTypes["TYPE_3D"] = 0] = "TYPE_3D";
        ESceneTypes[ESceneTypes["TYPE_2D"] = 1] = "TYPE_2D";
    })(akra.ESceneTypes || (akra.ESceneTypes = {}));
    var ESceneTypes = akra.ESceneTypes;
})(akra || (akra = {}));
/// <reference path="IEntity.ts" />
/// <reference path="IExplorerFunc.ts" />
/// <reference path="IReferenceCounter.ts" />
var akra;
(function (akra) {
    (function (EEntityTypes) {
        EEntityTypes[EEntityTypes["UNKNOWN"] = 0] = "UNKNOWN";
        EEntityTypes[EEntityTypes["NODE"] = 1] = "NODE";

        EEntityTypes[EEntityTypes["JOINT"] = 2] = "JOINT";

        EEntityTypes[EEntityTypes["SCENE_NODE"] = 3] = "SCENE_NODE";

        EEntityTypes[EEntityTypes["CAMERA"] = 4] = "CAMERA";
        EEntityTypes[EEntityTypes["SHADOW_CASTER"] = 5] = "SHADOW_CASTER";

        EEntityTypes[EEntityTypes["MODEL_ENTRY"] = 6] = "MODEL_ENTRY";

        EEntityTypes[EEntityTypes["LIGHT"] = 37] = "LIGHT";

        EEntityTypes[EEntityTypes["SCENE_OBJECT"] = 64] = "SCENE_OBJECT";

        EEntityTypes[EEntityTypes["MODEL"] = 65] = "MODEL";

        EEntityTypes[EEntityTypes["TERRAIN"] = 66] = "TERRAIN";
        EEntityTypes[EEntityTypes["TERRAIN_ROAM"] = 67] = "TERRAIN_ROAM";
        EEntityTypes[EEntityTypes["TERRAIN_SECTION"] = 68] = "TERRAIN_SECTION";
        EEntityTypes[EEntityTypes["TERRAIN_SECTION_ROAM"] = 69] = "TERRAIN_SECTION_ROAM";

        EEntityTypes[EEntityTypes["TEXT3D"] = 70] = "TEXT3D";
        EEntityTypes[EEntityTypes["SPRITE"] = 71] = "SPRITE";
        EEntityTypes[EEntityTypes["EMITTER"] = 72] = "EMITTER";

        EEntityTypes[EEntityTypes["UI_NODE"] = 100] = "UI_NODE";

        // UI_HTMLNODE,
        // UI_DNDNODE,
        // UI_COMPONENT,
        // UI_BUTTON,
        // UI_LABEL,
        // UI_TREE,
        EEntityTypes[EEntityTypes["OBJECTS_LIMIT"] = 128] = "OBJECTS_LIMIT";
    })(akra.EEntityTypes || (akra.EEntityTypes = {}));
    var EEntityTypes = akra.EEntityTypes;
})(akra || (akra = {}));
var akra;
(function (akra) {
})(akra || (akra = {}));
/// <reference path="IVec2.ts" />
/// <reference path="IVec3.ts" />
/// <reference path="IColorValue.ts" />
var akra;
(function (akra) {
    ;
})(akra || (akra = {}));
/// <reference path="IVec3.ts" />
/// <reference path="IMat3.ts" />
/// <reference path="IMat4.ts" />
var akra;
(function (akra) {
    ;
})(akra || (akra = {}));
/**
* @important Если внезапно задумаем перейти обратно на
* хранение данных в матрицах по строкам, как собственно и было в начале,
* то необходимо раскомментить definы и переписать метод set,
* так как он ложит по столбцам
*/
/// <reference path="IMat4.ts" />
/// <reference path="IVec3.ts" />
/// <reference path="IQuat4.ts" />
/**
* @important Если внезапно задумаем перейти обратно на
* хранение данных в матрицах по строкам, как собственно и было в начале,
* то необходимо раскомментить definы и переписать метод set,
* так как он ложит по столбцам
*/
/// <reference path="IVec3.ts" />
/// <reference path="IVec4.ts" />
/// <reference path="IMat3.ts" />
/// <reference path="IQuat4.ts" />
/// <reference path="IVec2.ts" />
/// <reference path="IMat4.ts" />
var akra;
(function (akra) {
})(akra || (akra = {}));
/// <reference path="IEntity.ts" />
/// <reference path="IVec3.ts" />
/// <reference path="IMat3.ts" />
/// <reference path="IMat4.ts" />
/// <reference path="IQuat4.ts" />
var akra;
(function (akra) {
    (function (ENodeInheritance) {
        ENodeInheritance[ENodeInheritance["NONE"] = 0] = "NONE";

        //inheritance only position
        ENodeInheritance[ENodeInheritance["POSITION"] = 1] = "POSITION";

        //inheritance rotation and scale only
        ENodeInheritance[ENodeInheritance["ROTSCALE"] = 2] = "ROTSCALE";

        //inheritance rotation ans position only
        ENodeInheritance[ENodeInheritance["ROTPOSITION"] = 3] = "ROTPOSITION";

        //inheritance all
        ENodeInheritance[ENodeInheritance["ALL"] = 4] = "ALL";
    })(akra.ENodeInheritance || (akra.ENodeInheritance = {}));
    var ENodeInheritance = akra.ENodeInheritance;
    ;
})(akra || (akra = {}));
/// <reference path="ISceneNode.ts" />
/// <reference path="IEngine.ts" />
/// <reference path="IVec3.ts" />
//SLERP <==> slerp for rotation, MATRIX_LINEAR - linear between matrices
var akra;
(function (akra) {
    (function (EAnimationInterpolations) {
        EAnimationInterpolations[EAnimationInterpolations["LINEAR"] = 0] = "LINEAR";
        EAnimationInterpolations[EAnimationInterpolations["SPHERICAL"] = 1] = "SPHERICAL";
    })(akra.EAnimationInterpolations || (akra.EAnimationInterpolations = {}));
    var EAnimationInterpolations = akra.EAnimationInterpolations;
})(akra || (akra = {}));
/// <reference path="IFrame.ts" />
/// <reference path="IQuat4.ts" />
/// <reference path="IVec3.ts" />
/// <reference path="IMat4.ts" />
/// <reference path="IFrame.ts" />
/// <reference path="INode.ts" />
/// <reference path="IJoint.ts" />
/// <reference path="IAnimationParameter.ts" />
/// <reference path="IPositionFrame.ts" />
/// <reference path="ISkeleton.ts" />
/// <reference path="ISceneNode.ts" />
/// <reference path="IMap.ts" />
/// <reference path="ISceneNode.ts" />
/// <reference path="IJoint.ts" />
/// <reference path="IPositionFrame.ts" />
/// <reference path="IAnimationTrack.ts" />
var akra;
(function (akra) {
    (function (EAnimationTypes) {
        EAnimationTypes[EAnimationTypes["ANIMATION"] = 0] = "ANIMATION";
        EAnimationTypes[EAnimationTypes["LIST"] = 1] = "LIST";
        EAnimationTypes[EAnimationTypes["CLIP"] = 2] = "CLIP";
        EAnimationTypes[EAnimationTypes["CONTAINER"] = 3] = "CONTAINER";
        EAnimationTypes[EAnimationTypes["BLEND"] = 4] = "BLEND";
    })(akra.EAnimationTypes || (akra.EAnimationTypes = {}));
    var EAnimationTypes = akra.EAnimationTypes;
})(akra || (akra = {}));
/// <reference path="IEventProvider.ts" />
/// <reference path="IAnimationBase.ts" />
/// <reference path="IEngine.ts" />
/// <reference path="ISceneNode.ts" />
/// <reference path="INode.ts" />
/// <reference path="IAnimationController.ts" />
var akra;
(function (akra) {
    (function (ESceneNodeFlags) {
        ESceneNodeFlags[ESceneNodeFlags["FROZEN_PARENT"] = 0] = "FROZEN_PARENT";
        ESceneNodeFlags[ESceneNodeFlags["FROZEN_SELF"] = 1] = "FROZEN_SELF";
        ESceneNodeFlags[ESceneNodeFlags["HIDDEN_PARENT"] = 2] = "HIDDEN_PARENT";
        ESceneNodeFlags[ESceneNodeFlags["HIDDEN_SELF"] = 3] = "HIDDEN_SELF";
    })(akra.ESceneNodeFlags || (akra.ESceneNodeFlags = {}));
    var ESceneNodeFlags = akra.ESceneNodeFlags;
})(akra || (akra = {}));
var akra;
(function (akra) {
    /** User events. */
    (function (EUserEvents) {
        EUserEvents[EUserEvents["CLICK"] = 0x01] = "CLICK";
        EUserEvents[EUserEvents["MOUSEMOVE"] = 0x02] = "MOUSEMOVE";
        EUserEvents[EUserEvents["MOUSEDOWN"] = 0x04] = "MOUSEDOWN";
        EUserEvents[EUserEvents["MOUSEUP"] = 0x08] = "MOUSEUP";
        EUserEvents[EUserEvents["MOUSEOVER"] = 0x10] = "MOUSEOVER";
        EUserEvents[EUserEvents["MOUSEOUT"] = 0x20] = "MOUSEOUT";
        EUserEvents[EUserEvents["DRAGSTART"] = 0x40] = "DRAGSTART";
        EUserEvents[EUserEvents["DRAGSTOP"] = 0x80] = "DRAGSTOP";
        EUserEvents[EUserEvents["DRAGGING"] = 0x100] = "DRAGGING";
        EUserEvents[EUserEvents["MOUSEWHEEL"] = 0x200] = "MOUSEWHEEL";

        EUserEvents[EUserEvents["ANY"] = EUserEvents.CLICK | EUserEvents.MOUSEMOVE | EUserEvents.MOUSEDOWN | EUserEvents.MOUSEUP | EUserEvents.MOUSEOVER | EUserEvents.MOUSEOUT | EUserEvents.DRAGSTART | EUserEvents.DRAGSTOP | EUserEvents.DRAGGING | EUserEvents.MOUSEWHEEL] = "ANY";
    })(akra.EUserEvents || (akra.EUserEvents = {}));
    var EUserEvents = akra.EUserEvents;

    
})(akra || (akra = {}));
/// <reference path="IPoint.ts" />
/// <reference path="IOffset.ts" />
var akra;
(function (akra) {
    (function (EKeyCodes) {
        EKeyCodes[EKeyCodes["BACKSPACE"] = 8] = "BACKSPACE";
        EKeyCodes[EKeyCodes["TAB"] = 9] = "TAB";
        EKeyCodes[EKeyCodes["ENTER"] = 13] = "ENTER";
        EKeyCodes[EKeyCodes["SHIFT"] = 16] = "SHIFT";
        EKeyCodes[EKeyCodes["CTRL"] = 17] = "CTRL";
        EKeyCodes[EKeyCodes["ALT"] = 18] = "ALT";
        EKeyCodes[EKeyCodes["PAUSE"] = 19] = "PAUSE";
        EKeyCodes[EKeyCodes["BREAK"] = 19] = "BREAK";
        EKeyCodes[EKeyCodes["CAPSLOCK"] = 20] = "CAPSLOCK";
        EKeyCodes[EKeyCodes["ESCAPE"] = 27] = "ESCAPE";
        EKeyCodes[EKeyCodes["SPACE"] = 32] = "SPACE";
        EKeyCodes[EKeyCodes["PAGEUP"] = 33] = "PAGEUP";
        EKeyCodes[EKeyCodes["PAGEDOWN"] = 34] = "PAGEDOWN";
        EKeyCodes[EKeyCodes["END"] = 35] = "END";
        EKeyCodes[EKeyCodes["HOME"] = 36] = "HOME";
        EKeyCodes[EKeyCodes["LEFT"] = 37] = "LEFT";
        EKeyCodes[EKeyCodes["UP"] = 38] = "UP";
        EKeyCodes[EKeyCodes["RIGHT"] = 39] = "RIGHT";
        EKeyCodes[EKeyCodes["DOWN"] = 40] = "DOWN";
        EKeyCodes[EKeyCodes["INSERT"] = 45] = "INSERT";
        EKeyCodes[EKeyCodes["DELETE"] = 46] = "DELETE";
        EKeyCodes[EKeyCodes["N0"] = 48] = "N0";
        EKeyCodes[EKeyCodes["N1"] = 49] = "N1";
        EKeyCodes[EKeyCodes["N2"] = 50] = "N2";
        EKeyCodes[EKeyCodes["N3"] = 51] = "N3";
        EKeyCodes[EKeyCodes["N4"] = 52] = "N4";
        EKeyCodes[EKeyCodes["N5"] = 53] = "N5";
        EKeyCodes[EKeyCodes["N6"] = 54] = "N6";
        EKeyCodes[EKeyCodes["N7"] = 55] = "N7";
        EKeyCodes[EKeyCodes["N8"] = 56] = "N8";
        EKeyCodes[EKeyCodes["N9"] = 57] = "N9";
        EKeyCodes[EKeyCodes["A"] = 65] = "A";
        EKeyCodes[EKeyCodes["B"] = 66] = "B";
        EKeyCodes[EKeyCodes["C"] = 67] = "C";
        EKeyCodes[EKeyCodes["D"] = 68] = "D";
        EKeyCodes[EKeyCodes["E"] = 69] = "E";
        EKeyCodes[EKeyCodes["F"] = 70] = "F";
        EKeyCodes[EKeyCodes["G"] = 71] = "G";
        EKeyCodes[EKeyCodes["H"] = 72] = "H";
        EKeyCodes[EKeyCodes["I"] = 73] = "I";
        EKeyCodes[EKeyCodes["J"] = 74] = "J";
        EKeyCodes[EKeyCodes["K"] = 75] = "K";
        EKeyCodes[EKeyCodes["L"] = 76] = "L";
        EKeyCodes[EKeyCodes["M"] = 77] = "M";
        EKeyCodes[EKeyCodes["N"] = 78] = "N";
        EKeyCodes[EKeyCodes["O"] = 79] = "O";
        EKeyCodes[EKeyCodes["P"] = 80] = "P";
        EKeyCodes[EKeyCodes["Q"] = 81] = "Q";
        EKeyCodes[EKeyCodes["R"] = 82] = "R";
        EKeyCodes[EKeyCodes["S"] = 83] = "S";
        EKeyCodes[EKeyCodes["T"] = 84] = "T";
        EKeyCodes[EKeyCodes["U"] = 85] = "U";
        EKeyCodes[EKeyCodes["V"] = 86] = "V";
        EKeyCodes[EKeyCodes["W"] = 87] = "W";
        EKeyCodes[EKeyCodes["X"] = 88] = "X";
        EKeyCodes[EKeyCodes["Y"] = 89] = "Y";
        EKeyCodes[EKeyCodes["Z"] = 90] = "Z";
        EKeyCodes[EKeyCodes["LEFTWINDOWKEY"] = 91] = "LEFTWINDOWKEY";
        EKeyCodes[EKeyCodes["RIGHTWINDOWKEY"] = 92] = "RIGHTWINDOWKEY";
        EKeyCodes[EKeyCodes["SELECTKEY"] = 93] = "SELECTKEY";
        EKeyCodes[EKeyCodes["NUMPAD0"] = 96] = "NUMPAD0";
        EKeyCodes[EKeyCodes["NUMPAD1"] = 97] = "NUMPAD1";
        EKeyCodes[EKeyCodes["NUMPAD2"] = 98] = "NUMPAD2";
        EKeyCodes[EKeyCodes["NUMPAD3"] = 99] = "NUMPAD3";
        EKeyCodes[EKeyCodes["NUMPAD4"] = 100] = "NUMPAD4";
        EKeyCodes[EKeyCodes["NUMPAD5"] = 101] = "NUMPAD5";
        EKeyCodes[EKeyCodes["NUMPAD6"] = 102] = "NUMPAD6";
        EKeyCodes[EKeyCodes["NUMPAD7"] = 103] = "NUMPAD7";
        EKeyCodes[EKeyCodes["NUMPAD8"] = 104] = "NUMPAD8";
        EKeyCodes[EKeyCodes["NUMPAD9"] = 105] = "NUMPAD9";
        EKeyCodes[EKeyCodes["MULTIPLY"] = 106] = "MULTIPLY";
        EKeyCodes[EKeyCodes["ADD"] = 107] = "ADD";
        EKeyCodes[EKeyCodes["SUBTRACT"] = 109] = "SUBTRACT";
        EKeyCodes[EKeyCodes["DECIMALPOINT"] = 110] = "DECIMALPOINT";
        EKeyCodes[EKeyCodes["DIVIDE"] = 111] = "DIVIDE";
        EKeyCodes[EKeyCodes["F1"] = 112] = "F1";
        EKeyCodes[EKeyCodes["F2"] = 113] = "F2";
        EKeyCodes[EKeyCodes["F3"] = 114] = "F3";
        EKeyCodes[EKeyCodes["F4"] = 115] = "F4";
        EKeyCodes[EKeyCodes["F5"] = 116] = "F5";
        EKeyCodes[EKeyCodes["F6"] = 117] = "F6";
        EKeyCodes[EKeyCodes["F7"] = 118] = "F7";
        EKeyCodes[EKeyCodes["F8"] = 119] = "F8";
        EKeyCodes[EKeyCodes["F9"] = 120] = "F9";
        EKeyCodes[EKeyCodes["F10"] = 121] = "F10";
        EKeyCodes[EKeyCodes["F11"] = 122] = "F11";
        EKeyCodes[EKeyCodes["F12"] = 123] = "F12";
        EKeyCodes[EKeyCodes["NUMLOCK"] = 144] = "NUMLOCK";
        EKeyCodes[EKeyCodes["SCROLLLOCK"] = 145] = "SCROLLLOCK";
        EKeyCodes[EKeyCodes["SEMICOLON"] = 186] = "SEMICOLON";
        EKeyCodes[EKeyCodes["EQUALSIGN"] = 187] = "EQUALSIGN";
        EKeyCodes[EKeyCodes["COMMA"] = 188] = "COMMA";
        EKeyCodes[EKeyCodes["DASH"] = 189] = "DASH";
        EKeyCodes[EKeyCodes["PERIOD"] = 190] = "PERIOD";
        EKeyCodes[EKeyCodes["FORWARDSLASH"] = 191] = "FORWARDSLASH";
        EKeyCodes[EKeyCodes["GRAVEACCENT"] = 192] = "GRAVEACCENT";
        EKeyCodes[EKeyCodes["OPENBRACKET"] = 219] = "OPENBRACKET";
        EKeyCodes[EKeyCodes["BACKSLASH"] = 220] = "BACKSLASH";
        EKeyCodes[EKeyCodes["CLOSEBRACKET"] = 221] = "CLOSEBRACKET";
        EKeyCodes[EKeyCodes["SINGLEQUOTE"] = 222] = "SINGLEQUOTE";
        EKeyCodes[EKeyCodes["TOTAL"] = 256] = "TOTAL";
    })(akra.EKeyCodes || (akra.EKeyCodes = {}));
    var EKeyCodes = akra.EKeyCodes;

    (function (EMouseButton) {
        EMouseButton[EMouseButton["UNKNOWN"] = 0] = "UNKNOWN";
        EMouseButton[EMouseButton["LEFT"] = 1] = "LEFT";
        EMouseButton[EMouseButton["MIDDLE"] = 2] = "MIDDLE";
        EMouseButton[EMouseButton["RIGHT"] = 3] = "RIGHT";
    })(akra.EMouseButton || (akra.EMouseButton = {}));
    var EMouseButton = akra.EMouseButton;
})(akra || (akra = {}));
/// <reference path="IEventProvider.ts" />
/// <reference path="IKeyMap.ts" />
/// <reference path="IVec2.ts" />
var akra;
(function (akra) {
    ;
})(akra || (akra = {}));
/// <reference path="IVec2.ts" />
/// <reference path="ICircle.ts" />
/// <reference path="IRect2d.ts" />
/// <reference path="IVec3.ts" />
/// <reference path="../IMap.ts" />
var akra;
(function (akra) {
    (function (parser) {
        (function (ENodeCreateMode) {
            ENodeCreateMode[ENodeCreateMode["k_Default"] = 0] = "k_Default";
            ENodeCreateMode[ENodeCreateMode["k_Necessary"] = 1] = "k_Necessary";
            ENodeCreateMode[ENodeCreateMode["k_Not"] = 2] = "k_Not";
        })(parser.ENodeCreateMode || (parser.ENodeCreateMode = {}));
        var ENodeCreateMode = parser.ENodeCreateMode;

        (function (EParserCode) {
            EParserCode[EParserCode["k_Pause"] = 0] = "k_Pause";
            EParserCode[EParserCode["k_Ok"] = 1] = "k_Ok";
            EParserCode[EParserCode["k_Error"] = 2] = "k_Error";
        })(parser.EParserCode || (parser.EParserCode = {}));
        var EParserCode = parser.EParserCode;

        (function (EParserType) {
            EParserType[EParserType["k_LR0"] = 0] = "k_LR0";
            EParserType[EParserType["k_LR1"] = 1] = "k_LR1";
            EParserType[EParserType["k_LALR"] = 2] = "k_LALR";
        })(parser.EParserType || (parser.EParserType = {}));
        var EParserType = parser.EParserType;

        (function (EParseMode) {
            EParseMode[EParseMode["k_AllNode"] = 0x0001] = "k_AllNode";
            EParseMode[EParseMode["k_Negate"] = 0x0002] = "k_Negate";
            EParseMode[EParseMode["k_Add"] = 0x0004] = "k_Add";
            EParseMode[EParseMode["k_Optimize"] = 0x0008] = "k_Optimize";
            EParseMode[EParseMode["k_DebugMode"] = 0x0010] = "k_DebugMode";
        })(parser.EParseMode || (parser.EParseMode = {}));
        var EParseMode = parser.EParseMode;

        (function (ETokenType) {
            ETokenType[ETokenType["k_NumericLiteral"] = 1] = "k_NumericLiteral";
            ETokenType[ETokenType["k_CommentLiteral"] = 2] = "k_CommentLiteral";
            ETokenType[ETokenType["k_StringLiteral"] = 3] = "k_StringLiteral";
            ETokenType[ETokenType["k_PunctuatorLiteral"] = 4] = "k_PunctuatorLiteral";
            ETokenType[ETokenType["k_WhitespaceLiteral"] = 5] = "k_WhitespaceLiteral";
            ETokenType[ETokenType["k_IdentifierLiteral"] = 6] = "k_IdentifierLiteral";
            ETokenType[ETokenType["k_KeywordLiteral"] = 7] = "k_KeywordLiteral";
            ETokenType[ETokenType["k_Unknown"] = 8] = "k_Unknown";
            ETokenType[ETokenType["k_End"] = 9] = "k_End";
        })(parser.ETokenType || (parser.ETokenType = {}));
        var ETokenType = parser.ETokenType;

        (function (EOperationType) {
            EOperationType[EOperationType["k_Error"] = 100] = "k_Error";
            EOperationType[EOperationType["k_Shift"] = 101] = "k_Shift";
            EOperationType[EOperationType["k_Reduce"] = 102] = "k_Reduce";
            EOperationType[EOperationType["k_Success"] = 103] = "k_Success";
            EOperationType[EOperationType["k_Pause"] = 104] = "k_Pause";
            EOperationType[EOperationType["k_Ok"] = 105] = "k_Ok";
        })(parser.EOperationType || (parser.EOperationType = {}));
        var EOperationType = parser.EOperationType;
    })(akra.parser || (akra.parser = {}));
    var parser = akra.parser;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (ERenderStateValues) {
        ERenderStateValues[ERenderStateValues["UNDEF"] = 0] = "UNDEF";

        ERenderStateValues[ERenderStateValues["TRUE"] = 1] = "TRUE";
        ERenderStateValues[ERenderStateValues["FALSE"] = 2] = "FALSE";
        ERenderStateValues[ERenderStateValues["ZERO"] = 3] = "ZERO";
        ERenderStateValues[ERenderStateValues["ONE"] = 4] = "ONE";
        ERenderStateValues[ERenderStateValues["SRCCOLOR"] = 5] = "SRCCOLOR";
        ERenderStateValues[ERenderStateValues["INVSRCCOLOR"] = 6] = "INVSRCCOLOR";
        ERenderStateValues[ERenderStateValues["SRCALPHA"] = 7] = "SRCALPHA";
        ERenderStateValues[ERenderStateValues["INVSRCALPHA"] = 8] = "INVSRCALPHA";
        ERenderStateValues[ERenderStateValues["DESTALPHA"] = 9] = "DESTALPHA";
        ERenderStateValues[ERenderStateValues["INVDESTALPHA"] = 10] = "INVDESTALPHA";
        ERenderStateValues[ERenderStateValues["DESTCOLOR"] = 11] = "DESTCOLOR";
        ERenderStateValues[ERenderStateValues["INVDESTCOLOR"] = 12] = "INVDESTCOLOR";
        ERenderStateValues[ERenderStateValues["SRCALPHASAT"] = 13] = "SRCALPHASAT";
        ERenderStateValues[ERenderStateValues["NONE"] = 14] = "NONE";
        ERenderStateValues[ERenderStateValues["CW"] = 15] = "CW";
        ERenderStateValues[ERenderStateValues["CCW"] = 16] = "CCW";
        ERenderStateValues[ERenderStateValues["FRONT"] = 17] = "FRONT";
        ERenderStateValues[ERenderStateValues["BACK"] = 18] = "BACK";
        ERenderStateValues[ERenderStateValues["FRONT_AND_BACK"] = 19] = "FRONT_AND_BACK";
        ERenderStateValues[ERenderStateValues["NEVER"] = 20] = "NEVER";
        ERenderStateValues[ERenderStateValues["LESS"] = 21] = "LESS";
        ERenderStateValues[ERenderStateValues["EQUAL"] = 22] = "EQUAL";
        ERenderStateValues[ERenderStateValues["LESSEQUAL"] = 23] = "LESSEQUAL";
        ERenderStateValues[ERenderStateValues["GREATER"] = 24] = "GREATER";
        ERenderStateValues[ERenderStateValues["NOTEQUAL"] = 25] = "NOTEQUAL";
        ERenderStateValues[ERenderStateValues["GREATEREQUAL"] = 26] = "GREATEREQUAL";
        ERenderStateValues[ERenderStateValues["ALWAYS"] = 27] = "ALWAYS";

        ERenderStateValues[ERenderStateValues["FUNCADD"] = 28] = "FUNCADD";
        ERenderStateValues[ERenderStateValues["FUNCSUBTRACT"] = 29] = "FUNCSUBTRACT";
        ERenderStateValues[ERenderStateValues["FUNCREVERSESUBTRACT"] = 30] = "FUNCREVERSESUBTRACT";
    })(akra.ERenderStateValues || (akra.ERenderStateValues = {}));
    var ERenderStateValues = akra.ERenderStateValues;
})(akra || (akra = {}));
/// <reference path="parser/IParser.ts" />
/// <reference path="IAFXComponent.ts" />
/// <reference path="IUnique.ts" />
/// <reference path="IRenderer.ts" />
/// <reference path="IMap.ts" />
/// <reference path="IAFXComposer.ts" />
/// <reference path="ERenderStateValues.ts" />
var akra;
(function (akra) {
    (function (EAFXInstructionTypes) {
        EAFXInstructionTypes[EAFXInstructionTypes["k_Instruction"] = 0] = "k_Instruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_InstructionCollector"] = 1] = "k_InstructionCollector";
        EAFXInstructionTypes[EAFXInstructionTypes["k_SimpleInstruction"] = 2] = "k_SimpleInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_VariableTypeInstruction"] = 3] = "k_VariableTypeInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_SystemTypeInstruction"] = 4] = "k_SystemTypeInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_ComplexTypeInstruction"] = 5] = "k_ComplexTypeInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_TypedInstruction"] = 6] = "k_TypedInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_DeclInstruction"] = 7] = "k_DeclInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_IntInstruction"] = 8] = "k_IntInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_FloatInstruction"] = 9] = "k_FloatInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_BoolInstruction"] = 10] = "k_BoolInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_StringInstruction"] = 11] = "k_StringInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_IdInstruction"] = 12] = "k_IdInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_KeywordInstruction"] = 13] = "k_KeywordInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_TypeDeclInstruction"] = 14] = "k_TypeDeclInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_VariableDeclInstruction"] = 15] = "k_VariableDeclInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_AnnotationInstruction"] = 16] = "k_AnnotationInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_UsageTypeInstruction"] = 17] = "k_UsageTypeInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_BaseTypeInstruction"] = 18] = "k_BaseTypeInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_StructDeclInstruction"] = 19] = "k_StructDeclInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_StructFieldsInstruction"] = 20] = "k_StructFieldsInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_ExprInstruction"] = 21] = "k_ExprInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_IdExprInstruction"] = 22] = "k_IdExprInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_ArithmeticExprInstruction"] = 23] = "k_ArithmeticExprInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_AssignmentExprInstruction"] = 24] = "k_AssignmentExprInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_RelationalExprInstruction"] = 25] = "k_RelationalExprInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_LogicalExprInstruction"] = 26] = "k_LogicalExprInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_ConditionalExprInstruction"] = 27] = "k_ConditionalExprInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_CastExprInstruction"] = 28] = "k_CastExprInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_UnaryExprInstruction"] = 29] = "k_UnaryExprInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_PostfixIndexInstruction"] = 30] = "k_PostfixIndexInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_PostfixPointInstruction"] = 31] = "k_PostfixPointInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_PostfixArithmeticInstruction"] = 32] = "k_PostfixArithmeticInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_PrimaryExprInstruction"] = 33] = "k_PrimaryExprInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_ComplexExprInstruction"] = 34] = "k_ComplexExprInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_FunctionCallInstruction"] = 35] = "k_FunctionCallInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_SystemCallInstruction"] = 36] = "k_SystemCallInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_ConstructorCallInstruction"] = 37] = "k_ConstructorCallInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_CompileExprInstruction"] = 38] = "k_CompileExprInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_InitExprInstruction"] = 39] = "k_InitExprInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_SamplerStateBlockInstruction"] = 40] = "k_SamplerStateBlockInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_SamplerStateInstruction"] = 41] = "k_SamplerStateInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_ExtractExprInstruction"] = 42] = "k_ExtractExprInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_MemExprInstruction"] = 43] = "k_MemExprInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_FunctionDeclInstruction"] = 44] = "k_FunctionDeclInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_ShaderFunctionInstruction"] = 45] = "k_ShaderFunctionInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_SystemFunctionInstruction"] = 46] = "k_SystemFunctionInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_FunctionDefInstruction"] = 47] = "k_FunctionDefInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_StmtInstruction"] = 48] = "k_StmtInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_StmtBlockInstruction"] = 49] = "k_StmtBlockInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_ExprStmtInstruction"] = 50] = "k_ExprStmtInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_BreakStmtInstruction"] = 51] = "k_BreakStmtInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_WhileStmtInstruction"] = 52] = "k_WhileStmtInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_ForStmtInstruction"] = 53] = "k_ForStmtInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_IfStmtInstruction"] = 54] = "k_IfStmtInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_DeclStmtInstruction"] = 55] = "k_DeclStmtInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_ReturnStmtInstruction"] = 56] = "k_ReturnStmtInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_ExtractStmtInstruction"] = 57] = "k_ExtractStmtInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_SemicolonStmtInstruction"] = 58] = "k_SemicolonStmtInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_PassInstruction"] = 59] = "k_PassInstruction";
        EAFXInstructionTypes[EAFXInstructionTypes["k_TechniqueInstruction"] = 60] = "k_TechniqueInstruction";
    })(akra.EAFXInstructionTypes || (akra.EAFXInstructionTypes = {}));
    var EAFXInstructionTypes = akra.EAFXInstructionTypes;

    (function (EFunctionType) {
        EFunctionType[EFunctionType["k_Vertex"] = 0] = "k_Vertex";
        EFunctionType[EFunctionType["k_Pixel"] = 1] = "k_Pixel";
        EFunctionType[EFunctionType["k_Fragment"] = 1] = "k_Fragment";
        EFunctionType[EFunctionType["k_Function"] = 2] = "k_Function";
        EFunctionType[EFunctionType["k_PassFunction"] = 3] = "k_PassFunction";
    })(akra.EFunctionType || (akra.EFunctionType = {}));
    var EFunctionType = akra.EFunctionType;

    (function (ECheckStage) {
        ECheckStage[ECheckStage["CODE_TARGET_SUPPORT"] = 0] = "CODE_TARGET_SUPPORT";
        ECheckStage[ECheckStage["SELF_CONTAINED"] = 1] = "SELF_CONTAINED";
    })(akra.ECheckStage || (akra.ECheckStage = {}));
    var ECheckStage = akra.ECheckStage;

    (function (EVarUsedMode) {
        EVarUsedMode[EVarUsedMode["k_Read"] = 0] = "k_Read";
        EVarUsedMode[EVarUsedMode["k_Write"] = 1] = "k_Write";
        EVarUsedMode[EVarUsedMode["k_ReadWrite"] = 2] = "k_ReadWrite";
        EVarUsedMode[EVarUsedMode["k_Undefined"] = 3] = "k_Undefined";
        EVarUsedMode[EVarUsedMode["k_Default"] = EVarUsedMode.k_ReadWrite] = "k_Default";
    })(akra.EVarUsedMode || (akra.EVarUsedMode = {}));
    var EVarUsedMode = akra.EVarUsedMode;

    (function (EExtractExprType) {
        EExtractExprType[EExtractExprType["k_Header"] = 0] = "k_Header";

        EExtractExprType[EExtractExprType["k_Float"] = 1] = "k_Float";
        EExtractExprType[EExtractExprType["k_Int"] = 2] = "k_Int";
        EExtractExprType[EExtractExprType["k_Bool"] = 3] = "k_Bool";

        EExtractExprType[EExtractExprType["k_Float2"] = 4] = "k_Float2";
        EExtractExprType[EExtractExprType["k_Int2"] = 5] = "k_Int2";
        EExtractExprType[EExtractExprType["k_Bool2"] = 6] = "k_Bool2";

        EExtractExprType[EExtractExprType["k_Float3"] = 7] = "k_Float3";
        EExtractExprType[EExtractExprType["k_Int3"] = 8] = "k_Int3";
        EExtractExprType[EExtractExprType["k_Bool3"] = 9] = "k_Bool3";

        EExtractExprType[EExtractExprType["k_Float4"] = 10] = "k_Float4";
        EExtractExprType[EExtractExprType["k_Int4"] = 11] = "k_Int4";
        EExtractExprType[EExtractExprType["k_Bool4"] = 12] = "k_Bool4";

        EExtractExprType[EExtractExprType["k_Float4x4"] = 13] = "k_Float4x4";
    })(akra.EExtractExprType || (akra.EExtractExprType = {}));
    var EExtractExprType = akra.EExtractExprType;

    (function (EAFXBlendMode) {
        EAFXBlendMode[EAFXBlendMode["k_Shared"] = 0] = "k_Shared";
        EAFXBlendMode[EAFXBlendMode["k_Uniform"] = 1] = "k_Uniform";
        EAFXBlendMode[EAFXBlendMode["k_Attribute"] = 2] = "k_Attribute";
        EAFXBlendMode[EAFXBlendMode["k_Foreign"] = 3] = "k_Foreign";
        EAFXBlendMode[EAFXBlendMode["k_Global"] = 4] = "k_Global";
        EAFXBlendMode[EAFXBlendMode["k_Varying"] = 5] = "k_Varying";
        EAFXBlendMode[EAFXBlendMode["k_TypeDecl"] = 6] = "k_TypeDecl";
        EAFXBlendMode[EAFXBlendMode["k_VertexOut"] = 7] = "k_VertexOut";
    })(akra.EAFXBlendMode || (akra.EAFXBlendMode = {}));
    var EAFXBlendMode = akra.EAFXBlendMode;

    

    
})(akra || (akra = {}));
/// <reference path="IResourcePoolItem.ts" />
/// <reference path="IAFXInstruction.ts" />
var akra;
(function (akra) {
    (function (EPassTypes) {
        EPassTypes[EPassTypes["UNDEF"] = 0] = "UNDEF";
        EPassTypes[EPassTypes["DEFAULT"] = 1] = "DEFAULT";
        EPassTypes[EPassTypes["POSTEFFECT"] = 2] = "POSTEFFECT";
    })(akra.EPassTypes || (akra.EPassTypes = {}));
    var EPassTypes = akra.EPassTypes;
    ;
})(akra || (akra = {}));
/// <reference path="IAFXComponent.ts" />
/// <reference path="IBuffer.ts" />
var akra;
(function (akra) {
    (function (EHardwareBufferFlags) {
        EHardwareBufferFlags[EHardwareBufferFlags["STATIC"] = 0x01] = "STATIC";
        EHardwareBufferFlags[EHardwareBufferFlags["DYNAMIC"] = 0x02] = "DYNAMIC";
        EHardwareBufferFlags[EHardwareBufferFlags["STREAM"] = 0x80] = "STREAM";

        EHardwareBufferFlags[EHardwareBufferFlags["READABLE"] = 0x04] = "READABLE";

        EHardwareBufferFlags[EHardwareBufferFlags["BACKUP_COPY"] = 0x08] = "BACKUP_COPY";

        /** indicate, that buffer does not use GPU memory or other specific memory. */
        EHardwareBufferFlags[EHardwareBufferFlags["SOFTWARE"] = 0x10] = "SOFTWARE";

        /** Indicate, tha buffer uses specific data aligment */
        EHardwareBufferFlags[EHardwareBufferFlags["ALIGNMENT"] = 0x20] = "ALIGNMENT";

        /** Indicates that the application will be refilling the contents
        of the buffer regularly (not just updating, but generating the
        contents from scratch), and therefore does not mind if the contents
        of the buffer are lost somehow and need to be recreated. This
        allows and additional level of optimisation on the buffer.
        This option only really makes sense when combined with
        DYNAMIC and without READING.
        */
        EHardwareBufferFlags[EHardwareBufferFlags["DISCARDABLE"] = 0x40] = "DISCARDABLE";

        EHardwareBufferFlags[EHardwareBufferFlags["STATIC_READABLE"] = EHardwareBufferFlags.STATIC | EHardwareBufferFlags.READABLE] = "STATIC_READABLE";
        EHardwareBufferFlags[EHardwareBufferFlags["DYNAMIC_DISCARDABLE"] = EHardwareBufferFlags.DYNAMIC | EHardwareBufferFlags.DISCARDABLE] = "DYNAMIC_DISCARDABLE";
    })(akra.EHardwareBufferFlags || (akra.EHardwareBufferFlags = {}));
    var EHardwareBufferFlags = akra.EHardwareBufferFlags;

    (function (ELockFlags) {
        ELockFlags[ELockFlags["READ"] = 0x01] = "READ";
        ELockFlags[ELockFlags["WRITE"] = 0x02] = "WRITE";
        ELockFlags[ELockFlags["DISCARD"] = 0x04] = "DISCARD";
        ELockFlags[ELockFlags["NO_OVERWRITE"] = 0x08] = "NO_OVERWRITE";

        ELockFlags[ELockFlags["NORMAL"] = ELockFlags.READ | ELockFlags.WRITE] = "NORMAL";
    })(akra.ELockFlags || (akra.ELockFlags = {}));
    var ELockFlags = akra.ELockFlags;
})(akra || (akra = {}));
/// <reference path="IHardwareBuffer.ts" />
/// <reference path="IRenderResource.ts" />
/// <reference path="IVertexData.ts" />
/// <reference path="IVertexElement.ts" />
/// <reference path="IVertexDeclaration.ts" />
var akra;
(function (akra) {
    (function (EVertexBufferTypes) {
        EVertexBufferTypes[EVertexBufferTypes["UNKNOWN"] = 0] = "UNKNOWN";
        EVertexBufferTypes[EVertexBufferTypes["VBO"] = 1] = "VBO";
        EVertexBufferTypes[EVertexBufferTypes["TBO"] = 2] = "TBO";
    })(akra.EVertexBufferTypes || (akra.EVertexBufferTypes = {}));
    var EVertexBufferTypes = akra.EVertexBufferTypes;
    ;
})(akra || (akra = {}));
/// <reference path="IBuffer.ts" />
/// <reference path="IBufferData.ts" />
/// <reference path="IBufferDataModifier.ts" />
/// <reference path="IVertexDeclaration.ts" />
/// <reference path="IVertexBuffer.ts" />
/// <reference path="IEventProvider.ts" />
/// <reference path="IVertexData.ts" />
/// <reference path="IColorValue.ts" />
/// <reference path="IUnique.ts" />
/// <reference path="IMaterial.ts" />
/// <reference path="ITexture.ts" />
var akra;
(function (akra) {
    (function (ESurfaceMaterialTextures) {
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["TEXTURE0"] = 0] = "TEXTURE0";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["TEXTURE1"] = 1] = "TEXTURE1";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["TEXTURE2"] = 2] = "TEXTURE2";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["TEXTURE3"] = 3] = "TEXTURE3";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["TEXTURE4"] = 4] = "TEXTURE4";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["TEXTURE5"] = 5] = "TEXTURE5";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["TEXTURE6"] = 6] = "TEXTURE6";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["TEXTURE7"] = 7] = "TEXTURE7";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["TEXTURE8"] = 8] = "TEXTURE8";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["TEXTURE9"] = 9] = "TEXTURE9";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["TEXTURE10"] = 10] = "TEXTURE10";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["TEXTURE11"] = 11] = "TEXTURE11";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["TEXTURE12"] = 12] = "TEXTURE12";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["TEXTURE13"] = 13] = "TEXTURE13";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["TEXTURE14"] = 14] = "TEXTURE14";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["TEXTURE15"] = 15] = "TEXTURE15";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["DIFFUSE"] = ESurfaceMaterialTextures.TEXTURE0] = "DIFFUSE";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["AMBIENT"] = ESurfaceMaterialTextures.TEXTURE1] = "AMBIENT";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["SPECULAR"] = ESurfaceMaterialTextures.TEXTURE2] = "SPECULAR";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["EMISSIVE"] = ESurfaceMaterialTextures.TEXTURE3] = "EMISSIVE";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["NORMAL"] = ESurfaceMaterialTextures.TEXTURE4] = "NORMAL";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["SHININESS"] = ESurfaceMaterialTextures.TEXTURE5] = "SHININESS";
        ESurfaceMaterialTextures[ESurfaceMaterialTextures["EMISSION"] = ESurfaceMaterialTextures.EMISSIVE] = "EMISSION";
    })(akra.ESurfaceMaterialTextures || (akra.ESurfaceMaterialTextures = {}));
    var ESurfaceMaterialTextures = akra.ESurfaceMaterialTextures;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (ERenderStates) {
        ERenderStates[ERenderStates["BLENDENABLE"] = 0] = "BLENDENABLE";
        ERenderStates[ERenderStates["CULLFACEENABLE"] = 1] = "CULLFACEENABLE";
        ERenderStates[ERenderStates["ZENABLE"] = 2] = "ZENABLE";
        ERenderStates[ERenderStates["ZWRITEENABLE"] = 3] = "ZWRITEENABLE";
        ERenderStates[ERenderStates["DITHERENABLE"] = 4] = "DITHERENABLE";
        ERenderStates[ERenderStates["SCISSORTESTENABLE"] = 5] = "SCISSORTESTENABLE";
        ERenderStates[ERenderStates["STENCILTESTENABLE"] = 6] = "STENCILTESTENABLE";
        ERenderStates[ERenderStates["POLYGONOFFSETFILLENABLE"] = 7] = "POLYGONOFFSETFILLENABLE";

        ERenderStates[ERenderStates["CULLFACE"] = 8] = "CULLFACE";
        ERenderStates[ERenderStates["FRONTFACE"] = 9] = "FRONTFACE";

        ERenderStates[ERenderStates["SRCBLENDCOLOR"] = 10] = "SRCBLENDCOLOR";
        ERenderStates[ERenderStates["DESTBLENDCOLOR"] = 11] = "DESTBLENDCOLOR";

        ERenderStates[ERenderStates["SRCBLENDALPHA"] = 12] = "SRCBLENDALPHA";
        ERenderStates[ERenderStates["DESTBLENDALPHA"] = 13] = "DESTBLENDALPHA";

        ERenderStates[ERenderStates["BLENDEQUATIONCOLOR"] = 14] = "BLENDEQUATIONCOLOR";
        ERenderStates[ERenderStates["BLENDEQUATIONALPHA"] = 15] = "BLENDEQUATIONALPHA";

        ERenderStates[ERenderStates["ZFUNC"] = 16] = "ZFUNC";

        ERenderStates[ERenderStates["ALPHABLENDENABLE"] = 17] = "ALPHABLENDENABLE";
        ERenderStates[ERenderStates["ALPHATESTENABLE"] = 18] = "ALPHATESTENABLE";

        ERenderStates[ERenderStates["SRCBLEND"] = 19] = "SRCBLEND";
        ERenderStates[ERenderStates["DESTBLEND"] = 20] = "DESTBLEND";

        ERenderStates[ERenderStates["BLENDFUNC"] = 21] = "BLENDFUNC";
        ERenderStates[ERenderStates["BLENDFUNCSEPARATE"] = 22] = "BLENDFUNCSEPARATE";

        ERenderStates[ERenderStates["BLENDEQUATION"] = 23] = "BLENDEQUATION";
        ERenderStates[ERenderStates["BLENDEQUATIONSEPARATE"] = 24] = "BLENDEQUATIONSEPARATE";
    })(akra.ERenderStates || (akra.ERenderStates = {}));
    var ERenderStates = akra.ERenderStates;
})(akra || (akra = {}));
/// <reference path="IAFXSamplerState.ts" />
/// <reference path="ISurfaceMaterial.ts" />
/// <reference path="IUnique.ts" />
/// <reference path="ERenderStates.ts" />
/// <reference path="IAFXComponentBlend.ts" />
/// <reference path="IMap.ts" />
/// <reference path="IAFXInstruction.ts" />
var akra;
(function (akra) {
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EAFXShaderVariableType) {
        EAFXShaderVariableType[EAFXShaderVariableType["k_NotVar"] = 0] = "k_NotVar";

        EAFXShaderVariableType[EAFXShaderVariableType["k_Texture"] = 2] = "k_Texture";

        EAFXShaderVariableType[EAFXShaderVariableType["k_Float"] = 3] = "k_Float";
        EAFXShaderVariableType[EAFXShaderVariableType["k_Int"] = 4] = "k_Int";
        EAFXShaderVariableType[EAFXShaderVariableType["k_Bool"] = 5] = "k_Bool";

        EAFXShaderVariableType[EAFXShaderVariableType["k_Float2"] = 6] = "k_Float2";
        EAFXShaderVariableType[EAFXShaderVariableType["k_Int2"] = 7] = "k_Int2";
        EAFXShaderVariableType[EAFXShaderVariableType["k_Bool2"] = 8] = "k_Bool2";

        EAFXShaderVariableType[EAFXShaderVariableType["k_Float3"] = 9] = "k_Float3";
        EAFXShaderVariableType[EAFXShaderVariableType["k_Int3"] = 10] = "k_Int3";
        EAFXShaderVariableType[EAFXShaderVariableType["k_Bool3"] = 11] = "k_Bool3";

        EAFXShaderVariableType[EAFXShaderVariableType["k_Float4"] = 12] = "k_Float4";
        EAFXShaderVariableType[EAFXShaderVariableType["k_Int4"] = 13] = "k_Int4";
        EAFXShaderVariableType[EAFXShaderVariableType["k_Bool4"] = 14] = "k_Bool4";

        EAFXShaderVariableType[EAFXShaderVariableType["k_Float2x2"] = 15] = "k_Float2x2";
        EAFXShaderVariableType[EAFXShaderVariableType["k_Float3x3"] = 16] = "k_Float3x3";
        EAFXShaderVariableType[EAFXShaderVariableType["k_Float4x4"] = 17] = "k_Float4x4";

        EAFXShaderVariableType[EAFXShaderVariableType["k_Sampler2D"] = 18] = "k_Sampler2D";
        EAFXShaderVariableType[EAFXShaderVariableType["k_SamplerCUBE"] = 19] = "k_SamplerCUBE";
        EAFXShaderVariableType[EAFXShaderVariableType["k_SamplerVertexTexture"] = 20] = "k_SamplerVertexTexture";

        EAFXShaderVariableType[EAFXShaderVariableType["k_CustomSystem"] = 21] = "k_CustomSystem";
        EAFXShaderVariableType[EAFXShaderVariableType["k_Complex"] = 22] = "k_Complex";
    })(akra.EAFXShaderVariableType || (akra.EAFXShaderVariableType = {}));
    var EAFXShaderVariableType = akra.EAFXShaderVariableType;
})(akra || (akra = {}));
/// <reference path="IAFXComponent.ts" />
/// <reference path="IAFXInstruction.ts" />
/// <reference path="IUnique.ts" />
/// <reference path="IAFXPassInputBlend.ts" />
/// <reference path="IAFXVariableContainer.ts" />
/// <reference path="IMap.ts" />
/// <reference path="IAFXInstruction.ts" />
var akra;
(function (akra) {
    (function (EPrimitiveTypes) {
        EPrimitiveTypes[EPrimitiveTypes["POINTLIST"] = 0] = "POINTLIST";
        EPrimitiveTypes[EPrimitiveTypes["LINELIST"] = 1] = "LINELIST";
        EPrimitiveTypes[EPrimitiveTypes["LINELOOP"] = 2] = "LINELOOP";
        EPrimitiveTypes[EPrimitiveTypes["LINESTRIP"] = 3] = "LINESTRIP";
        EPrimitiveTypes[EPrimitiveTypes["TRIANGLELIST"] = 4] = "TRIANGLELIST";
        EPrimitiveTypes[EPrimitiveTypes["TRIANGLESTRIP"] = 5] = "TRIANGLESTRIP";
        EPrimitiveTypes[EPrimitiveTypes["TRIANGLEFAN"] = 6] = "TRIANGLEFAN";
    })(akra.EPrimitiveTypes || (akra.EPrimitiveTypes = {}));
    var EPrimitiveTypes = akra.EPrimitiveTypes;
})(akra || (akra = {}));
/// <reference path="IRenderer.ts" />
/// <reference path="IBuffer.ts" />
/// <reference path="IBufferData.ts" />
/// <reference path="EDataTypes.ts" />
/// <reference path="EPrimitiveTypes.ts" />
/// <reference path="IReferenceCounter.ts" />
/// <reference path="IEventProvider.ts" />
/// <reference path="IVertexData.ts" />
/// <reference path="IIndexData.ts" />
var akra;
(function (akra) {
    (function (EDataFlowTypes) {
        EDataFlowTypes[EDataFlowTypes["MAPPABLE"] = 1] = "MAPPABLE";
        EDataFlowTypes[EDataFlowTypes["UNMAPPABLE"] = 0] = "UNMAPPABLE";
    })(akra.EDataFlowTypes || (akra.EDataFlowTypes = {}));
    var EDataFlowTypes = akra.EDataFlowTypes;
    ;
})(akra || (akra = {}));
/// <reference path="IMap.ts" />
/// <reference path="IRenderableObject.ts" />
/// <reference path="ISceneObject.ts" />
//remove in release version
/// <reference path="parser/IParser.ts" />
/// <reference path="IEngine.ts" />
/// <reference path="IAFXComponent.ts" />
/// <reference path="IEffect.ts" />
/// <reference path="IAFXComponentBlend.ts" />
/// <reference path="IAFXPassInputBlend.ts" />
/// <reference path="IBufferMap.ts" />
/// <reference path="ISurfaceMaterial.ts" />
/// <reference path="IRID.ts" />
/// <reference path="IRenderResource.ts" />
var akra;
(function (akra) {
    (function (EPixelFormats) {
        EPixelFormats[EPixelFormats["UNKNOWN"] = 0] = "UNKNOWN";

        EPixelFormats[EPixelFormats["L8"] = 1] = "L8";
        EPixelFormats[EPixelFormats["BYTE_L"] = EPixelFormats.L8] = "BYTE_L";
        EPixelFormats[EPixelFormats["L16"] = 2] = "L16";
        EPixelFormats[EPixelFormats["SHORT_L"] = EPixelFormats.L16] = "SHORT_L";
        EPixelFormats[EPixelFormats["A8"] = 3] = "A8";
        EPixelFormats[EPixelFormats["BYTE_A"] = EPixelFormats.A8] = "BYTE_A";
        EPixelFormats[EPixelFormats["A4L4"] = 4] = "A4L4";
        EPixelFormats[EPixelFormats["BYTE_LA"] = 5] = "BYTE_LA";

        EPixelFormats[EPixelFormats["R5G6B5"] = 6] = "R5G6B5";
        EPixelFormats[EPixelFormats["B5G6R5"] = 7] = "B5G6R5";
        EPixelFormats[EPixelFormats["R3G3B2"] = 31] = "R3G3B2";
        EPixelFormats[EPixelFormats["A4R4G4B4"] = 8] = "A4R4G4B4";
        EPixelFormats[EPixelFormats["A1R5G5B5"] = 9] = "A1R5G5B5";
        EPixelFormats[EPixelFormats["R8G8B8"] = 10] = "R8G8B8";
        EPixelFormats[EPixelFormats["B8G8R8"] = 11] = "B8G8R8";
        EPixelFormats[EPixelFormats["A8R8G8B8"] = 12] = "A8R8G8B8";
        EPixelFormats[EPixelFormats["A8B8G8R8"] = 13] = "A8B8G8R8";
        EPixelFormats[EPixelFormats["B8G8R8A8"] = 14] = "B8G8R8A8";
        EPixelFormats[EPixelFormats["R8G8B8A8"] = 28] = "R8G8B8A8";

        EPixelFormats[EPixelFormats["X8R8G8B8"] = 26] = "X8R8G8B8";
        EPixelFormats[EPixelFormats["X8B8G8R8"] = 27] = "X8B8G8R8";

        EPixelFormats[EPixelFormats["BYTE_RGB"] = EPixelFormats.R8G8B8] = "BYTE_RGB";
        EPixelFormats[EPixelFormats["BYTE_BGR"] = EPixelFormats.B8G8R8] = "BYTE_BGR";
        EPixelFormats[EPixelFormats["BYTE_BGRA"] = EPixelFormats.B8G8R8A8] = "BYTE_BGRA";
        EPixelFormats[EPixelFormats["BYTE_RGBA"] = EPixelFormats.R8G8B8A8] = "BYTE_RGBA";

        EPixelFormats[EPixelFormats["BYTE_ABGR"] = EPixelFormats.A8B8G8R8] = "BYTE_ABGR";
        EPixelFormats[EPixelFormats["BYTE_ARGB"] = EPixelFormats.A8R8G8B8] = "BYTE_ARGB";

        EPixelFormats[EPixelFormats["A2R10G10B10"] = 15] = "A2R10G10B10";
        EPixelFormats[EPixelFormats["A2B10G10R10"] = 16] = "A2B10G10R10";

        EPixelFormats[EPixelFormats["DXT1"] = 17] = "DXT1";
        EPixelFormats[EPixelFormats["DXT2"] = 18] = "DXT2";
        EPixelFormats[EPixelFormats["DXT3"] = 19] = "DXT3";
        EPixelFormats[EPixelFormats["DXT4"] = 20] = "DXT4";
        EPixelFormats[EPixelFormats["DXT5"] = 21] = "DXT5";

        EPixelFormats[EPixelFormats["FLOAT16_R"] = 32] = "FLOAT16_R";
        EPixelFormats[EPixelFormats["FLOAT16_RGB"] = 22] = "FLOAT16_RGB";
        EPixelFormats[EPixelFormats["FLOAT16_RGBA"] = 23] = "FLOAT16_RGBA";
        EPixelFormats[EPixelFormats["FLOAT32_R"] = 33] = "FLOAT32_R";
        EPixelFormats[EPixelFormats["FLOAT32_RGB"] = 24] = "FLOAT32_RGB";
        EPixelFormats[EPixelFormats["FLOAT32_RGBA"] = 25] = "FLOAT32_RGBA";
        EPixelFormats[EPixelFormats["FLOAT16_GR"] = 35] = "FLOAT16_GR";
        EPixelFormats[EPixelFormats["FLOAT32_GR"] = 36] = "FLOAT32_GR";

        EPixelFormats[EPixelFormats["FLOAT32_DEPTH"] = 29] = "FLOAT32_DEPTH";
        EPixelFormats[EPixelFormats["DEPTH8"] = 44] = "DEPTH8";
        EPixelFormats[EPixelFormats["BYTE_DEPTH"] = EPixelFormats.DEPTH8] = "BYTE_DEPTH";

        EPixelFormats[EPixelFormats["DEPTH16"] = 45] = "DEPTH16";
        EPixelFormats[EPixelFormats["SHORT_DEPTH"] = EPixelFormats.DEPTH16] = "SHORT_DEPTH";
        EPixelFormats[EPixelFormats["DEPTH32"] = 46] = "DEPTH32";
        EPixelFormats[EPixelFormats["DEPTH24STENCIL8"] = 47] = "DEPTH24STENCIL8";

        EPixelFormats[EPixelFormats["SHORT_RGBA"] = 30] = "SHORT_RGBA";
        EPixelFormats[EPixelFormats["SHORT_GR"] = 34] = "SHORT_GR";
        EPixelFormats[EPixelFormats["SHORT_RGB"] = 37] = "SHORT_RGB";

        EPixelFormats[EPixelFormats["PVRTC_RGB2"] = 38] = "PVRTC_RGB2";
        EPixelFormats[EPixelFormats["PVRTC_RGBA2"] = 39] = "PVRTC_RGBA2";
        EPixelFormats[EPixelFormats["PVRTC_RGB4"] = 40] = "PVRTC_RGB4";
        EPixelFormats[EPixelFormats["PVRTC_RGBA4"] = 41] = "PVRTC_RGBA4";

        EPixelFormats[EPixelFormats["R8"] = 42] = "R8";
        EPixelFormats[EPixelFormats["RG8"] = 43] = "RG8";
        EPixelFormats[EPixelFormats["TOTAL"] = 48] = "TOTAL";
    })(akra.EPixelFormats || (akra.EPixelFormats = {}));
    var EPixelFormats = akra.EPixelFormats;
    ;

    /**
    * Flags defining some on/off properties of pixel formats
    */
    (function (EPixelFormatFlags) {
        // This format has an alpha channel
        EPixelFormatFlags[EPixelFormatFlags["HASALPHA"] = 0x00000001] = "HASALPHA";

        // This format is compressed. This invalidates the values in elemBytes,
        // elemBits and the bit counts as these might not be fixed in a compressed format.
        EPixelFormatFlags[EPixelFormatFlags["COMPRESSED"] = 0x00000002] = "COMPRESSED";

        // This is a floating point format
        EPixelFormatFlags[EPixelFormatFlags["FLOAT"] = 0x00000004] = "FLOAT";

        // This is a depth format (for depth textures)
        EPixelFormatFlags[EPixelFormatFlags["DEPTH"] = 0x00000008] = "DEPTH";

        // Format is in native endian. Generally true for the 16, 24 and 32 bits
        // formats which can be represented as machine integers.
        EPixelFormatFlags[EPixelFormatFlags["NATIVEENDIAN"] = 0x00000010] = "NATIVEENDIAN";

        // This is an intensity format instead of a RGB one. The luminance
        // replaces R,G and B. (but not A)
        EPixelFormatFlags[EPixelFormatFlags["LUMINANCE"] = 0x00000020] = "LUMINANCE";
        EPixelFormatFlags[EPixelFormatFlags["STENCIL"] = 0x00000040] = "STENCIL";
    })(akra.EPixelFormatFlags || (akra.EPixelFormatFlags = {}));
    var EPixelFormatFlags = akra.EPixelFormatFlags;

    /** Pixel component format */
    (function (EPixelComponentTypes) {
        EPixelComponentTypes[EPixelComponentTypes["BYTE"] = 0] = "BYTE";
        EPixelComponentTypes[EPixelComponentTypes["SHORT"] = 1] = "SHORT";
        EPixelComponentTypes[EPixelComponentTypes["INT"] = 2] = "INT";
        EPixelComponentTypes[EPixelComponentTypes["FLOAT16"] = 3] = "FLOAT16";
        EPixelComponentTypes[EPixelComponentTypes["FLOAT32"] = 4] = "FLOAT32";
        EPixelComponentTypes[EPixelComponentTypes["COUNT"] = 5] = "COUNT";
    })(akra.EPixelComponentTypes || (akra.EPixelComponentTypes = {}));
    var EPixelComponentTypes = akra.EPixelComponentTypes;
    ;

    //used in pixelBox::scale()...
    (function (EFilters) {
        EFilters[EFilters["NEAREST"] = 0] = "NEAREST";
        EFilters[EFilters["LINEAR"] = 1] = "LINEAR";
        EFilters[EFilters["BILINEAR"] = 2] = "BILINEAR";
        EFilters[EFilters["BOX"] = 3] = "BOX";
        EFilters[EFilters["TRIANGLE"] = 4] = "TRIANGLE";
        EFilters[EFilters["BICUBIC"] = 5] = "BICUBIC";
    })(akra.EFilters || (akra.EFilters = {}));
    var EFilters = akra.EFilters;
})(akra || (akra = {}));
/// <reference path="IHardwareBuffer.ts" />
/// <reference path="IRenderTarget.ts" />
/// <reference path="IBox.ts" />
/// <reference path="EPixelFormats.ts" />
/// <reference path="IColorValue.ts" />
/// <reference path="IBox.ts" />
/// <reference path="IColor.ts" />
/// <reference path="EPixelFormats.ts" />
/// <reference path="IDepthBuffer.ts" />
/// <reference path="IFrameStats.ts" />
/// <reference path="ICamera.ts" />
/// <reference path="IPixelBuffer.ts" />
/// <reference path="ITexture.ts" />
/// <reference path="IPixelBox.ts" />
/// <reference path="IControllable.ts" />
var akra;
(function (akra) {
    (function (EFramebuffer) {
        EFramebuffer[EFramebuffer["FRONT"] = 0] = "FRONT";
        EFramebuffer[EFramebuffer["BACK"] = 1] = "BACK";
        EFramebuffer[EFramebuffer["AUTO"] = 2] = "AUTO";
    })(akra.EFramebuffer || (akra.EFramebuffer = {}));
    var EFramebuffer = akra.EFramebuffer;
    ;

    (function (EStatFlags) {
        EStatFlags[EStatFlags["NONE"] = 0] = "NONE";
        EStatFlags[EStatFlags["FPS"] = 1] = "FPS";
        EStatFlags[EStatFlags["AVG_FPS"] = 2] = "AVG_FPS";
        EStatFlags[EStatFlags["BEST_FPS"] = 4] = "BEST_FPS";
        EStatFlags[EStatFlags["WORST_FPS"] = 8] = "WORST_FPS";
        EStatFlags[EStatFlags["TRIANGLE_COUNT"] = 16] = "TRIANGLE_COUNT";
        EStatFlags[EStatFlags["ALL"] = 0xFFFF] = "ALL";
    })(akra.EStatFlags || (akra.EStatFlags = {}));
    var EStatFlags = akra.EStatFlags;
    ;
})(akra || (akra = {}));
/// <reference path="IUnique.ts" />
/// <reference path="IRenderTarget.ts" />
/// <reference path="IAFXPassInputBlend.ts" />
/// <reference path="IResourcePoolItem.ts" />
/// <reference path="IRenderer.ts" />
/// <reference path="IEffect.ts" />
/// <reference path="ISurfaceMaterial.ts" />
/// <reference path="IAFXPassInputBlend.ts" />
/// <reference path="ERenderStates.ts" />
/// <reference path="IEventProvider.ts" />
/// <reference path="IAFXComposer.ts" />
/// <reference path="ISceneObject.ts" />
/// <reference path="IRenderPass.ts" />
/// <reference path="IRenderPass.ts" />
/// <reference path="IRenderMethod.ts" />
/// <reference path="IAFXComponentBlend.ts" />
/// <reference path="IRenderData.ts" />
/// <reference path="IBuffer.ts" />
/// <reference path="IVertexBuffer.ts" />
/// <reference path="IVertexDeclaration.ts" />
/// <reference path="IRenderData.ts" />
/// <reference path="IBuffer.ts" />
/// <reference path="IReferenceCounter.ts" />
var akra;
(function (akra) {
    (function (ERenderDataBufferOptions) {
        ERenderDataBufferOptions[ERenderDataBufferOptions["VB_READABLE"] = 4 /* READABLE */] = "VB_READABLE";
        ERenderDataBufferOptions[ERenderDataBufferOptions["RD_ADVANCED_INDEX"] = 65536 /* ADVANCED_INDEX */] = "RD_ADVANCED_INDEX";
        ERenderDataBufferOptions[ERenderDataBufferOptions["RD_SINGLE_INDEX"] = 131072 /* SINGLE_INDEX */] = "RD_SINGLE_INDEX";
        ERenderDataBufferOptions[ERenderDataBufferOptions["RD_RENDERABLE"] = 262144 /* RENDERABLE */] = "RD_RENDERABLE";
    })(akra.ERenderDataBufferOptions || (akra.ERenderDataBufferOptions = {}));
    var ERenderDataBufferOptions = akra.ERenderDataBufferOptions;
    ;

    
})(akra || (akra = {}));
/// <reference path="IReferenceCounter.ts" />
/// <reference path="IEventProvider.ts" />
/// <reference path="IRenderDataCollection.ts" />
/// <reference path="IBufferMap.ts" />
/// <reference path="IVertexDeclaration.ts" />
/// <reference path="IVertexData.ts" />
var akra;
(function (akra) {
    (function (ERenderDataAttributeTypes) {
        ERenderDataAttributeTypes[ERenderDataAttributeTypes["STATIC"] = 0] = "STATIC";
        ERenderDataAttributeTypes[ERenderDataAttributeTypes["DYNAMIC"] = 1] = "DYNAMIC";
    })(akra.ERenderDataAttributeTypes || (akra.ERenderDataAttributeTypes = {}));
    var ERenderDataAttributeTypes = akra.ERenderDataAttributeTypes;
    ;

    (function (ERenderDataTypes) {
        ERenderDataTypes[ERenderDataTypes["ISOLATED"] = 0] = "ISOLATED";
        ERenderDataTypes[ERenderDataTypes["INDEXED"] = 1] = "INDEXED";
        ERenderDataTypes[ERenderDataTypes["I2I"] = 2] = "I2I";
        ERenderDataTypes[ERenderDataTypes["DIRECT"] = 3] = "DIRECT";
    })(akra.ERenderDataTypes || (akra.ERenderDataTypes = {}));
    var ERenderDataTypes = akra.ERenderDataTypes;
    ;

    (function (ERenderDataOptions) {
        ERenderDataOptions[ERenderDataOptions["ADVANCED_INDEX"] = 65536] = "ADVANCED_INDEX" /*1 << 0x10*/ ;
        ERenderDataOptions[ERenderDataOptions["SINGLE_INDEX"] = 131072] = "SINGLE_INDEX" /*1 << 0x11*/ ;

        /*<! создать RenderData как классические данные, с данными только в аттрибутах, без использования видео буфферов.*/
        ERenderDataOptions[ERenderDataOptions["RENDERABLE"] = 262144] = "RENDERABLE";
    })(akra.ERenderDataOptions || (akra.ERenderDataOptions = {}));
    var ERenderDataOptions = akra.ERenderDataOptions;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (ECompareFunction) {
        ECompareFunction[ECompareFunction["ALWAYS_FAIL"] = 0] = "ALWAYS_FAIL";
        ECompareFunction[ECompareFunction["ALWAYS_PASS"] = 1] = "ALWAYS_PASS";
        ECompareFunction[ECompareFunction["LESS"] = 2] = "LESS";
        ECompareFunction[ECompareFunction["LESS_EQUAL"] = 3] = "LESS_EQUAL";
        ECompareFunction[ECompareFunction["EQUAL"] = 4] = "EQUAL";
        ECompareFunction[ECompareFunction["NOT_EQUAL"] = 5] = "NOT_EQUAL";
        ECompareFunction[ECompareFunction["GREATER_EQUAL"] = 6] = "GREATER_EQUAL";
        ECompareFunction[ECompareFunction["GREATER"] = 7] = "GREATER";
    })(akra.ECompareFunction || (akra.ECompareFunction = {}));
    var ECompareFunction = akra.ECompareFunction;

    (function (ECullingMode) {
        ECullingMode[ECullingMode["NONE"] = 1] = "NONE";
        ECullingMode[ECullingMode["CLOCKWISE"] = 2] = "CLOCKWISE";
        ECullingMode[ECullingMode["ANTICLOCKWISE"] = 3] = "ANTICLOCKWISE";
    })(akra.ECullingMode || (akra.ECullingMode = {}));
    var ECullingMode = akra.ECullingMode;

    (function (EFrameBufferTypes) {
        EFrameBufferTypes[EFrameBufferTypes["COLOR"] = 0x1] = "COLOR";
        EFrameBufferTypes[EFrameBufferTypes["DEPTH"] = 0x2] = "DEPTH";
        EFrameBufferTypes[EFrameBufferTypes["STENCIL"] = 0x4] = "STENCIL";
    })(akra.EFrameBufferTypes || (akra.EFrameBufferTypes = {}));
    var EFrameBufferTypes = akra.EFrameBufferTypes;
})(akra || (akra = {}));
/// <reference path="IViewportState.ts" />
/// <reference path="IRect2d.ts" />
/// <reference path="IColor.ts" />
/// <reference path="IRenderTarget.ts" />
/// <reference path="ICamera.ts" />
/// <reference path="IRenderableObject.ts" />
/// <reference path="IClickable.ts" />
/// <reference path="IColor.ts" />
/// <reference path="IRID.ts" />
/// <reference path="IRect2d.ts" />
/// <reference path="IViewportState.ts" />
var akra;
(function (akra) {
    ;

    (function (EViewportTypes) {
        EViewportTypes[EViewportTypes["DEFAULT"] = -1] = "DEFAULT";
        EViewportTypes[EViewportTypes["DSVIEWPORT"] = 1] = "DSVIEWPORT";
        EViewportTypes[EViewportTypes["SHADOWVIEWPORT"] = 2] = "SHADOWVIEWPORT";
        EViewportTypes[EViewportTypes["COLORVIEWPORT"] = 3] = "COLORVIEWPORT";
        EViewportTypes[EViewportTypes["TEXTUREVIEWPORT"] = 4] = "TEXTUREVIEWPORT";
        EViewportTypes[EViewportTypes["LPPVIEWPORT"] = 5] = "LPPVIEWPORT";
        EViewportTypes[EViewportTypes["FORWARDVIEWPORT"] = 6] = "FORWARDVIEWPORT";
        EViewportTypes[EViewportTypes["MIRRORVIEWPORT"] = 7] = "MIRRORVIEWPORT";
    })(akra.EViewportTypes || (akra.EViewportTypes = {}));
    var EViewportTypes = akra.EViewportTypes;
})(akra || (akra = {}));
/// <reference path="IRenderTechnique.ts" />
/// <reference path="IEventProvider.ts" />
/// <reference path="ISceneObject.ts" />
/// <reference path="IRenderData.ts" />
/// <reference path="IViewport.ts" />
/// <reference path="IClickable.ts" />
var akra;
(function (akra) {
    (function (ERenderableTypes) {
        ERenderableTypes[ERenderableTypes["UNKNOWN"] = 0] = "UNKNOWN";

        ERenderableTypes[ERenderableTypes["MESH_SUBSET"] = 1] = "MESH_SUBSET";
        ERenderableTypes[ERenderableTypes["SCREEN"] = 2] = "SCREEN";
        ERenderableTypes[ERenderableTypes["SPRITE"] = 3] = "SPRITE";
    })(akra.ERenderableTypes || (akra.ERenderableTypes = {}));
    var ERenderableTypes = akra.ERenderableTypes;
})(akra || (akra = {}));
/// <reference path="ISceneNode.ts" />
/// <reference path="IControllable.ts" />
/// <reference path="IClickable.ts" />
/// <reference path="IRect3d.ts" />
/// <reference path="IRenderableObject.ts" />
/// <reference path="IViewport.ts" />
/// <reference path="IVec3.ts" />
/// <reference path="ICircle.ts" />
var akra;
(function (akra) {
    ;
})(akra || (akra = {}));
/// <reference path="IVec3.ts" />
var akra;
(function (akra) {
    ;
})(akra || (akra = {}));
/// <reference path="IVec3.ts" />
/// <reference path="IRay3d.ts" />
/// <reference path="IMat4.ts" />
/// <reference path="IVec3.ts" />
/// <reference path="ISphere.ts" />
/// <reference path="IRect3d.ts" />
/// <reference path="IPlane3d.ts" />
/// <reference path="ISceneObject.ts" />
/// <reference path="IViewport.ts" />
/// <reference path="IVec3.ts" />
/// <reference path="IMat4.ts" />
/// <reference path="IRect3d.ts" />
/// <reference path="IFrustum.ts" />
/// <reference path="IObjectArray.ts" />
var akra;
(function (akra) {
    (function (ECameraParameters) {
        ECameraParameters[ECameraParameters["CONST_ASPECT"] = 1] = "CONST_ASPECT";
    })(akra.ECameraParameters || (akra.ECameraParameters = {}));
    var ECameraParameters = akra.ECameraParameters;

    (function (ECameraTypes) {
        ECameraTypes[ECameraTypes["PERSPECTIVE"] = 0] = "PERSPECTIVE";
        ECameraTypes[ECameraTypes["ORTHO"] = 1] = "ORTHO";
        ECameraTypes[ECameraTypes["OFFSET_ORTHO"] = 2] = "OFFSET_ORTHO";
    })(akra.ECameraTypes || (akra.ECameraTypes = {}));
    var ECameraTypes = akra.ECameraTypes;
})(akra || (akra = {}));
/// <reference path="ISceneNode.ts" />
/// <reference path="ICamera.ts" />
/// <reference path="IFrustum.ts" />
var akra;
(function (akra) {
    (function (ELightTypes) {
        ELightTypes[ELightTypes["UNKNOWN"] = 0] = "UNKNOWN";
        ELightTypes[ELightTypes["PROJECT"] = 1] = "PROJECT";
        ELightTypes[ELightTypes["OMNI"] = 2] = "OMNI";
        ELightTypes[ELightTypes["SUN"] = 3] = "SUN";
    })(akra.ELightTypes || (akra.ELightTypes = {}));
    var ELightTypes = akra.ELightTypes;
})(akra || (akra = {}));
/// <reference path="ISkeleton.ts" />
/// <reference path="INode.ts" />
/// <reference path="IMesh.ts" />
/// <reference path="IEngine.ts" />
/// <reference path="INode.ts" />
/// <reference path="IMat4.ts" />
/// <reference path="IVertexData.ts" />
/// <reference path="IEventProvider.ts" />
/// <reference path="IMesh.ts" />
/// <reference path="ISkin.ts" />
/// <reference path="IRenderData.ts" />
/// <reference path="IRect3d.ts" />
/// <reference path="IRenderData.ts" />
/// <reference path="IEventProvider.ts" />
/// <reference path="IHardwareBuffer.ts" />
/// <reference path="IRenderDataCollection.ts" />
/// <reference path="ISkeleton.ts" />
/// <reference path="IRect3d.ts" />
/// <reference path="ISphere.ts" />
/// <reference path="IMeshSubset.ts" />
/// <reference path="ISceneNode.ts" />
/// <reference path="ISceneModel.ts" />
/// <reference path="ISkin.ts" />
var akra;
(function (akra) {
    (function (EMeshOptions) {
        EMeshOptions[EMeshOptions["HB_READABLE"] = 4 /* READABLE */] = "HB_READABLE";
        EMeshOptions[EMeshOptions["RD_ADVANCED_INDEX"] = 65536 /* ADVANCED_INDEX */] = "RD_ADVANCED_INDEX";
    })(akra.EMeshOptions || (akra.EMeshOptions = {}));
    var EMeshOptions = akra.EMeshOptions;
    ;

    (function (EMeshCloneOptions) {
        EMeshCloneOptions[EMeshCloneOptions["GEOMETRY_ONLY"] = 0x00] = "GEOMETRY_ONLY";
        EMeshCloneOptions[EMeshCloneOptions["SHARED_GEOMETRY"] = 0x01] = "SHARED_GEOMETRY";
    })(akra.EMeshCloneOptions || (akra.EMeshCloneOptions = {}));
    var EMeshCloneOptions = akra.EMeshCloneOptions;
    ;
})(akra || (akra = {}));
/// <reference path="ISceneObject.ts" />
/// <reference path="IMesh.ts" />
/// <reference path="ISceneObject.ts" />
/// <reference path="ITexture.ts" />
/// <reference path="IObjectArray.ts" />
/// <reference path="ISceneObject.ts" />
/// <reference path="ILightPoint.ts" />
/// <reference path="IObjectArray.ts" />
/// <reference path="IMat4.ts" />
/// <reference path="IFrustum.ts" />
/// <reference path="ISceneObject.ts" />
/// <reference path="IRect2d.ts" />
/// <reference path="IRenderableObject.ts" />
/// <reference path="IVertexDeclaration.ts" />
/// <reference path="ISceneObject.ts" />
/// <reference path="ITriTreeNode.ts" />
/// <reference path="IRect3d.ts" />
/// <reference path="ITerrainSection.ts" />
/// <reference path="IAnimationBase.ts" />
/// <reference path="ISceneNode.ts" />
/// <reference path="IPositionFrame.ts" />
/// <reference path="IAnimationTrack.ts" />
// supported only 4.1 ver.
/// <reference path="IModel.ts" />
/// <reference path="ISkeleton.ts" />
/// <reference path="IModel.ts" />
/// <reference path="IEngine.ts" />
/// <reference path="IMesh.ts" />
/// <reference path="IMap.ts" />
/// <reference path="IAnimation.ts" />
/// <reference path="IAnimationController.ts" />
/// <reference path="ICollada.ts" />
/// <reference path="IAnimationBase.ts" />
/// <reference path="ISceneNode.ts" />
/// <reference path="IScene3d.ts" />
/// <reference path="ISkeleton.ts" />
/// <reference path="IMesh.ts" />
var akra;
(function (akra) {
    (function (EModelFormats) {
        EModelFormats[EModelFormats["UNKNOWN"] = 0] = "UNKNOWN";
        EModelFormats[EModelFormats["COLLADA"] = 0x1000] = "COLLADA";
        EModelFormats[EModelFormats["OBJ"] = 0x2000] = "OBJ";
    })(akra.EModelFormats || (akra.EModelFormats = {}));
    var EModelFormats = akra.EModelFormats;
})(akra || (akra = {}));
/// <reference path="IResourcePoolItem.ts" />
/// <reference path="IColor.ts" />
/// <reference path="IPixelBox.ts" />
/// <reference path="EPixelFormats.ts" />
var akra;
(function (akra) {
    (function (EImageFlags) {
        EImageFlags[EImageFlags["COMPRESSED"] = 0x00000001] = "COMPRESSED";
        EImageFlags[EImageFlags["CUBEMAP"] = 0x00000002] = "CUBEMAP";
        EImageFlags[EImageFlags["TEXTURE_3D"] = 0x00000004] = "TEXTURE_3D";
    })(akra.EImageFlags || (akra.EImageFlags = {}));
    var EImageFlags = akra.EImageFlags;

    (function (EImageCubeFlags) {
        EImageCubeFlags[EImageCubeFlags["POSITIVE_X"] = 0x00000001] = "POSITIVE_X";
        EImageCubeFlags[EImageCubeFlags["NEGATIVE_X"] = 0x00000002] = "NEGATIVE_X";
        EImageCubeFlags[EImageCubeFlags["POSITIVE_Y"] = 0x00000004] = "POSITIVE_Y";
        EImageCubeFlags[EImageCubeFlags["NEGATIVE_Y"] = 0x00000008] = "NEGATIVE_Y";
        EImageCubeFlags[EImageCubeFlags["POSITIVE_Z"] = 0x000000010] = "POSITIVE_Z";
        EImageCubeFlags[EImageCubeFlags["NEGATIVE_Z"] = 0x000000020] = "NEGATIVE_Z";
    })(akra.EImageCubeFlags || (akra.EImageCubeFlags = {}));
    var EImageCubeFlags = akra.EImageCubeFlags;
})(akra || (akra = {}));
/// <reference path="IViewport.ts" />
/// <reference path="IRenderPass.ts" />
/// <reference path="ISceneObject.ts" />
/// <reference path="IEventProvider.ts" />
/// <reference path="IImg.ts" />
/// <reference path="IMegaTexture.ts" />
/// <reference path="ITerrainSection.ts" />
/// <reference path="ISceneObject.ts" />
/// <reference path="IRect3d.ts" />
/// <reference path="IViewport.ts" />
/// <reference path="ISceneNode.ts" />
/// <reference path="ITerrain.ts" />
/// <reference path="ITerrainSectionROAM.ts" />
/// <reference path="IRect3d.ts" />
/// <reference path="ISceneNode.ts" />
/// <reference path="ITriTreeNode.ts" />
/// <reference path="ICamera.ts" />
/// <reference path="ISceneNode.ts" />
/// <reference path="IModel.ts" />
/// <reference path="IAnimationController.ts" />
/// <reference path="IScene.ts" />
/// <reference path="ILightPoint.ts" />
/// <reference path="ISceneNode.ts" />
/// <reference path="ISceneModel.ts" />
/// <reference path="ISceneObject.ts" />
/// <reference path="ICamera.ts" />
/// <reference path="ISprite.ts" />
/// <reference path="IJoint.ts" />
/// <reference path="IDisplayList.ts" />
/// <reference path="IViewport.ts" />
/// <reference path="IShadowCaster.ts" />
/// <reference path="ITerrainSection.ts" />
/// <reference path="ITerrainSectionROAM.ts" />
/// <reference path="IModel.ts" />
/// <reference path="ITerrain.ts" />
/// <reference path="ITerrainROAM.ts" />
/// <reference path="IModelEntry.ts" />
/// <reference path="IScene.ts" />
/// <reference path="IManager.ts" />
/// <reference path="IScene.ts" />
/// <reference path="IEngine.ts" />
/// <reference path="IEngine.ts" />
/// <reference path="IScene3d.ts" />
/// <reference path="IScene2d.ts" />
/// <reference path="IManager.ts" />
var akra;
(function (akra) {
    (function (EResourceCodes) {
        EResourceCodes[EResourceCodes["INVALID_CODE"] = 0xFFFFFFFF] = "INVALID_CODE";
    })(akra.EResourceCodes || (akra.EResourceCodes = {}));
    var EResourceCodes = akra.EResourceCodes;
})(akra || (akra = {}));
/// <reference path="IEngine.ts" />
/// <reference path="IResourceCode.ts" />
/// <reference path="IResourcePoolItem.ts" />
/// <reference path="IResourcePoolManager.ts" />
/// <reference path="IResourcePoolItem.ts" />
/// <reference path="IMat4.ts" />
/// <reference path="IModel.ts" />
/// <reference path="IManager.ts" />
/// <reference path="IEngine.ts" />
/// <reference path="IResourceCode.ts" />
/// <reference path="IResourcePool.ts" />
/// <reference path="IResourceWatcherFunc.ts" />
/// <reference path="IResourcePoolItem.ts" />
/// <reference path="IRenderMethod.ts" />
/// <reference path="ITexture.ts" />
/// <reference path="IVertexBuffer.ts" />
/// <reference path="IModel.ts" />
/// <reference path="ISurfaceMaterial.ts" />
/// <reference path="IEffect.ts" />
/// <reference path="IShaderProgram.ts" />
/// <reference path="IModel.ts" />
/// <reference path="IObj.ts" />
/** Семейства ресурсов */
var akra;
(function (akra) {
    (function (EResourceFamilies) {
        EResourceFamilies[EResourceFamilies["VIDEO_RESOURCE"] = 0] = "VIDEO_RESOURCE";
        EResourceFamilies[EResourceFamilies["AUDIO_RESOURCE"] = 1] = "AUDIO_RESOURCE";
        EResourceFamilies[EResourceFamilies["GAME_RESOURCE"] = 2] = "GAME_RESOURCE";
        EResourceFamilies[EResourceFamilies["TOTAL_RESOURCE_FAMILIES"] = 3] = "TOTAL_RESOURCE_FAMILIES";
    })(akra.EResourceFamilies || (akra.EResourceFamilies = {}));
    var EResourceFamilies = akra.EResourceFamilies;
    ;

    /** Члены семейства видео ресурсов */
    (function (EVideoResources) {
        EVideoResources[EVideoResources["TEXTURE_RESOURCE"] = 0] = "TEXTURE_RESOURCE";
        EVideoResources[EVideoResources["VIDEOBUFFER_RESOURCE"] = 1] = "VIDEOBUFFER_RESOURCE";
        EVideoResources[EVideoResources["VERTEXBUFFER_RESOURCE"] = 2] = "VERTEXBUFFER_RESOURCE";
        EVideoResources[EVideoResources["INDEXBUFFER_RESOURCE"] = 3] = "INDEXBUFFER_RESOURCE";
        EVideoResources[EVideoResources["EFFECT_RESOURCE"] = 4] = "EFFECT_RESOURCE";
        EVideoResources[EVideoResources["RENDERMETHOD_RESOURCE"] = 5] = "RENDERMETHOD_RESOURCE";
        EVideoResources[EVideoResources["MODEL_RESOURCE"] = 6] = "MODEL_RESOURCE";
        EVideoResources[EVideoResources["EFFECTFILEDATA_RESOURCE"] = 7] = "EFFECTFILEDATA_RESOURCE";
        EVideoResources[EVideoResources["IMAGE_RESOURCE"] = 8] = "IMAGE_RESOURCE";
        EVideoResources[EVideoResources["SURFACEMATERIAL_RESOURCE"] = 9] = "SURFACEMATERIAL_RESOURCE";
        EVideoResources[EVideoResources["SHADERPROGRAM_RESOURCE"] = 10] = "SHADERPROGRAM_RESOURCE";
        EVideoResources[EVideoResources["COMPONENT_RESOURCE"] = 11] = "COMPONENT_RESOURCE";
        EVideoResources[EVideoResources["EFFECTDATA_RESOURCE"] = 12] = "EFFECTDATA_RESOURCE";
        EVideoResources[EVideoResources["TOTAL_VIDEO_RESOURCES"] = 13] = "TOTAL_VIDEO_RESOURCES";
    })(akra.EVideoResources || (akra.EVideoResources = {}));
    var EVideoResources = akra.EVideoResources;
    ;

    (function (EAudioResources) {
        EAudioResources[EAudioResources["TOTAL_AUDIO_RESOURCES"] = 0] = "TOTAL_AUDIO_RESOURCES";
    })(akra.EAudioResources || (akra.EAudioResources = {}));
    var EAudioResources = akra.EAudioResources;
    ;

    (function (EGameResources) {
        EGameResources[EGameResources["TOTAL_GAME_RESOURCES"] = 0] = "TOTAL_GAME_RESOURCES";
    })(akra.EGameResources || (akra.EGameResources = {}));
    var EGameResources = akra.EGameResources;
    ;

    
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EUtilTimerCommands) {
        //! <to reset the timer
        EUtilTimerCommands[EUtilTimerCommands["TIMER_RESET"] = 0] = "TIMER_RESET";

        //! <to start the timer
        EUtilTimerCommands[EUtilTimerCommands["TIMER_START"] = 1] = "TIMER_START";

        //! <to stop (or pause) the timer
        EUtilTimerCommands[EUtilTimerCommands["TIMER_STOP"] = 2] = "TIMER_STOP";

        //! <to advance the timer by 0.1 seconds
        EUtilTimerCommands[EUtilTimerCommands["TIMER_ADVANCE"] = 3] = "TIMER_ADVANCE";

        //! <to get the absolute system time
        EUtilTimerCommands[EUtilTimerCommands["TIMER_GET_ABSOLUTE_TIME"] = 4] = "TIMER_GET_ABSOLUTE_TIME";

        //! <to get the current time
        EUtilTimerCommands[EUtilTimerCommands["TIMER_GET_APP_TIME"] = 5] = "TIMER_GET_APP_TIME";
        EUtilTimerCommands[EUtilTimerCommands["TIMER_GET_ELAPSED_TIME"] = 6] = "TIMER_GET_ELAPSED_TIME";
    })(akra.EUtilTimerCommands || (akra.EUtilTimerCommands = {}));
    var EUtilTimerCommands = akra.EUtilTimerCommands;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EDependenceStatuses) {
        EDependenceStatuses[EDependenceStatuses["PENDING"] = 0] = "PENDING";
        EDependenceStatuses[EDependenceStatuses["INITIALIZATION"] = 1] = "INITIALIZATION";
        EDependenceStatuses[EDependenceStatuses["CHECKING"] = 2] = "CHECKING";
        EDependenceStatuses[EDependenceStatuses["LOADING"] = 3] = "LOADING";
        EDependenceStatuses[EDependenceStatuses["DOWNLOADING"] = 4] = "DOWNLOADING";
        EDependenceStatuses[EDependenceStatuses["UNPACKING"] = 5] = "UNPACKING";
        EDependenceStatuses[EDependenceStatuses["EXTRACTION"] = 6] = "EXTRACTION";
        EDependenceStatuses[EDependenceStatuses["LOADED"] = 7] = "LOADED";

        EDependenceStatuses[EDependenceStatuses["REJECTED"] = 8] = "REJECTED";
        EDependenceStatuses[EDependenceStatuses["INTERNAL_UPDATE"] = 9] = "INTERNAL_UPDATE";
    })(akra.EDependenceStatuses || (akra.EDependenceStatuses = {}));
    var EDependenceStatuses = akra.EDependenceStatuses;
})(akra || (akra = {}));
/// <reference path="IEventProvider.ts" />
/// <reference path="3d-party/gamepad.d.ts" />
var akra;
(function (akra) {
    (function (EGamepadCodes) {
        EGamepadCodes[EGamepadCodes["FACE_1"] = 0] = "FACE_1";
        EGamepadCodes[EGamepadCodes["FACE_2"] = 1] = "FACE_2";
        EGamepadCodes[EGamepadCodes["FACE_3"] = 2] = "FACE_3";
        EGamepadCodes[EGamepadCodes["FACE_4"] = 3] = "FACE_4";
        EGamepadCodes[EGamepadCodes["LEFT_SHOULDER"] = 4] = "LEFT_SHOULDER";
        EGamepadCodes[EGamepadCodes["RIGHT_SHOULDER"] = 5] = "RIGHT_SHOULDER";
        EGamepadCodes[EGamepadCodes["LEFT_SHOULDER_BOTTOM"] = 6] = "LEFT_SHOULDER_BOTTOM";
        EGamepadCodes[EGamepadCodes["RIGHT_SHOULDER_BOTTOM"] = 7] = "RIGHT_SHOULDER_BOTTOM";
        EGamepadCodes[EGamepadCodes["SELECT"] = 8] = "SELECT";
        EGamepadCodes[EGamepadCodes["START"] = 9] = "START";
        EGamepadCodes[EGamepadCodes["LEFT_ANALOGUE_STICK"] = 10] = "LEFT_ANALOGUE_STICK";
        EGamepadCodes[EGamepadCodes["RIGHT_ANALOGUE_STICK"] = 11] = "RIGHT_ANALOGUE_STICK";
        EGamepadCodes[EGamepadCodes["PAD_TOP"] = 12] = "PAD_TOP";
        EGamepadCodes[EGamepadCodes["PAD_BOTTOM"] = 13] = "PAD_BOTTOM";
        EGamepadCodes[EGamepadCodes["PAD_LEFT"] = 14] = "PAD_LEFT";
        EGamepadCodes[EGamepadCodes["PAD_RIGHT"] = 15] = "PAD_RIGHT";
    })(akra.EGamepadCodes || (akra.EGamepadCodes = {}));
    var EGamepadCodes = akra.EGamepadCodes;

    (function (EGamepadAxis) {
        EGamepadAxis[EGamepadAxis["LEFT_ANALOGUE_HOR"] = 0] = "LEFT_ANALOGUE_HOR";
        EGamepadAxis[EGamepadAxis["LEFT_ANALOGUE_VERT"] = 1] = "LEFT_ANALOGUE_VERT";
        EGamepadAxis[EGamepadAxis["RIGHT_ANALOGUE_HOR"] = 2] = "RIGHT_ANALOGUE_HOR";
        EGamepadAxis[EGamepadAxis["RIGHT_ANALOGUE_VERT"] = 3] = "RIGHT_ANALOGUE_VERT";
    })(akra.EGamepadAxis || (akra.EGamepadAxis = {}));
    var EGamepadAxis = akra.EGamepadAxis;
})(akra || (akra = {}));
/// <reference path="ISprite.ts" />
/// <reference path="IRenderData.ts" />
/// <reference path="ISceneManager.ts" />
/// <reference path="IParticleManager.ts" />
/// <reference path="IResourcePoolManager.ts" />
/// <reference path="IRenderer.ts" />
/// <reference path="IUtilTimer.ts" />
/// <reference path="IMesh.ts" />
/// <reference path="IRenderDataCollection.ts" />
/// <reference path="IBufferMap.ts" />
/// <reference path="IAnimationController.ts" />
/// <reference path="ISkeleton.ts" />
/// <reference path="IScene3d.ts" />
/// <reference path="IDeps.ts" />
/// <reference path="IAFXComposer.ts" />
/// <reference path="IGamepadMap.ts" />
/// <reference path="ISpriteManager.ts" />
var akra;
(function (akra) {
    ;

    var createEngine;
})(akra || (akra = {}));
/// <reference path="IReferenceCounter.ts" />
/// <reference path="IEventProvider.ts" />
/// <reference path="IEngine.ts" />
/// <reference path="IResourceWatcherFunc.ts" />
/// <reference path="IResourceNotifyRoutineFunc.ts" />
/// <reference path="IResourceCode.ts" />
/// <reference path="IResourcePool.ts" />
/// <reference path="IResourcePoolManager.ts" />
/**
* Отражает состояние ресурса
**/
var akra;
(function (akra) {
    (function (EResourceItemEvents) {
        //ресур создан
        EResourceItemEvents[EResourceItemEvents["CREATED"] = 0] = "CREATED";

        //ресур заполнен данным и готов к использованию
        EResourceItemEvents[EResourceItemEvents["LOADED"] = 1] = "LOADED";

        //ресур в данный момент отключен для использования
        EResourceItemEvents[EResourceItemEvents["DISABLED"] = 2] = "DISABLED";

        //ресур был изменен после загрузки
        EResourceItemEvents[EResourceItemEvents["ALTERED"] = 3] = "ALTERED";
        EResourceItemEvents[EResourceItemEvents["TOTALRESOURCEFLAGS"] = 4] = "TOTALRESOURCEFLAGS";
    })(akra.EResourceItemEvents || (akra.EResourceItemEvents = {}));
    var EResourceItemEvents = akra.EResourceItemEvents;
    ;
})(akra || (akra = {}));
/// <reference path="IResourcePoolItem.ts" />
/// <reference path="IRenderResource.ts" />
/// <reference path="IHardwareBuffer.ts" />
/// <reference path="IPixelBuffer.ts" />
/// <reference path="IImg.ts" />
/// <reference path="EPixelFormats.ts" />
var akra;
(function (akra) {
    (function (ETextureFlags) {
        ETextureFlags[ETextureFlags["STATIC"] = 1 /* STATIC */] = "STATIC";
        ETextureFlags[ETextureFlags["DYNAMIC"] = 2 /* DYNAMIC */] = "DYNAMIC";
        ETextureFlags[ETextureFlags["READEBLE"] = 4 /* READABLE */] = "READEBLE";
        ETextureFlags[ETextureFlags["DYNAMIC_DISCARDABLE"] = 66 /* DYNAMIC_DISCARDABLE */] = "DYNAMIC_DISCARDABLE";

        /// mipmaps will be automatically generated for this texture
        ETextureFlags[ETextureFlags["AUTOMIPMAP"] = 0x100] = "AUTOMIPMAP";

        /// this texture will be a render target, i.e. used as a target for render to texture
        /// setting this flag will ignore all other texture usages except AUTOMIPMAP
        ETextureFlags[ETextureFlags["RENDERTARGET"] = 0x200] = "RENDERTARGET";

        /// default to automatic mipmap generation static textures
        ETextureFlags[ETextureFlags["DEFAULT"] = 1 /* STATIC */] = "DEFAULT";
    })(akra.ETextureFlags || (akra.ETextureFlags = {}));
    var ETextureFlags = akra.ETextureFlags;

    (function (ETextureFilters) {
        ETextureFilters[ETextureFilters["UNDEF"] = 0x0000] = "UNDEF";
        ETextureFilters[ETextureFilters["NEAREST"] = 0x2600] = "NEAREST";
        ETextureFilters[ETextureFilters["LINEAR"] = 0x2601] = "LINEAR";
        ETextureFilters[ETextureFilters["NEAREST_MIPMAP_NEAREST"] = 0x2700] = "NEAREST_MIPMAP_NEAREST";
        ETextureFilters[ETextureFilters["LINEAR_MIPMAP_NEAREST"] = 0x2701] = "LINEAR_MIPMAP_NEAREST";
        ETextureFilters[ETextureFilters["NEAREST_MIPMAP_LINEAR"] = 0x2702] = "NEAREST_MIPMAP_LINEAR";
        ETextureFilters[ETextureFilters["LINEAR_MIPMAP_LINEAR"] = 0x2703] = "LINEAR_MIPMAP_LINEAR";
    })(akra.ETextureFilters || (akra.ETextureFilters = {}));
    var ETextureFilters = akra.ETextureFilters;

    (function (ETextureWrapModes) {
        ETextureWrapModes[ETextureWrapModes["UNDEF"] = 0x0000] = "UNDEF";
        ETextureWrapModes[ETextureWrapModes["REPEAT"] = 0x2901] = "REPEAT";
        ETextureWrapModes[ETextureWrapModes["CLAMP_TO_EDGE"] = 0x812F] = "CLAMP_TO_EDGE";
        ETextureWrapModes[ETextureWrapModes["MIRRORED_REPEAT"] = 0x8370] = "MIRRORED_REPEAT";
    })(akra.ETextureWrapModes || (akra.ETextureWrapModes = {}));
    var ETextureWrapModes = akra.ETextureWrapModes;

    (function (ETextureParameters) {
        ETextureParameters[ETextureParameters["MAG_FILTER"] = 0x2800] = "MAG_FILTER";
        ETextureParameters[ETextureParameters["MIN_FILTER"] = 10241] = "MIN_FILTER";
        ETextureParameters[ETextureParameters["WRAP_S"] = 10242] = "WRAP_S";
        ETextureParameters[ETextureParameters["WRAP_T"] = 10243] = "WRAP_T";
    })(akra.ETextureParameters || (akra.ETextureParameters = {}));
    var ETextureParameters = akra.ETextureParameters;

    (function (ETextureTypes) {
        ETextureTypes[ETextureTypes["TEXTURE_2D"] = 0x0DE1] = "TEXTURE_2D";
        ETextureTypes[ETextureTypes["TEXTURE_CUBE_MAP"] = 0x8513] = "TEXTURE_CUBE_MAP";
    })(akra.ETextureTypes || (akra.ETextureTypes = {}));
    var ETextureTypes = akra.ETextureTypes;

    (function (ECubeFace) {
        ECubeFace[ECubeFace["POSITIVE_X"] = 0] = "POSITIVE_X";
        ECubeFace[ECubeFace["NEGATIVE_X"] = 1] = "NEGATIVE_X";
        ECubeFace[ECubeFace["POSITIVE_Y"] = 2] = "POSITIVE_Y";
        ECubeFace[ECubeFace["NEGATIVE_Y"] = 3] = "NEGATIVE_Y";
        ECubeFace[ECubeFace["POSITIVE_Z"] = 4] = "POSITIVE_Z";
        ECubeFace[ECubeFace["NEGATIVE_Z"] = 5] = "NEGATIVE_Z";
    })(akra.ECubeFace || (akra.ECubeFace = {}));
    var ECubeFace = akra.ECubeFace;

    (function (ETextureCubeFlags) {
        ETextureCubeFlags[ETextureCubeFlags["POSITIVE_X"] = 0x00000001] = "POSITIVE_X";
        ETextureCubeFlags[ETextureCubeFlags["NEGATIVE_X"] = 0x00000002] = "NEGATIVE_X";
        ETextureCubeFlags[ETextureCubeFlags["POSITIVE_Y"] = 0x00000004] = "POSITIVE_Y";
        ETextureCubeFlags[ETextureCubeFlags["NEGATIVE_Y"] = 0x00000008] = "NEGATIVE_Y";
        ETextureCubeFlags[ETextureCubeFlags["POSITIVE_Z"] = 0x0000000c] = "POSITIVE_Z";
        ETextureCubeFlags[ETextureCubeFlags["NEGATIVE_Z"] = 0x000000010] = "NEGATIVE_Z";
    })(akra.ETextureCubeFlags || (akra.ETextureCubeFlags = {}));
    var ETextureCubeFlags = akra.ETextureCubeFlags;

    (function (ETextureUnits) {
        ETextureUnits[ETextureUnits["TEXTURE0"] = 0x84C0] = "TEXTURE0";
    })(akra.ETextureUnits || (akra.ETextureUnits = {}));
    var ETextureUnits = akra.ETextureUnits;

    
})(akra || (akra = {}));
/// <reference path="ITexture.ts" />
/// <reference path="IAFXSamplerState.ts" />
/// <reference path="IVertexData.ts" />
/// <reference path="ITexture.ts" />
/// <reference path="IMat3.ts" />
/// <reference path="IMat4.ts" />
/// <reference path="IVec2.ts" />
/// <reference path="IVec3.ts" />
/// <reference path="IVec4.ts" />
/// <reference path="IQuat4.ts" />
/// <reference path="IBufferMap.ts" />
/// <reference path="IAFXInstruction.ts" />
/// <reference path="IMap.ts" />
/// <reference path="IShaderProgram.ts" />
/// <reference path="IUnique.ts" />
/// <reference path="IAFXSamplerBlender.ts" />
/// <reference path="IAFXAttributeBlendContainer.ts" />
/// <reference path="IAFXPassInputBlend.ts" />
/// <reference path="IBufferMap.ts" />
/// <reference path="IAFXPassInputBlend.ts" />
/// <reference path="IShaderInput.ts" />
/// <reference path="IAFXInstruction.ts" />
/// <reference path="IAFXMaker.ts" />
/// <reference path="IShaderInput.ts" />
/// <reference path="IBufferMap.ts" />
/// <reference path="IViewport.ts" />
/// <reference path="IRenderEntry.ts" />
/// <reference path="parser/IParser.ts" />
/// <reference path="IAFXInstruction.ts" />
/// <reference path="IHardwareBuffer.ts" />
/// <reference path="IRenderResource.ts" />
/// <reference path="IRenderer.ts" />
/// <reference path="IIndexData.ts" />
/// <reference path="EDataTypes.ts" />
var akra;
(function (akra) {
    (function (ECanvasTypes) {
        ECanvasTypes[ECanvasTypes["TYPE_UNKNOWN"] = -1] = "TYPE_UNKNOWN";
        ECanvasTypes[ECanvasTypes["TYPE_2D"] = 1] = "TYPE_2D";
        ECanvasTypes[ECanvasTypes["TYPE_3D"] = 2] = "TYPE_3D";
    })(akra.ECanvasTypes || (akra.ECanvasTypes = {}));
    var ECanvasTypes = akra.ECanvasTypes;
    ;
})(akra || (akra = {}));
/// <reference path="ICanvas.ts" />
/// <reference path="IPoint.ts" />
/// <reference path="IEventProvider.ts" />
/// <reference path="IRenderQueue.ts" />
/// <reference path="IViewportState.ts" />
/// <reference path="IAFXComponent.ts" />
/// <reference path="IAFXEffect.ts" />
/// <reference path="IRenderableObject.ts" />
/// <reference path="ISceneObject.ts" />
/// <reference path="IBufferMap.ts" />
/// <reference path="IShaderProgram.ts" />
/// <reference path="ISurfaceMaterial.ts" />
/// <reference path="IVertexData.ts" />
/// <reference path="IVertexBuffer.ts" />
/// <reference path="ITexture.ts" />
/// <reference path="IIndexBuffer.ts" />
/// <reference path="IRenderResource.ts" />
/// <reference path="IRenderEntry.ts" />
/// <reference path="IViewport.ts" />
/// <reference path="IColor.ts" />
/// <reference path="IEngine.ts" />
/// <reference path="IRenderTarget.ts" />
/// <reference path="ICanvas3d.ts" />
/// <reference path="IViewportState.ts" />
/// <reference path="3d-party/webgl.d.ts" />
var akra;
(function (akra) {
    function CAPABILITYVALUE(category, value) {
        return ((category << (32 - 4)) | (1 << value));
    }

    (function (ERenderers) {
        ERenderers[ERenderers["UNKNOWN"] = 0] = "UNKNOWN";
        ERenderers[ERenderers["WEBGL"] = 1] = "WEBGL";
    })(akra.ERenderers || (akra.ERenderers = {}));
    var ERenderers = akra.ERenderers;

    //API SPECIFIFC CONSTANTS
    (function (ERenderCapabilitiesCategory) {
        ERenderCapabilitiesCategory[ERenderCapabilitiesCategory["C_COMMON"] = 0] = "C_COMMON";
        ERenderCapabilitiesCategory[ERenderCapabilitiesCategory["C_COMMON_2"] = 1] = "C_COMMON_2";
        ERenderCapabilitiesCategory[ERenderCapabilitiesCategory["C_WEBGL"] = 2] = "C_WEBGL";

        ERenderCapabilitiesCategory[ERenderCapabilitiesCategory["COUNT"] = 3] = "COUNT";
    })(akra.ERenderCapabilitiesCategory || (akra.ERenderCapabilitiesCategory = {}));
    var ERenderCapabilitiesCategory = akra.ERenderCapabilitiesCategory;

    (function (ERenderCapabilities) {
        ERenderCapabilities[ERenderCapabilities["AUTOMIPMAP"] = CAPABILITYVALUE(0 /* C_COMMON */, 0)] = "AUTOMIPMAP";
        ERenderCapabilities[ERenderCapabilities["BLENDING"] = CAPABILITYVALUE(0 /* C_COMMON */, 1)] = "BLENDING";

        /// Supports anisotropic texture filtering
        ERenderCapabilities[ERenderCapabilities["ANISOTROPY"] = CAPABILITYVALUE(0 /* C_COMMON */, 2)] = "ANISOTROPY";

        /// Supports fixed-function DOT3 texture blend
        ERenderCapabilities[ERenderCapabilities["DOT3"] = CAPABILITYVALUE(0 /* C_COMMON */, 3)] = "DOT3";

        /// Supports cube mapping
        ERenderCapabilities[ERenderCapabilities["CUBEMAPPING"] = CAPABILITYVALUE(0 /* C_COMMON */, 4)] = "CUBEMAPPING";

        /// Supports hardware stencil buffer
        ERenderCapabilities[ERenderCapabilities["HWSTENCIL"] = CAPABILITYVALUE(0 /* C_COMMON */, 5)] = "HWSTENCIL";

        /// Supports hardware vertex and index buffers
        ERenderCapabilities[ERenderCapabilities["VBO"] = CAPABILITYVALUE(0 /* C_COMMON */, 7)] = "VBO";

        /// Supports vertex programs (vertex shaders)
        ERenderCapabilities[ERenderCapabilities["VERTEX_PROGRAM"] = CAPABILITYVALUE(0 /* C_COMMON */, 9)] = "VERTEX_PROGRAM";

        /// Supports fragment programs (pixel shaders)
        ERenderCapabilities[ERenderCapabilities["FRAGMENT_PROGRAM"] = CAPABILITYVALUE(0 /* C_COMMON */, 10)] = "FRAGMENT_PROGRAM";

        /// Supports performing a scissor test to exclude areas of the screen
        ERenderCapabilities[ERenderCapabilities["SCISSOR_TEST"] = CAPABILITYVALUE(0 /* C_COMMON */, 11)] = "SCISSOR_TEST";

        /// Supports separate stencil updates for both front and back faces
        ERenderCapabilities[ERenderCapabilities["TWO_SIDED_STENCIL"] = CAPABILITYVALUE(0 /* C_COMMON */, 12)] = "TWO_SIDED_STENCIL";

        /// Supports wrapping the stencil value at the range extremeties
        ERenderCapabilities[ERenderCapabilities["STENCIL_WRAP"] = CAPABILITYVALUE(0 /* C_COMMON */, 13)] = "STENCIL_WRAP";

        /// Supports hardware occlusion queries
        ERenderCapabilities[ERenderCapabilities["HWOCCLUSION"] = CAPABILITYVALUE(0 /* C_COMMON */, 14)] = "HWOCCLUSION";

        /// Supports user clipping planes
        ERenderCapabilities[ERenderCapabilities["USER_CLIP_PLANES"] = CAPABILITYVALUE(0 /* C_COMMON */, 15)] = "USER_CLIP_PLANES";

        /// Supports the VET_UBYTE4 vertex element type
        ERenderCapabilities[ERenderCapabilities["VERTEX_FORMAT_UBYTE4"] = CAPABILITYVALUE(0 /* C_COMMON */, 16)] = "VERTEX_FORMAT_UBYTE4";

        /// Supports infinite far plane projection
        ERenderCapabilities[ERenderCapabilities["INFINITE_FAR_PLANE"] = CAPABILITYVALUE(0 /* C_COMMON */, 17)] = "INFINITE_FAR_PLANE";

        /// Supports hardware render-to-texture (bigger than framebuffer)
        ERenderCapabilities[ERenderCapabilities["HWRENDER_TO_TEXTURE"] = CAPABILITYVALUE(0 /* C_COMMON */, 18)] = "HWRENDER_TO_TEXTURE";

        /// Supports float textures and render targets
        ERenderCapabilities[ERenderCapabilities["TEXTURE_FLOAT"] = CAPABILITYVALUE(0 /* C_COMMON */, 19)] = "TEXTURE_FLOAT";

        /// Supports non-power of two textures
        ERenderCapabilities[ERenderCapabilities["NON_POWER_OF_2_TEXTURES"] = CAPABILITYVALUE(0 /* C_COMMON */, 20)] = "NON_POWER_OF_2_TEXTURES";

        /// Supports 3d (volume) textures
        ERenderCapabilities[ERenderCapabilities["TEXTURE_3D"] = CAPABILITYVALUE(0 /* C_COMMON */, 21)] = "TEXTURE_3D";

        /// Supports basic point sprite rendering
        ERenderCapabilities[ERenderCapabilities["POINT_SPRITES"] = CAPABILITYVALUE(0 /* C_COMMON */, 22)] = "POINT_SPRITES";

        /// Supports extra point parameters (minsize, maxsize, attenuation)
        ERenderCapabilities[ERenderCapabilities["POINT_EXTENDED_PARAMETERS"] = CAPABILITYVALUE(0 /* C_COMMON */, 23)] = "POINT_EXTENDED_PARAMETERS";

        /// Supports vertex texture fetch
        ERenderCapabilities[ERenderCapabilities["VERTEX_TEXTURE_FETCH"] = CAPABILITYVALUE(0 /* C_COMMON */, 24)] = "VERTEX_TEXTURE_FETCH";

        /// Supports mipmap LOD biasing
        ERenderCapabilities[ERenderCapabilities["MIPMAP_LOD_BIAS"] = CAPABILITYVALUE(0 /* C_COMMON */, 25)] = "MIPMAP_LOD_BIAS";

        /// Supports hardware geometry programs
        ERenderCapabilities[ERenderCapabilities["GEOMETRY_PROGRAM"] = CAPABILITYVALUE(0 /* C_COMMON */, 26)] = "GEOMETRY_PROGRAM";

        /// Supports rendering to vertex buffers
        ERenderCapabilities[ERenderCapabilities["HWRENDER_TO_VERTEX_BUFFER"] = CAPABILITYVALUE(0 /* C_COMMON */, 27)] = "HWRENDER_TO_VERTEX_BUFFER";

        /// Supports compressed textures
        ERenderCapabilities[ERenderCapabilities["TEXTURE_COMPRESSION"] = CAPABILITYVALUE(1 /* C_COMMON_2 */, 0)] = "TEXTURE_COMPRESSION";

        /// Supports compressed textures in the DXT/ST3C formats
        ERenderCapabilities[ERenderCapabilities["TEXTURE_COMPRESSION_DXT"] = CAPABILITYVALUE(1 /* C_COMMON_2 */, 1)] = "TEXTURE_COMPRESSION_DXT";

        /// Supports compressed textures in the VTC format
        ERenderCapabilities[ERenderCapabilities["TEXTURE_COMPRESSION_VTC"] = CAPABILITYVALUE(1 /* C_COMMON_2 */, 2)] = "TEXTURE_COMPRESSION_VTC";

        /// Supports compressed textures in the PVRTC format
        ERenderCapabilities[ERenderCapabilities["TEXTURE_COMPRESSION_PVRTC"] = CAPABILITYVALUE(1 /* C_COMMON_2 */, 3)] = "TEXTURE_COMPRESSION_PVRTC";

        ERenderCapabilities[ERenderCapabilities["TEXTURE_COMPRESSION_ATC"] = CAPABILITYVALUE(1 /* C_COMMON_2 */, 13)] = "TEXTURE_COMPRESSION_ATC";

        /// Supports fixed-function pipeline
        ERenderCapabilities[ERenderCapabilities["FIXED_FUNCTION"] = CAPABILITYVALUE(1 /* C_COMMON_2 */, 4)] = "FIXED_FUNCTION";

        /// Supports MRTs with different bit depths
        ERenderCapabilities[ERenderCapabilities["MRT_DIFFERENT_BIT_DEPTHS"] = CAPABILITYVALUE(1 /* C_COMMON_2 */, 5)] = "MRT_DIFFERENT_BIT_DEPTHS";

        /// Supports Alpha to Coverage (A2C)
        ERenderCapabilities[ERenderCapabilities["ALPHA_TO_COVERAGE"] = CAPABILITYVALUE(1 /* C_COMMON_2 */, 6)] = "ALPHA_TO_COVERAGE";

        /// Supports Blending operations other than +
        ERenderCapabilities[ERenderCapabilities["ADVANCED_BLEND_OPERATIONS"] = CAPABILITYVALUE(1 /* C_COMMON_2 */, 7)] = "ADVANCED_BLEND_OPERATIONS";

        /// Supports a separate depth buffer for RTTs. D3D 9 & 10, OGL w/FBO (FBO implies this flag)
        ERenderCapabilities[ERenderCapabilities["RTT_SEPARATE_DEPTHBUFFER"] = CAPABILITYVALUE(1 /* C_COMMON_2 */, 8)] = "RTT_SEPARATE_DEPTHBUFFER";

        /// Supports using the MAIN depth buffer for RTTs. D3D 9&10, OGL w/FBO support unknown
        /// (undefined behavior?), OGL w/ copy supports it
        ERenderCapabilities[ERenderCapabilities["RTT_MAIN_DEPTHBUFFER_ATTACHABLE"] = CAPABILITYVALUE(1 /* C_COMMON_2 */, 9)] = "RTT_MAIN_DEPTHBUFFER_ATTACHABLE";

        /// Supports attaching a depth buffer to an RTT that has width & height less or equal than RTT's.
        /// Otherwise must be of _exact_ same resolution. D3D 9, OGL 3.0 (not 2.0, not D3D10)
        ERenderCapabilities[ERenderCapabilities["RTT_DEPTHBUFFER_RESOLUTION_LESSEQUAL"] = CAPABILITYVALUE(1 /* C_COMMON_2 */, 10)] = "RTT_DEPTHBUFFER_RESOLUTION_LESSEQUAL";

        /// Supports using vertex buffers for instance data
        ERenderCapabilities[ERenderCapabilities["VERTEX_BUFFER_INSTANCE_DATA"] = CAPABILITYVALUE(1 /* C_COMMON_2 */, 11)] = "VERTEX_BUFFER_INSTANCE_DATA";

        /// Supports using vertex buffers for instance data
        ERenderCapabilities[ERenderCapabilities["CAN_GET_COMPILED_SHADER_BUFFER"] = CAPABILITYVALUE(1 /* C_COMMON_2 */, 12)] = "CAN_GET_COMPILED_SHADER_BUFFER";

        // ***** GL Specific Caps *****
        /// Support for Frame Buffer Objects (FBOs)
        ERenderCapabilities[ERenderCapabilities["FBO"] = CAPABILITYVALUE(2 /* C_WEBGL */, 2)] = "FBO";

        /// Support for PBuffer
        ERenderCapabilities[ERenderCapabilities["PBUFFER"] = CAPABILITYVALUE(2 /* C_WEBGL */, 5)] = "PBUFFER";

        ERenderCapabilities[ERenderCapabilities["SEPARATE_SHADER_OBJECTS"] = CAPABILITYVALUE(2 /* C_WEBGL */, 9)] = "SEPARATE_SHADER_OBJECTS";
    })(akra.ERenderCapabilities || (akra.ERenderCapabilities = {}));
    var ERenderCapabilities = akra.ERenderCapabilities;

    // export enum EGLSpecifics {
    //	 UNPACK_ALIGNMENT = 0x0CF5,
    //	 PACK_ALIGNMENT = 0x0D05,
    //	 UNPACK_FLIP_Y_WEBGL = 0x9240,
    //	 UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241,
    //	 CONTEXT_LOST_WEBGL = 0x9242,
    //	 UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243,
    //	 BROWSER_DEFAULT_WEBGL = 0x9244
    // };
    // export enum EBufferMasks {
    //	 DEPTH_BUFFER_BIT			   = 0x00000100,
    //	 STENCIL_BUFFER_BIT			 = 0x00000400,
    //	 COLOR_BUFFER_BIT			   = 0x00004000
    // };
    // export enum EBufferUsages {
    //	 STREAM_DRAW = 0x88E0,
    //	 STATIC_DRAW = 0x88E4,
    //	 DYNAMIC_DRAW = 0x88E8
    // };
    // export enum EBufferTypes {
    //	 ARRAY_BUFFER = 0x8892,
    //	 ELEMENT_ARRAY_BUFFER = 0x8893,
    //	 FRAME_BUFFER = 0x8D40,
    //	 RENDER_BUFFER = 0x8D41
    // };
    (function (EAttachmentTypes) {
        EAttachmentTypes[EAttachmentTypes["COLOR_ATTACHMENT0"] = 0x8CE0] = "COLOR_ATTACHMENT0";
        EAttachmentTypes[EAttachmentTypes["DEPTH_ATTACHMENT"] = 0x8D00] = "DEPTH_ATTACHMENT";
        EAttachmentTypes[EAttachmentTypes["STENCIL_ATTACHMENT"] = 0x8D20] = "STENCIL_ATTACHMENT";
        EAttachmentTypes[EAttachmentTypes["DEPTH_STENCIL_ATTACHMENT"] = 0x821A] = "DEPTH_STENCIL_ATTACHMENT";
    })(akra.EAttachmentTypes || (akra.EAttachmentTypes = {}));
    var EAttachmentTypes = akra.EAttachmentTypes;
    ;

    
})(akra || (akra = {}));
/// <reference path="../idl/IPathinfo.ts" />
/// <reference path="../logger.ts" />
var akra;
(function (akra) {
    (function (_path) {
        var Info = (function () {
            function Info(pPath) {
                this._sDirname = null;
                this._sExtension = null;
                this._sFilename = null;
                if (akra.isDef(pPath)) {
                    this.set(pPath);
                }
            }
            Info.prototype.getPath = function () {
                return this.toString();
            };

            Info.prototype.setPath = function (sPath) {
                this.set(sPath);
            };

            Info.prototype.getDirName = function () {
                return this._sDirname;
            };

            Info.prototype.setDirName = function (sDirname) {
                this._sDirname = sDirname;
            };

            Info.prototype.getFileName = function () {
                return this._sFilename;
            };

            Info.prototype.setFileName = function (sFilename) {
                this._sFilename = sFilename;
            };

            Info.prototype.getExt = function () {
                return this._sExtension;
            };

            Info.prototype.setExt = function (sExtension) {
                this._sExtension = sExtension;
            };

            Info.prototype.getBaseName = function () {
                return (this._sFilename ? this._sFilename + (this._sExtension ? "." + this._sExtension : "") : "");
            };

            Info.prototype.setBaseName = function (sBasename) {
                var nPos = sBasename.lastIndexOf(".");

                if (nPos < 0) {
                    this._sFilename = sBasename.substr(0);
                    this._sExtension = null;
                } else {
                    this._sFilename = sBasename.substr(0, nPos);
                    this._sExtension = sBasename.substr(nPos + 1);
                }
            };

            Info.prototype.set = function (sPath) {
                if (akra.isString(sPath)) {
                    var pParts = sPath.replace('\\', '/').split('/');

                    this.setBaseName(pParts.pop());

                    this._sDirname = pParts.join('/');
                } else if (sPath instanceof Info) {
                    this._sDirname = sPath.dirname;
                    this._sFilename = sPath.filename;
                    this._sExtension = sPath.ext;
                } else if (akra.isNull(sPath)) {
                    return null;
                } else {
                    //critical_error
                    akra.logger.error("Unexpected data type was used.", sPath);
                }
            };

            Info.prototype.isAbsolute = function () {
                return this._sDirname[0] === "/";
            };

            Info.prototype.toString = function () {
                return (this._sDirname ? this._sDirname + "/" : "") + (this.getBaseName());
            };
            return Info;
        })();

        function normalizeArray(parts, allowAboveRoot) {
            // if the path tries to go above the root, `up` ends up > 0
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
                var last = parts[i];
                if (last === '.') {
                    parts.splice(i, 1);
                } else if (last === "..") {
                    parts.splice(i, 1);
                    up++;
                } else if (up) {
                    parts.splice(i, 1);
                    up--;
                }
            }

            // if the path is allowed to go above the root, restore leading ..s
            if (allowAboveRoot) {
                for (; up--;) {
                    parts.unshift("..");
                }
            }

            return parts;
        }

        function normalize(sPath) {
            var info = parse(sPath);
            var isAbsolute = info.isAbsolute();
            var tail = info.getDirName();
            var trailingSlash = /[\\\/]$/.test(tail);

            tail = normalizeArray(tail.split(/[\\\/]+/).filter(function (p) {
                return !!p;
            }), !isAbsolute).join("/");

            if (tail && trailingSlash) {
                tail += "/";
            }

            info.setDirName((isAbsolute ? "/" : "") + tail);

            return info.toString();
        }
        _path.normalize = normalize;

        function parse(path) {
            return new Info(path);
        }
        _path.parse = parse;
    })(akra.path || (akra.path = {}));
    var path = akra.path;
})(akra || (akra = {}));
/// <reference path="../idl/IURI.ts" />
/// <reference path="../idl/IDataURI.ts" />
/// <reference path="../logger.ts" />
/// <reference path="../path/path.ts" />
var akra;
(function (akra) {
    (function (uri) {
        var URI = (function () {
            function URI(pUri) {
                this.sScheme = null;
                this.sUserinfo = null;
                this.sHost = null;
                this.nPort = 0;
                this.sPath = null;
                this.sQuery = null;
                this.sFragment = null;
                if (pUri) {
                    this.set(pUri);
                }
            }
            URI.prototype.getURN = function () {
                return (this.sPath ? this.sPath : "") + (this.sQuery ? '?' + this.sQuery : "") + (this.sFragment ? '#' + this.sFragment : "");
            };

            URI.prototype.getURL = function () {
                return (this.sScheme ? this.sScheme : "") + this.getAuthority();
            };

            URI.prototype.getAuthority = function () {
                return (this.sHost ? '//' + (this.sUserinfo ? this.sUserinfo + '@' : "") + this.sHost + (this.nPort ? ':' + this.nPort : "") : "");
            };

            URI.prototype.getScheme = function () {
                return this.sScheme;
            };

            URI.prototype.getProtocol = function () {
                if (!this.sScheme) {
                    return this.sScheme;
                }

                return (this.sScheme.substr(0, this.sScheme.lastIndexOf(':')));
            };

            URI.prototype.getUserInfo = function () {
                return this.sUserinfo;
            };

            URI.prototype.getHost = function () {
                return this.sHost;
            };

            URI.prototype.setHost = function (sHost) {
                //TODO: check host format
                this.sHost = sHost;
            };

            URI.prototype.getPort = function () {
                return this.nPort;
            };

            URI.prototype.setPort = function (iPort) {
                this.nPort = iPort;
            };

            URI.prototype.getPath = function () {
                return this.sPath;
            };

            URI.prototype.setPath = function (sPath) {
                // debug_assert(!isNull(sPath.match(new RegExp("^(/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)$"))),
                // 	"invalid path used: " + sPath);
                //TODO: check path format
                this.sPath = sPath;
            };

            URI.prototype.getQuery = function () {
                //TODO: check query format
                return this.sQuery;
            };

            URI.prototype.setQuery = function (sQuery) {
                this.sQuery = sQuery;
            };

            URI.prototype.getFragment = function () {
                return this.sFragment;
            };

            URI.prototype.set = function (pData) {
                if (akra.isString(pData)) {
                    var pUri = URI.uriExp.exec(pData);

                    akra.logger.assert(pUri !== null, 'Invalid URI format used.\nused uri: ' + pData);

                    if (!pUri) {
                        return null;
                    }

                    this.sScheme = pUri[1] || null;
                    this.sUserinfo = pUri[2] || null;
                    this.sHost = pUri[3] || null;
                    this.nPort = parseInt(pUri[4]) || null;
                    this.sPath = pUri[5] || pUri[6] || null;
                    this.sQuery = pUri[7] || null;
                    this.sFragment = pUri[8] || null;

                    return this;
                } else if (pData instanceof URI) {
                    return this.set(pData.toString());
                }

                akra.logger.error('Unexpected data type was used.');

                return null;
            };

            URI.prototype.toString = function () {
                return this.getURL() + this.getURN();
            };

            URI.uriExp = new RegExp("^([a-z0-9+.-]+:)?(?:\\/\\/(?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(?::(\\d*))?(\\/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?|(\\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})*(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?)(?:\\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?(?:#((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?$", "i");
            return URI;
        })();

        function normalizeURIPath(pFile) {
            if (!akra.isNull(pFile.getPath())) {
                if (pFile.getScheme() === "filesystem:") {
                    var pUri = parse(pFile.getPath());

                    pUri.setPath(akra.path.normalize(pUri.getPath()));
                    pFile.setPath(pUri.toString());
                } else {
                    pFile.setPath(akra.path.normalize(pFile.getPath()));
                }
            }

            return pFile;
        }

        function resolve(sFrom, sTo) {
            if (typeof sTo === "undefined") { sTo = document.location.href; }
            var pCurrentPath = parse(sTo);
            var pFile = parse(sFrom);
            var sDirname;

            normalizeURIPath(pFile);
            normalizeURIPath(pCurrentPath);

            if (!akra.isNull(pFile.getScheme()) || !akra.isNull(pFile.getHost()) || akra.path.parse(pFile.getPath()).isAbsolute()) {
                //another server or absolute path
                return sFrom;
            }

            sDirname = akra.path.parse(pCurrentPath.getPath()).getDirName();
            pCurrentPath.setPath(sDirname ? (sDirname + "/" + sFrom) : sFrom);

            return normalizeURIPath(pCurrentPath).toString();
        }
        uri.resolve = resolve;

        function parseDataURI(sUri) {
            var re = /^data:([\w\d\-\/]+)?(;charset=[\w\d\-]*)?(;base64)?,(.*)$/;
            var m = sUri.match(re);

            return {
                //like [text/plain]
                mediatype: m[1] || null,
                //like [;charset=windows-1251]
                charset: akra.isString(m[2]) ? m[2].substr(9) : null,
                //like [;base64]
                base64: akra.isDef(m[3]),
                data: m[4] || null
            };
        }
        uri.parseDataURI = parseDataURI;

        function parse(sUri) {
            return new URI(sUri);
        }
        uri.parse = parse;

        function currentScript() {
            if (akra.isDef(document['currentScript'])) {
                return document['currentScript'];
            }

            var pScripts = document.getElementsByTagName("script");
            return pScripts[pScripts.length - 1];
        }
        uri.currentScript = currentScript;

        function currentPath() {
            var pUri = uri.parse(currentScript().src);
            var sDirname = akra.path.parse(pUri.getPath()).getDirName();
            return pUri.getURL() + sDirname + "/";
        }
        uri.currentPath = currentPath;

        function here() {
            return new URI(document.location.href);
        }
        uri.here = here;
    })(akra.uri || (akra.uri = {}));
    var uri = akra.uri;
})(akra || (akra = {}));
/// <reference path="../idl/IAjaxParams.ts" />
/// <reference path="../idl/IRenderer.ts" />
/// <reference path="../uri/uri.ts" />

var akra;
(function (akra) {
    (function (config) {
        config.DEBUG = true;
        config.VERSION = "0.4.5-alpha.1d-build.local+sha.ba89d54";
        config.WEBGL = true;

        /**
        * Will be TRUE if ui extension presented.
        */
        config.UI = false;

        /**
        * Display debugging information while parsing effects.
        */
        config.AFX_DEBUG_PARSER = false;

        /**
        * If there is support for loading effects in text form, is TRUE.
        */
        config.AFX_ENABLE_TEXT_EFFECTS = true;

        /**
        * Use GPU for pre-calculation of atmospheric scattering.
        */
        config.USE_ATMOSPHERIC_SCATTERING_GPU_MODE = false;

        /**
        * Do not use this, if you dont know what it.
        * @debug
        */
        config.__VIEW_INTERNALS__ = false;

        /**
        * If [WebGLDebugUtils](https://www.khronos.org/registry/webgl/sdk/debug/webgl-debug.js) presented,
        * they will use to create a context.
        */
        config.WEBGL_DEBUG = false;

        /**
        * Calculate profile information for terrain tesselation
        * @debug
        */
        config.PROFILE_TESSEALLATION = false;

        //path to data folder
        config.data = config['data'] || akra.uri.currentPath();

        //required deps for Akra Engine
        config.coreDeps = {
            files: [{"path":"akra.map","type":"map"}]
        };

        /** Unknown constants. */
        config.unknown = {
            "code": 0,
            "message": "Unknown code.",
            "name": "unknown"
        };

        /** Default <any> name */
        config.defaultName = "default";

        /** Type of used renderer. Default to ERenderers::WEBGL. */
        config.renderer = 0 /* UNKNOWN */;

        if (config.WEBGL) {
            config.renderer = 1 /* WEBGL */;
        }

        /** Ajax default parameters. */
        config.ajax = {
            "async": false,
            "statusCode": {},
            "success": null,
            "error": null,
            "beforeSend": null,
            "data": null,
            "cache": false,
            "contentType": "application/x-www-form-urlencoded",
            "dataType": "text",
            "type": "get",
            "timeout": 0
        };

        config.threading = {
            "min": 0,
            "max": 4,
            "idleTime": 30
        };

        config.render = {
            shadows: {
                enabled: true,
                /**
                * Distance in meters, after which the shadow of the object will not be rendered.
                */
                discardDistance: 70.
            }
        };

        config.io = {
            //thread file config
            "tfile": {
                "iface": {
	"content": "../../src/akra/resources/js/webgl-debug.js",
	"format": "Enclosure",
	"type": "javascript"
},
                "local": {
	"content": "../../src/akra/io/LocalFile.t.js",
	"format": "Enclosure",
	"type": null
},
                "remote": {
	"content": "../../src/akra/io/RemoteFile.t.js",
	"format": "Enclosure",
	"type": null
}
            },
            //local file config
            "local": {
                "filesystemLimit": 32 * 1024 * 1024
            }
        };

        // URL.createObjectURL(new Blob([], { type: "application/javascript" }))
        config.deps = {
            "archiveIndex": ".map",
            "etag": {
                "file": ".etag",
                "forceCheck": true
            }
        };

        config.net = {
            "port": 1337
        };

        config.rpc = {
            "deferredCallsLimit": 20000,
            "reconnectTimeout": 2500,
            "systemRoutineInterval": 10000,
            "callbackLifetime": 60000,
            "maxCallbacksCount": -1,
            "procListName": "proc_list",
            "callsFrequency": -1
        };

        config.material = {
            "name": config.defaultName,
            "default": {
                "diffuse": .5,
                "ambient": .5,
                "specular": .5,
                "emissive": .5,
                "shininess": 0.2,
                "transparency": 1.
            }
        };

        config.fx = {
            grammar: "grammars/HLSL.gr"
        };

        config.terrain = {
            "useMegaTexture": true,
            "roam": {
                "tessellationThread": {
	"content": "../../src/akra/terrain/TessellationThread.t.js",
	"format": "Enclosure",
	"type": null
}
            }
        };

        config.webgl = {
            "preparedFramebuffersNum": 32,
            "indexbufferMinSize": 1024,
            "vertexbufferMinSize": 1024,
            "vertexTextureMinSize": 32,
            "extensionsBlackList": []
        };

        config.addons = {};
    })(akra.config || (akra.config = {}));
    var config = akra.config;
})(akra || (akra = {}));
var akra;
(function (akra) {
    var t = Date.now();

    /**
    * Get current time in milliseconds from the time the page is loaded.
    */
    akra.time = akra.isDef(window.performance) ? function () {
        return window.performance.now();
    } : function () {
        return Date.now() - t;
    };
    ;
})(akra || (akra = {}));
/// <reference path="idl/IAjaxParams.ts" />
/// <reference path="logger.ts" />
/// <reference path="config/config.ts" />
/// <reference path="conv/conv.ts" />
/// <reference path="time.ts" />
var akra;
(function (akra) {
    var pDefaulParams = akra.config.ajax;

    function stringToHttpMethod(sMethod) {
        if (sMethod.toLowerCase() === "get") {
            return 1 /* GET */;
        }

        return 2 /* POST */;
    }

    function stringToAjaxDataType(sDataType) {
        switch (sDataType.toLowerCase()) {
            case "json":
                return 1 /* JSON */;
            case "blob":
                return 2 /* BLOB */;
            case "html":
            case "document":
                return 4 /* DOCUMENT */;
            case "array_buffer":
            case "arraybuffer":
                return 3 /* ARRAY_BUFFER */;
        }

        return 0 /* TEXT */;
    }

    function ajaxDataTypeToXHRResponseType(eDataType) {
        switch (eDataType) {
            case 2 /* BLOB */:
                return "blob";
            case 3 /* ARRAY_BUFFER */:
                return "arraybuffer";
            case 4 /* DOCUMENT */:
                return "document";
            case 0 /* TEXT */:
                return "text";
        }

        return "";
    }

    function createXMLHttpRequest() {
        if (window.XMLHttpRequest) {
            return new XMLHttpRequest();
        } else if (window.ActiveXObject) {
            return new ActiveXObject("Microsoft.XMLHTTP");
        }

        return null;
    }

    function queryString(pData, sPrefix) {
        if (typeof sPrefix === "undefined") { sPrefix = null; }
        if (akra.isString(pData)) {
            return pData;
        }

        var pQueryParts = [];

        for (var p in pData) {
            var k = sPrefix ? sPrefix + "[" + p + "]" : p, v = pData[p];

            pQueryParts.push(akra.isObject(v) ? queryString(v, k) : encodeURIComponent(k) + "=" + encodeURIComponent(v));
        }

        return pQueryParts.join("&");
    }

    function convertXHRResponse(pRequest, eType, isAsync) {
        switch (eType) {
            case 0 /* TEXT */:
                return String(pRequest.responseText);
            case 1 /* JSON */:
                return akra.conv.parseJSON(pRequest.responseText);
            case 2 /* BLOB */:
                return (isAsync ? pRequest.response : (new Blob([pRequest.responseText], { type: "application/octet-stream" })));
            case 3 /* ARRAY_BUFFER */:
                return (isAsync ? (pRequest.response) : pRequest.responseText);
            case 4 /* DOCUMENT */:
                return (isAsync ? pRequest.response : akra.conv.parseHTML(pRequest.responseText));
        }

        return null;
    }

    function ajax(pUrl, pSettings, pRequest) {
        var iTimeoutId = 0;
        var isAborted = false;
        var sQueryString;
        var pData;
        var sUrl;

        if (akra.isString(arguments[0])) {
            sUrl = String(arguments[0]);
            pSettings = arguments[1] || {};
            pRequest = arguments[2];
            pSettings.url = sUrl;
        } else {
            pSettings = arguments[0];
            pRequest = arguments[1];
        }

        pData = pSettings.data || {};

        for (var sKey in pDefaulParams) {
            if (akra.isDef(pSettings[sKey])) {
                continue;
            }

            pSettings[sKey] = pDefaulParams[sKey];
        }

        //if something parameters setuped by strings
        if (akra.isString(pSettings.type)) {
            pSettings.type = stringToHttpMethod(pSettings.type);
        }

        if (akra.isString(pSettings.dataType)) {
            pSettings.dataType = stringToAjaxDataType(pSettings.dataType);
        }

        var fnCauseError = function (pReq, pErr) {
            if (!pSettings.error) {
                akra.logger.error(pErr);
            } else {
                pSettings.error(pReq, (pReq ? pReq.statusText : null), pErr);
            }
        };

        var fnBeforeResult = function () {
            if (iTimeoutId !== null) {
                clearTimeout(iTimeoutId);
            }
        };

        pRequest = pRequest || createXMLHttpRequest();

        if (!pRequest) {
            fnCauseError(null, new Error("Invalid request object."));
        }

        if (pSettings.timeout > 0) {
            iTimeoutId = setTimeout(function () {
                isAborted = true;
                pRequest.abort();
                fnCauseError(pRequest, new Error("Timeout is over."));
            }, pSettings.timeout);
        }

        if (pSettings.beforeSend) {
            if (!pSettings.beforeSend(pRequest, pSettings)) {
                return null;
            }
        }

        if (pSettings.cache) {
            pData["TIMESTAMP"] = akra.time();
        }

        sQueryString = queryString(pData);

        pRequest.onreadystatechange = function () {
            if (isAborted) {
                return;
            }

            if (pRequest.readyState == this.HEADERS_RECEIVED) {
                if (pSettings.timeout > 0) {
                    clearTimeout(iTimeoutId);
                }
            }

            if (pRequest.readyState == this.DONE) {
                var iStatusCode = pRequest.status;
                var fnStatusHandler = pSettings.statusCode[iStatusCode];

                if (akra.isDefAndNotNull(fnStatusHandler)) {
                    fnStatusHandler(pRequest.status);
                }

                fnBeforeResult();

                if (iStatusCode == 200 /* OK */) {
                    if (pSettings.success) {
                        pSettings.success(convertXHRResponse(pRequest, pSettings.dataType, true), pRequest.statusText, pRequest);
                    }
                } else if (!fnStatusHandler) {
                    fnCauseError(pRequest, new Error("Request is not completed successfully (code: " + iStatusCode + ")"));
                }
            }
        };

        if (isAborted) {
            return null;
        }

        if (pSettings.async) {
            try  {
                if (pSettings.type == 1 /* GET */) {
                    pRequest.open("GET", pSettings.url + (sQueryString.length ? "?" + sQueryString : ""), true);
                    pRequest.responseType = ajaxDataTypeToXHRResponseType(pSettings.dataType);
                    pRequest.send(null);
                } else {
                    pRequest.open("POST", pSettings.url, true);
                    pRequest.setRequestHeader("Content-Type", pSettings.contentType);
                    pRequest.responseType = ajaxDataTypeToXHRResponseType(pSettings.dataType);
                    pRequest.send(sQueryString);
                }
            } catch (e) {
                fnCauseError(pRequest, e);
            }
        } else {
            if (pSettings.type == 1 /* GET */) {
                pRequest.open("GET", pSettings.url + "?" + sQueryString, false);
                pRequest.send(null);
            } else {
                pRequest.open("POST", pSettings.url, false);
                pRequest.setRequestHeader("Content-type", pSettings.contentType);
                pRequest.send(sQueryString);
            }

            fnBeforeResult();

            return {
                data: convertXHRResponse(pRequest, pSettings.dataType, false),
                statusText: pRequest.statusText,
                xhr: pRequest
            };
        }

        return null;
    }
    akra.ajax = ajax;
})(akra || (akra = {}));
/// <reference path="IMap.ts" />
/// <reference path="IFrame.ts" />
/// <reference path="IUnique.ts" />
var akra;
(function (akra) {
    (function (EDocumentEntry) {
        EDocumentEntry[EDocumentEntry["k_Unknown"] = 0] = "k_Unknown";

        EDocumentEntry[EDocumentEntry["k_Instance"] = 1] = "k_Instance";
        EDocumentEntry[EDocumentEntry["k_Controller"] = 2] = "k_Controller";
        EDocumentEntry[EDocumentEntry["k_Animation"] = 3] = "k_Animation";
        EDocumentEntry[EDocumentEntry["k_AnimationBlend"] = 4] = "k_AnimationBlend";
        EDocumentEntry[EDocumentEntry["k_AnimationContainer"] = 5] = "k_AnimationContainer";
        EDocumentEntry[EDocumentEntry["k_SceneNode"] = 6] = "k_SceneNode";

        EDocumentEntry[EDocumentEntry["k_Material"] = 7] = "k_Material";
    })(akra.EDocumentEntry || (akra.EDocumentEntry = {}));
    var EDocumentEntry = akra.EDocumentEntry;

    (function (EDocumentFormat) {
        EDocumentFormat[EDocumentFormat["JSON"] = 0] = "JSON";
        EDocumentFormat[EDocumentFormat["BINARY_JSON"] = 1] = "BINARY_JSON";
    })(akra.EDocumentFormat || (akra.EDocumentFormat = {}));
    var EDocumentFormat = akra.EDocumentFormat;
})(akra || (akra = {}));
/// <reference path="IAnimationBase.ts" />
/// <reference path="IMap.ts" />
/// <reference path="IAnimationBase.ts" />
/// <reference path="IPositionFrame.ts" />
/// <reference path="logger.ts" />
var akra;
(function (akra) {
    akra.debug = new akra.util.Logger();

    akra.debug.init();
    akra.debug.setUnknownCode(0, "unknown");
    akra.debug.setLogLevel(31 /* ALL */);

    akra.debug.registerCodeFamily(0, 100, "SystemCodes");

    //Default log routines
    function logRoutine(pLogEntity) {
        var pArgs = pLogEntity.info;
        pArgs.unshift("%c[D]", "color: gray;");
        console.log.apply(console, pArgs);
    }

    function warningRoutine(pLogEntity) {
        var pArgs = pLogEntity.info || [];

        var sCodeInfo = "%c[W]" + (pLogEntity.code != 0 ? " AE" + pLogEntity.code.toString() + ":" : "") + " ";
        pArgs.unshift(sCodeInfo, "color: red;");

        console.warn.apply(console, pArgs);
    }

    function errorRoutine(pLogEntity) {
        var pArgs = pLogEntity.info || [];

        var sMessage = pLogEntity.message;
        var sCodeInfo = "[E]" + (pLogEntity.code != 0 ? " AE" + pLogEntity.code.toString() + ":" : "") + " ";

        pArgs.unshift("%c " + sCodeInfo, "color: red;", sMessage);

        console.error.apply(console, pArgs);
    }

    akra.debug.setLogRoutine(logRoutine, 1 /* LOG */ | 2 /* INFORMATION */);
    akra.debug.setLogRoutine(warningRoutine, 4 /* WARNING */);
    akra.debug.setLogRoutine(errorRoutine, 8 /* ERROR */ | 16 /* CRITICAL */);
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (math) {
        //matrix 4x4 elements
        math.__11 = 0;
        math.__12 = 4;
        math.__13 = 8;
        math.__14 = 12;
        math.__21 = 1;
        math.__22 = 5;
        math.__23 = 9;
        math.__24 = 13;
        math.__31 = 2;
        math.__32 = 6;
        math.__33 = 10;
        math.__34 = 14;
        math.__41 = 3;
        math.__42 = 7;
        math.__43 = 11;
        math.__44 = 15;

        //matrix 3x3 elements
        math.__a11 = 0;
        math.__a12 = 3;
        math.__a13 = 6;
        math.__a21 = 1;
        math.__a22 = 4;
        math.__a23 = 7;
        math.__a31 = 2;
        math.__a32 = 5;
        math.__a33 = 8;
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
/// <reference path="../common.ts" />
var akra;
(function (akra) {
    (function (gen) {
        /**
        * Generated typed array by {Type} and {size}.
        */
        function array(size, Type) {
            if (typeof Type === "undefined") { Type = null; }
            var tmp = new Array(size);

            for (var i = 0; i < size; ++i) {
                tmp[i] = (!akra.isNull(Type) ? (new Type) : null);
            }

            return tmp;
        }
        gen.array = array;
    })(akra.gen || (akra.gen = {}));
    var gen = akra.gen;
})(akra || (akra = {}));
/// <reference path="../common.ts" />
/// <reference path="../logger.ts" />
/// <reference path="../idl/IVec2.ts" />
/// <reference path="math.ts" />
/// <reference path="../gen/generate.ts" />
var akra;
(function (akra) {
    (function (math) {
        var pBuffer;
        var iElement;

        var Vec2 = (function () {
            function Vec2() {
                this.x = 0.;
                this.y = 0.;
                var n = arguments.length;
                var v = this;

                switch (n) {
                    case 1:
                        v.set(arguments[0]);
                        break;
                    case 2:
                        v.set(arguments[0], arguments[1]);
                        break;
                    default:
                        v.x = v.y = 0.;
                }
            }
            Vec2.prototype.set = function () {
                var n = arguments.length;

                switch (n) {
                    case 0:
                        this.x = this.y = 0.;
                        break;
                    case 1:
                        if (akra.isFloat(arguments[0])) {
                            this.x = this.y = arguments[0];
                        } else if (arguments[0] instanceof Vec2) {
                            var v2fVec = arguments[0];

                            this.x = v2fVec.x;
                            this.y = v2fVec.y;
                        } else {
                            var pArray = arguments[0];

                            this.x = pArray[0];
                            this.y = pArray[1];
                        }
                        break;
                    case 2:
                        this.x = arguments[0];
                        this.y = arguments[1];
                        break;
                }

                return this;
            };

            /**  */ Vec2.prototype.clear = function () {
                this.x = this.y = 0.;
                return this;
            };

            Vec2.prototype.add = function (v2fVec, v2fDestination) {
                if (!akra.isDef(v2fDestination)) {
                    v2fDestination = this;
                }

                v2fDestination.x = this.x + v2fVec.x;
                v2fDestination.y = this.y + v2fVec.y;

                return v2fDestination;
            };

            Vec2.prototype.subtract = function (v2fVec, v2fDestination) {
                if (!akra.isDef(v2fDestination)) {
                    v2fDestination = this;
                }

                v2fDestination.x = this.x - v2fVec.x;
                v2fDestination.y = this.y - v2fVec.y;

                return v2fDestination;
            };

            /**  */ Vec2.prototype.dot = function (v2fVec) {
                return this.x * v2fVec.x + this.y * v2fVec.y;
            };

            Vec2.prototype.isEqual = function (v2fVec, fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if (fEps === 0.) {
                    if (this.x != v2fVec.x || this.y != v2fVec.y) {
                        return false;
                    }
                } else {
                    if (math.abs(this.x - v2fVec.x) > fEps || math.abs(this.y - v2fVec.y) > fEps) {
                        return false;
                    }
                }

                return true;
            };

            Vec2.prototype.isClear = function (fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if (fEps === 0.) {
                    if (this.x != 0. || this.y != 0.) {
                        return false;
                    }
                } else {
                    if (math.abs(this.x) > fEps || math.abs(this.y) > fEps) {
                        return false;
                    }
                }

                return true;
            };

            Vec2.prototype.negate = function (v2fDestination) {
                if (!akra.isDef(v2fDestination)) {
                    v2fDestination = this;
                }

                v2fDestination.x = -this.x;
                v2fDestination.y = -this.y;

                return v2fDestination;
            };

            Vec2.prototype.scale = function (fScale, v2fDestination) {
                if (!akra.isDef(v2fDestination)) {
                    v2fDestination = this;
                }

                v2fDestination.x = this.x * fScale;
                v2fDestination.y = this.y * fScale;

                return v2fDestination;
            };

            Vec2.prototype.normalize = function (v2fDestination) {
                if (!akra.isDef(v2fDestination)) {
                    v2fDestination = this;
                }

                var x = this.x, y = this.y;
                var fLength = math.sqrt(x * x + y * y);

                if (fLength !== 0.) {
                    var fInvLength = 1. / fLength;

                    x *= fInvLength;
                    y *= fInvLength;
                }

                v2fDestination.x = x;
                v2fDestination.y = y;

                return v2fDestination;
            };

            /**  */ Vec2.prototype.length = function () {
                var x = this.x, y = this.y;
                return math.sqrt(x * x + y * y);
            };

            /**  */ Vec2.prototype.lengthSquare = function () {
                var x = this.x, y = this.y;
                return x * x + y * y;
            };

            Vec2.prototype.direction = function (v2fVec, v2fDestination) {
                if (!akra.isDef(v2fDestination)) {
                    v2fDestination = this;
                }

                var x = v2fVec.x - this.x;
                var y = v2fVec.y - this.y;

                var fLength = math.sqrt(x * x + y * y);

                if (fLength !== 0.) {
                    var fInvLength = 1. / fLength;

                    x *= fInvLength;
                    y *= fInvLength;
                }

                v2fDestination.x = x;
                v2fDestination.y = y;

                return v2fDestination;
            };

            Vec2.prototype.mix = function (v2fVec, fA, v2fDestination) {
                if (!akra.isDef(v2fDestination)) {
                    v2fDestination = this;
                }

                fA = math.clamp(fA, 0., 1.);

                var fA1 = 1. - fA;
                var fA2 = fA;

                v2fDestination.x = fA1 * this.x + fA2 * v2fVec.x;
                v2fDestination.y = fA1 * this.y + fA2 * v2fVec.y;

                return v2fDestination;
            };

            /**  */ Vec2.prototype.toString = function () {
                return "[x: " + this.x + ", y: " + this.y + "]";
            };

            Vec2.prototype.clone = function (sForm, v2fDest) {
                if (!akra.isDefAndNotNull(v2fDest)) {
                    v2fDest = Vec2.temp();
                }

                switch (sForm) {
                    case "xx":
                        return v2fDest.set(this.x);
                    case "xy":
                        return v2fDest.set(this.x, this.y);
                    case "yx":
                        return v2fDest.set(this.y, this.x);
                    case "yy":
                        return v2fDest.set(this.y);
                }

                akra.logger.error("Bad vector form", sForm);
                return null;
            };

            Vec2.prototype.copy = function (sForm, pVec2OrFloat) {
                var v2fFrom = akra.isFloat(pVec2OrFloat) ? Vec2.temp(pVec2OrFloat) : pVec2OrFloat;

                switch (sForm) {
                    case "xx":
                        this.x = v2fFrom.x;
                        this.x = v2fFrom.y;
                        break;
                    case "xy":
                        this.x = v2fFrom.x;
                        this.y = v2fFrom.y;
                        break;
                    case "yx":
                        this.y = v2fFrom.x;
                        this.x = v2fFrom.y;
                        break;
                    case "yy":
                        this.y = v2fFrom.x;
                        this.y = v2fFrom.y;
                        break;
                    default:
                        akra.logger.error("Bad vector form", sForm);
                        break;
                }

                return this;
            };

            Vec2.temp = function () {
                iElement = ((iElement === pBuffer.length - 1) ? 0 : iElement);
                var p = pBuffer[iElement++];

                var n = arguments.length;

                switch (n) {
                    case 0:
                        p.x = p.y = 0.;
                        break;
                    case 1:
                        if (akra.isFloat(arguments[0])) {
                            p.x = p.y = arguments[0];
                        } else if (arguments[0] instanceof Vec2) {
                            var v2fVec = arguments[0];

                            p.x = v2fVec.x;
                            p.y = v2fVec.y;
                        } else {
                            var pArray = arguments[0];

                            p.x = pArray[0];
                            p.y = pArray[1];
                        }
                        break;
                    case 2:
                        p.x = arguments[0];
                        p.y = arguments[1];
                        break;
                }

                return p;
            };
            return Vec2;
        })();
        math.Vec2 = Vec2;

        pBuffer = akra.gen.array(256, Vec2);
        iElement = 0;
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
/// <reference path="../common.ts" />
/// <reference path="../logger.ts" />
/// <reference path="../idl/IVec3.ts" />
/// <reference path="math.ts" />
/// <reference path="../gen/generate.ts" />
var akra;
(function (akra) {
    (function (math) {
        //import __11 = math.__11;
        //import __12 = math.__12;
        //import __13 = math.__13;
        //import __14 = math.__14;
        //import __21 = math.__21;
        //import __22 = math.__22;
        //import __23 = math.__23;
        //import __24 = math.__24;
        //import __31 = math.__31;
        //import __32 = math.__32;
        //import __33 = math.__33;
        //import __34 = math.__34;
        //import __41 = math.__41;
        //import __42 = math.__42;
        //import __43 = math.__43;
        //import __44 = math.__44;
        var pBuffer;
        var iElement;

        var Vec3 = (function () {
            function Vec3() {
                var nArg = arguments.length;

                switch (nArg) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 2:
                        this.set(arguments[0], arguments[1]);
                        break;
                    case 3:
                        this.set(arguments[0], arguments[1], arguments[2]);
                        break;
                    default:
                        this.x = this.y = this.z = 0.;
                        break;
                }
            }
            Vec3.prototype.set = function () {
                var nArgumentsLength = arguments.length;

                switch (nArgumentsLength) {
                    case 0:
                        this.x = this.y = this.z = 0.;
                        break;
                    case 1:
                        if (akra.isFloat(arguments[0])) {
                            this.x = this.y = this.z = arguments[0];
                        } else if (arguments[0] instanceof Vec3) {
                            var v3fVec = arguments[0];

                            this.x = v3fVec.x;
                            this.y = v3fVec.y;
                            this.z = v3fVec.z;
                        } else {
                            var pArray = arguments[0];

                            this.x = pArray[0];
                            this.y = pArray[1];
                            this.z = pArray[2];
                        }
                        break;
                    case 2:
                        if (akra.isFloat(arguments[0])) {
                            var fValue = arguments[0];
                            var v2fVec = arguments[1];

                            this.x = fValue;
                            this.y = v2fVec.x;
                            this.z = v2fVec.y;
                        } else {
                            var v2fVec = arguments[0];
                            var fValue = arguments[1];

                            this.x = v2fVec.x;
                            this.y = v2fVec.y;
                            this.z = fValue;
                        }
                        break;
                    case 3:
                        this.x = arguments[0];
                        this.y = arguments[1];
                        this.z = arguments[2];
                        break;
                }

                return this;
            };

            Vec3.prototype.X = function (fLength) {
                if (typeof fLength === "undefined") { fLength = 1.; }
                return this.set(fLength, 0., 0.);
            };

            Vec3.prototype.Y = function (fLength) {
                if (typeof fLength === "undefined") { fLength = 1.; }
                return this.set(0., fLength, 0.);
            };

            Vec3.prototype.Z = function (fLength) {
                if (typeof fLength === "undefined") { fLength = 1.; }
                return this.set(0., 0., fLength);
            };

            /**  */ Vec3.prototype.clear = function () {
                this.x = this.y = this.z = 0.;
                return this;
            };

            Vec3.prototype.add = function (v3fVec, v3fDestination) {
                if (!akra.isDef(v3fDestination)) {
                    v3fDestination = this;
                }

                v3fDestination.x = this.x + v3fVec.x;
                v3fDestination.y = this.y + v3fVec.y;
                v3fDestination.z = this.z + v3fVec.z;

                return v3fDestination;
            };

            Vec3.prototype.subtract = function (v3fVec, v3fDestination) {
                if (!akra.isDef(v3fDestination)) {
                    v3fDestination = this;
                }

                v3fDestination.x = this.x - v3fVec.x;
                v3fDestination.y = this.y - v3fVec.y;
                v3fDestination.z = this.z - v3fVec.z;

                return v3fDestination;
            };

            /**  */ Vec3.prototype.dot = function (v3fVec) {
                return this.x * v3fVec.x + this.y * v3fVec.y + this.z * v3fVec.z;
            };

            Vec3.prototype.cross = function (v3fVec, v3fDestination) {
                if (!akra.isDef(v3fDestination)) {
                    v3fDestination = this;
                }

                var x1 = this.x, y1 = this.y, z1 = this.z;
                var x2 = v3fVec.x, y2 = v3fVec.y, z2 = v3fVec.z;

                v3fDestination.x = y1 * z2 - z1 * y2;
                v3fDestination.y = z1 * x2 - x1 * z2;
                v3fDestination.z = x1 * y2 - y1 * x2;

                return v3fDestination;
            };

            Vec3.prototype.isEqual = function (v3fVec, fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if (fEps === 0.) {
                    if (this.x != v3fVec.x || this.y != v3fVec.y || this.z != v3fVec.z) {
                        return false;
                    }
                } else {
                    if (math.abs(this.x - v3fVec.x) > fEps || math.abs(this.y - v3fVec.y) > fEps || math.abs(this.z - v3fVec.z) > fEps) {
                        return false;
                    }
                }
                return true;
            };

            Vec3.prototype.isClear = function (fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if (fEps === 0.) {
                    if (this.x != 0. || this.y != 0. || this.z != 0.) {
                        return false;
                    }
                } else {
                    if (math.abs(this.x) > fEps || math.abs(this.y) > fEps || math.abs(this.z) > fEps) {
                        return false;
                    }
                }

                return true;
            };

            Vec3.prototype.negate = function (v3fDestination) {
                if (!akra.isDef(v3fDestination)) {
                    v3fDestination = this;
                }

                v3fDestination.x = -this.x;
                v3fDestination.y = -this.y;
                v3fDestination.z = -this.z;

                return v3fDestination;
            };

            Vec3.prototype.scale = function () {
                var v3fDestination = (arguments.length === 2 && akra.isDef(arguments[1])) ? arguments[1] : this;

                if (akra.isNumber(arguments[0])) {
                    var fScale = arguments[0];
                    v3fDestination.x = this.x * fScale;
                    v3fDestination.y = this.y * fScale;
                    v3fDestination.z = this.z * fScale;
                } else {
                    var v3fScale = arguments[0];
                    v3fDestination.x = this.x * v3fScale.x;
                    v3fDestination.y = this.y * v3fScale.y;
                    v3fDestination.z = this.z * v3fScale.z;
                }

                return v3fDestination;
            };

            Vec3.prototype.normalize = function (v3fDestination) {
                if (!v3fDestination) {
                    v3fDestination = this;
                }

                var x = this.x, y = this.y, z = this.z;
                var fLength = math.sqrt(x * x + y * y + z * z);

                if (fLength !== 0.) {
                    var fInvLength = 1. / fLength;

                    x *= fInvLength;
                    y *= fInvLength;
                    z *= fInvLength;
                }

                v3fDestination.x = x;
                v3fDestination.y = y;
                v3fDestination.z = z;

                return v3fDestination;
            };

            /**  */ Vec3.prototype.length = function () {
                return math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            };

            /**  */ Vec3.prototype.lengthSquare = function () {
                var x = this.x, y = this.y, z = this.z;
                return x * x + y * y + z * z;
            };

            Vec3.prototype.direction = function (v3fVec, v3fDestination) {
                if (!akra.isDef(v3fDestination)) {
                    v3fDestination = this;
                }

                var x = v3fVec.x - this.x;
                var y = v3fVec.y - this.y;
                var z = v3fVec.z - this.z;

                var fLength = math.sqrt(x * x + y * y + z * z);

                if (fLength !== 0.) {
                    var fInvLength = 1. / fLength;

                    x *= fInvLength;
                    y *= fInvLength;
                    z *= fInvLength;
                }

                v3fDestination.x = x;
                v3fDestination.y = y;
                v3fDestination.z = z;

                return v3fDestination;
            };

            Vec3.prototype.mix = function (v3fVec, fA, v3fDestination) {
                if (!akra.isDef(v3fDestination)) {
                    v3fDestination = this;
                }

                fA = math.clamp(fA, 0., 1.);

                var fA1 = 1. - fA;
                var fA2 = fA;

                v3fDestination.x = fA1 * this.x + fA2 * v3fVec.x;
                v3fDestination.y = fA1 * this.y + fA2 * v3fVec.y;
                v3fDestination.z = fA1 * this.z + fA2 * v3fVec.z;

                return v3fDestination;
            };

            /**  */ Vec3.prototype.toString = function () {
                return "[x: " + this.x + " ,y: " + this.y + ", z: " + this.z + "]";
            };

            /**  */ Vec3.prototype.toArray = function (pDest) {
                if (typeof pDest === "undefined") { pDest = []; }
                pDest[0] = this.x;
                pDest[1] = this.y;
                pDest[2] = this.z;
                return pDest;
            };

            Vec3.prototype.toTranslationMatrix = function (m4fDestination) {
                if (!akra.isDef(m4fDestination)) {
                    m4fDestination = new math.Mat4(1.);
                } else {
                    m4fDestination.set(1.);
                }

                var pData = m4fDestination.data;

                pData[math.__14] = this.x;
                pData[math.__24] = this.y;
                pData[math.__34] = this.z;

                return m4fDestination;
            };

            Vec3.prototype.vec3TransformCoord = function (m4fTransformation, v3fDestination) {
                if (!v3fDestination) {
                    v3fDestination = this;
                }

                var pData = m4fTransformation.data;

                var x = this.x;
                var y = this.y;
                var z = this.z;
                var w;

                x = pData[math.__11] * x + pData[math.__12] * y + pData[math.__13] * z + pData[math.__14];
                y = pData[math.__21] * x + pData[math.__22] * y + pData[math.__23] * z + pData[math.__24];
                z = pData[math.__31] * x + pData[math.__32] * y + pData[math.__33] * z + pData[math.__34];
                w = pData[math.__41] * x + pData[math.__42] * y + pData[math.__43] * z + pData[math.__44];

                var fInvW = 1. / w;

                v3fDestination.x = x * fInvW;
                v3fDestination.y = y * fInvW;
                v3fDestination.z = z * fInvW;

                return v3fDestination;
            };

            Vec3.prototype.clone = function (sForm, pVec2OrVec3) {
                if (sForm.length === 2) {
                    var v2fDest = akra.isDefAndNotNull(pVec2OrVec3) ? pVec2OrVec3 : math.Vec2.temp();

                    switch (sForm) {
                        case "xx":
                            return v2fDest.set(this.x, this.x);
                        case "xy":
                            return v2fDest.set(this.x, this.y);
                        case "xz":
                            return v2fDest.set(this.x, this.z);
                        case "yx":
                            return v2fDest.set(this.y, this.x);
                        case "yy":
                            return v2fDest.set(this.y, this.y);
                        case "yz":
                            return v2fDest.set(this.y, this.z);
                        case "zx":
                            return v2fDest.set(this.z, this.x);
                        case "zy":
                            return v2fDest.set(this.z, this.y);
                        case "zz":
                            return v2fDest.set(this.z, this.z);
                    }
                } else if (sForm.length === 3) {
                    var v3fDest = akra.isDefAndNotNull(pVec2OrVec3) ? pVec2OrVec3 : Vec3.temp();

                    switch (sForm) {
                        case "xxx":
                            return v3fDest.set(this.x, this.x, this.x);
                        case "xxy":
                            return v3fDest.set(this.x, this.x, this.y);
                        case "xxz":
                            return v3fDest.set(this.x, this.x, this.z);
                        case "xyx":
                            return v3fDest.set(this.x, this.y, this.x);
                        case "xyy":
                            return v3fDest.set(this.x, this.y, this.y);
                        case "xyz":
                            return v3fDest.set(this.x, this.y, this.z);
                        case "xzx":
                            return v3fDest.set(this.x, this.z, this.x);
                        case "xzy":
                            return v3fDest.set(this.x, this.z, this.y);
                        case "xzz":
                            return v3fDest.set(this.x, this.z, this.z);
                        case "yxx":
                            return v3fDest.set(this.y, this.x, this.x);
                        case "yxy":
                            return v3fDest.set(this.y, this.x, this.y);
                        case "yxz":
                            return v3fDest.set(this.y, this.x, this.z);
                        case "yyx":
                            return v3fDest.set(this.y, this.y, this.x);
                        case "yyy":
                            return v3fDest.set(this.y, this.y, this.y);
                        case "yyz":
                            return v3fDest.set(this.y, this.y, this.z);
                        case "yzx":
                            return v3fDest.set(this.y, this.z, this.x);
                        case "yzy":
                            return v3fDest.set(this.y, this.z, this.y);
                        case "yzz":
                            return v3fDest.set(this.y, this.z, this.z);
                        case "zxx":
                            return v3fDest.set(this.z, this.x, this.x);
                        case "zxy":
                            return v3fDest.set(this.z, this.x, this.y);
                        case "zxz":
                            return v3fDest.set(this.z, this.x, this.z);
                        case "zyx":
                            return v3fDest.set(this.z, this.y, this.x);
                        case "zyy":
                            return v3fDest.set(this.z, this.y, this.y);
                        case "zyz":
                            return v3fDest.set(this.z, this.y, this.z);
                        case "zzx":
                            return v3fDest.set(this.z, this.z, this.x);
                        case "zzy":
                            return v3fDest.set(this.z, this.z, this.y);
                        case "zzz":
                            return v3fDest.set(this.z, this.z, this.z);
                    }
                }

                akra.logger.error("Bad vector form", sForm);
                return null;
            };

            Vec3.prototype.copy = function (sForm, pVectorOrFloat) {
                if (sForm.length === 2) {
                    var v2fFrom = akra.isFloat(pVectorOrFloat) ? math.Vec2.temp(pVectorOrFloat) : pVectorOrFloat;

                    switch (sForm) {
                        case "xx":
                            this.x = v2fFrom.x;
                            this.x = v2fFrom.y;
                            return this;
                        case "xy":
                            this.x = v2fFrom.x;
                            this.y = v2fFrom.y;
                            return this;
                        case "xz":
                            this.x = v2fFrom.x;
                            this.z = v2fFrom.y;
                            return this;
                        case "yx":
                            this.y = v2fFrom.x;
                            this.x = v2fFrom.y;
                            return this;
                        case "yy":
                            this.y = v2fFrom.x;
                            this.y = v2fFrom.y;
                            return this;
                        case "yz":
                            this.y = v2fFrom.x;
                            this.z = v2fFrom.y;
                            return this;
                        case "zx":
                            this.z = v2fFrom.x;
                            this.x = v2fFrom.y;
                            return this;
                        case "zy":
                            this.z = v2fFrom.x;
                            this.y = v2fFrom.y;
                            return this;
                        case "zz":
                            this.z = v2fFrom.x;
                            this.z = v2fFrom.y;
                            return this;
                    }
                } else if (sForm.length === 3) {
                    var v3fFrom = akra.isFloat(pVectorOrFloat) ? Vec3.temp(pVectorOrFloat) : pVectorOrFloat;

                    switch (sForm) {
                        case "xxx":
                            this.x = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "xxy":
                            this.x = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "xxz":
                            this.x = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "xyx":
                            this.x = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "xyy":
                            this.x = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "xyz":
                            this.x = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "xzx":
                            this.x = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "xzy":
                            this.x = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "xzz":
                            this.x = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "yxx":
                            this.y = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "yxy":
                            this.y = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "yxz":
                            this.y = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "yyx":
                            this.y = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "yyy":
                            this.y = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "yyz":
                            this.y = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "yzx":
                            this.y = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "yzy":
                            this.y = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "yzz":
                            this.y = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "zxx":
                            this.z = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "zxy":
                            this.z = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "zxz":
                            this.z = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "zyx":
                            this.z = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "zyy":
                            this.z = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "zyz":
                            this.z = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "zzx":
                            this.z = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "zzy":
                            this.z = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "zzz":
                            this.z = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                    }
                }

                akra.logger.error("Bad vector form", sForm);
                return this;
            };

            Vec3.temp = function () {
                iElement = (iElement === pBuffer.length - 1 ? 0 : iElement);
                var p = pBuffer[iElement++];
                var nArgumentsLength = arguments.length;

                switch (nArgumentsLength) {
                    case 0:
                        p.x = p.y = p.z = 0.;
                        break;
                    case 1:
                        if (akra.isFloat(arguments[0])) {
                            p.x = p.y = p.z = arguments[0];
                        } else if (arguments[0] instanceof Vec3) {
                            var v3fVec = arguments[0];

                            p.x = v3fVec.x;
                            p.y = v3fVec.y;
                            p.z = v3fVec.z;
                        } else {
                            var pArray = arguments[0];

                            p.x = pArray[0];
                            p.y = pArray[1];
                            p.z = pArray[2];
                        }
                        break;
                    case 2:
                        if (akra.isFloat(arguments[0])) {
                            var fValue = arguments[0];
                            var v2fVec = arguments[1];

                            p.x = fValue;
                            p.y = v2fVec.x;
                            p.z = v2fVec.y;
                        } else {
                            var v2fVec = arguments[0];
                            var fValue = arguments[1];

                            p.x = v2fVec.x;
                            p.y = v2fVec.y;
                            p.z = fValue;
                        }
                        break;
                    case 3:
                        p.x = arguments[0];
                        p.y = arguments[1];
                        p.z = arguments[2];
                        break;
                }

                return p;
            };
            return Vec3;
        })();
        math.Vec3 = Vec3;

        pBuffer = akra.gen.array(256, Vec3);
        iElement = 0;
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
/// <reference path="../common.ts" />
/// <reference path="../logger.ts" />
/// <reference path="../idl/IVec4.ts" />
/// <reference path="math.ts" />
/// <reference path="../gen/generate.ts" />
var akra;
(function (akra) {
    (function (math) {
        var pBuffer;
        var iElement;

        var Vec4 = (function () {
            function Vec4() {
                var n = arguments.length;
                var v = this;

                switch (n) {
                    case 1:
                        v.set(arguments[0]);
                        break;
                    case 2:
                        v.set(arguments[0], arguments[1]);
                        break;
                    case 3:
                        v.set(arguments[0], arguments[1], arguments[2]);
                        break;
                    case 4:
                        v.set(arguments[0], arguments[1], arguments[2], arguments[3]);
                        break;
                    default:
                        v.x = v.y = v.z = v.w = 0.;
                        break;
                }
            }
            Vec4.prototype.set = function () {
                var nArgumentsLength = arguments.length;

                switch (nArgumentsLength) {
                    case 0:
                        this.x = this.y = this.z = this.w = 0.;
                        break;
                    case 1:
                        if (akra.isFloat(arguments[0])) {
                            this.x = this.y = this.z = this.w = arguments[0];
                        } else if (arguments[0] instanceof Vec4) {
                            var v4fVec = arguments[0];

                            this.x = v4fVec.x;
                            this.y = v4fVec.y;
                            this.z = v4fVec.z;
                            this.w = v4fVec.w;
                        } else if (akra.isDef(arguments[0].r)) {
                            this.x = arguments[0].r;
                            this.y = arguments[0].g;
                            this.z = arguments[0].b;
                            this.w = arguments[0].a;
                        } else {
                            //array
                            var pArray = arguments[0];

                            this.x = pArray[0];
                            this.y = pArray[1];
                            this.z = pArray[2];
                            this.w = pArray[3];
                        }
                        break;
                    case 2:
                        if (akra.isFloat(arguments[0])) {
                            var fValue = arguments[0];
                            var v3fVec = arguments[1];

                            this.x = fValue;
                            this.y = v3fVec.x;
                            this.z = v3fVec.y;
                            this.w = v3fVec.z;
                        } else if (arguments[0] instanceof math.Vec2) {
                            var v2fVec1 = arguments[0];
                            var v2fVec2 = arguments[1];

                            this.x = v2fVec1.x;
                            this.y = v2fVec1.y;
                            this.z = v2fVec2.x;
                            this.w = v2fVec2.y;
                        } else {
                            var v3fVec = arguments[0];
                            var fValue = arguments[1];

                            this.x = v3fVec.x;
                            this.y = v3fVec.y;
                            this.z = v3fVec.z;
                            this.w = fValue;
                        }
                        break;
                    case 3:
                        if (akra.isFloat(arguments[0])) {
                            var fValue1 = arguments[0];

                            if (akra.isFloat(arguments[1])) {
                                var fValue2 = arguments[1];
                                var v2fVec = arguments[2];

                                this.x = fValue1;
                                this.y = fValue2;
                                this.z = v2fVec.x;
                                this.w = v2fVec.y;
                            } else {
                                var v2fVec = arguments[1];
                                var fValue2 = arguments[2];

                                this.x = fValue1;
                                this.y = v2fVec.x;
                                this.z = v2fVec.y;
                                this.w = fValue2;
                            }
                        } else {
                            var v2fVec = arguments[0];
                            var fValue1 = arguments[1];
                            var fValue2 = arguments[2];

                            this.x = v2fVec.x;
                            this.y = v2fVec.y;
                            this.z = fValue1;
                            this.w = fValue2;
                        }
                        break;
                    case 4:
                        this.x = arguments[0];
                        this.y = arguments[1];
                        this.z = arguments[2];
                        this.w = arguments[3];
                        break;
                }

                return this;
            };

            /**  */ Vec4.prototype.clear = function () {
                this.x = this.y = this.z = this.w = 0.;
                return this;
            };

            Vec4.prototype.add = function (v4fVec, v4fDestination) {
                if (!akra.isDef(v4fDestination)) {
                    v4fDestination = this;
                }

                v4fDestination.x = this.x + v4fVec.x;
                v4fDestination.y = this.y + v4fVec.y;
                v4fDestination.z = this.z + v4fVec.z;
                v4fDestination.w = this.w + v4fVec.w;

                return v4fDestination;
            };

            Vec4.prototype.subtract = function (v4fVec, v4fDestination) {
                if (!akra.isDef(v4fDestination)) {
                    v4fDestination = this;
                }

                v4fDestination.x = this.x - v4fVec.x;
                v4fDestination.y = this.y - v4fVec.y;
                v4fDestination.z = this.z - v4fVec.z;
                v4fDestination.w = this.w - v4fVec.w;

                return v4fDestination;
            };

            /**  */ Vec4.prototype.dot = function (v4fVec) {
                return this.x * v4fVec.x + this.y * v4fVec.y + this.z * v4fVec.z + this.w * v4fVec.w;
            };

            Vec4.prototype.isEqual = function (v4fVec, fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if (fEps === 0.) {
                    if (this.x != v4fVec.x || this.y != v4fVec.y || this.z != v4fVec.z || this.w != v4fVec.w) {
                        return false;
                    }
                } else {
                    if (math.abs(this.x - v4fVec.x) > fEps || math.abs(this.y - v4fVec.y) > fEps || math.abs(this.z - v4fVec.z) > fEps || math.abs(this.w - v4fVec.w) > fEps) {
                        return false;
                    }
                }
                return true;
            };

            Vec4.prototype.isClear = function (fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if (fEps === 0.) {
                    if (this.x != 0. || this.y != 0. || this.z != 0. || this.w != 0.) {
                        return false;
                    }
                } else {
                    if (math.abs(this.x) > fEps || math.abs(this.y) > fEps || math.abs(this.z) > fEps || math.abs(this.w) > fEps) {
                        return false;
                    }
                }
                return true;
            };

            Vec4.prototype.negate = function (v4fDestination) {
                if (!akra.isDef(v4fDestination)) {
                    v4fDestination = this;
                }

                v4fDestination.x = -this.x;
                v4fDestination.y = -this.y;
                v4fDestination.z = -this.z;
                v4fDestination.w = -this.w;

                return v4fDestination;
            };

            Vec4.prototype.scale = function (fScale, v4fDestination) {
                if (!akra.isDef(v4fDestination)) {
                    v4fDestination = this;
                }

                v4fDestination.x = this.x * fScale;
                v4fDestination.y = this.y * fScale;
                v4fDestination.z = this.z * fScale;
                v4fDestination.w = this.w * fScale;

                return v4fDestination;
            };

            Vec4.prototype.normalize = function (v4fDestination) {
                if (!akra.isDef(v4fDestination)) {
                    v4fDestination = this;
                }

                var x = this.x, y = this.y, z = this.z, w = this.w;
                var fLength = math.sqrt(x * x + y * y + z * z + w * w);

                if (fLength !== 0.) {
                    var fInvLength = 1. / fLength;

                    x *= fInvLength;
                    y *= fInvLength;
                    z *= fInvLength;
                    w *= fInvLength;
                }

                v4fDestination.x = x;
                v4fDestination.y = y;
                v4fDestination.z = z;
                v4fDestination.w = w;

                return v4fDestination;
            };

            /**  */ Vec4.prototype.length = function () {
                var x = this.x, y = this.y, z = this.z, w = this.w;
                return math.sqrt(x * x + y * y + z * z + w * w);
            };

            /**  */ Vec4.prototype.lengthSquare = function () {
                var x = this.x, y = this.y, z = this.z, w = this.w;
                return x * x + y * y + z * z + w * w;
            };

            Vec4.prototype.direction = function (v4fVec, v4fDestination) {
                if (!akra.isDef(v4fDestination)) {
                    v4fDestination = this;
                }

                var x = v4fVec.x - this.x;
                var y = v4fVec.y - this.y;
                var z = v4fVec.z - this.z;
                var w = v4fVec.w - this.w;

                var fLength = math.sqrt(x * x + y * y + z * z + w * w);

                if (fLength !== 0.) {
                    var fInvLength = 1. / fLength;

                    x *= fInvLength;
                    y *= fInvLength;
                    z *= fInvLength;
                    w *= fInvLength;
                }

                v4fDestination.x = x;
                v4fDestination.y = y;
                v4fDestination.z = z;
                v4fDestination.w = w;

                return v4fDestination;
            };

            Vec4.prototype.mix = function (v4fVec, fA, v4fDestination) {
                if (!akra.isDef(v4fDestination)) {
                    v4fDestination = this;
                }

                fA = math.clamp(fA, 0., 1.);

                var fA1 = 1. - fA;
                var fA2 = fA;

                v4fDestination.x = fA1 * this.x + fA2 * v4fVec.x;
                v4fDestination.y = fA1 * this.y + fA2 * v4fVec.y;
                v4fDestination.z = fA1 * this.z + fA2 * v4fVec.z;
                v4fDestination.w = fA1 * this.w + fA2 * v4fVec.w;

                return v4fDestination;
            };

            /**  */ Vec4.prototype.toString = function () {
                return "[x: " + this.x + ", y: " + this.y + ", z: " + this.z + ", w: " + this.w + "]";
            };

            Vec4.prototype.clone = function (sForm, pVec2OrVec3OrVec4) {
                if (sForm.length === 2) {
                    var v2fDest = akra.isDefAndNotNull(pVec2OrVec3OrVec4) ? pVec2OrVec3OrVec4 : math.Vec2.temp();

                    switch (sForm) {
                        case "xx":
                            return v2fDest.set(this.x, this.x);
                        case "xy":
                            return v2fDest.set(this.x, this.y);
                        case "xz":
                            return v2fDest.set(this.x, this.z);
                        case "xw":
                            return v2fDest.set(this.x, this.w);
                        case "yx":
                            return v2fDest.set(this.y, this.x);
                        case "yy":
                            return v2fDest.set(this.y, this.y);
                        case "yz":
                            return v2fDest.set(this.y, this.z);
                        case "yw":
                            return v2fDest.set(this.y, this.w);
                        case "zx":
                            return v2fDest.set(this.z, this.x);
                        case "zy":
                            return v2fDest.set(this.z, this.y);
                        case "zz":
                            return v2fDest.set(this.z, this.z);
                        case "zw":
                            return v2fDest.set(this.z, this.w);
                        case "wx":
                            return v2fDest.set(this.w, this.x);
                        case "wy":
                            return v2fDest.set(this.w, this.y);
                        case "wz":
                            return v2fDest.set(this.w, this.z);
                        case "ww":
                            return v2fDest.set(this.w, this.w);
                    }
                } else if (sForm.length === 3) {
                    var v3fDest = akra.isDefAndNotNull(pVec2OrVec3OrVec4) ? pVec2OrVec3OrVec4 : math.Vec3.temp();

                    switch (sForm) {
                        case "xxx":
                            return v3fDest.set(this.x, this.x, this.x);
                        case "xxy":
                            return v3fDest.set(this.x, this.x, this.y);
                        case "xxz":
                            return v3fDest.set(this.x, this.x, this.z);
                        case "xxw":
                            return v3fDest.set(this.x, this.x, this.w);
                        case "xyx":
                            return v3fDest.set(this.x, this.y, this.x);
                        case "xyy":
                            return v3fDest.set(this.x, this.y, this.y);
                        case "xyz":
                            return v3fDest.set(this.x, this.y, this.z);
                        case "xyw":
                            return v3fDest.set(this.x, this.y, this.w);
                        case "xzx":
                            return v3fDest.set(this.x, this.z, this.x);
                        case "xzy":
                            return v3fDest.set(this.x, this.z, this.y);
                        case "xzz":
                            return v3fDest.set(this.x, this.z, this.z);
                        case "xzw":
                            return v3fDest.set(this.x, this.z, this.w);
                        case "xwx":
                            return v3fDest.set(this.x, this.w, this.x);
                        case "xwy":
                            return v3fDest.set(this.x, this.w, this.y);
                        case "xwz":
                            return v3fDest.set(this.x, this.w, this.z);
                        case "xww":
                            return v3fDest.set(this.x, this.w, this.w);
                        case "yxx":
                            return v3fDest.set(this.y, this.x, this.x);
                        case "yxy":
                            return v3fDest.set(this.y, this.x, this.y);
                        case "yxz":
                            return v3fDest.set(this.y, this.x, this.z);
                        case "yxw":
                            return v3fDest.set(this.y, this.x, this.w);
                        case "yyx":
                            return v3fDest.set(this.y, this.y, this.x);
                        case "yyy":
                            return v3fDest.set(this.y, this.y, this.y);
                        case "yyz":
                            return v3fDest.set(this.y, this.y, this.z);
                        case "yyw":
                            return v3fDest.set(this.y, this.y, this.w);
                        case "yzx":
                            return v3fDest.set(this.y, this.z, this.x);
                        case "yzy":
                            return v3fDest.set(this.y, this.z, this.y);
                        case "yzz":
                            return v3fDest.set(this.y, this.z, this.z);
                        case "yzw":
                            return v3fDest.set(this.y, this.z, this.w);
                        case "ywx":
                            return v3fDest.set(this.y, this.w, this.x);
                        case "ywy":
                            return v3fDest.set(this.y, this.w, this.y);
                        case "ywz":
                            return v3fDest.set(this.y, this.w, this.z);
                        case "yww":
                            return v3fDest.set(this.y, this.w, this.w);
                        case "zxx":
                            return v3fDest.set(this.z, this.x, this.x);
                        case "zxy":
                            return v3fDest.set(this.z, this.x, this.y);
                        case "zxz":
                            return v3fDest.set(this.z, this.x, this.z);
                        case "zxw":
                            return v3fDest.set(this.z, this.x, this.w);
                        case "zyx":
                            return v3fDest.set(this.z, this.y, this.x);
                        case "zyy":
                            return v3fDest.set(this.z, this.y, this.y);
                        case "zyz":
                            return v3fDest.set(this.z, this.y, this.z);
                        case "zyw":
                            return v3fDest.set(this.z, this.y, this.w);
                        case "zzx":
                            return v3fDest.set(this.z, this.z, this.x);
                        case "zzy":
                            return v3fDest.set(this.z, this.z, this.y);
                        case "zzz":
                            return v3fDest.set(this.z, this.z, this.z);
                        case "zzw":
                            return v3fDest.set(this.z, this.z, this.w);
                        case "zwx":
                            return v3fDest.set(this.z, this.w, this.x);
                        case "zwy":
                            return v3fDest.set(this.z, this.w, this.y);
                        case "zwz":
                            return v3fDest.set(this.z, this.w, this.z);
                        case "zww":
                            return v3fDest.set(this.z, this.w, this.w);
                        case "wxx":
                            return v3fDest.set(this.w, this.x, this.x);
                        case "wxy":
                            return v3fDest.set(this.w, this.x, this.y);
                        case "wxz":
                            return v3fDest.set(this.w, this.x, this.z);
                        case "wxw":
                            return v3fDest.set(this.w, this.x, this.w);
                        case "wyx":
                            return v3fDest.set(this.w, this.y, this.x);
                        case "wyy":
                            return v3fDest.set(this.w, this.y, this.y);
                        case "wyz":
                            return v3fDest.set(this.w, this.y, this.z);
                        case "wyw":
                            return v3fDest.set(this.w, this.y, this.w);
                        case "wzx":
                            return v3fDest.set(this.w, this.z, this.x);
                        case "wzy":
                            return v3fDest.set(this.w, this.z, this.y);
                        case "wzz":
                            return v3fDest.set(this.w, this.z, this.z);
                        case "wzw":
                            return v3fDest.set(this.w, this.z, this.w);
                        case "wwx":
                            return v3fDest.set(this.w, this.w, this.x);
                        case "wwy":
                            return v3fDest.set(this.w, this.w, this.y);
                        case "wwz":
                            return v3fDest.set(this.w, this.w, this.z);
                        case "www":
                            return v3fDest.set(this.w, this.w, this.w);
                    }
                } else if (sForm.length === 4) {
                    var v4fDest = akra.isDefAndNotNull(pVec2OrVec3OrVec4) ? pVec2OrVec3OrVec4 : Vec4.temp();

                    switch (sForm) {
                        case "xxxx":
                            return v4fDest.set(this.x, this.x, this.x, this.x);
                        case "xxxy":
                            return v4fDest.set(this.x, this.x, this.x, this.y);
                        case "xxxz":
                            return v4fDest.set(this.x, this.x, this.x, this.z);
                        case "xxxw":
                            return v4fDest.set(this.x, this.x, this.x, this.w);
                        case "xxyx":
                            return v4fDest.set(this.x, this.x, this.y, this.x);
                        case "xxyy":
                            return v4fDest.set(this.x, this.x, this.y, this.y);
                        case "xxyz":
                            return v4fDest.set(this.x, this.x, this.y, this.z);
                        case "xxyw":
                            return v4fDest.set(this.x, this.x, this.y, this.w);
                        case "xxzx":
                            return v4fDest.set(this.x, this.x, this.z, this.x);
                        case "xxzy":
                            return v4fDest.set(this.x, this.x, this.z, this.y);
                        case "xxzz":
                            return v4fDest.set(this.x, this.x, this.z, this.z);
                        case "xxzw":
                            return v4fDest.set(this.x, this.x, this.z, this.w);
                        case "xxwx":
                            return v4fDest.set(this.x, this.x, this.w, this.x);
                        case "xxwy":
                            return v4fDest.set(this.x, this.x, this.w, this.y);
                        case "xxwz":
                            return v4fDest.set(this.x, this.x, this.w, this.z);
                        case "xxww":
                            return v4fDest.set(this.x, this.x, this.w, this.w);
                        case "xyxx":
                            return v4fDest.set(this.x, this.y, this.x, this.x);
                        case "xyxy":
                            return v4fDest.set(this.x, this.y, this.x, this.y);
                        case "xyxz":
                            return v4fDest.set(this.x, this.y, this.x, this.z);
                        case "xyxw":
                            return v4fDest.set(this.x, this.y, this.x, this.w);
                        case "xyyx":
                            return v4fDest.set(this.x, this.y, this.y, this.x);
                        case "xyyy":
                            return v4fDest.set(this.x, this.y, this.y, this.y);
                        case "xyyz":
                            return v4fDest.set(this.x, this.y, this.y, this.z);
                        case "xyyw":
                            return v4fDest.set(this.x, this.y, this.y, this.w);
                        case "xyzx":
                            return v4fDest.set(this.x, this.y, this.z, this.x);
                        case "xyzy":
                            return v4fDest.set(this.x, this.y, this.z, this.y);
                        case "xyzz":
                            return v4fDest.set(this.x, this.y, this.z, this.z);
                        case "xyzw":
                            return v4fDest.set(this.x, this.y, this.z, this.w);
                        case "xywx":
                            return v4fDest.set(this.x, this.y, this.w, this.x);
                        case "xywy":
                            return v4fDest.set(this.x, this.y, this.w, this.y);
                        case "xywz":
                            return v4fDest.set(this.x, this.y, this.w, this.z);
                        case "xyww":
                            return v4fDest.set(this.x, this.y, this.w, this.w);
                        case "xzxx":
                            return v4fDest.set(this.x, this.z, this.x, this.x);
                        case "xzxy":
                            return v4fDest.set(this.x, this.z, this.x, this.y);
                        case "xzxz":
                            return v4fDest.set(this.x, this.z, this.x, this.z);
                        case "xzxw":
                            return v4fDest.set(this.x, this.z, this.x, this.w);
                        case "xzyx":
                            return v4fDest.set(this.x, this.z, this.y, this.x);
                        case "xzyy":
                            return v4fDest.set(this.x, this.z, this.y, this.y);
                        case "xzyz":
                            return v4fDest.set(this.x, this.z, this.y, this.z);
                        case "xzyw":
                            return v4fDest.set(this.x, this.z, this.y, this.w);
                        case "xzzx":
                            return v4fDest.set(this.x, this.z, this.z, this.x);
                        case "xzzy":
                            return v4fDest.set(this.x, this.z, this.z, this.y);
                        case "xzzz":
                            return v4fDest.set(this.x, this.z, this.z, this.z);
                        case "xzzw":
                            return v4fDest.set(this.x, this.z, this.z, this.w);
                        case "xzwx":
                            return v4fDest.set(this.x, this.z, this.w, this.x);
                        case "xzwy":
                            return v4fDest.set(this.x, this.z, this.w, this.y);
                        case "xzwz":
                            return v4fDest.set(this.x, this.z, this.w, this.z);
                        case "xzww":
                            return v4fDest.set(this.x, this.z, this.w, this.w);
                        case "xwxx":
                            return v4fDest.set(this.x, this.w, this.x, this.x);
                        case "xwxy":
                            return v4fDest.set(this.x, this.w, this.x, this.y);
                        case "xwxz":
                            return v4fDest.set(this.x, this.w, this.x, this.z);
                        case "xwxw":
                            return v4fDest.set(this.x, this.w, this.x, this.w);
                        case "xwyx":
                            return v4fDest.set(this.x, this.w, this.y, this.x);
                        case "xwyy":
                            return v4fDest.set(this.x, this.w, this.y, this.y);
                        case "xwyz":
                            return v4fDest.set(this.x, this.w, this.y, this.z);
                        case "xwyw":
                            return v4fDest.set(this.x, this.w, this.y, this.w);
                        case "xwzx":
                            return v4fDest.set(this.x, this.w, this.z, this.x);
                        case "xwzy":
                            return v4fDest.set(this.x, this.w, this.z, this.y);
                        case "xwzz":
                            return v4fDest.set(this.x, this.w, this.z, this.z);
                        case "xwzw":
                            return v4fDest.set(this.x, this.w, this.z, this.w);
                        case "xwwx":
                            return v4fDest.set(this.x, this.w, this.w, this.x);
                        case "xwwy":
                            return v4fDest.set(this.x, this.w, this.w, this.y);
                        case "xwwz":
                            return v4fDest.set(this.x, this.w, this.w, this.z);
                        case "xwww":
                            return v4fDest.set(this.x, this.w, this.w, this.w);
                        case "yxxx":
                            return v4fDest.set(this.y, this.x, this.x, this.x);
                        case "yxxy":
                            return v4fDest.set(this.y, this.x, this.x, this.y);
                        case "yxxz":
                            return v4fDest.set(this.y, this.x, this.x, this.z);
                        case "yxxw":
                            return v4fDest.set(this.y, this.x, this.x, this.w);
                        case "yxyx":
                            return v4fDest.set(this.y, this.x, this.y, this.x);
                        case "yxyy":
                            return v4fDest.set(this.y, this.x, this.y, this.y);
                        case "yxyz":
                            return v4fDest.set(this.y, this.x, this.y, this.z);
                        case "yxyw":
                            return v4fDest.set(this.y, this.x, this.y, this.w);
                        case "yxzx":
                            return v4fDest.set(this.y, this.x, this.z, this.x);
                        case "yxzy":
                            return v4fDest.set(this.y, this.x, this.z, this.y);
                        case "yxzz":
                            return v4fDest.set(this.y, this.x, this.z, this.z);
                        case "yxzw":
                            return v4fDest.set(this.y, this.x, this.z, this.w);
                        case "yxwx":
                            return v4fDest.set(this.y, this.x, this.w, this.x);
                        case "yxwy":
                            return v4fDest.set(this.y, this.x, this.w, this.y);
                        case "yxwz":
                            return v4fDest.set(this.y, this.x, this.w, this.z);
                        case "yxww":
                            return v4fDest.set(this.y, this.x, this.w, this.w);
                        case "yyxx":
                            return v4fDest.set(this.y, this.y, this.x, this.x);
                        case "yyxy":
                            return v4fDest.set(this.y, this.y, this.x, this.y);
                        case "yyxz":
                            return v4fDest.set(this.y, this.y, this.x, this.z);
                        case "yyxw":
                            return v4fDest.set(this.y, this.y, this.x, this.w);
                        case "yyyx":
                            return v4fDest.set(this.y, this.y, this.y, this.x);
                        case "yyyy":
                            return v4fDest.set(this.y, this.y, this.y, this.y);
                        case "yyyz":
                            return v4fDest.set(this.y, this.y, this.y, this.z);
                        case "yyyw":
                            return v4fDest.set(this.y, this.y, this.y, this.w);
                        case "yyzx":
                            return v4fDest.set(this.y, this.y, this.z, this.x);
                        case "yyzy":
                            return v4fDest.set(this.y, this.y, this.z, this.y);
                        case "yyzz":
                            return v4fDest.set(this.y, this.y, this.z, this.z);
                        case "yyzw":
                            return v4fDest.set(this.y, this.y, this.z, this.w);
                        case "yywx":
                            return v4fDest.set(this.y, this.y, this.w, this.x);
                        case "yywy":
                            return v4fDest.set(this.y, this.y, this.w, this.y);
                        case "yywz":
                            return v4fDest.set(this.y, this.y, this.w, this.z);
                        case "yyww":
                            return v4fDest.set(this.y, this.y, this.w, this.w);
                        case "yzxx":
                            return v4fDest.set(this.y, this.z, this.x, this.x);
                        case "yzxy":
                            return v4fDest.set(this.y, this.z, this.x, this.y);
                        case "yzxz":
                            return v4fDest.set(this.y, this.z, this.x, this.z);
                        case "yzxw":
                            return v4fDest.set(this.y, this.z, this.x, this.w);
                        case "yzyx":
                            return v4fDest.set(this.y, this.z, this.y, this.x);
                        case "yzyy":
                            return v4fDest.set(this.y, this.z, this.y, this.y);
                        case "yzyz":
                            return v4fDest.set(this.y, this.z, this.y, this.z);
                        case "yzyw":
                            return v4fDest.set(this.y, this.z, this.y, this.w);
                        case "yzzx":
                            return v4fDest.set(this.y, this.z, this.z, this.x);
                        case "yzzy":
                            return v4fDest.set(this.y, this.z, this.z, this.y);
                        case "yzzz":
                            return v4fDest.set(this.y, this.z, this.z, this.z);
                        case "yzzw":
                            return v4fDest.set(this.y, this.z, this.z, this.w);
                        case "yzwx":
                            return v4fDest.set(this.y, this.z, this.w, this.x);
                        case "yzwy":
                            return v4fDest.set(this.y, this.z, this.w, this.y);
                        case "yzwz":
                            return v4fDest.set(this.y, this.z, this.w, this.z);
                        case "yzww":
                            return v4fDest.set(this.y, this.z, this.w, this.w);
                        case "ywxx":
                            return v4fDest.set(this.y, this.w, this.x, this.x);
                        case "ywxy":
                            return v4fDest.set(this.y, this.w, this.x, this.y);
                        case "ywxz":
                            return v4fDest.set(this.y, this.w, this.x, this.z);
                        case "ywxw":
                            return v4fDest.set(this.y, this.w, this.x, this.w);
                        case "ywyx":
                            return v4fDest.set(this.y, this.w, this.y, this.x);
                        case "ywyy":
                            return v4fDest.set(this.y, this.w, this.y, this.y);
                        case "ywyz":
                            return v4fDest.set(this.y, this.w, this.y, this.z);
                        case "ywyw":
                            return v4fDest.set(this.y, this.w, this.y, this.w);
                        case "ywzx":
                            return v4fDest.set(this.y, this.w, this.z, this.x);
                        case "ywzy":
                            return v4fDest.set(this.y, this.w, this.z, this.y);
                        case "ywzz":
                            return v4fDest.set(this.y, this.w, this.z, this.z);
                        case "ywzw":
                            return v4fDest.set(this.y, this.w, this.z, this.w);
                        case "ywwx":
                            return v4fDest.set(this.y, this.w, this.w, this.x);
                        case "ywwy":
                            return v4fDest.set(this.y, this.w, this.w, this.y);
                        case "ywwz":
                            return v4fDest.set(this.y, this.w, this.w, this.z);
                        case "ywww":
                            return v4fDest.set(this.y, this.w, this.w, this.w);
                        case "zxxx":
                            return v4fDest.set(this.z, this.x, this.x, this.x);
                        case "zxxy":
                            return v4fDest.set(this.z, this.x, this.x, this.y);
                        case "zxxz":
                            return v4fDest.set(this.z, this.x, this.x, this.z);
                        case "zxxw":
                            return v4fDest.set(this.z, this.x, this.x, this.w);
                        case "zxyx":
                            return v4fDest.set(this.z, this.x, this.y, this.x);
                        case "zxyy":
                            return v4fDest.set(this.z, this.x, this.y, this.y);
                        case "zxyz":
                            return v4fDest.set(this.z, this.x, this.y, this.z);
                        case "zxyw":
                            return v4fDest.set(this.z, this.x, this.y, this.w);
                        case "zxzx":
                            return v4fDest.set(this.z, this.x, this.z, this.x);
                        case "zxzy":
                            return v4fDest.set(this.z, this.x, this.z, this.y);
                        case "zxzz":
                            return v4fDest.set(this.z, this.x, this.z, this.z);
                        case "zxzw":
                            return v4fDest.set(this.z, this.x, this.z, this.w);
                        case "zxwx":
                            return v4fDest.set(this.z, this.x, this.w, this.x);
                        case "zxwy":
                            return v4fDest.set(this.z, this.x, this.w, this.y);
                        case "zxwz":
                            return v4fDest.set(this.z, this.x, this.w, this.z);
                        case "zxww":
                            return v4fDest.set(this.z, this.x, this.w, this.w);
                        case "zyxx":
                            return v4fDest.set(this.z, this.y, this.x, this.x);
                        case "zyxy":
                            return v4fDest.set(this.z, this.y, this.x, this.y);
                        case "zyxz":
                            return v4fDest.set(this.z, this.y, this.x, this.z);
                        case "zyxw":
                            return v4fDest.set(this.z, this.y, this.x, this.w);
                        case "zyyx":
                            return v4fDest.set(this.z, this.y, this.y, this.x);
                        case "zyyy":
                            return v4fDest.set(this.z, this.y, this.y, this.y);
                        case "zyyz":
                            return v4fDest.set(this.z, this.y, this.y, this.z);
                        case "zyyw":
                            return v4fDest.set(this.z, this.y, this.y, this.w);
                        case "zyzx":
                            return v4fDest.set(this.z, this.y, this.z, this.x);
                        case "zyzy":
                            return v4fDest.set(this.z, this.y, this.z, this.y);
                        case "zyzz":
                            return v4fDest.set(this.z, this.y, this.z, this.z);
                        case "zyzw":
                            return v4fDest.set(this.z, this.y, this.z, this.w);
                        case "zywx":
                            return v4fDest.set(this.z, this.y, this.w, this.x);
                        case "zywy":
                            return v4fDest.set(this.z, this.y, this.w, this.y);
                        case "zywz":
                            return v4fDest.set(this.z, this.y, this.w, this.z);
                        case "zyww":
                            return v4fDest.set(this.z, this.y, this.w, this.w);
                        case "zzxx":
                            return v4fDest.set(this.z, this.z, this.x, this.x);
                        case "zzxy":
                            return v4fDest.set(this.z, this.z, this.x, this.y);
                        case "zzxz":
                            return v4fDest.set(this.z, this.z, this.x, this.z);
                        case "zzxw":
                            return v4fDest.set(this.z, this.z, this.x, this.w);
                        case "zzyx":
                            return v4fDest.set(this.z, this.z, this.y, this.x);
                        case "zzyy":
                            return v4fDest.set(this.z, this.z, this.y, this.y);
                        case "zzyz":
                            return v4fDest.set(this.z, this.z, this.y, this.z);
                        case "zzyw":
                            return v4fDest.set(this.z, this.z, this.y, this.w);
                        case "zzzx":
                            return v4fDest.set(this.z, this.z, this.z, this.x);
                        case "zzzy":
                            return v4fDest.set(this.z, this.z, this.z, this.y);
                        case "zzzz":
                            return v4fDest.set(this.z, this.z, this.z, this.z);
                        case "zzzw":
                            return v4fDest.set(this.z, this.z, this.z, this.w);
                        case "zzwx":
                            return v4fDest.set(this.z, this.z, this.w, this.x);
                        case "zzwy":
                            return v4fDest.set(this.z, this.z, this.w, this.y);
                        case "zzwz":
                            return v4fDest.set(this.z, this.z, this.w, this.z);
                        case "zzww":
                            return v4fDest.set(this.z, this.z, this.w, this.w);
                        case "zwxx":
                            return v4fDest.set(this.z, this.w, this.x, this.x);
                        case "zwxy":
                            return v4fDest.set(this.z, this.w, this.x, this.y);
                        case "zwxz":
                            return v4fDest.set(this.z, this.w, this.x, this.z);
                        case "zwxw":
                            return v4fDest.set(this.z, this.w, this.x, this.w);
                        case "zwyx":
                            return v4fDest.set(this.z, this.w, this.y, this.x);
                        case "zwyy":
                            return v4fDest.set(this.z, this.w, this.y, this.y);
                        case "zwyz":
                            return v4fDest.set(this.z, this.w, this.y, this.z);
                        case "zwyw":
                            return v4fDest.set(this.z, this.w, this.y, this.w);
                        case "zwzx":
                            return v4fDest.set(this.z, this.w, this.z, this.x);
                        case "zwzy":
                            return v4fDest.set(this.z, this.w, this.z, this.y);
                        case "zwzz":
                            return v4fDest.set(this.z, this.w, this.z, this.z);
                        case "zwzw":
                            return v4fDest.set(this.z, this.w, this.z, this.w);
                        case "zwwx":
                            return v4fDest.set(this.z, this.w, this.w, this.x);
                        case "zwwy":
                            return v4fDest.set(this.z, this.w, this.w, this.y);
                        case "zwwz":
                            return v4fDest.set(this.z, this.w, this.w, this.z);
                        case "zwww":
                            return v4fDest.set(this.z, this.w, this.w, this.w);
                        case "wxxx":
                            return v4fDest.set(this.w, this.x, this.x, this.x);
                        case "wxxy":
                            return v4fDest.set(this.w, this.x, this.x, this.y);
                        case "wxxz":
                            return v4fDest.set(this.w, this.x, this.x, this.z);
                        case "wxxw":
                            return v4fDest.set(this.w, this.x, this.x, this.w);
                        case "wxyx":
                            return v4fDest.set(this.w, this.x, this.y, this.x);
                        case "wxyy":
                            return v4fDest.set(this.w, this.x, this.y, this.y);
                        case "wxyz":
                            return v4fDest.set(this.w, this.x, this.y, this.z);
                        case "wxyw":
                            return v4fDest.set(this.w, this.x, this.y, this.w);
                        case "wxzx":
                            return v4fDest.set(this.w, this.x, this.z, this.x);
                        case "wxzy":
                            return v4fDest.set(this.w, this.x, this.z, this.y);
                        case "wxzz":
                            return v4fDest.set(this.w, this.x, this.z, this.z);
                        case "wxzw":
                            return v4fDest.set(this.w, this.x, this.z, this.w);
                        case "wxwx":
                            return v4fDest.set(this.w, this.x, this.w, this.x);
                        case "wxwy":
                            return v4fDest.set(this.w, this.x, this.w, this.y);
                        case "wxwz":
                            return v4fDest.set(this.w, this.x, this.w, this.z);
                        case "wxww":
                            return v4fDest.set(this.w, this.x, this.w, this.w);
                        case "wyxx":
                            return v4fDest.set(this.w, this.y, this.x, this.x);
                        case "wyxy":
                            return v4fDest.set(this.w, this.y, this.x, this.y);
                        case "wyxz":
                            return v4fDest.set(this.w, this.y, this.x, this.z);
                        case "wyxw":
                            return v4fDest.set(this.w, this.y, this.x, this.w);
                        case "wyyx":
                            return v4fDest.set(this.w, this.y, this.y, this.x);
                        case "wyyy":
                            return v4fDest.set(this.w, this.y, this.y, this.y);
                        case "wyyz":
                            return v4fDest.set(this.w, this.y, this.y, this.z);
                        case "wyyw":
                            return v4fDest.set(this.w, this.y, this.y, this.w);
                        case "wyzx":
                            return v4fDest.set(this.w, this.y, this.z, this.x);
                        case "wyzy":
                            return v4fDest.set(this.w, this.y, this.z, this.y);
                        case "wyzz":
                            return v4fDest.set(this.w, this.y, this.z, this.z);
                        case "wyzw":
                            return v4fDest.set(this.w, this.y, this.z, this.w);
                        case "wywx":
                            return v4fDest.set(this.w, this.y, this.w, this.x);
                        case "wywy":
                            return v4fDest.set(this.w, this.y, this.w, this.y);
                        case "wywz":
                            return v4fDest.set(this.w, this.y, this.w, this.z);
                        case "wyww":
                            return v4fDest.set(this.w, this.y, this.w, this.w);
                        case "wzxx":
                            return v4fDest.set(this.w, this.z, this.x, this.x);
                        case "wzxy":
                            return v4fDest.set(this.w, this.z, this.x, this.y);
                        case "wzxz":
                            return v4fDest.set(this.w, this.z, this.x, this.z);
                        case "wzxw":
                            return v4fDest.set(this.w, this.z, this.x, this.w);
                        case "wzyx":
                            return v4fDest.set(this.w, this.z, this.y, this.x);
                        case "wzyy":
                            return v4fDest.set(this.w, this.z, this.y, this.y);
                        case "wzyz":
                            return v4fDest.set(this.w, this.z, this.y, this.z);
                        case "wzyw":
                            return v4fDest.set(this.w, this.z, this.y, this.w);
                        case "wzzx":
                            return v4fDest.set(this.w, this.z, this.z, this.x);
                        case "wzzy":
                            return v4fDest.set(this.w, this.z, this.z, this.y);
                        case "wzzz":
                            return v4fDest.set(this.w, this.z, this.z, this.z);
                        case "wzzw":
                            return v4fDest.set(this.w, this.z, this.z, this.w);
                        case "wzwx":
                            return v4fDest.set(this.w, this.z, this.w, this.x);
                        case "wzwy":
                            return v4fDest.set(this.w, this.z, this.w, this.y);
                        case "wzwz":
                            return v4fDest.set(this.w, this.z, this.w, this.z);
                        case "wzww":
                            return v4fDest.set(this.w, this.z, this.w, this.w);
                        case "wwxx":
                            return v4fDest.set(this.w, this.w, this.x, this.x);
                        case "wwxy":
                            return v4fDest.set(this.w, this.w, this.x, this.y);
                        case "wwxz":
                            return v4fDest.set(this.w, this.w, this.x, this.z);
                        case "wwxw":
                            return v4fDest.set(this.w, this.w, this.x, this.w);
                        case "wwyx":
                            return v4fDest.set(this.w, this.w, this.y, this.x);
                        case "wwyy":
                            return v4fDest.set(this.w, this.w, this.y, this.y);
                        case "wwyz":
                            return v4fDest.set(this.w, this.w, this.y, this.z);
                        case "wwyw":
                            return v4fDest.set(this.w, this.w, this.y, this.w);
                        case "wwzx":
                            return v4fDest.set(this.w, this.w, this.z, this.x);
                        case "wwzy":
                            return v4fDest.set(this.w, this.w, this.z, this.y);
                        case "wwzz":
                            return v4fDest.set(this.w, this.w, this.z, this.z);
                        case "wwzw":
                            return v4fDest.set(this.w, this.w, this.z, this.w);
                        case "wwwx":
                            return v4fDest.set(this.w, this.w, this.w, this.x);
                        case "wwwy":
                            return v4fDest.set(this.w, this.w, this.w, this.y);
                        case "wwwz":
                            return v4fDest.set(this.w, this.w, this.w, this.z);
                        case "wwww":
                            return v4fDest.set(this.w, this.w, this.w, this.w);
                    }
                }

                akra.logger.error("Bad vector form", sForm);
                return null;
            };

            Vec4.prototype.copy = function (sForm, pVectorOrFloat) {
                if (sForm.length === 2) {
                    var v2fFrom = akra.isFloat(pVectorOrFloat) ? math.Vec2.temp(pVectorOrFloat) : pVectorOrFloat;

                    switch (sForm) {
                        case "xx":
                            this.x = v2fFrom.x;
                            this.x = v2fFrom.y;
                            return this;
                        case "xy":
                            this.x = v2fFrom.x;
                            this.y = v2fFrom.y;
                            return this;
                        case "xz":
                            this.x = v2fFrom.x;
                            this.z = v2fFrom.y;
                            return this;
                        case "xw":
                            this.x = v2fFrom.x;
                            this.w = v2fFrom.y;
                            return this;
                        case "yx":
                            this.y = v2fFrom.x;
                            this.x = v2fFrom.y;
                            return this;
                        case "yy":
                            this.y = v2fFrom.x;
                            this.y = v2fFrom.y;
                            return this;
                        case "yz":
                            this.y = v2fFrom.x;
                            this.z = v2fFrom.y;
                            return this;
                        case "yw":
                            this.y = v2fFrom.x;
                            this.w = v2fFrom.y;
                            return this;
                        case "zx":
                            this.z = v2fFrom.x;
                            this.x = v2fFrom.y;
                            return this;
                        case "zy":
                            this.z = v2fFrom.x;
                            this.y = v2fFrom.y;
                            return this;
                        case "zz":
                            this.z = v2fFrom.x;
                            this.z = v2fFrom.y;
                            return this;
                        case "zw":
                            this.z = v2fFrom.x;
                            this.w = v2fFrom.y;
                            return this;
                        case "wx":
                            this.w = v2fFrom.x;
                            this.x = v2fFrom.y;
                            return this;
                        case "wy":
                            this.w = v2fFrom.x;
                            this.y = v2fFrom.y;
                            return this;
                        case "wz":
                            this.w = v2fFrom.x;
                            this.z = v2fFrom.y;
                            return this;
                        case "ww":
                            this.w = v2fFrom.x;
                            this.w = v2fFrom.y;
                            return this;
                    }
                } else if (sForm.length === 3) {
                    var v3fFrom = akra.isFloat(pVectorOrFloat) ? math.Vec3.temp(pVectorOrFloat) : pVectorOrFloat;

                    switch (sForm) {
                        case "xxx":
                            this.x = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "xxy":
                            this.x = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "xxz":
                            this.x = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "xxw":
                            this.x = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.w = v3fFrom.z;
                            return this;
                        case "xyx":
                            this.x = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "xyy":
                            this.x = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "xyz":
                            this.x = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "xyw":
                            this.x = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.w = v3fFrom.z;
                            return this;
                        case "xzx":
                            this.x = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "xzy":
                            this.x = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "xzz":
                            this.x = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "xzw":
                            this.x = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.w = v3fFrom.z;
                            return this;
                        case "xwx":
                            this.x = v3fFrom.x;
                            this.w = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "xwy":
                            this.x = v3fFrom.x;
                            this.w = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "xwz":
                            this.x = v3fFrom.x;
                            this.w = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "xww":
                            this.x = v3fFrom.x;
                            this.w = v3fFrom.y;
                            this.w = v3fFrom.z;
                            return this;
                        case "yxx":
                            this.y = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "yxy":
                            this.y = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "yxz":
                            this.y = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "yxw":
                            this.y = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.w = v3fFrom.z;
                            return this;
                        case "yyx":
                            this.y = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "yyy":
                            this.y = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "yyz":
                            this.y = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "yyw":
                            this.y = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.w = v3fFrom.z;
                            return this;
                        case "yzx":
                            this.y = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "yzy":
                            this.y = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "yzz":
                            this.y = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "yzw":
                            this.y = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.w = v3fFrom.z;
                            return this;
                        case "ywx":
                            this.y = v3fFrom.x;
                            this.w = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "ywy":
                            this.y = v3fFrom.x;
                            this.w = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "ywz":
                            this.y = v3fFrom.x;
                            this.w = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "yww":
                            this.y = v3fFrom.x;
                            this.w = v3fFrom.y;
                            this.w = v3fFrom.z;
                            return this;
                        case "zxx":
                            this.z = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "zxy":
                            this.z = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "zxz":
                            this.z = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "zxw":
                            this.z = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.w = v3fFrom.z;
                            return this;
                        case "zyx":
                            this.z = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "zyy":
                            this.z = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "zyz":
                            this.z = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "zyw":
                            this.z = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.w = v3fFrom.z;
                            return this;
                        case "zzx":
                            this.z = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "zzy":
                            this.z = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "zzz":
                            this.z = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "zzw":
                            this.z = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.w = v3fFrom.z;
                            return this;
                        case "zwx":
                            this.z = v3fFrom.x;
                            this.w = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "zwy":
                            this.z = v3fFrom.x;
                            this.w = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "zwz":
                            this.z = v3fFrom.x;
                            this.w = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "zww":
                            this.z = v3fFrom.x;
                            this.w = v3fFrom.y;
                            this.w = v3fFrom.z;
                            return this;
                        case "wxx":
                            this.w = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "wxy":
                            this.w = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "wxz":
                            this.w = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "wxw":
                            this.w = v3fFrom.x;
                            this.x = v3fFrom.y;
                            this.w = v3fFrom.z;
                            return this;
                        case "wyx":
                            this.w = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "wyy":
                            this.w = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "wyz":
                            this.w = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "wyw":
                            this.w = v3fFrom.x;
                            this.y = v3fFrom.y;
                            this.w = v3fFrom.z;
                            return this;
                        case "wzx":
                            this.w = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "wzy":
                            this.w = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "wzz":
                            this.w = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "wzw":
                            this.w = v3fFrom.x;
                            this.z = v3fFrom.y;
                            this.w = v3fFrom.z;
                            return this;
                        case "wwx":
                            this.w = v3fFrom.x;
                            this.w = v3fFrom.y;
                            this.x = v3fFrom.z;
                            return this;
                        case "wwy":
                            this.w = v3fFrom.x;
                            this.w = v3fFrom.y;
                            this.y = v3fFrom.z;
                            return this;
                        case "wwz":
                            this.w = v3fFrom.x;
                            this.w = v3fFrom.y;
                            this.z = v3fFrom.z;
                            return this;
                        case "www":
                            this.w = v3fFrom.x;
                            this.w = v3fFrom.y;
                            this.w = v3fFrom.z;
                            return this;
                    }
                } else if (sForm.length === 4) {
                    var v4fFrom = akra.isFloat(pVectorOrFloat) ? Vec4.temp(pVectorOrFloat) : pVectorOrFloat;

                    switch (sForm) {
                        case "xxxx":
                            this.x = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "xxxy":
                            this.x = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "xxxz":
                            this.x = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "xxxw":
                            this.x = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "xxyx":
                            this.x = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "xxyy":
                            this.x = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "xxyz":
                            this.x = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "xxyw":
                            this.x = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "xxzx":
                            this.x = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "xxzy":
                            this.x = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "xxzz":
                            this.x = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "xxzw":
                            this.x = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "xxwx":
                            this.x = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "xxwy":
                            this.x = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "xxwz":
                            this.x = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "xxww":
                            this.x = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "xyxx":
                            this.x = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "xyxy":
                            this.x = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "xyxz":
                            this.x = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "xyxw":
                            this.x = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "xyyx":
                            this.x = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "xyyy":
                            this.x = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "xyyz":
                            this.x = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "xyyw":
                            this.x = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "xyzx":
                            this.x = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "xyzy":
                            this.x = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "xyzz":
                            this.x = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "xyzw":
                            this.x = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "xywx":
                            this.x = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "xywy":
                            this.x = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "xywz":
                            this.x = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "xyww":
                            this.x = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "xzxx":
                            this.x = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "xzxy":
                            this.x = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "xzxz":
                            this.x = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "xzxw":
                            this.x = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "xzyx":
                            this.x = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "xzyy":
                            this.x = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "xzyz":
                            this.x = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "xzyw":
                            this.x = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "xzzx":
                            this.x = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "xzzy":
                            this.x = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "xzzz":
                            this.x = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "xzzw":
                            this.x = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "xzwx":
                            this.x = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "xzwy":
                            this.x = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "xzwz":
                            this.x = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "xzww":
                            this.x = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "xwxx":
                            this.x = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "xwxy":
                            this.x = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "xwxz":
                            this.x = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "xwxw":
                            this.x = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "xwyx":
                            this.x = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "xwyy":
                            this.x = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "xwyz":
                            this.x = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "xwyw":
                            this.x = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "xwzx":
                            this.x = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "xwzy":
                            this.x = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "xwzz":
                            this.x = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "xwzw":
                            this.x = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "xwwx":
                            this.x = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "xwwy":
                            this.x = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "xwwz":
                            this.x = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "xwww":
                            this.x = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "yxxx":
                            this.y = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "yxxy":
                            this.y = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "yxxz":
                            this.y = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "yxxw":
                            this.y = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "yxyx":
                            this.y = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "yxyy":
                            this.y = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "yxyz":
                            this.y = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "yxyw":
                            this.y = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "yxzx":
                            this.y = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "yxzy":
                            this.y = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "yxzz":
                            this.y = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "yxzw":
                            this.y = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "yxwx":
                            this.y = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "yxwy":
                            this.y = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "yxwz":
                            this.y = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "yxww":
                            this.y = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "yyxx":
                            this.y = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "yyxy":
                            this.y = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "yyxz":
                            this.y = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "yyxw":
                            this.y = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "yyyx":
                            this.y = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "yyyy":
                            this.y = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "yyyz":
                            this.y = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "yyyw":
                            this.y = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "yyzx":
                            this.y = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "yyzy":
                            this.y = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "yyzz":
                            this.y = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "yyzw":
                            this.y = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "yywx":
                            this.y = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "yywy":
                            this.y = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "yywz":
                            this.y = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "yyww":
                            this.y = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "yzxx":
                            this.y = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "yzxy":
                            this.y = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "yzxz":
                            this.y = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "yzxw":
                            this.y = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "yzyx":
                            this.y = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "yzyy":
                            this.y = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "yzyz":
                            this.y = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "yzyw":
                            this.y = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "yzzx":
                            this.y = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "yzzy":
                            this.y = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "yzzz":
                            this.y = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "yzzw":
                            this.y = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "yzwx":
                            this.y = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "yzwy":
                            this.y = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "yzwz":
                            this.y = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "yzww":
                            this.y = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "ywxx":
                            this.y = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "ywxy":
                            this.y = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "ywxz":
                            this.y = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "ywxw":
                            this.y = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "ywyx":
                            this.y = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "ywyy":
                            this.y = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "ywyz":
                            this.y = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "ywyw":
                            this.y = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "ywzx":
                            this.y = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "ywzy":
                            this.y = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "ywzz":
                            this.y = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "ywzw":
                            this.y = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "ywwx":
                            this.y = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "ywwy":
                            this.y = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "ywwz":
                            this.y = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "ywww":
                            this.y = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "zxxx":
                            this.z = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "zxxy":
                            this.z = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "zxxz":
                            this.z = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "zxxw":
                            this.z = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "zxyx":
                            this.z = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "zxyy":
                            this.z = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "zxyz":
                            this.z = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "zxyw":
                            this.z = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "zxzx":
                            this.z = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "zxzy":
                            this.z = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "zxzz":
                            this.z = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "zxzw":
                            this.z = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "zxwx":
                            this.z = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "zxwy":
                            this.z = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "zxwz":
                            this.z = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "zxww":
                            this.z = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "zyxx":
                            this.z = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "zyxy":
                            this.z = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "zyxz":
                            this.z = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "zyxw":
                            this.z = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "zyyx":
                            this.z = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "zyyy":
                            this.z = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "zyyz":
                            this.z = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "zyyw":
                            this.z = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "zyzx":
                            this.z = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "zyzy":
                            this.z = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "zyzz":
                            this.z = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "zyzw":
                            this.z = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "zywx":
                            this.z = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "zywy":
                            this.z = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "zywz":
                            this.z = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "zyww":
                            this.z = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "zzxx":
                            this.z = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "zzxy":
                            this.z = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "zzxz":
                            this.z = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "zzxw":
                            this.z = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "zzyx":
                            this.z = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "zzyy":
                            this.z = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "zzyz":
                            this.z = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "zzyw":
                            this.z = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "zzzx":
                            this.z = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "zzzy":
                            this.z = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "zzzz":
                            this.z = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "zzzw":
                            this.z = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "zzwx":
                            this.z = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "zzwy":
                            this.z = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "zzwz":
                            this.z = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "zzww":
                            this.z = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "zwxx":
                            this.z = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "zwxy":
                            this.z = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "zwxz":
                            this.z = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "zwxw":
                            this.z = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "zwyx":
                            this.z = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "zwyy":
                            this.z = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "zwyz":
                            this.z = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "zwyw":
                            this.z = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "zwzx":
                            this.z = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "zwzy":
                            this.z = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "zwzz":
                            this.z = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "zwzw":
                            this.z = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "zwwx":
                            this.z = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "zwwy":
                            this.z = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "zwwz":
                            this.z = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "zwww":
                            this.z = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "wxxx":
                            this.w = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "wxxy":
                            this.w = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "wxxz":
                            this.w = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "wxxw":
                            this.w = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "wxyx":
                            this.w = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "wxyy":
                            this.w = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "wxyz":
                            this.w = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "wxyw":
                            this.w = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "wxzx":
                            this.w = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "wxzy":
                            this.w = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "wxzz":
                            this.w = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "wxzw":
                            this.w = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "wxwx":
                            this.w = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "wxwy":
                            this.w = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "wxwz":
                            this.w = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "wxww":
                            this.w = v4fFrom.x;
                            this.x = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "wyxx":
                            this.w = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "wyxy":
                            this.w = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "wyxz":
                            this.w = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "wyxw":
                            this.w = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "wyyx":
                            this.w = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "wyyy":
                            this.w = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "wyyz":
                            this.w = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "wyyw":
                            this.w = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "wyzx":
                            this.w = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "wyzy":
                            this.w = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "wyzz":
                            this.w = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "wyzw":
                            this.w = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "wywx":
                            this.w = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "wywy":
                            this.w = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "wywz":
                            this.w = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "wyww":
                            this.w = v4fFrom.x;
                            this.y = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "wzxx":
                            this.w = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "wzxy":
                            this.w = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "wzxz":
                            this.w = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "wzxw":
                            this.w = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "wzyx":
                            this.w = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "wzyy":
                            this.w = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "wzyz":
                            this.w = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "wzyw":
                            this.w = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "wzzx":
                            this.w = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "wzzy":
                            this.w = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "wzzz":
                            this.w = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "wzzw":
                            this.w = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "wzwx":
                            this.w = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "wzwy":
                            this.w = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "wzwz":
                            this.w = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "wzww":
                            this.w = v4fFrom.x;
                            this.z = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "wwxx":
                            this.w = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "wwxy":
                            this.w = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "wwxz":
                            this.w = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "wwxw":
                            this.w = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.x = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "wwyx":
                            this.w = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "wwyy":
                            this.w = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "wwyz":
                            this.w = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "wwyw":
                            this.w = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.y = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "wwzx":
                            this.w = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "wwzy":
                            this.w = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "wwzz":
                            this.w = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "wwzw":
                            this.w = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.z = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                        case "wwwx":
                            this.w = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.x = v4fFrom.w;
                            return this;
                        case "wwwy":
                            this.w = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.y = v4fFrom.w;
                            return this;
                        case "wwwz":
                            this.w = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.z = v4fFrom.w;
                            return this;
                        case "wwww":
                            this.w = v4fFrom.x;
                            this.w = v4fFrom.y;
                            this.w = v4fFrom.z;
                            this.w = v4fFrom.w;
                            return this;
                    }
                }

                akra.logger.error("Bad vector form", sForm);
                return this;
            };

            Vec4.temp = function () {
                iElement = (iElement === pBuffer.length - 1 ? 0 : iElement);
                var p = pBuffer[iElement++];
                var nArgumentsLength = arguments.length;

                switch (nArgumentsLength) {
                    case 0:
                        p.x = p.y = p.z = p.w = 0.;
                        break;
                    case 1:
                        if (akra.isFloat(arguments[0])) {
                            p.x = p.y = p.z = p.w = arguments[0];
                        } else if (arguments[0] instanceof Vec4) {
                            var v4fVec = arguments[0];

                            p.x = v4fVec.x;
                            p.y = v4fVec.y;
                            p.z = v4fVec.z;
                            p.w = v4fVec.w;
                        } else if (akra.isDef(arguments[0].r)) {
                            p.x = arguments[0].r;
                            p.y = arguments[0].g;
                            p.z = arguments[0].b;
                            p.w = arguments[0].a;
                        } else {
                            //array
                            var pArray = arguments[0];

                            p.x = pArray[0];
                            p.y = pArray[1];
                            p.z = pArray[2];
                            p.w = pArray[3];
                        }
                        break;
                    case 2:
                        if (akra.isFloat(arguments[0])) {
                            var fValue = arguments[0];
                            var v3fVec = arguments[1];

                            p.x = fValue;
                            p.y = v3fVec.x;
                            p.z = v3fVec.y;
                            p.w = v3fVec.z;
                        } else if (arguments[0] instanceof math.Vec2) {
                            var v2fVec1 = arguments[0];
                            var v2fVec2 = arguments[1];

                            p.x = v2fVec1.x;
                            p.y = v2fVec1.y;
                            p.z = v2fVec2.x;
                            p.w = v2fVec2.y;
                        } else {
                            var v3fVec = arguments[0];
                            var fValue = arguments[1];

                            p.x = v3fVec.x;
                            p.y = v3fVec.y;
                            p.z = v3fVec.z;
                            p.w = fValue;
                        }
                        break;
                    case 3:
                        if (akra.isFloat(arguments[0])) {
                            var fValue1 = arguments[0];

                            if (akra.isFloat(arguments[1])) {
                                var fValue2 = arguments[1];
                                var v2fVec = arguments[2];

                                p.x = fValue1;
                                p.y = fValue2;
                                p.z = v2fVec.x;
                                p.w = v2fVec.y;
                            } else {
                                var v2fVec = arguments[1];
                                var fValue2 = arguments[2];

                                p.x = fValue1;
                                p.y = v2fVec.x;
                                p.z = v2fVec.y;
                                p.w = fValue2;
                            }
                        } else {
                            var v2fVec = arguments[0];
                            var fValue1 = arguments[1];
                            var fValue2 = arguments[2];

                            p.x = v2fVec.x;
                            p.y = v2fVec.y;
                            p.z = fValue1;
                            p.w = fValue2;
                        }
                        break;
                    case 4:
                        p.x = arguments[0];
                        p.y = arguments[1];
                        p.z = arguments[2];
                        p.w = arguments[3];
                        break;
                }

                return p;
            };
            return Vec4;
        })();
        math.Vec4 = Vec4;

        pBuffer = akra.gen.array(256, Vec4);
        iElement = 0;
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
/// <reference path="../common.ts" />
/// <reference path="../logger.ts" />
/// <reference path="../idl/IMat3.ts" />
/// <reference path="math.ts" />
/// <reference path="../gen/generate.ts" />
/// <reference path="matrixIndecies.ts" />
var akra;
(function (akra) {
    (function (math) {
        /** Imports need for increase performance in Debug build */
        //import __a11 = math.__a11;
        //import __a12 = math.__a12;
        //import __a13 = math.__a13;
        //import __a21 = math.__a21;
        //import __a22 = math.__a22;
        //import __a23 = math.__a23;
        //import __a31 = math.__a31;
        //import __a32 = math.__a32;
        //import __a33 = math.__a33;
        //import __11 = math.__11;
        //import __12 = math.__12;
        //import __13 = math.__13;
        //import __14 = math.__14;
        //import __21 = math.__21;
        //import __22 = math.__22;
        //import __23 = math.__23;
        //import __24 = math.__24;
        //import __31 = math.__31;
        //import __32 = math.__32;
        //import __33 = math.__33;
        //import __34 = math.__34;
        //import __41 = math.__41;
        //import __42 = math.__42;
        //import __43 = math.__43;
        //import __44 = math.__44;
        var pBuffer;
        var iElement;

        var Mat3 = (function () {
            function Mat3() {
                var nArgumentsLength = arguments.length;

                this.data = new Float32Array(9);

                switch (nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 3:
                        this.set(arguments[0], arguments[1], arguments[2]);
                        break;
                    case 9:
                        this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]);
                        break;
                    default:
                        break;
                }
            }
            Mat3.prototype.set = function () {
                var pData = this.data;

                //без аргументов инициализируется нулями
                var n = arguments.length;
                if (n == 0) {
                    pData[math.__a11] = pData[math.__a12] = pData[math.__a13] = 0;
                    pData[math.__a21] = pData[math.__a22] = pData[math.__a23] = 0;
                    pData[math.__a31] = pData[math.__a32] = pData[math.__a33] = 0;
                }
                if (n == 1) {
                    if (akra.isFloat(arguments[0])) {
                        var nValue = arguments[0];

                        pData[math.__a11] = nValue;
                        pData[math.__a12] = 0;
                        pData[math.__a13] = 0;

                        pData[math.__a21] = 0;
                        pData[math.__a22] = nValue;
                        pData[math.__a23] = 0;

                        pData[math.__a31] = 0;
                        pData[math.__a32] = 0;
                        pData[math.__a33] = nValue;
                    } else if (akra.isDef(arguments[0].data)) {
                        var pElements = arguments[0].data;

                        if (pElements.length === 9) {
                            //Mat3
                            pData[math.__a11] = pElements[math.__a11];
                            pData[math.__a12] = pElements[math.__a12];
                            pData[math.__a13] = pElements[math.__a13];

                            pData[math.__a21] = pElements[math.__a21];
                            pData[math.__a22] = pElements[math.__a22];
                            pData[math.__a23] = pElements[math.__a23];

                            pData[math.__a31] = pElements[math.__a31];
                            pData[math.__a32] = pElements[math.__a32];
                            pData[math.__a33] = pElements[math.__a33];
                        } else {
                            //Mat4
                            pData[math.__a11] = pElements[math.__11];
                            pData[math.__a12] = pElements[math.__12];
                            pData[math.__a13] = pElements[math.__13];

                            pData[math.__a21] = pElements[math.__21];
                            pData[math.__a22] = pElements[math.__22];
                            pData[math.__a23] = pElements[math.__23];

                            pData[math.__a31] = pElements[math.__31];
                            pData[math.__a32] = pElements[math.__32];
                            pData[math.__a33] = pElements[math.__33];
                        }
                    } else if (arguments[0] instanceof math.Vec3) {
                        var v3fVec = arguments[0];

                        //диагональ
                        pData[math.__a11] = v3fVec.x;
                        pData[math.__a12] = 0;
                        pData[math.__a13] = 0;

                        pData[math.__a21] = 0;
                        pData[math.__a22] = v3fVec.y;
                        pData[math.__a23] = 0;

                        pData[math.__a31] = 0;
                        pData[math.__a32] = 0;
                        pData[math.__a33] = v3fVec.z;
                    } else {
                        var pArray = arguments[0];

                        if (pElements.length == 3) {
                            //ложим диагональ
                            pData[math.__a11] = pArray[0];
                            pData[math.__a12] = 0;
                            pData[math.__a13] = 0;

                            pData[math.__a21] = 0;
                            pData[math.__a22] = pArray[1];
                            pData[math.__a23] = 0;

                            pData[math.__a31] = 0;
                            pData[math.__a32] = 0;
                            pData[math.__a33] = pArray[2];
                        } else {
                            pData[math.__a11] = pArray[math.__a11];
                            pData[math.__a12] = pArray[math.__a12];
                            pData[math.__a13] = pArray[math.__a13];

                            pData[math.__a21] = pArray[math.__a21];
                            pData[math.__a22] = pArray[math.__a22];
                            pData[math.__a23] = pArray[math.__a23];

                            pData[math.__a31] = pArray[math.__a31];
                            pData[math.__a32] = pArray[math.__a32];
                            pData[math.__a33] = pArray[math.__a33];
                        }
                    }
                } else if (n == 3) {
                    if (akra.isFloat(arguments[0])) {
                        //выставляем диагональ
                        pData[math.__a11] = arguments[0];
                        pData[math.__a12] = 0;
                        pData[math.__a13] = 0;

                        pData[math.__a21] = 0;
                        pData[math.__a22] = arguments[1];
                        pData[math.__a23] = 0;

                        pData[math.__a31] = 0;
                        pData[math.__a32] = 0;
                        pData[math.__a33] = arguments[2];
                    } else {
                        if (arguments[0] instanceof math.Vec3) {
                            var v3fVec1 = arguments[0];
                            var v3fVec2 = arguments[1];
                            var v3fVec3 = arguments[2];

                            //ложим по столбцам
                            pData[math.__a11] = v3fVec1.x;
                            pData[math.__a12] = v3fVec2.x;
                            pData[math.__a13] = v3fVec3.x;

                            pData[math.__a21] = v3fVec1.y;
                            pData[math.__a22] = v3fVec2.y;
                            pData[math.__a23] = v3fVec3.y;

                            pData[math.__a31] = v3fVec1.z;
                            pData[math.__a32] = v3fVec2.z;
                            pData[math.__a33] = v3fVec3.z;
                        } else {
                            var pVec1 = arguments[0];
                            var pVec2 = arguments[1];
                            var pVec3 = arguments[2];

                            //ложим по столбцам
                            pData[math.__a11] = pVec1[0];
                            pData[math.__a12] = pVec2[0];
                            pData[math.__a13] = pVec3[0];

                            pData[math.__a21] = pVec1[1];
                            pData[math.__a22] = pVec2[1];
                            pData[math.__a23] = pVec3[1];

                            pData[math.__a31] = pVec1[2];
                            pData[math.__a32] = pVec2[2];
                            pData[math.__a33] = pVec3[2];
                        }
                    }
                } else if (n == 9) {
                    //просто числа
                    pData[math.__a11] = arguments[math.__a11];
                    pData[math.__a12] = arguments[math.__a12];
                    pData[math.__a13] = arguments[math.__a13];

                    pData[math.__a21] = arguments[math.__a21];
                    pData[math.__a22] = arguments[math.__a22];
                    pData[math.__a23] = arguments[math.__a23];

                    pData[math.__a31] = arguments[math.__a31];
                    pData[math.__a32] = arguments[math.__a32];
                    pData[math.__a33] = arguments[math.__a33];
                }

                return this;
            };

            Mat3.prototype.identity = function () {
                var pData = this.data;

                pData[math.__a11] = 1.;
                pData[math.__a12] = 0.;
                pData[math.__a13] = 0.;

                pData[math.__a21] = 0.;
                pData[math.__a22] = 1.;
                pData[math.__a23] = 0.;

                pData[math.__a31] = 0.;
                pData[math.__a32] = 0.;
                pData[math.__a33] = 1.;

                return this;
            };

            Mat3.prototype.add = function (m3fMat, m3fDestination) {
                if (!akra.isDef(m3fDestination)) {
                    m3fDestination = this;
                }

                var pData1 = this.data;
                var pData2 = m3fMat.data;
                var pDataDestination = m3fDestination.data;

                pDataDestination[math.__a11] = pData1[math.__a11] + pData2[math.__a11];
                pDataDestination[math.__a12] = pData1[math.__a12] + pData2[math.__a12];
                pDataDestination[math.__a13] = pData1[math.__a13] + pData2[math.__a13];

                pDataDestination[math.__a21] = pData1[math.__a21] + pData2[math.__a21];
                pDataDestination[math.__a22] = pData1[math.__a22] + pData2[math.__a22];
                pDataDestination[math.__a23] = pData1[math.__a23] + pData2[math.__a23];

                pDataDestination[math.__a31] = pData1[math.__a31] + pData2[math.__a31];
                pDataDestination[math.__a32] = pData1[math.__a32] + pData2[math.__a32];
                pDataDestination[math.__a33] = pData1[math.__a33] + pData2[math.__a33];

                return m3fDestination;
            };

            Mat3.prototype.subtract = function (m3fMat, m3fDestination) {
                if (!akra.isDef(m3fDestination)) {
                    m3fDestination = this;
                }

                var pData1 = this.data;
                var pData2 = m3fMat.data;
                var pDataDestination = m3fDestination.data;

                pDataDestination[math.__a11] = pData1[math.__a11] - pData2[math.__a11];
                pDataDestination[math.__a12] = pData1[math.__a12] - pData2[math.__a12];
                pDataDestination[math.__a13] = pData1[math.__a13] - pData2[math.__a13];

                pDataDestination[math.__a21] = pData1[math.__a21] - pData2[math.__a21];
                pDataDestination[math.__a22] = pData1[math.__a22] - pData2[math.__a22];
                pDataDestination[math.__a23] = pData1[math.__a23] - pData2[math.__a23];

                pDataDestination[math.__a31] = pData1[math.__a31] - pData2[math.__a31];
                pDataDestination[math.__a32] = pData1[math.__a32] - pData2[math.__a32];
                pDataDestination[math.__a33] = pData1[math.__a33] - pData2[math.__a33];

                return m3fDestination;
            };

            Mat3.prototype.multiply = function (m3fMat, m3fDestination) {
                var pData1 = this.data;
                var pData2 = m3fMat.data;

                if (!akra.isDef(m3fDestination)) {
                    m3fDestination = this;
                }
                var pDataDestination = m3fDestination.data;

                // Cache the matrix values (makes for huge speed increases!)
                var a11 = pData1[math.__a11], a12 = pData1[math.__a12], a13 = pData1[math.__a13];
                var a21 = pData1[math.__a21], a22 = pData1[math.__a22], a23 = pData1[math.__a23];
                var a31 = pData1[math.__a31], a32 = pData1[math.__a32], a33 = pData1[math.__a33];

                var b11 = pData2[math.__a11], b12 = pData2[math.__a12], b13 = pData2[math.__a13];
                var b21 = pData2[math.__a21], b22 = pData2[math.__a22], b23 = pData2[math.__a23];
                var b31 = pData2[math.__a31], b32 = pData2[math.__a32], b33 = pData2[math.__a33];

                pDataDestination[math.__a11] = a11 * b11 + a12 * b21 + a13 * b31;
                pDataDestination[math.__a12] = a11 * b12 + a12 * b22 + a13 * b32;
                pDataDestination[math.__a13] = a11 * b13 + a12 * b23 + a13 * b33;

                pDataDestination[math.__a21] = a21 * b11 + a22 * b21 + a23 * b31;
                pDataDestination[math.__a22] = a21 * b12 + a22 * b22 + a23 * b32;
                pDataDestination[math.__a23] = a21 * b13 + a22 * b23 + a23 * b33;

                pDataDestination[math.__a31] = a31 * b11 + a32 * b21 + a33 * b31;
                pDataDestination[math.__a32] = a31 * b12 + a32 * b22 + a33 * b32;
                pDataDestination[math.__a33] = a31 * b13 + a32 * b23 + a33 * b33;

                return m3fDestination;
            };

            Mat3.prototype.multiplyVec3 = function (v3fVec, v3fDestination) {
                var pData = this.data;

                if (!akra.isDef(v3fDestination)) {
                    v3fDestination = v3fVec;
                }

                var x = v3fVec.x, y = v3fVec.y, z = v3fVec.z;

                v3fDestination.x = pData[math.__a11] * x + pData[math.__a12] * y + pData[math.__a13] * z;
                v3fDestination.y = pData[math.__a21] * x + pData[math.__a22] * y + pData[math.__a23] * z;
                v3fDestination.z = pData[math.__a31] * x + pData[math.__a32] * y + pData[math.__a33] * z;

                return v3fDestination;
            };

            Mat3.prototype.transpose = function (m3fDestination) {
                var pData = this.data;
                if (!akra.isDef(m3fDestination)) {
                    //быстрее будет явно обработать оба случая
                    var a12 = pData[math.__a12], a13 = pData[math.__a13], a23 = pData[math.__a23];

                    pData[math.__a12] = pData[math.__a21];
                    pData[math.__a13] = pData[math.__a31];

                    pData[math.__a21] = a12;
                    pData[math.__a23] = pData[math.__a32];

                    pData[math.__a31] = a13;
                    pData[math.__a32] = a23;

                    return this;
                }

                var pDataDestination = m3fDestination.data;

                pDataDestination[math.__a11] = pData[math.__a11];
                pDataDestination[math.__a12] = pData[math.__a21];
                pDataDestination[math.__a13] = pData[math.__a31];

                pDataDestination[math.__a21] = pData[math.__a12];
                pDataDestination[math.__a22] = pData[math.__a22];
                pDataDestination[math.__a23] = pData[math.__a32];

                pDataDestination[math.__a31] = pData[math.__a13];
                pDataDestination[math.__a32] = pData[math.__a23];
                pDataDestination[math.__a33] = pData[math.__a33];

                return m3fDestination;
            };

            Mat3.prototype.determinant = function () {
                var pData = this.data;

                var a11 = pData[math.__a11], a12 = pData[math.__a12], a13 = pData[math.__a13];
                var a21 = pData[math.__a21], a22 = pData[math.__a22], a23 = pData[math.__a23];
                var a31 = pData[math.__a31], a32 = pData[math.__a32], a33 = pData[math.__a33];

                return a11 * (a22 * a33 - a23 * a32) - a12 * (a21 * a33 - a23 * a31) + a13 * (a21 * a32 - a22 * a31);
            };

            Mat3.prototype.inverse = function (m3fDestination) {
                if (!akra.isDef(m3fDestination)) {
                    m3fDestination = this;
                }

                var pData = this.data;
                var pDataDestination = m3fDestination.data;

                var a11 = pData[math.__a11], a12 = pData[math.__a12], a13 = pData[math.__a13];
                var a21 = pData[math.__a21], a22 = pData[math.__a22], a23 = pData[math.__a23];
                var a31 = pData[math.__a31], a32 = pData[math.__a32], a33 = pData[math.__a33];

                var A11 = a22 * a33 - a23 * a32;
                var A12 = a21 * a33 - a23 * a31;
                var A13 = a21 * a32 - a22 * a31;

                var A21 = a12 * a33 - a13 * a32;
                var A22 = a11 * a33 - a13 * a31;
                var A23 = a11 * a32 - a12 * a31;

                var A31 = a12 * a23 - a13 * a22;
                var A32 = a11 * a23 - a13 * a21;
                var A33 = a11 * a22 - a12 * a21;

                var fDeterminant = a11 * A11 - a12 * A12 + a13 * A13;

                if (fDeterminant == 0.) {
                    akra.logger.error("обращение матрицы с нулевым детеминантом:\n", this.toString());

                    return m3fDestination.set(1.);
                    //чтоб все не навернулось
                }

                var fInverseDeterminant = 1. / fDeterminant;

                pDataDestination[math.__a11] = A11 * fInverseDeterminant;
                pDataDestination[math.__a12] = -A21 * fInverseDeterminant;
                pDataDestination[math.__a13] = A31 * fInverseDeterminant;

                pDataDestination[math.__a21] = -A12 * fInverseDeterminant;
                pDataDestination[math.__a22] = A22 * fInverseDeterminant;
                pDataDestination[math.__a23] = -A32 * fInverseDeterminant;

                pDataDestination[math.__a31] = A13 * fInverseDeterminant;
                pDataDestination[math.__a32] = -A23 * fInverseDeterminant;
                pDataDestination[math.__a33] = A33 * fInverseDeterminant;

                return m3fDestination;
            };

            Mat3.prototype.isEqual = function (m3fMat, fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                var pData1 = this.data;
                var pData2 = m3fMat.data;

                if (fEps == 0) {
                    if (pData1[math.__a11] != pData2[math.__a11] || pData1[math.__a12] != pData2[math.__a12] || pData1[math.__a13] != pData2[math.__a13] || pData1[math.__a21] != pData2[math.__a21] || pData1[math.__a22] != pData2[math.__a22] || pData1[math.__a23] != pData2[math.__a23] || pData1[math.__a31] != pData2[math.__a31] || pData1[math.__a32] != pData2[math.__a32] || pData1[math.__a33] != pData2[math.__a33]) {
                        return false;
                    }
                } else {
                    if (Math.abs(pData1[math.__a11] - pData2[math.__a11]) > fEps || Math.abs(pData1[math.__a12] - pData2[math.__a12]) > fEps || Math.abs(pData1[math.__a13] - pData2[math.__a13]) > fEps || Math.abs(pData1[math.__a21] - pData2[math.__a21]) > fEps || Math.abs(pData1[math.__a22] - pData2[math.__a22]) > fEps || Math.abs(pData1[math.__a23] - pData2[math.__a23]) > fEps || Math.abs(pData1[math.__a31] - pData2[math.__a31]) > fEps || Math.abs(pData1[math.__a32] - pData2[math.__a32]) > fEps || Math.abs(pData1[math.__a33] - pData2[math.__a33]) > fEps) {
                        return false;
                    }
                }
                return true;
            };

            Mat3.prototype.isDiagonal = function (fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                var pData = this.data;

                if (fEps == 0) {
                    if (pData[math.__a12] != 0 || pData[math.__a13] != 0 || pData[math.__a21] != 0 || pData[math.__a23] != 0 || pData[math.__a31] != 0 || pData[math.__a32] != 0) {
                        return false;
                    }
                } else {
                    if (Math.abs(pData[math.__a12]) > fEps || Math.abs(pData[math.__a13]) > fEps || Math.abs(pData[math.__a21]) > fEps || Math.abs(pData[math.__a23]) > fEps || Math.abs(pData[math.__a31]) > fEps || Math.abs(pData[math.__a32]) > fEps) {
                        return false;
                    }
                }

                return true;
            };

            Mat3.prototype.toMat4 = function (m4fDestination) {
                if (!akra.isDef(m4fDestination)) {
                    m4fDestination = new math.Mat4();
                }

                var pData = this.data;
                var pDataDestination = m4fDestination.data;

                pDataDestination[math.__11] = pData[math.__a11];
                pDataDestination[math.__12] = pData[math.__a12];
                pDataDestination[math.__13] = pData[math.__a13];
                pDataDestination[math.__14] = 0;

                pDataDestination[math.__21] = pData[math.__a21];
                pDataDestination[math.__22] = pData[math.__a22];
                pDataDestination[math.__23] = pData[math.__a23];
                pDataDestination[math.__24] = 0;

                pDataDestination[math.__31] = pData[math.__a31];
                pDataDestination[math.__32] = pData[math.__a32];
                pDataDestination[math.__33] = pData[math.__a33];
                pDataDestination[math.__34] = 0;

                pDataDestination[math.__41] = 0;
                pDataDestination[math.__42] = 0;
                pDataDestination[math.__43] = 0;
                pDataDestination[math.__44] = 1;

                return m4fDestination;
            };

            Mat3.prototype.toQuat4 = function (q4fDestination) {
                if (!akra.isDef(q4fDestination)) {
                    q4fDestination = new math.Quat4();
                }

                var pData = this.data;

                var a11 = pData[math.__a11], a12 = pData[math.__a12], a13 = pData[math.__a13];
                var a21 = pData[math.__a21], a22 = pData[math.__a22], a23 = pData[math.__a23];
                var a31 = pData[math.__a31], a32 = pData[math.__a32], a33 = pData[math.__a33];

                var x2 = ((a11 - a22 - a33) + 1) / 4;
                var y2 = ((a22 - a11 - a33) + 1) / 4;
                var z2 = ((a33 - a11 - a22) + 1) / 4;
                var w2 = ((a11 + a22 + a33) + 1) / 4;

                var fMax = Math.max(x2, Math.max(y2, Math.max(z2, w2)));

                if (fMax == x2) {
                    //максимальная компонента берется положительной
                    var x = Math.sqrt(x2);

                    q4fDestination.x = x;
                    q4fDestination.y = (a21 + a12) / 4 / x;
                    q4fDestination.z = (a31 + a13) / 4 / x;
                    q4fDestination.w = (a32 - a23) / 4 / x;
                } else if (fMax == y2) {
                    //максимальная компонента берется положительной
                    var y = Math.sqrt(y2);

                    q4fDestination.x = (a21 + a12) / 4 / y;
                    q4fDestination.y = y;
                    q4fDestination.z = (a32 + a23) / 4 / y;
                    q4fDestination.w = (a13 - a31) / 4 / y;
                } else if (fMax == z2) {
                    //максимальная компонента берется положительной
                    var z = Math.sqrt(z2);

                    q4fDestination.x = (a31 + a13) / 4 / z;
                    q4fDestination.y = (a32 + a23) / 4 / z;
                    q4fDestination.z = z;
                    q4fDestination.w = (a21 - a12) / 4 / z;
                } else {
                    //максимальная компонента берется положительной
                    var w = Math.sqrt(w2);

                    q4fDestination.x = (a32 - a23) / 4 / w;
                    q4fDestination.y = (a13 - a31) / 4 / w;
                    q4fDestination.z = (a21 - a12) / 4 / w;
                    q4fDestination.w = w;
                }

                return q4fDestination;
            };

            Mat3.prototype.toString = function () {
                var pData = this.data;
                return '[' + pData[math.__a11] + ', ' + pData[math.__a12] + ', ' + pData[math.__a13] + ',\n' + +pData[math.__a21] + ', ' + pData[math.__a22] + ', ' + pData[math.__a23] + ',\n' + +pData[math.__a31] + ', ' + pData[math.__a32] + ', ' + pData[math.__a33] + ']';
            };

            Mat3.prototype.decompose = function (q4fRotation, v3fScale) {
                //изначально предполагаем, что порядок умножения был rot * scale
                var m3fRotScale = this;
                var m3fRotScaleTransposed = this.transpose(Mat3.temp());
                var isRotScale = true;

                //понадобятся если порядок умножения был другим
                var m3fScaleRot = null;
                var m3fScaleRotTransposed;

                //было отражение или нет
                var scaleSign = (m3fRotScale.determinant() >= 0.) ? 1 : -1;

                var m3fResult = Mat3.temp();

                //first variant rot * scale
                // (rot * scale)T * (rot * scale) =
                // scaleT * rotT * rot * scale = scaleT *rot^-1 * rot * scale =
                // scaleT * scale
                m3fRotScaleTransposed.multiply(m3fRotScale, m3fResult);
                if (!m3fResult.isDiagonal(1e-4)) {
                    //предположение было неверным
                    isRotScale = false;

                    //просто переобозначения чтобы не было путаницы
                    m3fScaleRot = m3fRotScale;
                    m3fScaleRotTransposed = m3fRotScaleTransposed;

                    //second variant scale * rot
                    // (scale * rot) * (scale * rot)T =
                    // scale * rot * rotT * scaleT = scale *rot * rot^-1 * scaleT =
                    // scale * scaleT
                    m3fScaleRot.multiply(m3fScaleRotTransposed, m3fResult);
                }

                var pResultData = m3fResult.data;

                var x = math.sqrt(pResultData[math.__a11]);
                var y = math.sqrt(pResultData[math.__a22]) * scaleSign;
                var z = math.sqrt(pResultData[math.__a33]);

                v3fScale.x = x;
                v3fScale.y = y;
                v3fScale.z = z;

                var m3fInverseScale = Mat3.temp(1. / x, 1. / y, 1. / z);

                if (isRotScale) {
                    m3fRotScale.multiply(m3fInverseScale, Mat3.temp()).toQuat4(q4fRotation);
                    return true;
                } else {
                    m3fInverseScale.multiply(m3fScaleRot, Mat3.temp()).toQuat4(q4fRotation);

                    //debug_assert(false, "порядок умножения scale rot в данный момент не поддерживается");
                    return false;
                }
            };

            Mat3.prototype.row = function (iRow, v3fDestination) {
                if (!akra.isDef(v3fDestination)) {
                    v3fDestination = new math.Vec3();
                }

                var pData = this.data;

                switch (iRow) {
                    case 1:
                        v3fDestination.x = pData[math.__a11];
                        v3fDestination.y = pData[math.__a12];
                        v3fDestination.z = pData[math.__a13];
                        break;
                    case 2:
                        v3fDestination.x = pData[math.__a21];
                        v3fDestination.y = pData[math.__a22];
                        v3fDestination.z = pData[math.__a23];
                        break;
                    case 3:
                        v3fDestination.x = pData[math.__a31];
                        v3fDestination.y = pData[math.__a32];
                        v3fDestination.z = pData[math.__a33];
                        break;
                }

                return v3fDestination;
            };

            Mat3.prototype.column = function (iColumn, v3fDestination) {
                if (!akra.isDef(v3fDestination)) {
                    v3fDestination = new math.Vec3();
                }

                var pData = this.data;

                switch (iColumn) {
                    case 1:
                        v3fDestination.x = pData[math.__a11];
                        v3fDestination.y = pData[math.__a21];
                        v3fDestination.z = pData[math.__a31];
                        break;
                    case 2:
                        v3fDestination.x = pData[math.__a12];
                        v3fDestination.y = pData[math.__a22];
                        v3fDestination.z = pData[math.__a32];
                        break;
                    case 3:
                        v3fDestination.x = pData[math.__a13];
                        v3fDestination.y = pData[math.__a23];
                        v3fDestination.z = pData[math.__a33];
                        break;
                }

                return v3fDestination;
            };

            Mat3.fromYawPitchRoll = function (fYaw, fPitch, fRoll, m3fDestination) {
                if (arguments.length <= 2) {
                    //Vec3 + m3fDestination
                    var v3fVec = arguments[0];

                    fYaw = v3fVec.x;
                    fPitch = v3fVec.y;
                    fRoll = v3fVec.z;

                    m3fDestination = arguments[1];
                }

                if (!akra.isDef(m3fDestination)) {
                    m3fDestination = new Mat3();
                }

                var pDataDestination = m3fDestination.data;

                var fSin1 = Math.sin(fYaw);
                var fSin2 = Math.sin(fPitch);
                var fSin3 = Math.sin(fRoll);

                var fCos1 = Math.cos(fYaw);
                var fCos2 = Math.cos(fPitch);
                var fCos3 = Math.cos(fRoll);

                pDataDestination[math.__a11] = fCos1 * fCos3 + fSin1 * fSin2 * fSin3;
                pDataDestination[math.__a12] = fCos3 * fSin1 * fSin2 - fCos1 * fSin3;
                pDataDestination[math.__a13] = fCos2 * fSin1;

                pDataDestination[math.__a21] = fCos2 * fSin3;
                pDataDestination[math.__a22] = fCos2 * fCos3;
                pDataDestination[math.__a23] = -fSin2;

                pDataDestination[math.__a31] = fCos1 * fSin2 * fSin3 - fCos3 * fSin1;
                pDataDestination[math.__a32] = fSin1 * fSin3 + fCos1 * fCos3 * fSin2;
                pDataDestination[math.__a33] = fCos1 * fCos2;

                return m3fDestination;
            };

            Mat3.fromXYZ = function (fX, fY, fZ, m3fDestination) {
                if (arguments.length <= 2) {
                    //Vec3 + m3fDestination
                    var v3fVec = arguments[0];
                    return Mat3.fromYawPitchRoll(v3fVec.y, v3fVec.x, v3fVec.z, arguments[1]);
                } else {
                    //fX fY fZ m3fDestination
                    //var fX: float = arguments[0];
                    //var fY: float = arguments[1];
                    //var fZ: float = arguments[2];
                    return Mat3.fromYawPitchRoll(fY, fX, fZ, arguments[3]);
                }
            };

            Mat3.temp = function () {
                iElement = (iElement === pBuffer.length - 1 ? 0 : iElement);
                var p = pBuffer[iElement++];
                var n = arguments.length;
                switch (n) {
                    case 1:
                        p.set(arguments[0]);
                        break;
                    case 3:
                        p.set(arguments[0], arguments[1], arguments[2]);
                        break;
                    case 9:
                        p.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]);
                        break;
                    default:
                        p.set();
                        break;
                }

                return p;
            };
            return Mat3;
        })();
        math.Mat3 = Mat3;

        pBuffer = akra.gen.array(256, Mat3);
        iElement = 0;
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
/// <reference path="../common.ts" />
/// <reference path="../logger.ts" />
/// <reference path="../idl/IMat4.ts" />
/// <reference path="math.ts" />
/// <reference path="../gen/generate.ts" />
/// <reference path="matrixIndecies.ts" />
var akra;
(function (akra) {
    (function (math) {
        /** Imports need for increase performance in Debug build */
        //import __11 = math.__11;
        //import __12 = math.__12;
        //import __13 = math.__13;
        //import __14 = math.__14;
        //import __21 = math.__21;
        //import __22 = math.__22;
        //import __23 = math.__23;
        //import __24 = math.__24;
        //import __31 = math.__31;
        //import __32 = math.__32;
        //import __33 = math.__33;
        //import __34 = math.__34;
        //import __41 = math.__41;
        //import __42 = math.__42;
        //import __43 = math.__43;
        //import __44 = math.__44;
        //import __a11 = math.__a11;
        //import __a12 = math.__a12;
        //import __a13 = math.__a13;
        //import __a21 = math.__a21;
        //import __a22 = math.__a22;
        //import __a23 = math.__a23;
        //import __a31 = math.__a31;
        //import __a32 = math.__a32;
        //import __a33 = math.__a33;
        var pBuffer;
        var iElement;

        var Mat4 = (function () {
            function Mat4() {
                var n = arguments.length;

                if (n === 2) {
                    if (akra.isBoolean(arguments[1])) {
                        if (arguments[1]) {
                            this.data = arguments[0];
                        } else {
                            this.data = new Float32Array(16);
                            this.set(arguments[0]);
                        }
                    } else {
                        this.data = new Float32Array(16);
                        this.set(arguments[0], arguments[1]);
                    }
                } else {
                    this.data = new Float32Array(16);

                    switch (n) {
                        case 1:
                            if (arguments[0] instanceof math.Mat3) {
                                this.set(arguments[0], math.Vec3.temp(0.));
                            } else {
                                this.set(arguments[0]);
                            }
                            break;
                        case 4:
                            this.set(arguments[0], arguments[1], arguments[2], arguments[3]);
                            break;
                        case 16:
                            this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8], arguments[9], arguments[10], arguments[11], arguments[12], arguments[13], arguments[14], arguments[15]);
                            break;
                        default:
                            break;
                    }
                }
            }
            Mat4.prototype.set = function () {
                var nArgumentsLength = arguments.length;
                var pData = this.data;

                if (nArgumentsLength === 0) {
                    pData[math.__11] = pData[math.__12] = pData[math.__13] = pData[math.__14] = pData[math.__21] = pData[math.__22] = pData[math.__23] = pData[math.__24] = pData[math.__31] = pData[math.__32] = pData[math.__33] = pData[math.__34] = pData[math.__41] = pData[math.__42] = pData[math.__43] = pData[math.__44] = 0.;

                    return this;
                }

                if (nArgumentsLength === 1) {
                    if (akra.isFloat(arguments[0])) {
                        var fValue = arguments[0];

                        pData[math.__11] = fValue;
                        pData[math.__12] = 0.;
                        pData[math.__13] = 0.;
                        pData[math.__14] = 0.;

                        pData[math.__21] = 0.;
                        pData[math.__22] = fValue;
                        pData[math.__23] = 0.;
                        pData[math.__24] = 0.;

                        pData[math.__31] = 0.;
                        pData[math.__32] = 0.;
                        pData[math.__33] = fValue;
                        pData[math.__34] = 0.;

                        pData[math.__41] = 0.;
                        pData[math.__42] = 0.;
                        pData[math.__43] = 0.;
                        pData[math.__44] = fValue;
                    } else if (arguments[0] instanceof math.Vec4) {
                        var v4fVec = arguments[0];

                        pData[math.__11] = v4fVec.x;
                        pData[math.__12] = 0.;
                        pData[math.__13] = 0.;
                        pData[math.__14] = 0.;

                        pData[math.__21] = 0.;
                        pData[math.__22] = v4fVec.y;
                        pData[math.__23] = 0.;
                        pData[math.__24] = 0.;

                        pData[math.__31] = 0.;
                        pData[math.__32] = 0.;
                        pData[math.__33] = v4fVec.z;
                        pData[math.__34] = 0.;

                        pData[math.__41] = 0.;
                        pData[math.__42] = 0.;
                        pData[math.__43] = 0.;
                        pData[math.__44] = v4fVec.w;
                    } else if (akra.isDef(arguments[0].data)) {
                        var pMatrixData = arguments[0].data;
                        if (pMatrixData.length == 16) {
                            //Mat4
                            pData.set(pMatrixData);
                        } else {
                            //Mat3
                            pData[math.__11] = pMatrixData[math.__a11];
                            pData[math.__12] = pMatrixData[math.__a12];
                            pData[math.__13] = pMatrixData[math.__a13];

                            pData[math.__21] = pMatrixData[math.__a21];
                            pData[math.__22] = pMatrixData[math.__a22];
                            pData[math.__23] = pMatrixData[math.__a23];

                            pData[math.__31] = pMatrixData[math.__a31];
                            pData[math.__32] = pMatrixData[math.__a32];
                            pData[math.__33] = pMatrixData[math.__a33];

                            pData[math.__41] = 0.;
                            pData[math.__42] = 0.;
                            pData[math.__43] = 0.;
                            pData[math.__44] = 1.;
                        }
                    } else {
                        //array
                        var pArray = arguments[0];

                        if (pArray.length === 4) {
                            pData[math.__11] = pArray[0];
                            pData[math.__12] = 0.;
                            pData[math.__13] = 0.;
                            pData[math.__14] = 0.;

                            pData[math.__21] = 0.;
                            pData[math.__22] = pArray[1];
                            pData[math.__23] = 0.;
                            pData[math.__24] = 0.;

                            pData[math.__31] = 0.;
                            pData[math.__32] = 0.;
                            pData[math.__33] = pArray[2];
                            pData[math.__34] = 0.;

                            pData[math.__41] = 0.;
                            pData[math.__42] = 0.;
                            pData[math.__43] = 0.;
                            pData[math.__44] = pArray[3];
                        } else {
                            //length == 16
                            pData[math.__11] = pArray[math.__11];
                            pData[math.__12] = pArray[math.__12];
                            pData[math.__13] = pArray[math.__13];
                            pData[math.__14] = pArray[math.__14];

                            pData[math.__21] = pArray[math.__21];
                            pData[math.__22] = pArray[math.__22];
                            pData[math.__23] = pArray[math.__23];
                            pData[math.__24] = pArray[math.__24];

                            pData[math.__31] = pArray[math.__31];
                            pData[math.__32] = pArray[math.__32];
                            pData[math.__33] = pArray[math.__33];
                            pData[math.__34] = pArray[math.__34];

                            pData[math.__41] = pArray[math.__41];
                            pData[math.__42] = pArray[math.__42];
                            pData[math.__43] = pArray[math.__43];
                            pData[math.__44] = pArray[math.__44];
                        }
                    }
                } else if (nArgumentsLength == 2) {
                    var pMatrixData = arguments[0];
                    var v3fTranslation = arguments[1];

                    pData[math.__11] = pMatrixData[math.__a11];
                    pData[math.__12] = pMatrixData[math.__a12];
                    pData[math.__13] = pMatrixData[math.__a13];
                    pData[math.__14] = v3fTranslation.x;

                    pData[math.__21] = pMatrixData[math.__a21];
                    pData[math.__22] = pMatrixData[math.__a22];
                    pData[math.__23] = pMatrixData[math.__a23];
                    pData[math.__24] = v3fTranslation.y;

                    pData[math.__31] = pMatrixData[math.__a31];
                    pData[math.__32] = pMatrixData[math.__a32];
                    pData[math.__33] = pMatrixData[math.__a33];
                    pData[math.__34] = v3fTranslation.z;

                    pData[math.__41] = 0.;
                    pData[math.__42] = 0.;
                    pData[math.__43] = 0.;
                    pData[math.__44] = 1.;
                } else if (nArgumentsLength == 4) {
                    if (akra.isFloat(arguments[0])) {
                        pData[math.__11] = arguments[0];
                        pData[math.__12] = 0;
                        pData[math.__13] = 0;
                        pData[math.__14] = 0;

                        pData[math.__21] = 0;
                        pData[math.__22] = arguments[1];
                        pData[math.__23] = 0;
                        pData[math.__24] = 0;

                        pData[math.__31] = 0;
                        pData[math.__32] = 0;
                        pData[math.__33] = arguments[2];
                        pData[math.__34] = 0;

                        pData[math.__41] = 0;
                        pData[math.__42] = 0;
                        pData[math.__43] = 0;
                        pData[math.__44] = arguments[3];
                    } else if (arguments[0] instanceof math.Vec4) {
                        var v4fColumn1 = arguments[0];
                        var v4fColumn2 = arguments[1];
                        var v4fColumn3 = arguments[2];
                        var v4fColumn4 = arguments[3];

                        pData[math.__11] = v4fColumn1.x;
                        pData[math.__12] = v4fColumn2.x;
                        pData[math.__13] = v4fColumn3.x;
                        pData[math.__14] = v4fColumn4.x;

                        pData[math.__21] = v4fColumn1.y;
                        pData[math.__22] = v4fColumn2.y;
                        pData[math.__23] = v4fColumn3.y;
                        pData[math.__24] = v4fColumn4.y;

                        pData[math.__31] = v4fColumn1.z;
                        pData[math.__32] = v4fColumn2.z;
                        pData[math.__33] = v4fColumn3.z;
                        pData[math.__34] = v4fColumn4.z;

                        pData[math.__41] = v4fColumn1.w;
                        pData[math.__42] = v4fColumn2.w;
                        pData[math.__43] = v4fColumn3.w;
                        pData[math.__44] = v4fColumn4.w;
                    } else {
                        //arrays
                        var pColumn1 = arguments[0];
                        var pColumn2 = arguments[1];
                        var pColumn3 = arguments[2];
                        var pColumn4 = arguments[3];

                        pData[math.__11] = pColumn1[0];
                        pData[math.__12] = pColumn2[0];
                        pData[math.__13] = pColumn3[0];
                        pData[math.__14] = pColumn4[0];

                        pData[math.__21] = pColumn1[1];
                        pData[math.__22] = pColumn2[1];
                        pData[math.__23] = pColumn3[1];
                        pData[math.__24] = pColumn4[1];

                        pData[math.__31] = pColumn1[2];
                        pData[math.__32] = pColumn2[2];
                        pData[math.__33] = pColumn3[2];
                        pData[math.__34] = pColumn4[2];

                        pData[math.__41] = pColumn1[3];
                        pData[math.__42] = pColumn2[3];
                        pData[math.__43] = pColumn3[3];
                        pData[math.__44] = pColumn4[3];
                    }
                } else {
                    //nArgumentsLength === 16
                    pData[math.__11] = arguments[math.__11];
                    pData[math.__12] = arguments[math.__12];
                    pData[math.__13] = arguments[math.__13];
                    pData[math.__14] = arguments[math.__14];

                    pData[math.__21] = arguments[math.__21];
                    pData[math.__22] = arguments[math.__22];
                    pData[math.__23] = arguments[math.__23];
                    pData[math.__24] = arguments[math.__24];

                    pData[math.__31] = arguments[math.__31];
                    pData[math.__32] = arguments[math.__32];
                    pData[math.__33] = arguments[math.__33];
                    pData[math.__34] = arguments[math.__34];

                    pData[math.__41] = arguments[math.__41];
                    pData[math.__42] = arguments[math.__42];
                    pData[math.__43] = arguments[math.__43];
                    pData[math.__44] = arguments[math.__44];
                }
                return this;
            };

            Mat4.prototype.identity = function () {
                var pData = this.data;

                pData[math.__11] = 1.;
                pData[math.__12] = 0.;
                pData[math.__13] = 0.;
                pData[math.__14] = 0.;

                pData[math.__21] = 0.;
                pData[math.__22] = 1.;
                pData[math.__23] = 0.;
                pData[math.__24] = 0.;

                pData[math.__31] = 0.;
                pData[math.__32] = 0.;
                pData[math.__33] = 1.;
                pData[math.__34] = 0.;

                pData[math.__41] = 0.;
                pData[math.__42] = 0.;
                pData[math.__43] = 0.;
                pData[math.__44] = 1.;

                return this;
            };

            Mat4.prototype.add = function (m4fMat, m4fDestination) {
                if (!akra.isDef(m4fDestination)) {
                    m4fDestination = this;
                }

                var pData1 = this.data;
                var pData2 = m4fMat.data;
                var pDataDestination = m4fDestination.data;

                pDataDestination[math.__11] = pData1[math.__11] + pData2[math.__11];
                pDataDestination[math.__12] = pData1[math.__12] + pData2[math.__12];
                pDataDestination[math.__13] = pData1[math.__13] + pData2[math.__13];
                pDataDestination[math.__14] = pData1[math.__14] + pData2[math.__14];

                pDataDestination[math.__21] = pData1[math.__21] + pData2[math.__21];
                pDataDestination[math.__22] = pData1[math.__22] + pData2[math.__22];
                pDataDestination[math.__23] = pData1[math.__23] + pData2[math.__23];
                pDataDestination[math.__24] = pData1[math.__24] + pData2[math.__24];

                pDataDestination[math.__31] = pData1[math.__31] + pData2[math.__31];
                pDataDestination[math.__32] = pData1[math.__32] + pData2[math.__32];
                pDataDestination[math.__33] = pData1[math.__33] + pData2[math.__33];
                pDataDestination[math.__34] = pData1[math.__34] + pData2[math.__34];

                pDataDestination[math.__41] = pData1[math.__41] + pData2[math.__41];
                pDataDestination[math.__42] = pData1[math.__42] + pData2[math.__42];
                pDataDestination[math.__43] = pData1[math.__43] + pData2[math.__43];
                pDataDestination[math.__44] = pData1[math.__44] + pData2[math.__44];

                return m4fDestination;
            };

            Mat4.prototype.subtract = function (m4fMat, m4fDestination) {
                if (!akra.isDef(m4fDestination)) {
                    m4fDestination = this;
                }

                var pData1 = this.data;
                var pData2 = m4fMat.data;
                var pDataDestination = m4fDestination.data;

                pDataDestination[math.__11] = pData1[math.__11] - pData2[math.__11];
                pDataDestination[math.__12] = pData1[math.__12] - pData2[math.__12];
                pDataDestination[math.__13] = pData1[math.__13] - pData2[math.__13];
                pDataDestination[math.__14] = pData1[math.__14] - pData2[math.__14];

                pDataDestination[math.__21] = pData1[math.__21] - pData2[math.__21];
                pDataDestination[math.__22] = pData1[math.__22] - pData2[math.__22];
                pDataDestination[math.__23] = pData1[math.__23] - pData2[math.__23];
                pDataDestination[math.__24] = pData1[math.__24] - pData2[math.__24];

                pDataDestination[math.__31] = pData1[math.__31] - pData2[math.__31];
                pDataDestination[math.__32] = pData1[math.__32] - pData2[math.__32];
                pDataDestination[math.__33] = pData1[math.__33] - pData2[math.__33];
                pDataDestination[math.__34] = pData1[math.__34] - pData2[math.__34];

                pDataDestination[math.__41] = pData1[math.__41] - pData2[math.__41];
                pDataDestination[math.__42] = pData1[math.__42] - pData2[math.__42];
                pDataDestination[math.__43] = pData1[math.__43] - pData2[math.__43];
                pDataDestination[math.__44] = pData1[math.__44] - pData2[math.__44];

                return m4fDestination;
            };

            Mat4.prototype.multiply = function (m4fMat, m4fDestination) {
                var m4fDest = akra.isDef(m4fDestination) ? m4fDestination : this;

                //if (!isDef(m4fDestination)) {
                //	m4fDestination = this;
                //}
                var pData1 = this.data;
                var pData2 = m4fMat.data;
                var pDataDestination = m4fDest.data;

                //кешируем значения матриц для ускорения
                var a11 = pData1[math.__11], a12 = pData1[math.__12], a13 = pData1[math.__13], a14 = pData1[math.__14];
                var a21 = pData1[math.__21], a22 = pData1[math.__22], a23 = pData1[math.__23], a24 = pData1[math.__24];
                var a31 = pData1[math.__31], a32 = pData1[math.__32], a33 = pData1[math.__33], a34 = pData1[math.__34];
                var a41 = pData1[math.__41], a42 = pData1[math.__42], a43 = pData1[math.__43], a44 = pData1[math.__44];

                var b11 = pData2[math.__11], b12 = pData2[math.__12], b13 = pData2[math.__13], b14 = pData2[math.__14];
                var b21 = pData2[math.__21], b22 = pData2[math.__22], b23 = pData2[math.__23], b24 = pData2[math.__24];
                var b31 = pData2[math.__31], b32 = pData2[math.__32], b33 = pData2[math.__33], b34 = pData2[math.__34];
                var b41 = pData2[math.__41], b42 = pData2[math.__42], b43 = pData2[math.__43], b44 = pData2[math.__44];

                pDataDestination[math.__11] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
                pDataDestination[math.__12] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
                pDataDestination[math.__13] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
                pDataDestination[math.__14] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

                pDataDestination[math.__21] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
                pDataDestination[math.__22] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
                pDataDestination[math.__23] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
                pDataDestination[math.__24] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

                pDataDestination[math.__31] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
                pDataDestination[math.__32] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
                pDataDestination[math.__33] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
                pDataDestination[math.__34] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

                pDataDestination[math.__41] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
                pDataDestination[math.__42] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
                pDataDestination[math.__43] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
                pDataDestination[math.__44] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

                return m4fDest;
            };

            Mat4.prototype.multiplyLeft = function (m4fMat, m4fDestination) {
                if (!akra.isDef(m4fDestination)) {
                    m4fDestination = this;
                }
                return m4fMat.multiply(this, m4fDestination);
            };

            Mat4.prototype.multiplyVec4 = function (v4fVec, v4fDestination) {
                if (!akra.isDef(v4fDestination)) {
                    v4fDestination = v4fVec;
                }

                var pData = this.data;

                var x = v4fVec.x, y = v4fVec.y, z = v4fVec.z, w = v4fVec.w;

                v4fDestination.x = pData[math.__11] * x + pData[math.__12] * y + pData[math.__13] * z + pData[math.__14] * w;
                v4fDestination.y = pData[math.__21] * x + pData[math.__22] * y + pData[math.__23] * z + pData[math.__24] * w;
                v4fDestination.z = pData[math.__31] * x + pData[math.__32] * y + pData[math.__33] * z + pData[math.__34] * w;
                v4fDestination.w = pData[math.__41] * x + pData[math.__42] * y + pData[math.__43] * z + pData[math.__44] * w;

                return v4fDestination;
            };

            /**
            * Multiply matrix by number. Per component multiply.
            */
            Mat4.prototype.multiplyNumber = function (fValue, m4fDestination) {
                if (!akra.isDef(m4fDestination)) {
                    m4fDestination = this;
                }

                var pDataDestination = m4fDestination.data;
                var pData = this.data;

                pDataDestination[math.__11] = pData[math.__11] * fValue;
                pDataDestination[math.__12] = pData[math.__12] * fValue;
                pDataDestination[math.__13] = pData[math.__13] * fValue;
                pDataDestination[math.__14] = pData[math.__14] * fValue;

                pDataDestination[math.__21] = pData[math.__21] * fValue;
                pDataDestination[math.__22] = pData[math.__22] * fValue;
                pDataDestination[math.__23] = pData[math.__23] * fValue;
                pDataDestination[math.__24] = pData[math.__24] * fValue;

                pDataDestination[math.__31] = pData[math.__31] * fValue;
                pDataDestination[math.__32] = pData[math.__32] * fValue;
                pDataDestination[math.__33] = pData[math.__33] * fValue;
                pDataDestination[math.__34] = pData[math.__34] * fValue;

                pDataDestination[math.__41] = pData[math.__41] * fValue;
                pDataDestination[math.__42] = pData[math.__42] * fValue;
                pDataDestination[math.__43] = pData[math.__43] * fValue;
                pDataDestination[math.__44] = pData[math.__44] * fValue;

                return m4fDestination;
            };

            Mat4.prototype.transpose = function (m4fDestination) {
                var pData = this.data;

                if (!akra.isDef(m4fDestination)) {
                    var a12 = pData[math.__12], a13 = pData[math.__13], a14 = pData[math.__14];
                    var a23 = pData[math.__23], a24 = pData[math.__24];
                    var a34 = pData[math.__34];

                    pData[math.__12] = pData[math.__21];
                    pData[math.__13] = pData[math.__31];
                    pData[math.__14] = pData[math.__41];

                    pData[math.__21] = a12;
                    pData[math.__23] = pData[math.__32];
                    pData[math.__24] = pData[math.__42];

                    pData[math.__31] = a13;
                    pData[math.__32] = a23;
                    pData[math.__34] = pData[math.__43];

                    pData[math.__41] = a14;
                    pData[math.__42] = a24;
                    pData[math.__43] = a34;

                    return this;
                }

                var pDataDestination = m4fDestination.data;

                pDataDestination[math.__11] = pData[math.__11];
                pDataDestination[math.__12] = pData[math.__21];
                pDataDestination[math.__13] = pData[math.__31];
                pDataDestination[math.__14] = pData[math.__41];

                pDataDestination[math.__21] = pData[math.__12];
                pDataDestination[math.__22] = pData[math.__22];
                pDataDestination[math.__23] = pData[math.__32];
                pDataDestination[math.__24] = pData[math.__42];

                pDataDestination[math.__31] = pData[math.__13];
                pDataDestination[math.__32] = pData[math.__23];
                pDataDestination[math.__33] = pData[math.__33];
                pDataDestination[math.__34] = pData[math.__43];

                pDataDestination[math.__41] = pData[math.__14];
                pDataDestination[math.__42] = pData[math.__24];
                pDataDestination[math.__43] = pData[math.__34];
                pDataDestination[math.__44] = pData[math.__44];

                return m4fDestination;
            };

            Mat4.prototype.determinant = function () {
                var pData = this.data;

                var a11 = pData[math.__11], a12 = pData[math.__12], a13 = pData[math.__13], a14 = pData[math.__14];
                var a21 = pData[math.__21], a22 = pData[math.__22], a23 = pData[math.__23], a24 = pData[math.__24];
                var a31 = pData[math.__31], a32 = pData[math.__32], a33 = pData[math.__33], a34 = pData[math.__34];
                var a41 = pData[math.__41], a42 = pData[math.__42], a43 = pData[math.__43], a44 = pData[math.__44];

                return a41 * a32 * a23 * a14 - a31 * a42 * a23 * a14 - a41 * a22 * a33 * a14 + a21 * a42 * a33 * a14 + a31 * a22 * a43 * a14 - a21 * a32 * a43 * a14 - a41 * a32 * a13 * a24 + a31 * a42 * a13 * a24 + a41 * a12 * a33 * a24 - a11 * a42 * a33 * a24 - a31 * a12 * a43 * a24 + a11 * a32 * a43 * a24 + a41 * a22 * a13 * a34 - a21 * a42 * a13 * a34 - a41 * a12 * a23 * a34 + a11 * a42 * a23 * a34 + a21 * a12 * a43 * a34 - a11 * a22 * a43 * a34 - a31 * a22 * a13 * a44 + a21 * a32 * a13 * a44 + a31 * a12 * a23 * a44 - a11 * a32 * a23 * a44 - a21 * a12 * a33 * a44 + a11 * a22 * a33 * a44;
            };

            Mat4.prototype.inverse = function (m4fDestination) {
                if (!akra.isDef(m4fDestination)) {
                    m4fDestination = this;
                }

                var pData = this.data;
                var pDataDestination = m4fDestination.data;

                // Cache the matrix values (makes for huge speed increases!)
                var a11 = pData[math.__11], a12 = pData[math.__12], a13 = pData[math.__13], a14 = pData[math.__14];
                var a21 = pData[math.__21], a22 = pData[math.__22], a23 = pData[math.__23], a24 = pData[math.__24];
                var a31 = pData[math.__31], a32 = pData[math.__32], a33 = pData[math.__33], a34 = pData[math.__34];
                var a41 = pData[math.__41], a42 = pData[math.__42], a43 = pData[math.__43], a44 = pData[math.__44];

                var b00 = a11 * a22 - a12 * a21;
                var b01 = a11 * a23 - a13 * a21;
                var b02 = a11 * a24 - a14 * a21;
                var b03 = a12 * a23 - a13 * a22;
                var b04 = a12 * a24 - a14 * a22;
                var b05 = a13 * a24 - a14 * a23;
                var b06 = a31 * a42 - a32 * a41;
                var b07 = a31 * a43 - a33 * a41;
                var b08 = a31 * a44 - a34 * a41;
                var b09 = a32 * a43 - a33 * a42;
                var b10 = a32 * a44 - a34 * a42;
                var b11 = a33 * a44 - a34 * a43;

                var fDeterminant = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

                if (fDeterminant === 0.) {
                    //debug_assert(false,"обращение матрицы с нулевым детеминантом:\n"
                    //                + this.toString());
                    //чтоб все не навернулось
                    return m4fDestination.set(1.);
                }

                var fInverseDeterminant = 1 / fDeterminant;

                pDataDestination[math.__11] = (a22 * b11 - a23 * b10 + a24 * b09) * fInverseDeterminant;
                pDataDestination[math.__12] = (-a12 * b11 + a13 * b10 - a14 * b09) * fInverseDeterminant;
                pDataDestination[math.__13] = (a42 * b05 - a43 * b04 + a44 * b03) * fInverseDeterminant;
                pDataDestination[math.__14] = (-a32 * b05 + a33 * b04 - a34 * b03) * fInverseDeterminant;

                pDataDestination[math.__21] = (-a21 * b11 + a23 * b08 - a24 * b07) * fInverseDeterminant;
                pDataDestination[math.__22] = (a11 * b11 - a13 * b08 + a14 * b07) * fInverseDeterminant;
                pDataDestination[math.__23] = (-a41 * b05 + a43 * b02 - a44 * b01) * fInverseDeterminant;
                pDataDestination[math.__24] = (a31 * b05 - a33 * b02 + a34 * b01) * fInverseDeterminant;

                pDataDestination[math.__31] = (a21 * b10 - a22 * b08 + a24 * b06) * fInverseDeterminant;
                pDataDestination[math.__32] = (-a11 * b10 + a12 * b08 - a14 * b06) * fInverseDeterminant;
                pDataDestination[math.__33] = (a41 * b04 - a42 * b02 + a44 * b00) * fInverseDeterminant;
                pDataDestination[math.__34] = (-a31 * b04 + a32 * b02 - a34 * b00) * fInverseDeterminant;

                pDataDestination[math.__41] = (-a21 * b09 + a22 * b07 - a23 * b06) * fInverseDeterminant;
                pDataDestination[math.__42] = (a11 * b09 - a12 * b07 + a13 * b06) * fInverseDeterminant;
                pDataDestination[math.__43] = (-a41 * b03 + a42 * b01 - a43 * b00) * fInverseDeterminant;
                pDataDestination[math.__44] = (a31 * b03 - a32 * b01 + a33 * b00) * fInverseDeterminant;

                return m4fDestination;
            };

            /**  */ Mat4.prototype.trace = function () {
                var pData = this.data;
                return pData[math.__11] + pData[math.__22] + pData[math.__33] + pData[math.__44];
            };

            Mat4.prototype.isEqual = function (m4fMat, fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                var pData1 = this.data;
                var pData2 = m4fMat.data;

                if (fEps === 0.) {
                    if (pData1[math.__11] !== pData2[math.__11] || pData1[math.__12] !== pData2[math.__12] || pData1[math.__13] !== pData2[math.__13] || pData1[math.__14] !== pData2[math.__14] || pData1[math.__21] !== pData2[math.__21] || pData1[math.__22] !== pData2[math.__22] || pData1[math.__23] !== pData2[math.__23] || pData1[math.__24] !== pData2[math.__24] || pData1[math.__31] !== pData2[math.__31] || pData1[math.__32] !== pData2[math.__32] || pData1[math.__33] !== pData2[math.__33] || pData1[math.__34] !== pData2[math.__34] || pData1[math.__41] !== pData2[math.__41] || pData1[math.__42] !== pData2[math.__42] || pData1[math.__43] !== pData2[math.__43] || pData1[math.__44] !== pData2[math.__44]) {
                        return false;
                    }
                } else {
                    if (math.abs(pData1[math.__11] - pData2[math.__11]) > fEps || math.abs(pData1[math.__12] - pData2[math.__12]) > fEps || math.abs(pData1[math.__13] - pData2[math.__13]) > fEps || math.abs(pData1[math.__14] - pData2[math.__14]) > fEps || math.abs(pData1[math.__21] - pData2[math.__21]) > fEps || math.abs(pData1[math.__22] - pData2[math.__22]) > fEps || math.abs(pData1[math.__23] - pData2[math.__23]) > fEps || math.abs(pData1[math.__24] - pData2[math.__24]) > fEps || math.abs(pData1[math.__31] - pData2[math.__31]) > fEps || math.abs(pData1[math.__32] - pData2[math.__32]) > fEps || math.abs(pData1[math.__33] - pData2[math.__33]) > fEps || math.abs(pData1[math.__34] - pData2[math.__34]) > fEps || math.abs(pData1[math.__41] - pData2[math.__41]) > fEps || math.abs(pData1[math.__42] - pData2[math.__42]) > fEps || math.abs(pData1[math.__43] - pData2[math.__43]) > fEps || math.abs(pData1[math.__44] - pData2[math.__44]) > fEps) {
                        return false;
                    }
                }
                return true;
            };

            Mat4.prototype.isDiagonal = function (fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                var pData = this.data;

                if (fEps === 0.) {
                    if (pData[math.__12] !== 0. || pData[math.__13] !== 0. || pData[math.__14] != 0. || pData[math.__21] !== 0. || pData[math.__23] !== 0. || pData[math.__24] != 0. || pData[math.__31] !== 0. || pData[math.__32] !== 0. || pData[math.__34] != 0. || pData[math.__41] !== 0. || pData[math.__42] !== 0. || pData[math.__43] != 0.) {
                        return false;
                    }
                } else {
                    if (math.abs(pData[math.__12]) > fEps || math.abs(pData[math.__13]) > fEps || math.abs(pData[math.__14]) > fEps || math.abs(pData[math.__21]) > fEps || math.abs(pData[math.__23]) > fEps || math.abs(pData[math.__24]) > fEps || math.abs(pData[math.__31]) > fEps || math.abs(pData[math.__32]) > fEps || math.abs(pData[math.__34]) > fEps || math.abs(pData[math.__41]) > fEps || math.abs(pData[math.__42]) > fEps || math.abs(pData[math.__43]) > fEps) {
                        return false;
                    }
                }
                return true;
            };

            Mat4.prototype.toMat3 = function (m3fDestination) {
                if (!akra.isDef(m3fDestination)) {
                    m3fDestination = new math.Mat3();
                }

                var pData = this.data;
                var pDataDestination = m3fDestination.data;

                pDataDestination[math.__a11] = pData[math.__11];
                pDataDestination[math.__a12] = pData[math.__12];
                pDataDestination[math.__a13] = pData[math.__13];

                pDataDestination[math.__a21] = pData[math.__21];
                pDataDestination[math.__a22] = pData[math.__22];
                pDataDestination[math.__a23] = pData[math.__23];

                pDataDestination[math.__a31] = pData[math.__31];
                pDataDestination[math.__a32] = pData[math.__32];
                pDataDestination[math.__a33] = pData[math.__33];

                return m3fDestination;
            };

            Mat4.prototype.toQuat4 = function (q4fDestination) {
                if (!akra.isDef(q4fDestination)) {
                    q4fDestination = new math.Quat4();
                }

                var pData = this.data;

                var a11 = pData[math.__11], a12 = pData[math.__12], a13 = pData[math.__13];
                var a21 = pData[math.__21], a22 = pData[math.__22], a23 = pData[math.__23];
                var a31 = pData[math.__31], a32 = pData[math.__32], a33 = pData[math.__33];

                var x2 = ((a11 - a22 - a33) + 1.) / 4.;
                var y2 = ((a22 - a11 - a33) + 1.) / 4.;
                var z2 = ((a33 - a11 - a22) + 1.) / 4.;
                var w2 = ((a11 + a22 + a33) + 1.) / 4.;

                var fMax = math.max(x2, math.max(y2, math.max(z2, w2)));

                if (fMax == x2) {
                    //максимальная компонента берется положительной
                    var x = math.sqrt(x2);

                    q4fDestination.x = x;
                    q4fDestination.y = (a21 + a12) / 4. / x;
                    q4fDestination.z = (a31 + a13) / 4. / x;
                    q4fDestination.w = (a32 - a23) / 4. / x;
                } else if (fMax == y2) {
                    //максимальная компонента берется положительной
                    var y = math.sqrt(y2);

                    q4fDestination.x = (a21 + a12) / 4. / y;
                    q4fDestination.y = y;
                    q4fDestination.z = (a32 + a23) / 4. / y;
                    q4fDestination.w = (a13 - a31) / 4. / y;
                } else if (fMax == z2) {
                    //максимальная компонента берется положительной
                    var z = math.sqrt(z2);

                    q4fDestination.x = (a31 + a13) / 4. / z;
                    q4fDestination.y = (a32 + a23) / 4. / z;
                    q4fDestination.z = z;
                    q4fDestination.w = (a21 - a12) / 4. / z;
                } else {
                    //максимальная компонента берется положительной
                    var w = math.sqrt(w2);

                    q4fDestination.x = (a32 - a23) / 4. / w;
                    q4fDestination.y = (a13 - a31) / 4. / w;
                    q4fDestination.z = (a21 - a12) / 4. / w;
                    q4fDestination.w = w;
                }

                return q4fDestination;
            };

            Mat4.prototype.toRotationMatrix = function (m4fDestination) {
                if (!akra.isDef(m4fDestination)) {
                    m4fDestination = new Mat4();
                }

                var pData = this.data;
                var pDataDestination = m4fDestination.data;

                pDataDestination[math.__11] = pData[math.__11];
                pDataDestination[math.__12] = pData[math.__12];
                pDataDestination[math.__13] = pData[math.__13];
                pDataDestination[math.__14] = 0.;

                pDataDestination[math.__21] = pData[math.__21];
                pDataDestination[math.__22] = pData[math.__22];
                pDataDestination[math.__23] = pData[math.__23];
                pDataDestination[math.__24] = 0.;

                pDataDestination[math.__31] = pData[math.__31];
                pDataDestination[math.__32] = pData[math.__32];
                pDataDestination[math.__33] = pData[math.__33];
                pDataDestination[math.__34] = 0.;

                pDataDestination[math.__41] = 0.;
                pDataDestination[math.__42] = 0.;
                pDataDestination[math.__43] = 0.;
                pDataDestination[math.__44] = 1.;

                return m4fDestination;
            };

            Mat4.prototype.toString = function (iFixed) {
                if (typeof iFixed === "undefined") { iFixed = 2; }
                var pData = this.data;

                return '[' + pData[math.__11].toFixed(iFixed) + ", " + pData[math.__12].toFixed(iFixed) + ', ' + pData[math.__13].toFixed(iFixed) + ', ' + pData[math.__14].toFixed(iFixed) + ',\n' + pData[math.__21].toFixed(iFixed) + ", " + pData[math.__22].toFixed(iFixed) + ', ' + pData[math.__23].toFixed(iFixed) + ', ' + pData[math.__24].toFixed(iFixed) + ',\n' + pData[math.__31].toFixed(iFixed) + ", " + pData[math.__32].toFixed(iFixed) + ', ' + pData[math.__33].toFixed(iFixed) + ', ' + pData[math.__34].toFixed(iFixed) + ',\n' + pData[math.__41].toFixed(iFixed) + ", " + pData[math.__42].toFixed(iFixed) + ', ' + pData[math.__43].toFixed(iFixed) + ', ' + pData[math.__44].toFixed(iFixed) + ']';
            };

            Mat4.prototype.toArray = function (pDest) {
                if (typeof pDest === "undefined") { pDest = new Array(16); }
                //TODO: too slow :(
                return akra.conv.retrieve(this.data, pDest, 1, 0, 16) && pDest;
            };

            Mat4.prototype.rotateRight = function (fAngle, v3fAxis, m4fDestination) {
                var pData = this.data;

                var x = v3fAxis.x, y = v3fAxis.y, z = v3fAxis.z;
                var fLength = Math.sqrt(x * x + y * y + z * z);

                if (fLength === 0.) {
                    akra.logger.assert(false, "попытка вращения вокруг оси нулевой длины. Угол " + fAngle + ". Ось " + v3fAxis.toString());
                    if (akra.isDef(m4fDestination)) {
                        m4fDestination.set(this);
                    } else {
                        m4fDestination = this;
                    }
                    return m4fDestination;
                }

                var fInvLength = 1. / fLength;

                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;

                var a11 = pData[math.__11], a12 = pData[math.__12], a13 = pData[math.__13];
                var a21 = pData[math.__21], a22 = pData[math.__22], a23 = pData[math.__23];
                var a31 = pData[math.__31], a32 = pData[math.__32], a33 = pData[math.__33];

                var fSin = math.sin(fAngle);
                var fCos = math.cos(fAngle);
                var fTmp = 1. - fCos;

                //build Rotation matrix
                var b11 = fCos + fTmp * x * x, b12 = fTmp * x * y - fSin * z, b13 = fTmp * x * z + fSin * y;
                var b21 = fTmp * y * z + fSin * z, b22 = fCos + fTmp * y * y, b23 = fTmp * y * z - fSin * x;
                var b31 = fTmp * z * x - fSin * y, b32 = fTmp * z * y + fSin * x, b33 = fCos + fTmp * z * z;

                if (!akra.isDef(m4fDestination)) {
                    pData[math.__11] = a11 * b11 + a12 * b21 + a13 * b31;
                    pData[math.__12] = a11 * b12 + a12 * b22 + a13 * b32;
                    pData[math.__13] = a11 * b13 + a12 * b23 + a13 * b33;

                    pData[math.__21] = a21 * b11 + a22 * b21 + a23 * b31;
                    pData[math.__22] = a21 * b12 + a22 * b22 + a23 * b32;
                    pData[math.__23] = a21 * b13 + a22 * b23 + a23 * b33;

                    pData[math.__31] = a31 * b11 + a32 * b21 + a33 * b31;
                    pData[math.__32] = a31 * b12 + a32 * b22 + a33 * b32;
                    pData[math.__33] = a31 * b13 + a32 * b23 + a33 * b33;

                    return this;
                }

                var pDataDestination = m4fDestination.data;

                pDataDestination[math.__11] = a11 * b11 + a12 * b21 + a13 * b31;
                pDataDestination[math.__12] = a11 * b12 + a12 * b22 + a13 * b32;
                pDataDestination[math.__13] = a11 * b13 + a12 * b23 + a13 * b33;
                pDataDestination[math.__14] = pData[math.__14];

                pDataDestination[math.__21] = a21 * b11 + a22 * b21 + a23 * b31;
                pDataDestination[math.__22] = a21 * b12 + a22 * b22 + a23 * b32;
                pDataDestination[math.__23] = a21 * b13 + a22 * b23 + a23 * b33;
                pDataDestination[math.__24] = pData[math.__24];

                pDataDestination[math.__31] = a31 * b11 + a32 * b21 + a33 * b31;
                pDataDestination[math.__32] = a31 * b12 + a32 * b22 + a33 * b32;
                pDataDestination[math.__33] = a31 * b13 + a32 * b23 + a33 * b33;
                pDataDestination[math.__34] = pData[math.__34];

                pDataDestination[math.__41] = pData[math.__41];
                pDataDestination[math.__42] = pData[math.__42];
                pDataDestination[math.__43] = pData[math.__43];
                pDataDestination[math.__44] = pData[math.__44];

                return m4fDestination;
            };

            Mat4.prototype.rotateLeft = function (fAngle, v3fAxis, m4fDestination) {
                var pData = this.data;

                var x = v3fAxis.x, y = v3fAxis.y, z = v3fAxis.z;
                var fLength = Math.sqrt(x * x + y * y + z * z);

                if (fLength === 0.) {
                    akra.logger.assert(false, "попытка вращения вокруг оси нулевой длины. Угол " + fAngle + ". Ось " + v3fAxis.toString());
                    if (akra.isDef(m4fDestination)) {
                        m4fDestination.set(this);
                    } else {
                        m4fDestination = this;
                    }
                    return m4fDestination;
                }

                var fInvLength = 1. / fLength;

                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;

                var a11 = pData[math.__11], a12 = pData[math.__12], a13 = pData[math.__13], a14 = pData[math.__14];
                var a21 = pData[math.__21], a22 = pData[math.__22], a23 = pData[math.__23], a24 = pData[math.__24];
                var a31 = pData[math.__31], a32 = pData[math.__32], a33 = pData[math.__33], a34 = pData[math.__34];

                var fSin = math.sin(fAngle);
                var fCos = math.cos(fAngle);
                var fTmp = 1. - fCos;

                //build Rotation matrix
                var b11 = fCos + fTmp * x * x, b12 = fTmp * x * y - fSin * z, b13 = fTmp * x * z + fSin * y;
                var b21 = fTmp * y * z + fSin * z, b22 = fCos + fTmp * y * y, b23 = fTmp * y * z - fSin * x;
                var b31 = fTmp * z * x - fSin * y, b32 = fTmp * z * y + fSin * x, b33 = fCos + fTmp * z * z;

                if (!akra.isDef(m4fDestination)) {
                    pData[math.__11] = b11 * a11 + b12 * a21 + b13 * a31;
                    pData[math.__12] = b11 * a12 + b12 * a22 + b13 * a32;
                    pData[math.__13] = b11 * a13 + b12 * a23 + b13 * a33;
                    pData[math.__14] = b11 * a14 + b12 * a24 + b13 * a34;

                    pData[math.__21] = b21 * a11 + b22 * a21 + b23 * a31;
                    pData[math.__22] = b21 * a12 + b22 * a22 + b23 * a32;
                    pData[math.__23] = b21 * a13 + b22 * a23 + b23 * a33;
                    pData[math.__24] = b21 * a14 + b22 * a24 + b23 * a34;

                    pData[math.__31] = b31 * a11 + b32 * a21 + b33 * a31;
                    pData[math.__32] = b31 * a12 + b32 * a22 + b33 * a32;
                    pData[math.__33] = b31 * a13 + b32 * a23 + b33 * a33;
                    pData[math.__34] = b31 * a14 + b32 * a24 + b33 * a34;

                    return this;
                }

                var pDataDestination = m4fDestination.data;

                pDataDestination[math.__11] = b11 * a11 + b12 * a21 + b13 * a31;
                pDataDestination[math.__12] = b11 * a12 + b12 * a22 + b13 * a32;
                pDataDestination[math.__13] = b11 * a13 + b12 * a23 + b13 * a33;
                pDataDestination[math.__14] = b11 * a14 + b12 * a24 + b13 * a34;

                pDataDestination[math.__21] = b21 * a11 + b22 * a21 + b23 * a31;
                pDataDestination[math.__22] = b21 * a12 + b22 * a22 + b23 * a32;
                pDataDestination[math.__23] = b21 * a13 + b22 * a23 + b23 * a33;
                pDataDestination[math.__24] = b21 * a14 + b22 * a24 + b23 * a34;

                pDataDestination[math.__31] = b31 * a11 + b32 * a21 + b33 * a31;
                pDataDestination[math.__32] = b31 * a12 + b32 * a22 + b33 * a32;
                pDataDestination[math.__33] = b31 * a13 + b32 * a23 + b33 * a33;
                pDataDestination[math.__34] = b31 * a14 + b32 * a24 + b33 * a34;

                pDataDestination[math.__41] = pData[math.__41];
                pDataDestination[math.__42] = pData[math.__42];
                pDataDestination[math.__43] = pData[math.__43];
                pDataDestination[math.__44] = pData[math.__44];

                return m4fDestination;
            };

            /**  */ Mat4.prototype.setTranslation = function (v3fTranslation) {
                var pData = this.data;

                pData[math.__14] = v3fTranslation.x;
                pData[math.__24] = v3fTranslation.y;
                pData[math.__34] = v3fTranslation.z;

                return this;
            };

            /**  */ Mat4.prototype.getTranslation = function (v3fTranslation) {
                if (!akra.isDef(v3fTranslation)) {
                    v3fTranslation = new math.Vec3();
                }

                var pData = this.data;

                v3fTranslation.x = pData[math.__14];
                v3fTranslation.y = pData[math.__24];
                v3fTranslation.z = pData[math.__34];

                return v3fTranslation;
            };

            Mat4.prototype.translateRight = function (v3fTranslation, m4fDestination) {
                var pData = this.data;

                var x = v3fTranslation.x, y = v3fTranslation.y, z = v3fTranslation.z;

                if (!akra.isDef(m4fDestination)) {
                    pData[math.__14] = pData[math.__11] * x + pData[math.__12] * y + pData[math.__13] * z + pData[math.__14];
                    pData[math.__24] = pData[math.__21] * x + pData[math.__22] * y + pData[math.__23] * z + pData[math.__24];
                    pData[math.__34] = pData[math.__31] * x + pData[math.__32] * y + pData[math.__33] * z + pData[math.__34];
                    pData[math.__44] = pData[math.__41] * x + pData[math.__42] * y + pData[math.__43] * z + pData[math.__44];

                    //строго говоря последнюю строчку умножать не обязательно, так как она должна быть -> 0 0 0 1
                    return this;
                }

                var pDataDestination = m4fDestination.data;

                //кешируем матрицу вращений
                var a11 = pData[math.__11], a12 = pData[math.__12], a13 = pData[math.__13];
                var a21 = pData[math.__11], a22 = pData[math.__22], a23 = pData[math.__23];
                var a31 = pData[math.__11], a32 = pData[math.__32], a33 = pData[math.__33];
                var a41 = pData[math.__11], a42 = pData[math.__42], a43 = pData[math.__43];

                pDataDestination[math.__11] = a11;
                pDataDestination[math.__12] = a12;
                pDataDestination[math.__13] = a13;
                pDataDestination[math.__14] = a11 * x + a12 * y + a13 * z + pData[math.__14];

                pDataDestination[math.__21] = a21;
                pDataDestination[math.__22] = a22;
                pDataDestination[math.__23] = a23;
                pDataDestination[math.__24] = a21 * x + a22 * y + a23 * z + pData[math.__24];

                pDataDestination[math.__31] = a31;
                pDataDestination[math.__32] = a32;
                pDataDestination[math.__33] = a33;
                pDataDestination[math.__34] = a31 * x + a32 * y + a33 * z + pData[math.__34];

                pDataDestination[math.__41] = a41;
                pDataDestination[math.__42] = a42;
                pDataDestination[math.__43] = a43;
                pDataDestination[math.__44] = a41 * x + a42 * y + a43 * z + pData[math.__44];

                return m4fDestination;
            };

            Mat4.prototype.translateLeft = function (v3fTranslation, m4fDestination) {
                var pData = this.data;

                var x = v3fTranslation.x, y = v3fTranslation.y, z = v3fTranslation.z;

                if (!akra.isDef(m4fDestination)) {
                    pData[math.__14] = x + pData[math.__14];
                    pData[math.__24] = y + pData[math.__24];
                    pData[math.__34] = z + pData[math.__34];
                    return this;
                }

                var pDataDestination = m4fDestination.data;

                pDataDestination[math.__11] = pData[math.__11];
                pDataDestination[math.__12] = pData[math.__12];
                pDataDestination[math.__13] = pData[math.__13];
                pDataDestination[math.__14] = x + pData[math.__14];

                pDataDestination[math.__21] = pData[math.__21];
                pDataDestination[math.__22] = pData[math.__22];
                pDataDestination[math.__23] = pData[math.__23];
                pDataDestination[math.__24] = y + pData[math.__24];

                pDataDestination[math.__31] = pData[math.__31];
                pDataDestination[math.__32] = pData[math.__32];
                pDataDestination[math.__33] = pData[math.__33];
                pDataDestination[math.__34] = z + pData[math.__34];

                pDataDestination[math.__41] = pData[math.__41];
                pDataDestination[math.__42] = pData[math.__42];
                pDataDestination[math.__43] = pData[math.__43];
                pDataDestination[math.__44] = pData[math.__44];

                return m4fDestination;
            };

            Mat4.prototype.scaleRight = function (scale, m4fDestination) {
                var pData = this.data;

                var x, y, z;

                if (akra.isNumber(scale)) {
                    x = y = z = scale;
                } else {
                    x = scale.x;
                    y = scale.y;
                    z = scale.z;
                }

                if (!akra.isDef(m4fDestination)) {
                    pData[math.__11] *= x;
                    pData[math.__12] *= y;
                    pData[math.__13] *= z;

                    pData[math.__21] *= x;
                    pData[math.__22] *= y;
                    pData[math.__23] *= z;

                    pData[math.__31] *= x;
                    pData[math.__32] *= y;
                    pData[math.__33] *= z;

                    //скейлить эти компоненты необязательно, так как там должны лежать нули
                    pData[math.__41] *= x;
                    pData[math.__42] *= y;
                    pData[math.__43] *= z;

                    return this;
                }

                var pDataDestination = m4fDestination.data;

                pDataDestination[math.__11] = pData[math.__11] * x;
                pDataDestination[math.__12] = pData[math.__12] * y;
                pDataDestination[math.__13] = pData[math.__13] * z;
                pDataDestination[math.__14] = pData[math.__14];

                pDataDestination[math.__21] = pData[math.__21] * x;
                pDataDestination[math.__22] = pData[math.__22] * y;
                pDataDestination[math.__23] = pData[math.__23] * z;
                pDataDestination[math.__24] = pData[math.__24];

                pDataDestination[math.__31] = pData[math.__31] * x;
                pDataDestination[math.__32] = pData[math.__32] * y;
                pDataDestination[math.__33] = pData[math.__33] * z;
                pDataDestination[math.__34] = pData[math.__34];

                //скейлить эти компоненты необязательно, так как там должны лежать нули
                pDataDestination[math.__41] = pData[math.__41] * x;
                pDataDestination[math.__42] = pData[math.__42] * y;
                pDataDestination[math.__43] = pData[math.__43] * z;
                pDataDestination[math.__44] = pData[math.__44];

                return m4fDestination;
            };

            Mat4.prototype.scaleLeft = function (scale, m4fDestination) {
                var pData = this.data;

                var x, y, z;

                if (akra.isNumber(scale)) {
                    x = y = z = scale;
                } else {
                    x = scale.x;
                    y = scale.y;
                    z = scale.z;
                }

                if (!akra.isDef(m4fDestination)) {
                    pData[math.__11] *= x;
                    pData[math.__12] *= x;
                    pData[math.__13] *= x;
                    pData[math.__14] *= x;

                    pData[math.__21] *= y;
                    pData[math.__22] *= y;
                    pData[math.__23] *= y;
                    pData[math.__24] *= y;

                    pData[math.__31] *= z;
                    pData[math.__32] *= z;
                    pData[math.__33] *= z;
                    pData[math.__34] *= z;

                    return this;
                }

                var pDataDestination = m4fDestination.data;

                pDataDestination[math.__11] = pData[math.__11] * x;
                pDataDestination[math.__12] = pData[math.__12] * x;
                pDataDestination[math.__13] = pData[math.__13] * x;
                pDataDestination[math.__14] = pData[math.__14] * x;

                pDataDestination[math.__21] = pData[math.__21] * y;
                pDataDestination[math.__22] = pData[math.__22] * y;
                pDataDestination[math.__23] = pData[math.__23] * y;
                pDataDestination[math.__24] = pData[math.__24] * y;

                pDataDestination[math.__31] = pData[math.__31] * z;
                pDataDestination[math.__32] = pData[math.__32] * z;
                pDataDestination[math.__33] = pData[math.__33] * z;
                pDataDestination[math.__34] = pData[math.__34] * z;

                pDataDestination[math.__41] = pData[math.__41];
                pDataDestination[math.__42] = pData[math.__42];
                pDataDestination[math.__43] = pData[math.__43];
                pDataDestination[math.__44] = pData[math.__44];

                return m4fDestination;
            };

            /**  */ Mat4.prototype.decompose = function (q4fRotation, v3fScale, v3fTranslation) {
                this.getTranslation(v3fTranslation);
                var m3fRotScale = this.toMat3(math.Mat3.temp());
                return m3fRotScale.decompose(q4fRotation, v3fScale);
            };

            Mat4.prototype.row = function (iRow, v4fDestination) {
                if (!akra.isDef(v4fDestination)) {
                    v4fDestination = new math.Vec4();
                }

                var pData = this.data;

                switch (iRow) {
                    case 1:
                        v4fDestination.x = pData[math.__11];
                        v4fDestination.y = pData[math.__12];
                        v4fDestination.z = pData[math.__13];
                        v4fDestination.w = pData[math.__14];
                        break;
                    case 2:
                        v4fDestination.x = pData[math.__21];
                        v4fDestination.y = pData[math.__22];
                        v4fDestination.z = pData[math.__23];
                        v4fDestination.w = pData[math.__24];
                        break;
                    case 3:
                        v4fDestination.x = pData[math.__31];
                        v4fDestination.y = pData[math.__32];
                        v4fDestination.z = pData[math.__33];
                        v4fDestination.w = pData[math.__34];
                        break;
                    case 4:
                        v4fDestination.x = pData[math.__41];
                        v4fDestination.y = pData[math.__42];
                        v4fDestination.z = pData[math.__43];
                        v4fDestination.w = pData[math.__44];
                        break;
                }

                return v4fDestination;
            };

            Mat4.prototype.column = function (iColumn, v4fDestination) {
                if (!akra.isDef(v4fDestination)) {
                    v4fDestination = new math.Vec4();
                }

                var pData = this.data;

                switch (iColumn) {
                    case 1:
                        v4fDestination.x = pData[math.__11];
                        v4fDestination.y = pData[math.__21];
                        v4fDestination.z = pData[math.__31];
                        v4fDestination.w = pData[math.__41];
                        break;
                    case 2:
                        v4fDestination.x = pData[math.__12];
                        v4fDestination.y = pData[math.__22];
                        v4fDestination.z = pData[math.__32];
                        v4fDestination.w = pData[math.__42];
                        break;
                    case 3:
                        v4fDestination.x = pData[math.__13];
                        v4fDestination.y = pData[math.__23];
                        v4fDestination.z = pData[math.__33];
                        v4fDestination.w = pData[math.__43];
                        break;
                    case 4:
                        v4fDestination.x = pData[math.__14];
                        v4fDestination.y = pData[math.__24];
                        v4fDestination.z = pData[math.__34];
                        v4fDestination.w = pData[math.__44];
                        break;
                }

                return v4fDestination;
            };

            Mat4.prototype.unproj = function (v, v4fDestination) {
                if (!akra.isDef(v4fDestination)) {
                    v4fDestination = new math.Vec4();
                }

                var pData = this.data;
                var v3fScreen = v;
                var x, y, z;

                if (this.isOrthogonalProjection()) {
                    //orthogonal projection case
                    z = (v3fScreen.z - pData[math.__34]) / pData[math.__33];
                    y = (v3fScreen.y - pData[math.__24]) / pData[math.__22];
                    x = (v3fScreen.x - pData[math.__14]) / pData[math.__11];
                } else {
                    //frustum case
                    z = -pData[math.__34] / (pData[math.__33] + v3fScreen.z);
                    y = -(v3fScreen.y + pData[math.__23]) * z / pData[math.__22];
                    x = -(v3fScreen.x + pData[math.__13]) * z / pData[math.__11];
                }

                v4fDestination.x = x;
                v4fDestination.y = y;
                v4fDestination.z = z;
                v4fDestination.w = 1.;

                return v4fDestination;
            };

            Mat4.prototype.unprojZ = function (fZ) {
                var pData = this.data;

                if (this.isOrthogonalProjection()) {
                    //orthogonal projection case
                    return (fZ - pData[math.__34]) / pData[math.__33];
                } else {
                    //pData[__43] === -1
                    //frustum case
                    return -pData[math.__34] / (pData[math.__33] + fZ);
                }
            };

            /**  */ Mat4.prototype.isOrthogonalProjection = function () {
                // var pData: Float32Array = this.data;
                // if(pData[__44] === 1){
                // 	//orthogonal projection
                // 	return true;
                // }
                // else{
                // 	//pData[__43] === -1
                // 	//frustum projection
                // 	return false;
                // }
                return ((this.data[math.__44] === 1) ? true : false);
            };

            Mat4.fromYawPitchRoll = function () {
                var fYaw = 0.0, fPitch = 0.0, fRoll = 0.0, m4fDestination = null;

                if (arguments.length <= 2) {
                    //Vec3 + m4fDestination
                    var v3fVec = arguments[0];

                    fYaw = v3fVec.x;
                    fPitch = v3fVec.y;
                    fRoll = v3fVec.z;

                    m4fDestination = arguments[1];
                } else {
                    fYaw = arguments[0];
                    fPitch = arguments[1];
                    fRoll = arguments[2];
                    m4fDestination = arguments[3];
                }

                if (!akra.isDef(m4fDestination)) {
                    m4fDestination = new Mat4();
                }

                var pDataDestination = m4fDestination.data;

                var fSin1 = Math.sin(fYaw);
                var fSin2 = Math.sin(fPitch);
                var fSin3 = Math.sin(fRoll);

                var fCos1 = Math.cos(fYaw);
                var fCos2 = Math.cos(fPitch);
                var fCos3 = Math.cos(fRoll);

                pDataDestination[math.__11] = fCos1 * fCos3 + fSin1 * fSin2 * fSin3;
                pDataDestination[math.__12] = fCos3 * fSin1 * fSin2 - fCos1 * fSin3;
                pDataDestination[math.__13] = fCos2 * fSin1;
                pDataDestination[math.__14] = 0.;

                pDataDestination[math.__21] = fCos2 * fSin3;
                pDataDestination[math.__22] = fCos2 * fCos3;
                pDataDestination[math.__23] = -fSin2;
                pDataDestination[math.__24] = 0.;

                pDataDestination[math.__31] = fCos1 * fSin2 * fSin3 - fCos3 * fSin1;
                pDataDestination[math.__32] = fSin1 * fSin3 + fCos1 * fCos3 * fSin2;
                pDataDestination[math.__33] = fCos1 * fCos2;
                pDataDestination[math.__34] = 0.;

                pDataDestination[math.__41] = 0.;
                pDataDestination[math.__42] = 0.;
                pDataDestination[math.__43] = 0.;
                pDataDestination[math.__44] = 1.;

                return m4fDestination;
            };

            Mat4.fromXYZ = function (fX, fY, fZ, m4fDestination) {
                if (arguments.length <= 2) {
                    //Vec3 + m4fDestination
                    var v3fVec = arguments[0];
                    return Mat4.fromYawPitchRoll(v3fVec.y, v3fVec.x, v3fVec.z, arguments[1]);
                } else {
                    ////fX fY fZ m4fDestination
                    //var fX: float = arguments[0];
                    //var fY: float = arguments[1];
                    //var fZ: float = arguments[2];
                    return Mat4.fromYawPitchRoll(fY, fX, fZ, arguments[3]);
                }
            };

            Mat4.frustum = function (fLeft, fRight, fBottom, fTop, fNear, fFar, m4fDestination) {
                if (!akra.isDef(m4fDestination)) {
                    m4fDestination = new Mat4();
                }

                var pDataDestination = m4fDestination.data;

                var fRL = fRight - fLeft;
                var fTB = fTop - fBottom;
                var fFN = fFar - fNear;

                pDataDestination[math.__11] = 2. * fNear / fRL;
                pDataDestination[math.__12] = 0.;
                pDataDestination[math.__13] = (fRight + fLeft) / fRL;
                pDataDestination[math.__14] = 0.;

                pDataDestination[math.__21] = 0.;
                pDataDestination[math.__22] = 2. * fNear / fTB;
                pDataDestination[math.__23] = (fTop + fBottom) / fTB;
                pDataDestination[math.__24] = 0.;

                pDataDestination[math.__31] = 0.;
                pDataDestination[math.__32] = 0.;
                pDataDestination[math.__33] = -(fFar + fNear) / fFN;
                pDataDestination[math.__34] = -2. * fFar * fNear / fFN;

                pDataDestination[math.__41] = 0.;
                pDataDestination[math.__42] = 0.;
                pDataDestination[math.__43] = -1.;
                pDataDestination[math.__44] = 0.;

                return m4fDestination;
            };

            /**  */ Mat4.perspective = function (fFovy, fAspect, fNear, fFar, m4fDestination) {
                var fTop = fNear * math.tan(fFovy / 2.);
                var fRight = fTop * fAspect;

                return Mat4.frustum(-fRight, fRight, -fTop, fTop, fNear, fFar, m4fDestination);
            };

            Mat4.orthogonalProjectionAsymmetric = function (fLeft, fRight, fBottom, fTop, fNear, fFar, m4fDestination) {
                if (!akra.isDef(m4fDestination)) {
                    m4fDestination = new Mat4();
                }

                var pDataDestination = m4fDestination.data;

                var fRL = fRight - fLeft;
                var fTB = fTop - fBottom;
                var fFN = fFar - fNear;

                pDataDestination[math.__11] = 2. / fRL;
                pDataDestination[math.__12] = 0.;
                pDataDestination[math.__13] = 0.;
                pDataDestination[math.__14] = -(fRight + fLeft) / fRL;

                pDataDestination[math.__21] = 0.;
                pDataDestination[math.__22] = 2. / fTB;
                pDataDestination[math.__23] = 0.;
                pDataDestination[math.__24] = -(fTop + fBottom) / fTB;

                pDataDestination[math.__31] = 0.;
                pDataDestination[math.__32] = 0.;
                pDataDestination[math.__33] = -2. / fFN;
                pDataDestination[math.__34] = -(fFar + fNear) / fFN;

                pDataDestination[math.__41] = 0.;
                pDataDestination[math.__42] = 0.;
                pDataDestination[math.__43] = 0.;
                pDataDestination[math.__44] = 1.;

                return m4fDestination;
            };

            /**  */ Mat4.orthogonalProjection = function (fWidth, fHeight, fNear, fFar, m4fDestination) {
                var fRight = fWidth / 2.;
                var fTop = fHeight / 2.;
                return Mat4.orthogonalProjectionAsymmetric(-fRight, fRight, -fTop, fTop, fNear, fFar, m4fDestination);
            };

            Mat4.lookAt = function (v3fEye, v3fCenter, v3fUp, m4fDestination) {
                if (!akra.isDef(m4fDestination)) {
                    m4fDestination = new Mat4(1.);
                }

                var fEyeX = v3fEye.x, fEyeY = v3fEye.y, fEyeZ = v3fEye.z;
                var fCenterX = v3fCenter.x, fCenterY = v3fCenter.y, fCenterZ = v3fCenter.z;
                var fUpX = v3fUp.x, fUpY = v3fUp.y, fUpZ = v3fUp.z;

                var fLength;
                var fInvLength;

                if (fEyeX === fCenterX && fEyeY === fCenterY && fEyeZ === fCenterZ) {
                    return m4fDestination;
                }

                var fXNewX, fXNewY, fXNewZ;
                var fYNewX, fYNewY, fYNewZ;
                var fZNewX, fZNewY, fZNewZ;

                //ось Z направлена на наблюдателя
                fZNewX = fEyeX - fCenterX;
                fZNewY = fEyeY - fCenterY;
                fZNewZ = fEyeZ - fCenterZ;

                fLength = math.sqrt(fZNewX * fZNewX + fZNewY * fZNewY + fZNewZ * fZNewZ);
                fInvLength = 1. / fLength;

                //новая ось Z
                fZNewX = fZNewX * fInvLength;
                fZNewY = fZNewY * fInvLength;
                fZNewZ = fZNewZ * fInvLength;

                //новая ось X
                fXNewX = fUpY * fZNewZ - fUpZ * fZNewY;
                fXNewY = fUpZ * fZNewX - fUpX * fZNewZ;
                fXNewZ = fUpX * fZNewY - fUpY * fZNewX;

                fLength = math.sqrt(fXNewX * fXNewX + fXNewY * fXNewY + fXNewZ * fXNewZ);
                if (fLength) {
                    fInvLength = 1. / fLength;

                    fXNewX = fXNewX * fInvLength;
                    fXNewY = fXNewY * fInvLength;
                    fXNewZ = fXNewZ * fInvLength;
                }

                //новая ось Y
                fYNewX = fZNewY * fXNewZ - fZNewZ * fXNewY;
                fYNewY = fZNewZ * fXNewX - fZNewX * fXNewZ;
                fYNewZ = fZNewX * fXNewY - fZNewY * fXNewX;

                //нормировать ненужно, так как было векторное умножение двух ортонормированных векторов
                //положение камеры в новых осях
                var fEyeNewX = fEyeX * fXNewX + fEyeY * fXNewY + fEyeZ * fXNewZ;
                var fEyeNewY = fEyeX * fYNewX + fEyeY * fYNewY + fEyeZ * fYNewZ;
                var fEyeNewZ = fEyeX * fZNewX + fEyeY * fZNewY + fEyeZ * fZNewZ;

                var pDataDestination = m4fDestination.data;

                //lookAt matrix === camera view matrix
                //почему новый базис записывается по строкам?
                //это сзязано с тем, что это получающаяся матрица -
                //это viewMatrix камеры, а на эту матрицу умножается при рендеринге, то есть
                //модель должна испытать преобразования противоположные тем, которые испытывает камера
                //то есть вращение в другую сторону(базис по строкам) и сдвиг в противоположную сторону
                pDataDestination[math.__11] = fXNewX;
                pDataDestination[math.__12] = fXNewY;
                pDataDestination[math.__13] = fXNewZ;
                pDataDestination[math.__14] = -fEyeNewX; /*отъезжаем в позицию камеры*/

                pDataDestination[math.__21] = fYNewX;
                pDataDestination[math.__22] = fYNewY;
                pDataDestination[math.__23] = fYNewZ;
                pDataDestination[math.__24] = -fEyeNewY; /*отъезжаем в позицию камеры*/

                pDataDestination[math.__31] = fZNewX;
                pDataDestination[math.__32] = fZNewY;
                pDataDestination[math.__33] = fZNewZ;
                pDataDestination[math.__34] = -fEyeNewZ; /*отъезжаем в позицию камеры*/

                pDataDestination[math.__41] = 0.;
                pDataDestination[math.__42] = 0.;
                pDataDestination[math.__43] = 0.;
                pDataDestination[math.__44] = 1.;

                return m4fDestination;
            };

            Mat4.temp = function () {
                iElement = (iElement === pBuffer.length - 1 ? 0 : iElement);
                var p = pBuffer[iElement++];

                var n = arguments.length;
                switch (n) {
                    case 1:
                        p.set(arguments[0]);
                        break;
                    case 2:
                        p.set(arguments[0], arguments[1]);
                        break;
                    case 4:
                        p.set(arguments[0], arguments[1], arguments[2], arguments[3]);
                        break;
                    case 16:
                        p.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8], arguments[9], arguments[10], arguments[11], arguments[12], arguments[13], arguments[14], arguments[15]);
                        break;
                    default:
                        p.set();
                        break;
                }

                return p;
            };
            return Mat4;
        })();
        math.Mat4 = Mat4;

        pBuffer = akra.gen.array(256, Mat4);
        iElement = 0;
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
/// <reference path="../common.ts" />
/// <reference path="../logger.ts" />
/// <reference path="../idl/IQuat4.ts" />
/// <reference path="math.ts" />
/// <reference path="../gen/generate.ts" />
var akra;
(function (akra) {
    (function (math) {
        //import __11 = math.__11;
        //import __12 = math.__12;
        //import __13 = math.__13;
        //import __14 = math.__14;
        //import __21 = math.__21;
        //import __22 = math.__22;
        //import __23 = math.__23;
        //import __24 = math.__24;
        //import __31 = math.__31;
        //import __32 = math.__32;
        //import __33 = math.__33;
        //import __34 = math.__34;
        //import __41 = math.__41;
        //import __42 = math.__42;
        //import __43 = math.__43;
        //import __44 = math.__44;
        //import __a11 = math.__a11;
        //import __a12 = math.__a12;
        //import __a13 = math.__a13;
        //import __a21 = math.__a21;
        //import __a22 = math.__a22;
        //import __a23 = math.__a23;
        //import __a31 = math.__a31;
        //import __a32 = math.__a32;
        //import __a33 = math.__a33;
        var pBuffer;
        var iElement;

        var Quat4 = (function () {
            function Quat4() {
                var nArgumentsLength = arguments.length;

                switch (nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 2:
                        this.set(arguments[0], arguments[1]);
                        break;
                    case 4:
                        this.set(arguments[0], arguments[1], arguments[2], arguments[3]);
                        break;
                    default:
                        this.x = this.y = this.z = 0.;
                        this.w = 1.;
                        break;
                }
            }
            Quat4.prototype.set = function () {
                var nArgumentsLength = arguments.length;

                if (nArgumentsLength === 0) {
                    this.x = this.y = this.z = 0.;
                    this.w = 1.;
                } else if (nArgumentsLength === 1) {
                    if (arguments[0] instanceof Quat4) {
                        var q4fQuat = arguments[0];

                        this.x = q4fQuat.x;
                        this.y = q4fQuat.y;
                        this.z = q4fQuat.z;
                        this.w = q4fQuat.w;
                    } else {
                        //Array
                        var pElements = arguments[0];

                        this.x = pElements[0];
                        this.y = pElements[1];
                        this.z = pElements[2];
                        this.w = pElements[3];
                    }
                } else if (nArgumentsLength === 2) {
                    //float float
                    //vec3 float
                    if (akra.isFloat(arguments[0])) {
                        //float float
                        var fValue = arguments[0];

                        this.x = fValue;
                        this.y = fValue;
                        this.z = fValue;
                        this.w = arguments[1];
                    } else {
                        //vec3 float
                        var v3fValue = arguments[0];

                        this.x = v3fValue.x;
                        this.y = v3fValue.y;
                        this.z = v3fValue.z;
                        this.w = arguments[1];
                    }
                } else if (nArgumentsLength === 4) {
                    this.x = arguments[0];
                    this.y = arguments[1];
                    this.z = arguments[2];
                    this.w = arguments[3];
                }

                return this;
            };

            Quat4.prototype.multiply = function (q4fQuat, q4fDestination) {
                if (!akra.isDef(q4fDestination)) {
                    q4fDestination = this;
                }

                var x1 = this.x, y1 = this.y, z1 = this.z, w1 = this.w;
                var x2 = q4fQuat.x, y2 = q4fQuat.y, z2 = q4fQuat.z, w2 = q4fQuat.w;

                q4fDestination.x = x1 * w2 + x2 * w1 + y1 * z2 - z1 * y2;
                q4fDestination.y = y1 * w2 + y2 * w1 + z1 * x2 - x1 * z2;
                q4fDestination.z = z1 * w2 + z2 * w1 + x1 * y2 - y1 * x2;
                q4fDestination.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;

                return q4fDestination;
            };

            Quat4.prototype.multiplyVec3 = function (v3fVec, v3fDestination) {
                if (!akra.isDef(v3fDestination)) {
                    v3fDestination = v3fVec;
                }

                var q4fVec = Quat4.temp(v3fVec, 0.);
                var qInverse = this.inverse(Quat4.temp());
                var qResult = this.multiply(q4fVec.multiply(qInverse), Quat4.temp());

                v3fDestination.x = qResult.x;
                v3fDestination.y = qResult.y;
                v3fDestination.z = qResult.z;

                return v3fDestination;
            };

            Quat4.prototype.conjugate = function (q4fDestination) {
                if (!akra.isDef(q4fDestination)) {
                    this.x = -this.x;
                    this.y = -this.y;
                    this.z = -this.z;

                    return this;
                }

                q4fDestination.x = -this.x;
                q4fDestination.y = -this.y;
                q4fDestination.z = -this.z;
                q4fDestination.w = this.w;

                return q4fDestination;
            };

            Quat4.prototype.inverse = function (q4fDestination) {
                if (!akra.isDef(q4fDestination)) {
                    q4fDestination = this;
                }

                var x = this.x, y = this.y, z = this.z, w = this.w;
                var fSqLength = x * x + y * y + z * z + w * w;

                if (fSqLength === 0.) {
                    q4fDestination.x = 0.;
                    q4fDestination.y = 0.;
                    q4fDestination.z = 0.;
                    q4fDestination.w = 0.;
                } else {
                    var fInvSqLength = 1. / fSqLength;
                    q4fDestination.x = -x * fInvSqLength;
                    q4fDestination.y = -y * fInvSqLength;
                    q4fDestination.z = -z * fInvSqLength;
                    q4fDestination.w = w * fInvSqLength;
                }

                return q4fDestination;
            };

            /**  */ Quat4.prototype.length = function () {
                var x = this.x, y = this.y, z = this.z, w = this.w;
                return math.sqrt(x * x + y * y + z * z + w * w);
            };

            Quat4.prototype.normalize = function (q4fDestination) {
                if (!akra.isDef(q4fDestination)) {
                    q4fDestination = this;
                }

                var x = this.x, y = this.y, z = this.z, w = this.w;

                var fLength = math.sqrt(x * x + y * y + z * z + w * w);

                if (fLength === 0.) {
                    q4fDestination.x = 0.;
                    q4fDestination.y = 0.;
                    q4fDestination.z = 0.;
                    q4fDestination.w = 0.;
                } else {
                    var fInvLength = 1 / fLength;

                    q4fDestination.x = x * fInvLength;
                    q4fDestination.y = y * fInvLength;
                    q4fDestination.z = z * fInvLength;
                    q4fDestination.w = w * fInvLength;
                }

                return q4fDestination;
            };

            Quat4.prototype.calculateW = function (q4fDestination) {
                var x = this.x, y = this.y, z = this.z;

                if (!akra.isDef(q4fDestination)) {
                    this.w = math.sqrt(1. - x * x - y * y - z * z);
                    return this;
                }

                q4fDestination.x = x;
                q4fDestination.y = y;
                q4fDestination.z = z;
                q4fDestination.w = math.sqrt(1. - x * x - y * y - z * z);

                return q4fDestination;
            };

            Quat4.prototype.isEqual = function (q4fQuat, fEps, asMatrix) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if (typeof asMatrix === "undefined") { asMatrix = false; }
                var x1 = this.x, y1 = this.y, z1 = this.z, w1 = this.w;
                var x2 = q4fQuat.x, y2 = q4fQuat.y, z2 = q4fQuat.z, w2 = q4fQuat.w;

                var fLength1 = math.sqrt(x1 * x1 + y1 * y1 + z1 * z1 + w1 * w1);
                var fLength2 = math.sqrt(x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2);

                if (math.abs(fLength2 - fLength2) > fEps) {
                    return false;
                }

                var cosHalfTheta = (x1 * x2 + y1 * y2 + z1 * z2 + w1 * w2) / fLength1 / fLength2;

                if (asMatrix) {
                    cosHalfTheta = math.abs(cosHalfTheta);
                }

                if (1. - cosHalfTheta > fEps) {
                    return false;
                }
                return true;
            };

            Quat4.prototype.getYaw = function () {
                var fYaw;

                var x = this.x, y = this.y, z = this.z, w = this.w;

                var fx2 = x * 2.;
                var fy2 = y * 2.;

                if (math.abs(x) == math.abs(w)) {
                    //вырожденный случай обрабатывается отдельно
                    //
                    var wTemp = w * math.sqrt(2.);

                    //cos(Yaw/2)*cos(Roll/2) + sin(Yaw/2)*sin(Roll/2) = cos((Yaw-Roll)/2); Roll = 0;
                    //x==-w
                    //cos(Yaw/2)*cos(Roll/2) - sin(Yaw/2)*sin(Roll/2) = cos((Yaw+Roll)/2); Roll = 0;
                    var yTemp = y * math.sqrt(2.);

                    //sin(Yaw/2)*cos(Roll/2) - cos(Yaw/2)*sin(Roll/2) = sin((Yaw-Roll)/2); Roll = 0;
                    //x==-w
                    //sin(Yaw/2)*cos(Roll/2) + cos(Yaw/2)*sin(Roll/2) = sin((Yaw+Roll)/2); Roll = 0;
                    fYaw = math.atan2(yTemp, wTemp) * 2.;

                    //fRoll = 0;
                    //убираем дополнительный оборот
                    var pi = math.PI;
                    if (fYaw > pi) {
                        fYaw -= pi;
                        //fRoll = (x == w) ? -pi : pi;
                    } else if (fYaw < -pi) {
                        fYaw += pi;
                        //fRoll = (x == w) ? pi : -pi;
                    }
                } else {
                    //Math.atan2(sin(Yaw)*cos(Pitch),cos(Yaw)*cos(Pitch));
                    fYaw = math.atan2(fx2 * z + fy2 * w, 1. - (fx2 * x + fy2 * y));
                }

                return fYaw;
            };

            Quat4.prototype.getPitch = function () {
                var fPitch;

                var x = this.x, y = this.y, z = this.z, w = this.w;

                var fx2 = x * 2.;
                var fy2 = y * 2.;

                var fSinPitch = math.clamp(fx2 * w - fy2 * z, -1., 1.);
                fPitch = math.asin(fSinPitch);

                return fPitch;
            };

            Quat4.prototype.getRoll = function () {
                var fRoll;

                var x = this.x, y = this.y, z = this.z, w = this.w;

                var fx2 = x * 2.;
                var fz2 = z * 2.;

                if (math.abs(x) == math.abs(w)) {
                    //вырожденный случай обрабатывается отдельно
                    //
                    var wTemp = w * math.sqrt(2.);

                    //cos(Yaw/2)*cos(Roll/2) + sin(Yaw/2)*sin(Roll/2) = cos((Yaw-Roll)/2); Roll = 0;
                    //x==-w
                    //cos(Yaw/2)*cos(Roll/2) - sin(Yaw/2)*sin(Roll/2) = cos((Yaw+Roll)/2); Roll = 0;
                    var yTemp = y * math.sqrt(2.);

                    //sin(Yaw/2)*cos(Roll/2) - cos(Yaw/2)*sin(Roll/2) = sin((Yaw-Roll)/2); Roll = 0;
                    //x==-w
                    //sin(Yaw/2)*cos(Roll/2) + cos(Yaw/2)*sin(Roll/2) = sin((Yaw+Roll)/2); Roll = 0;
                    var fYaw = math.atan2(yTemp, wTemp) * 2.;
                    fRoll = 0.;

                    //убираем дополнительный оборот
                    var pi = math.PI;
                    if (fYaw > pi) {
                        //fYaw -= pi;
                        fRoll = (x == w) ? -pi : pi;
                    } else if (fYaw < -pi) {
                        //fYaw += pi;
                        fRoll = (x == w) ? pi : -pi;
                    }
                } else {
                    //Math.atan2(cos(Pitch) * sin(Roll),cos(Pitch)*cos(Roll));
                    fRoll = math.atan2(fx2 * y + fz2 * w, 1. - (fx2 * x + fz2 * z));
                }

                return fRoll;
            };

            Quat4.prototype.toYawPitchRoll = function (v3fDestination) {
                if (!akra.isDef(v3fDestination)) {
                    v3fDestination = new math.Vec3();
                }

                var fYaw, fPitch, fRoll;

                var x = this.x, y = this.y, z = this.z, w = this.w;

                var fx2 = x * 2.;
                var fy2 = y * 2.;
                var fz2 = z * 2.;
                var fw2 = w * 2.;

                var fSinPitch = math.clamp(fx2 * w - fy2 * z, -1., 1.);
                fPitch = math.asin(fSinPitch);

                //не известен знак косинуса, как следствие это потребует дополнительной проверки.
                //как показала практика - это не на что не влияет, просто один и тот же кватернион можно получить двумя разными вращениями
                if (math.abs(x) == math.abs(w)) {
                    //вырожденный случай обрабатывается отдельно
                    //
                    var wTemp = w * math.sqrt(2.);

                    //cos(Yaw/2)*cos(Roll/2) + sin(Yaw/2)*sin(Roll/2) = cos((Yaw-Roll)/2); Roll = 0;
                    //x==-w
                    //cos(Yaw/2)*cos(Roll/2) - sin(Yaw/2)*sin(Roll/2) = cos((Yaw+Roll)/2); Roll = 0;
                    var yTemp = y * math.sqrt(2.);

                    //sin(Yaw/2)*cos(Roll/2) - cos(Yaw/2)*sin(Roll/2) = sin((Yaw-Roll)/2); Roll = 0;
                    //x==-w
                    //sin(Yaw/2)*cos(Roll/2) + cos(Yaw/2)*sin(Roll/2) = sin((Yaw+Roll)/2); Roll = 0;
                    fYaw = math.atan2(yTemp, wTemp) * 2.;
                    fRoll = 0.;

                    //убираем дополнительный оборот
                    var pi = math.PI;
                    if (fYaw > pi) {
                        fYaw -= pi;
                        fRoll = (x == w) ? -pi : pi;
                    } else if (fYaw < -pi) {
                        fYaw += pi;
                        fRoll = (x == w) ? pi : -pi;
                    }
                } else {
                    //Math.atan2(sin(Yaw)*cos(Pitch),cos(Yaw)*cos(Pitch));
                    fYaw = math.atan2(fx2 * z + fy2 * w, 1. - (fx2 * x + fy2 * y));

                    //Math.atan2(cos(Pitch) * sin(Roll),cos(Pitch)*cos(Roll));
                    fRoll = math.atan2(fx2 * y + fz2 * w, 1. - (fx2 * x + fz2 * z));
                }

                v3fDestination.x = fYaw;
                v3fDestination.y = fPitch;
                v3fDestination.z = fRoll;

                return v3fDestination;
            };

            Quat4.prototype.toMat3 = function (m3fDestination) {
                if (!akra.isDef(m3fDestination)) {
                    m3fDestination = new math.Mat3();
                }
                var pDataDestination = m3fDestination.data;

                var x = this.x, y = this.y, z = this.z, w = this.w;

                //потом необходимо ускорить
                pDataDestination[math.__a11] = 1. - 2. * (y * y + z * z);
                pDataDestination[math.__a12] = 2. * (x * y - z * w);
                pDataDestination[math.__a13] = 2. * (x * z + y * w);

                pDataDestination[math.__a21] = 2. * (x * y + z * w);
                pDataDestination[math.__a22] = 1. - 2. * (x * x + z * z);
                pDataDestination[math.__a23] = 2. * (y * z - x * w);

                pDataDestination[math.__a31] = 2. * (x * z - y * w);
                pDataDestination[math.__a32] = 2. * (y * z + x * w);
                pDataDestination[math.__a33] = 1. - 2. * (x * x + y * y);

                return m3fDestination;
            };

            Quat4.prototype.toMat4 = function (m4fDestination) {
                var m4fDest = akra.isDef(m4fDestination) ? m4fDestination : new math.Mat4();

                //if (!isDef(m4fDestination)) {
                //	m4fDestination = new Mat4();
                //}
                var pDataDestination = m4fDest.data;

                var x = this.x, y = this.y, z = this.z, w = this.w;

                //потом необходимо ускорить
                pDataDestination[math.__11] = 1. - 2. * (y * y + z * z);
                pDataDestination[math.__12] = 2. * (x * y - z * w);
                pDataDestination[math.__13] = 2. * (x * z + y * w);
                pDataDestination[math.__14] = 0.;

                pDataDestination[math.__21] = 2. * (x * y + z * w);
                pDataDestination[math.__22] = 1. - 2. * (x * x + z * z);
                pDataDestination[math.__23] = 2. * (y * z - x * w);
                pDataDestination[math.__24] = 0.;

                pDataDestination[math.__31] = 2. * (x * z - y * w);
                pDataDestination[math.__32] = 2. * (y * z + x * w);
                pDataDestination[math.__33] = 1. - 2. * (x * x + y * y);
                pDataDestination[math.__34] = 0.;

                pDataDestination[math.__41] = 0.;
                pDataDestination[math.__42] = 0.;
                pDataDestination[math.__43] = 0.;
                pDataDestination[math.__44] = 1.;

                return m4fDest;
            };

            /**  */ Quat4.prototype.toString = function () {
                return "[x: " + this.x + ", y: " + this.y + ", z: " + this.z + ", w: " + this.w + "]";
            };

            Quat4.prototype.mix = function (q4fQuat, fA, q4fDestination, bShortestPath) {
                if (typeof bShortestPath === "undefined") { bShortestPath = true; }
                if (!akra.isDef(q4fDestination)) {
                    q4fDestination = this;
                }

                fA = math.clamp(fA, 0, 1);

                var x1 = this.x, y1 = this.y, z1 = this.z, w1 = this.w;
                var x2 = q4fQuat.x, y2 = q4fQuat.y, z2 = q4fQuat.z, w2 = q4fQuat.w;

                //скалярное произведение
                var fCos = x1 * x2 + y1 * y2 + z1 * z2 + w1 * w2;

                if (fCos < 0. && bShortestPath) {
                    x2 = -x2;
                    y2 = -y2;
                    z2 = -z2;
                    w2 = -w2;
                }

                var k1 = 1. - fA;
                var k2 = fA;

                q4fDestination.x = x1 * k1 + x2 * k2;
                q4fDestination.y = y1 * k1 + y2 * k2;
                q4fDestination.z = z1 * k1 + z2 * k2;
                q4fDestination.w = w1 * k1 + w2 * k2;

                return q4fDestination;
            };

            Quat4.prototype.smix = function (q4fQuat, fA, q4fDestination, bShortestPath) {
                if (typeof bShortestPath === "undefined") { bShortestPath = true; }
                if (!akra.isDef(q4fDestination)) {
                    q4fDestination = this;
                }

                fA = math.clamp(fA, 0, 1);

                var x1 = this.x, y1 = this.y, z1 = this.z, w1 = this.w;
                var x2 = q4fQuat.x, y2 = q4fQuat.y, z2 = q4fQuat.z, w2 = q4fQuat.w;

                //скалярное произведение
                var fCos = x1 * x2 + y1 * y2 + z1 * z2 + w1 * w2;

                if (fCos < 0 && bShortestPath) {
                    fCos = -fCos;
                    x2 = -x2;
                    y2 = -y2;
                    z2 = -z2;
                    w2 = -w2;
                }

                var fEps = 1e-3;
                if (math.abs(fCos) < 1. - fEps) {
                    var fSin = math.sqrt(1. - fCos * fCos);
                    var fInvSin = 1. / fSin;

                    var fAngle = math.atan2(fSin, fCos);

                    var k1 = math.sin((1. - fA) * fAngle) * fInvSin;
                    var k2 = math.sin(fA * fAngle) * fInvSin;

                    q4fDestination.x = x1 * k1 + x2 * k2;
                    q4fDestination.y = y1 * k1 + y2 * k2;
                    q4fDestination.z = z1 * k1 + z2 * k2;
                    q4fDestination.w = w1 * k1 + w2 * k2;
                } else {
                    //два кватерниона или очень близки (тогда можно делать линейную интерполяцию)
                    //или два кватениона диаметрально противоположны, тогда можно интерполировать любым способом
                    //позже надо будет реализовать какой-нибудь, а пока тоже линейная интерполяция
                    var k1 = 1 - fA;
                    var k2 = fA;

                    var x = x1 * k1 + x2 * k2;
                    var y = y1 * k1 + y2 * k2;
                    var z = z1 * k1 + z2 * k2;
                    var w = w1 * k1 + w2 * k2;

                    // и нормализуем так-как мы сошли со сферы
                    var fLength = math.sqrt(x * x + y * y + z * z + w * w);
                    var fInvLen = fLength ? 1 / fLength : 0;

                    q4fDestination.x = x * fInvLen;
                    q4fDestination.y = y * fInvLen;
                    q4fDestination.z = z * fInvLen;
                    q4fDestination.w = w * fInvLen;
                }

                return q4fDestination;
            };

            Quat4.fromForwardUp = function (v3fForward, v3fUp, q4fDestination) {
                if (!akra.isDef(q4fDestination)) {
                    q4fDestination = new Quat4();
                }

                var fForwardX = v3fForward.x, fForwardY = v3fForward.y, fForwardZ = v3fForward.z;
                var fUpX = v3fUp.x, fUpY = v3fUp.y, fUpZ = v3fUp.z;

                var m3fTemp = math.Mat3.temp();
                var pTempData = m3fTemp.data;

                pTempData[math.__a11] = fUpY * fForwardZ - fUpZ * fForwardY;
                pTempData[math.__a12] = fUpX;
                pTempData[math.__a13] = fForwardX;

                pTempData[math.__a21] = fUpZ * fForwardX - fUpX * fForwardZ;
                pTempData[math.__a22] = fUpY;
                pTempData[math.__a23] = fForwardY;

                pTempData[math.__a31] = fUpX * fForwardY - fUpY * fForwardX;
                pTempData[math.__a32] = fUpZ;
                pTempData[math.__a33] = fForwardZ;

                return m3fTemp.toQuat4(q4fDestination);
            };

            Quat4.fromAxisAngle = function (v3fAxis, fAngle, q4fDestination) {
                if (!akra.isDef(q4fDestination)) {
                    q4fDestination = new Quat4();
                }

                var x = v3fAxis.x, y = v3fAxis.y, z = v3fAxis.z;

                var fLength = math.sqrt(x * x + y * y + z * z);

                if (fLength === 0.) {
                    q4fDestination.x = q4fDestination.y = q4fDestination.z = 0;
                    q4fDestination.w = 1;
                    return q4fDestination;
                }

                var fInvLength = 1 / fLength;

                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;

                var fSin = math.sin(fAngle / 2);
                var fCos = math.cos(fAngle / 2);

                q4fDestination.x = x * fSin;
                q4fDestination.y = y * fSin;
                q4fDestination.z = z * fSin;
                q4fDestination.w = fCos;

                return q4fDestination;
            };

            Quat4.fromYawPitchRoll = function (arg1, arg2, arg3, arg4) {
                var fYaw = 0.0, fPitch = 0.0, fRoll = 0.0, q4fDestination = null;
                if (arguments.length <= 2) {
                    var v3fVec = arg1;

                    fYaw = v3fVec.x;
                    fPitch = v3fVec.y;
                    fRoll = v3fVec.z;

                    q4fDestination = arg2;
                } else {
                    fYaw = arg1;
                    fPitch = arg2;
                    fRoll = arg3;
                    q4fDestination = arg4;
                }

                if (!akra.isDef(q4fDestination)) {
                    q4fDestination = new Quat4();
                }

                var fHalfYaw = fYaw * 0.5;
                var fHalfPitch = fPitch * 0.5;
                var fHalfRoll = fRoll * 0.5;

                var fCos1 = math.cos(fHalfYaw), fSin1 = math.sin(fHalfYaw);
                var fCos2 = math.cos(fHalfPitch), fSin2 = math.sin(fHalfPitch);
                var fCos3 = math.cos(fHalfRoll), fSin3 = math.sin(fHalfRoll);

                q4fDestination.x = fCos1 * fSin2 * fCos3 + fSin1 * fCos2 * fSin3;
                q4fDestination.y = fSin1 * fCos2 * fCos3 - fCos1 * fSin2 * fSin3;
                q4fDestination.z = fCos1 * fCos2 * fSin3 - fSin1 * fSin2 * fCos3;
                q4fDestination.w = fCos1 * fCos2 * fCos3 + fSin1 * fSin2 * fSin3;

                return q4fDestination;
            };

            Quat4.fromXYZ = function (fX, fY, fZ, q4fDestination) {
                if (arguments.length <= 2) {
                    //Vec3 + m4fDestination
                    var v3fVec = arguments[0];
                    return Quat4.fromYawPitchRoll(v3fVec.y, v3fVec.x, v3fVec.z, arguments[1]);
                } else {
                    //fX fY fZ m4fDestination
                    //var fX: float = arguments[0];
                    //var fY: float = arguments[1];
                    //var fZ: float = arguments[2];
                    return Quat4.fromYawPitchRoll(fY, fX, fZ, arguments[3]);
                }
            };

            Quat4.temp = function () {
                iElement = (iElement === pBuffer.length - 1 ? 0 : iElement);
                var p = pBuffer[iElement++];
                var nArgumentsLength = arguments.length;

                if (nArgumentsLength === 0) {
                    p.x = p.y = p.z = 0.;
                    p.w = 1.;
                } else if (nArgumentsLength === 1) {
                    if (arguments[0] instanceof Quat4) {
                        var q4fQuat = arguments[0];

                        p.x = q4fQuat.x;
                        p.y = q4fQuat.y;
                        p.z = q4fQuat.z;
                        p.w = q4fQuat.w;
                    } else {
                        //Array
                        var pElements = arguments[0];

                        p.x = pElements[0];
                        p.y = pElements[1];
                        p.z = pElements[2];
                        p.w = pElements[3];
                    }
                } else if (nArgumentsLength === 2) {
                    //float float
                    //vec3 float
                    if (akra.isFloat(arguments[0])) {
                        //float float
                        var fValue = arguments[0];

                        p.x = fValue;
                        p.y = fValue;
                        p.z = fValue;
                        p.w = arguments[1];
                    } else {
                        //vec3 float
                        var v3fValue = arguments[0];

                        p.x = v3fValue.x;
                        p.y = v3fValue.y;
                        p.z = v3fValue.z;
                        p.w = arguments[1];
                    }
                } else if (nArgumentsLength === 4) {
                    p.x = arguments[0];
                    p.y = arguments[1];
                    p.z = arguments[2];
                    p.w = arguments[3];
                }

                return p;
            };
            return Quat4;
        })();
        math.Quat4 = Quat4;

        pBuffer = akra.gen.array(256, Quat4);
        iElement = 0;
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
/// <reference path="matrixIndecies.ts" />
/// <reference path="Vec2.ts" />
/// <reference path="Vec3.ts" />
/// <reference path="Vec4.ts" />
/// <reference path="Mat3.ts" />
/// <reference path="Mat4.ts" />
/// <reference path="Quat4.ts" />
var akra;
(function (akra) {
    (function (math) {
        math.E = Math.E;
        math.LN2 = Math.LN2;
        math.LOG2E = Math.LOG2E;
        math.LOG10E = Math.LOG10E;
        math.PI = Math.PI;
        math.SQRT1_2 = Math.SQRT1_2;
        math.SQRT2 = Math.SQRT2;
        math.LN10 = Math.LN10;

        math.POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
        math.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY;

        math.FLOAT_PRECISION = (3.4e-8);
        math.TWO_PI = (2.0 * math.PI);
        math.HALF_PI = (math.PI / 2.0);
        math.QUARTER_PI = (math.PI / 4.0);
        math.EIGHTH_PI = (math.PI / 8.0);
        math.PI_SQUARED = (9.86960440108935861883449099987615113531369940724079);
        math.PI_INVERSE = (0.31830988618379067153776752674502872406891929148091);
        math.PI_OVER_180 = (math.PI / 180);
        math.PI_DIV_180 = (180 / math.PI);
        math.NATURAL_LOGARITHM_BASE = (2.71828182845904523536028747135266249775724709369996);
        math.EULERS_CONSTANT = (0.57721566490153286060651);
        math.SQUARE_ROOT_2 = (1.41421356237309504880168872420969807856967187537695);
        math.INVERSE_ROOT_2 = (0.707106781186547524400844362105198);
        math.SQUARE_ROOT_3 = (1.73205080756887729352744634150587236694280525381038);
        math.SQUARE_ROOT_5 = (2.23606797749978969640917366873127623544061835961153);
        math.SQUARE_ROOT_10 = (3.16227766016837933199889354443271853371955513932522);
        math.CUBE_ROOT_2 = (1.25992104989487316476721060727822835057025146470151);
        math.CUBE_ROOT_3 = (1.44224957030740838232163831078010958839186925349935);
        math.FOURTH_ROOT_2 = (1.18920711500272106671749997056047591529297209246382);
        math.NATURAL_LOG_2 = (0.69314718055994530941723212145817656807550013436026);
        math.NATURAL_LOG_3 = (1.09861228866810969139524523692252570464749055782275);
        math.NATURAL_LOG_10 = (2.30258509299404568401799145468436420760110148862877);
        math.NATURAL_LOG_PI = (1.14472988584940017414342735135305871164729481291531);
        math.BASE_TEN_LOG_PI = (0.49714987269413385435126828829089887365167832438044);
        math.NATURAL_LOGARITHM_BASE_INVERSE = (0.36787944117144232159552377016146086744581113103177);
        math.NATURAL_LOGARITHM_BASE_SQUARED = (7.38905609893065022723042746057500781318031557055185);
        math.GOLDEN_RATIO = ((math.SQUARE_ROOT_5 + 1.0) / 2.0);
        math.DEGREE_RATIO = (math.PI_DIV_180);
        math.RADIAN_RATIO = (math.PI_OVER_180);
        math.GRAVITY_CONSTANT = 9.81;

        math.abs = Math.abs;
        math.acos = Math.acos;
        math.asin = Math.asin;
        math.atan = Math.atan;
        math.atan2 = Math.atan2;
        math.exp = Math.exp;
        math.min = Math.min;
        math.random = Math.random;
        math.sqrt = Math.sqrt;
        math.log = Math.log;
        math.round = Math.round;
        math.floor = Math.floor;
        math.ceil = Math.ceil;
        math.sin = Math.sin;
        math.cos = Math.cos;
        math.tan = Math.tan;
        math.pow = Math.pow;
        math.max = Math.max;

        /*
        -----------------------------------------------------------------
        Floating Point Macros
        -----------------------------------------------------------------
        */
        // reinterpret a float as an int32
        /** @ */
        math.fpBits = function (f) {
            return math.floor(f);
        };

        // reinterpret an int32 as a float
        /** @ */
        math.intBits = function (i) {
            return i;
        };

        // return 0 or -1 based on the sign of the float
        /** @ */
        math.fpSign = function (f) {
            return (f >> 31);
        };

        // extract the 8 bits of exponent as a signed integer
        // by masking out this bits, shifting down by 23,
        // and subtracting the bias value of 127
        /** @ */
        math.fpExponent = function (f) {
            return (((math.fpBits(f) & 0x7fffffff) >> 23) - 127);
        };

        // return 0 or -1 based on the sign of the exponent
        /** @ */
        math.fpExponentSign = function (f) {
            return (math.fpExponent(f) >> 31);
        };

        // get the 23 bits of mantissa without the implied bit
        /** @ */
        math.fpPureMantissa = function (f) {
            return ((math.fpBits(f) & 0x7fffff));
        };

        // get the 23 bits of mantissa with the implied bit replaced
        /** @ */
        math.fpMantissa = function (f) {
            return (math.fpPureMantissa(f) | (1 << 23));
        };

        math.fpOneBits = 0x3F800000;

        // flipSign is a helper Macro to
        // invert the sign of i if flip equals -1,
        // if flip equals 0, it does nothing
        //export var flipSign = (i, flip) ((i^ flip) - flip)
        /** @ */
        math.flipSign = function (i, flip) {
            return ((flip == -1) ? -i : i);
        };

        /**
        * Число положительно?
        */
        math.isPositive = function (a) {
            return (a >= 0);
        };

        /**
        * Число отрицательно?
        */
        math.isNegative = function (a) {
            return (a < 0);
        };

        /**
        * Число одного знака?
        */
        math.sameSigns = function (a, b) {
            return (math.isNegative(a) == math.isNegative(b));
        };

        /**
        * Копировать знак
        */
        math.copySign = function (a, b) {
            return (math.isNegative(b) ? -math.abs(a) : math.abs(a));
        };

        /**
        * Растояние между а и b меньше epsilon?
        */
        math.deltaRangeTest = function (a, b, epsilon) {
            if (typeof epsilon === "undefined") { epsilon = 0.0000001; }
            return ((math.abs(a - b) < epsilon) ? true : false);
        };

        /**
        * Ограничивает value интервалом [low,high]
        */
        math.clamp = function (value, low, high) {
            return math.max(low, math.min(value, high));
        };

        /**
        * Ограничивает value интервалом [0,+Infinity]
        */
        math.clampPositive = function (value) {
            return (value < 0 ? 0 : value);
        };

        /**
        * Ограничивает value интервалом [-Infinity,0]
        */
        math.clampNegative = function (value) {
            return (value > 0 ? 0 : value);
        };

        /**
        * Ограничивает value интервалом [-1,1]
        */
        math.clampUnitSize = function (value) {
            return math.clamp(value, -1, 1);
        };
        math.sign = function (value) {
            return value >= 0 ? 1 : -1;
        };

        /**
        * Номер с права начиная от нуля, самого левого установленного бита
        */
        math.highestBitSet = function (value) {
            return value == 0 ? (null) : (value < 0 ? 31 : ((math.log(value) / math.LN2) << 0));
        };

        /**
        * Номер с права начиная от нуля, самого правого установленного бита
        */
        math.lowestBitSet = function (value) {
            var temp;

            if (value == 0) {
                return null;
            }

            for (temp = 0; temp <= 31; temp++) {
                if (value & (1 << temp)) {
                    return temp;
                }
            }

            return null;
        };

        /**
        * Является ли число степенью двойки
        */
        math.isPowerOfTwo = function (value) {
            return (value > 0 && math.highestBitSet(value) == math.lowestBitSet(value));
        };

        /**
        * Округление до числа наиболее близкого к степени двойки
        */
        math.nearestPowerOfTwo = function (value) {
            if (value <= 1) {
                return 1;
            }

            var highestBit = math.highestBitSet(value);
            var roundingTest = value & (1 << (highestBit - 1));

            if (roundingTest != 0) {
                ++highestBit;
            }

            return 1 << highestBit;
        };

        /**
        * Округление до следующего числа являющегося к степени двойки
        */
        math.ceilingPowerOfTwo = function (value) {
            if (value <= 1) {
                return 1;
            }

            var highestBit = math.highestBitSet(value);
            var mask = value & ((1 << highestBit) - 1);

            highestBit += mask && 1;

            return 1 << highestBit;
        };

        /**
        * Округление до предыдущего числа являющегося к степени двойки
        */
        math.floorPowerOfTwo = function (value) {
            if (value <= 1) {
                return 1;
            }

            var highestBit = math.highestBitSet(value);
            return 1 << highestBit;
        };

        /**
        * Деление по модулю
        */
        math.modulus = function (e, divisor) {
            akra.debug.assert(!!divisor, "invalid divisor used");
            return (e - math.floor(e / divisor) * divisor);
        };

        /**
        *
        */
        math.mod = math.modulus;

        /**
        * Вырвнивание числа на alignment вверх
        */
        math.alignUp = function (value, alignment) {
            var iRemainder = math.modulus(value, alignment);
            if (iRemainder == 0) {
                return (value);
            }
            return (value + (alignment - iRemainder));
        };

        /**
        * Вырвнивание числа на alignment вниз
        */
        math.alignDown = function (value, alignment) {
            var remainder = math.modulus(value, alignment);

            if (remainder == 0) {
                return (value);
            }

            return (value - remainder);
        };

        /**
        * пнвертировать число
        */
        math.inverse = function (a) {
            return 1. / a;
        };

        /**
        * log base 2
        */
        math.log2 = function (f) {
            return math.log(f) / math.LN2;
        };

        /**
        * Округлени числа с определенной точностью, где округляется до значащих чисел как 1/(2^precision)
        */
        math.trimFloat = function (f, precision) {
            return f;
        };

        /**
        * Перевод дробного в целое с усеением
        */
        math.realToInt32_chop = function (a) {
            return math.round(a);
        };

        /**
        * Перевод дробного в целое до меньшего
        */
        math.realToInt32_floor = function (a) {
            return math.floor(a);
        };

        /**
        * Перевод дробного в целое до большего
        */
        math.realToInt32_ceil = function (a) {
            return math.ceil(a);
        };

        /**
        * Наибольший общий делитель
        */
        math.nod = function (n, m) {
            var p = n % m;

            while (p != 0) {
                n = m;
                m = p;
                p = n % m;
            }

            return m;
        };

        /**
        * Наименьшее общее кратное
        */
        math.nok = function (n, m) {
            return math.abs(n * m) / math.nod(n, m);
        };

        /**
        * Greatest common devider
        */
        math.gcd = math.nod;

        /**
        * Least common multiple
        */
        math.lcm = math.nok;

        // var pMat3Stack = new Array(100);
        // var iMat3StackIndex = 0;
        math.isRealEqual = function (a, b, tolerance) {
            if (typeof tolerance === "undefined") { tolerance = 1.19209e-007; }
            if (math.abs(b - a) <= tolerance)
                return true;
            else
                return false;
        };

        function calcPOTtextureSize(nPixels) {
            var w, h;
            var n = nPixels;

            w = Math.ceil(Math.log(n) / Math.LN2 / 2.0);
            h = Math.ceil(Math.log(n / Math.pow(2, w)) / Math.LN2);
            w = Math.pow(2, w);
            h = Math.pow(2, h);
            n = w * h;

            return [w, h, n];
        }
        math.calcPOTtextureSize = calcPOTtextureSize;

        function floatToFloat3(value) {
            var data = value;
            var result = math.Vec3.temp(0.);

            if (data == 0.) {
                var signedZeroTest = 1. / value;
                if (signedZeroTest < 0.) {
                    result.x = 128.;
                }
                return result;
            }

            if (data < 0.) {
                result.x = 128.;
                data = -data;
            }

            var power = 0.;
            var counter = 0.;

            while (counter < 64.) {
                counter += 1.;
                if (data >= 2.) {
                    data = data * 0.5;
                    power += 1.;
                    if (power == 63.) {
                        counter = 65.;
                    }
                } else {
                    if (data < 1.) {
                        data = data * 2.;
                        power -= 1.;
                        if (power == -62.) {
                            counter = 65.;
                        }
                    } else {
                        counter = 65.;
                    }
                }
            }

            if (power == -62. && data < 1.) {
                power = 0.;
            } else {
                power = power + 63.;
                data = data - 1.;
            }

            result.x += power;
            data *= 256.;
            result.y = math.floor(data);

            data -= math.floor(data);
            data *= 256.;

            result.z = math.floor(data);
            return result;
        }
        math.floatToFloat3 = floatToFloat3;
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EIO) {
        EIO[EIO["IN"] = 0x01] = "IN";
        EIO[EIO["OUT"] = 0x02] = "OUT";
        EIO[EIO["ATE"] = 0x04] = "ATE";
        EIO[EIO["APP"] = 0x08] = "APP";
        EIO[EIO["TRUNC"] = 0x10] = "TRUNC";
        EIO[EIO["BINARY"] = 0x20] = "BINARY";
        EIO[EIO["TEXT"] = 0x40] = "TEXT";
        EIO[EIO["JSON"] = 0x80] = "JSON";
        EIO[EIO["URL"] = 0x100] = "URL";

        EIO[EIO["BIN"] = 0x20] = "BIN";
    })(akra.EIO || (akra.EIO = {}));
    var EIO = akra.EIO;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EFileTransferModes) {
        EFileTransferModes[EFileTransferModes["k_Normal"] = 0] = "k_Normal";
        EFileTransferModes[EFileTransferModes["k_Fast"] = 1] = "k_Fast";
        EFileTransferModes[EFileTransferModes["k_Slow"] = 2] = "k_Slow";
    })(akra.EFileTransferModes || (akra.EFileTransferModes = {}));
    var EFileTransferModes = akra.EFileTransferModes;
})(akra || (akra = {}));
/// <reference path="IManager.ts" />
/// <reference path="IThread.ts" />
var akra;
(function (akra) {
    var x = 0;
    function guid() {
        return ++x;
    }
    akra.guid = guid;
})(akra || (akra = {}));
/// <reference path="../idl/IBrowserInfo.ts" />
/// <reference path="../util/Singleton.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var akra;
(function (akra) {
    (function (info) {
        var Singleton = akra.util.Singleton;

        var BrowserInfo = (function (_super) {
            __extends(BrowserInfo, _super);
            function BrowserInfo() {
                _super.call(this);
                this._sBrowser = null;
                this._sVersion = null;
                this._sOS = null;
                this._sVersionSearch = null;

                this.init();
            }
            BrowserInfo.prototype.getName = function () {
                return this._sBrowser;
            };

            BrowserInfo.prototype.getVersion = function () {
                return this._sVersion;
            };

            BrowserInfo.prototype.getOS = function () {
                return this._sOS;
            };

            BrowserInfo.prototype.init = function () {
                this._sBrowser = this.searchString(BrowserInfo.dataBrowser) || "An unknown browser";
                this._sVersion = this.searchVersion(navigator.userAgent) || this.searchVersion(navigator.appVersion) || "an unknown version";
                this._sOS = this.searchString(BrowserInfo.dataOS) || "an unknown OS";
            };

            BrowserInfo.prototype.searchString = function (pDataBrowser) {
                for (var i = 0; i < pDataBrowser.length; i++) {
                    var sData = pDataBrowser[i].string;
                    var dataProp = pDataBrowser[i].prop;

                    this._sVersionSearch = pDataBrowser[i].versionSearch || pDataBrowser[i].identity;

                    if (sData) {
                        if (sData.indexOf(pDataBrowser[i].subString) != -1) {
                            return pDataBrowser[i].identity;
                        }
                    } else if (dataProp) {
                        return pDataBrowser[i].identity;
                    }
                }
                return null;
            };

            BrowserInfo.prototype.searchVersion = function (sData) {
                var iStartIndex = sData.indexOf(this._sVersionSearch);

                if (iStartIndex == -1) {
                    return null;
                }

                iStartIndex = sData.indexOf('/', iStartIndex + 1);

                if (iStartIndex == -1) {
                    return null;
                }

                var iEndIndex = sData.indexOf(' ', iStartIndex + 1);

                if (iEndIndex == -1) {
                    iEndIndex = sData.indexOf(';', iStartIndex + 1);
                    if (iEndIndex == -1) {
                        return null;
                    }
                    return sData.slice(iStartIndex + 1);
                }

                return sData.slice((iStartIndex + 1), iEndIndex);
            };

            BrowserInfo.dataBrowser = [
                {
                    string: navigator.userAgent,
                    subString: "Chrome",
                    identity: "Chrome"
                },
                {
                    string: navigator.userAgent,
                    subString: "OmniWeb",
                    versionSearch: "OmniWeb/",
                    identity: "OmniWeb"
                },
                {
                    string: navigator.vendor,
                    subString: "Apple",
                    identity: "Safari",
                    versionSearch: "Version"
                },
                {
                    string: null,
                    subString: null,
                    prop: window.opera,
                    identity: "Opera",
                    versionSearch: "Version"
                },
                {
                    string: navigator.vendor,
                    subString: "iCab",
                    identity: "iCab"
                },
                {
                    string: navigator.vendor,
                    subString: "KDE",
                    identity: "Konqueror"
                },
                {
                    string: navigator.userAgent,
                    subString: "Firefox",
                    identity: "Firefox"
                },
                {
                    string: navigator.vendor,
                    subString: "Camino",
                    identity: "Camino"
                },
                {
                    // for newer Netscapes (6+)
                    string: navigator.userAgent,
                    subString: "Netscape",
                    identity: "Netscape"
                },
                {
                    string: navigator.userAgent,
                    subString: "MSIE",
                    identity: "Explorer",
                    versionSearch: "MSIE"
                },
                {
                    string: navigator.userAgent,
                    subString: "Gecko",
                    identity: "Mozilla",
                    versionSearch: "rv"
                },
                {
                    // for older Netscapes (4-)
                    string: navigator.userAgent,
                    subString: "Mozilla",
                    identity: "Netscape",
                    versionSearch: "Mozilla"
                }
            ];

            BrowserInfo.dataOS = [
                {
                    string: navigator.platform,
                    subString: "Win",
                    identity: "Windows"
                },
                {
                    string: navigator.platform,
                    subString: "Mac",
                    identity: "Mac"
                },
                {
                    string: navigator.userAgent,
                    subString: "iPhone",
                    identity: "iPhone/iPod"
                },
                {
                    string: navigator.platform,
                    subString: "Linux",
                    identity: "Linux"
                }
            ];
            return BrowserInfo;
        })(Singleton);
        info.BrowserInfo = BrowserInfo;
    })(akra.info || (akra.info = {}));
    var info = akra.info;
})(akra || (akra = {}));
/// <reference path="EPixelFormats.ts" />
var akra;
(function (akra) {
    function copy(pDst, iDstOffset, pSrc, iSrcOffset, nLength) {
        var dstU8 = new Uint8Array(pDst, iDstOffset, nLength);
        var srcU8 = new Uint8Array(pSrc, iSrcOffset, nLength);
        dstU8.set(srcU8);
    }
    akra.copy = copy;

    /** mem copy from beginning*/
    function copyfb(pDst, pSrc, nLength) {
        copy(pDst, 0, pSrc, 0, nLength);
    }
    akra.copyfb = copyfb;
})(akra || (akra = {}));
/// <reference path="../idl/IBox.ts" />
/// <reference path="../logger.ts" />
/// <reference path="../gen/generate.ts" />
var akra;
(function (akra) {
    (function (geometry) {
        var pBuffer;
        var iElement;

        var Box = (function () {
            function Box() {
                this.left = 0;
                this.top = 0;
                this.front = 0;
                this.right = 0;
                this.bottom = 0;
                this.back = 0;
                this.set.apply(this, arguments);
            }
            Box.prototype.getWidth = function () {
                return this.right - this.left;
            };

            Box.prototype.getHeight = function () {
                return this.bottom - this.top;
            };

            Box.prototype.getDepth = function () {
                return this.back - this.front;
            };

            Box.prototype.set = function () {
                switch (arguments.length) {
                    case 1:
                        this.left = arguments[0].left;
                        this.top = arguments[0].top;
                        this.front = arguments[0].front;

                        this.right = arguments[0].right;
                        this.bottom = arguments[0].bottom;
                        this.back = arguments[0].back;
                        break;

                    case 0:
                        this.left = 0;
                        this.top = 0;
                        this.front = 0;

                        this.right = 1;
                        this.bottom = 1;
                        this.back = 1;
                        break;

                    case 3:
                        this.left = arguments[0];
                        this.top = arguments[1];
                        this.front = arguments[2];

                        this.right = arguments[0] + 1;
                        this.bottom = arguments[1] + 1;
                        this.back = arguments[2] + 1;
                        break;
                    case 6:
                        this.left = arguments[0];
                        this.top = arguments[1];
                        this.front = arguments[2];

                        this.right = arguments[3];
                        this.bottom = arguments[4];
                        this.back = arguments[5];
                        break;
                    case 4:
                        this.left = arguments[0];
                        this.top = arguments[1];
                        this.right = arguments[2];
                        this.bottom = arguments[3];

                        this.back = 1;
                        this.front = 0;
                        break;
                    case 5:
                        akra.logger.error("invalid number of arguments");
                }

                akra.logger.assert(this.right >= this.left && this.bottom >= this.top && this.back >= this.front);

                return this;
            };

            Box.prototype.contains = function (pDest) {
                return (pDest.left >= this.left && pDest.top >= this.top && pDest.front >= this.front && pDest.right <= this.right && pDest.bottom <= this.bottom && pDest.back <= this.back);
            };

            Box.prototype.setPosition = function (iLeft, iTop, iWidth, iHeight, iFront, iDepth) {
                if (typeof iFront === "undefined") { iFront = 0; }
                if (typeof iDepth === "undefined") { iDepth = 1; }
                this.left = iLeft;
                this.top = iTop;
                this.right = iLeft + iWidth;
                this.bottom = iTop + iHeight;
                this.front = iFront;
                this.back = iFront + iDepth;
                return;
            };

            Box.prototype.isEqual = function (pDest) {
                return (pDest.left == this.left && pDest.top == this.top && pDest.front == this.front && pDest.right == this.right && pDest.bottom == this.bottom && pDest.back == this.back);
            };

            Box.prototype.toString = function () {
                return "---------------------------\n" + "left: " + this.left + ", right: " + this.right + "\n" + "top: " + this.top + ", bottom: " + this.bottom + "\n" + "front: " + this.front + ", back: " + this.back + "\n" + "---------------------------";
            };

            Box.temp = function () {
                iElement = (iElement === pBuffer.length - 1 ? 0 : iElement);
                var pBox = pBuffer[iElement++];

                var iLeft = 0, iTop = 0, iFront = 0, iWidth = 0, iHeight = 0, iDepth = 0;

                switch (arguments.length) {
                    case 1:
                        iLeft = arguments[0].left;
                        iTop = arguments[0].top;
                        iFront = arguments[0].front;
                        iWidth = arguments[0].width;
                        iHeight = arguments[0].height;
                        iDepth = arguments[0].depth;
                        break;
                    case 0:
                        iLeft = 0;
                        iTop = 0;
                        iFront = 0;
                        iWidth = 1;
                        iHeight = 1;
                        iDepth = 1;
                        break;
                    case 3:
                        iLeft = arguments[0];
                        iTop = arguments[1];
                        iFront = arguments[2];
                        iWidth = arguments[0] + 1;
                        iHeight = arguments[1] + 1;
                        iDepth = arguments[2] + 1;
                        break;

                    case 6:
                        iLeft = arguments[0];
                        iTop = arguments[1];
                        iFront = arguments[2];
                        iWidth = arguments[3] - arguments[0];
                        iHeight = arguments[4] - arguments[1];
                        iDepth = arguments[5] - arguments[2];
                        break;
                    case 4:
                        iLeft = arguments[0];
                        iTop = arguments[1];
                        iFront = 0;
                        iWidth = arguments[2] - arguments[0];
                        iHeight = arguments[3] - arguments[1];
                        iDepth = 1;
                        break;
                    default:
                        akra.logger.error("Inavlid number of arguments");
                        return null;
                }

                pBox.setPosition(iLeft, iTop, iWidth, iHeight, iFront, iDepth);

                return pBox;
            };
            return Box;
        })();
        geometry.Box = Box;

        pBuffer = akra.gen.array(20, Box);
        iElement = 0;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
/// <reference path="../idl/IColor.ts" />
/// <reference path="../math/math.ts" />
/// <reference path="../gen/generate.ts" />
var akra;
(function (akra) {
    (function (color) {
        var pBuffer;
        var iElement;

        var Color = (function () {
            function Color(r, g, b, a) {
                this.set.apply(this, arguments);
            }
            Color.prototype.getHtml = function () {
                // LOG(this.r, this.g, this.b);
                var r = akra.math.round(this.r * 255).toString(16);
                var g = akra.math.round(this.g * 255).toString(16);
                var b = akra.math.round(this.b * 255).toString(16);
                r = r.length < 2 ? "0" + r : r;
                g = g.length < 2 ? "0" + g : g;
                b = b.length < 2 ? "0" + b : b;

                // LOG(r, g, b);
                return "#" + r + g + b;
            };

            Color.prototype.getHtmlRgba = function () {
                return "rgba(" + akra.math.floor(255 * this.r) + ", " + akra.math.floor(255 * this.g) + ", " + akra.math.floor(255 * this.b) + ", " + this.a + ")";
            };

            Color.prototype.getRgba = function () {
                var val32 = 0;

                // Convert to 32bit pattern
                val32 = (this.a * 255) << 24;
                val32 += (this.b * 255) << 16;
                val32 += (this.g * 255) << 8;
                val32 += (this.r * 255);
                val32 = val32 >>> 0;
                return val32;
            };

            Color.prototype.getArgb = function () {
                var val32 = 0;

                // Convert to 32bit pattern
                val32 = (this.b * 255) << 24;
                val32 += (this.g * 255) << 16;
                val32 += (this.r * 255) << 8;
                val32 += (this.a * 255);
                val32 = val32 >>> 0;
                return val32;
            };

            Color.prototype.getBgra = function () {
                var val32 = 0;

                // Convert to 32bit pattern
                val32 = (this.a * 255) << 24;
                val32 += (this.r * 255) << 16;
                val32 += (this.g * 255) << 8;
                val32 += (this.b * 255);
                val32 = val32 >>> 0;
                return val32;
            };

            Color.prototype.getAbgr = function () {
                var val32 = 0;

                // Convert to 32bit pattern
                val32 = (this.r * 255) << 24;
                val32 += (this.g * 255) << 16;
                val32 += (this.b * 255) << 8;
                val32 += (this.a * 255);
                val32 = val32 >>> 0;
                return val32;
            };

            Color.prototype.setRgba = function (c) {
                var val32 = c;

                // Convert from 32bit pattern
                this.a = ((val32 >> 24) & 0xFF) / 255.0;
                this.b = ((val32 >> 16) & 0xFF) / 255.0;
                this.g = ((val32 >> 8) & 0xFF) / 255.0;
                this.r = (val32 & 0xFF) / 255.0;
            };

            Color.prototype.setArgb = function (c) {
                var val32 = c;

                // Convert from 32bit pattern
                this.b = ((val32 >> 24) & 0xFF) / 255.0;
                this.g = ((val32 >> 16) & 0xFF) / 255.0;
                this.r = ((val32 >> 8) & 0xFF) / 255.0;
                this.a = (val32 & 0xFF) / 255.0;
            };

            Color.prototype.setBgra = function (c) {
                var val32 = c;

                // Convert from 32bit pattern
                this.a = ((val32 >> 24) & 0xFF) / 255.0;
                this.r = ((val32 >> 16) & 0xFF) / 255.0;
                this.g = ((val32 >> 8) & 0xFF) / 255.0;
                this.b = (val32 & 0xFF) / 255.0;
            };

            Color.prototype.setAbgr = function (c) {
                var val32 = c;

                // Convert from 32bit pattern
                this.r = ((val32 >> 24) & 0xFF) / 255.0;
                this.g = ((val32 >> 16) & 0xFF) / 255.0;
                this.b = ((val32 >> 8) & 0xFF) / 255.0;
                this.a = (val32 & 0xFF) / 255.0;
            };

            Color.prototype.set = function (r, g, b, a) {
                switch (arguments.length) {
                    case 0:
                        this.r = this.g = this.b = 0.;
                        this.a = 1.;
                        break;
                    case 1:
                        if (akra.isFloat(arguments[0])) {
                            this.r = this.g = this.b = r;
                            this.a = 1.;
                        } else if (akra.isDef(arguments[0].buffer)) {
                            var c = arguments[0];
                            this.r = c[0];
                            this.g = c[1];
                            this.b = c[2];
                            this.a = c[3];
                        } else if (akra.isString(arguments[0])) {
                            var s = arguments[0].toLowerCase();

                            if (s[0] === '#') {
                                s = s.substr(1);
                            }

                            akra.logger.assert(s.length == 6, "Incorrect color string.");
                            var R = parseInt('0x' + s.substr(0, 2));
                            var G = parseInt('0x' + s.substr(2, 2));
                            var B = parseInt('0x' + s.substr(4, 2));

                            this.set(R / 255., G / 255., B / 255.);
                        } else {
                            var v = arguments[0];
                            this.r = v.r;
                            this.g = v.g;
                            this.b = v.b;
                            this.a = v.a;
                        }
                        break;
                    case 2:
                        this.r = this.g = this.b = r;
                        this.a = g;
                        break;
                    case 3:
                    case 4:
                        this.r = r;
                        this.g = g;
                        this.b = b;
                        this.a = akra.isDef(a) ? a : 1.;
                        break;
                }

                return this;
            };

            Color.prototype.saturate = function () {
                if (this.r < 0.)
                    this.r = 0.;
                else if (this.r > 1.)
                    this.r = 1.;

                if (this.g < 0.)
                    this.g = 0.;
                else if (this.g > 1.)
                    this.g = 1.;

                if (this.b < 0.)
                    this.b = 0.;
                else if (this.b > 1.)
                    this.b = 1.;

                if (this.a < 0.)
                    this.a = 0.;
                else if (this.a > 1.)
                    this.a = 1.;

                return this;
            };

            /** As saturate, except that this colour value is unaffected and
            the saturated colour value is returned as a copy. */
            Color.prototype.saturateCopy = function () {
                var ret = new Color(this);
                ret.saturate();
                return ret;
            };

            Color.prototype.add = function (cColor, ppDest) {
                if (typeof ppDest === "undefined") { ppDest = new Color; }
                ppDest.r = this.r + cColor.r;
                ppDest.g = this.g + cColor.g;
                ppDest.b = this.b + cColor.b;
                ppDest.a = this.a + cColor.a;

                return ppDest;
            };

            Color.prototype.subtract = function (cColor, ppDest) {
                if (typeof ppDest === "undefined") { ppDest = new Color; }
                ppDest.r = this.r - cColor.r;
                ppDest.g = this.g - cColor.g;
                ppDest.b = this.b - cColor.b;
                ppDest.a = this.a - cColor.a;

                return ppDest;
            };

            Color.prototype.multiply = function (fScalar, ppDest) {
                if (typeof ppDest === "undefined") { ppDest = new Color; }
                if (akra.isNumber(fScalar)) {
                    var f = fScalar;
                    ppDest.r = this.r * f;
                    ppDest.g = this.g * f;
                    ppDest.b = this.b * f;
                    ppDest.a = this.a * f;
                } else {
                    var c = arguments[0];
                    ppDest.r = this.r * c.r;
                    ppDest.g = this.g * c.g;
                    ppDest.b = this.b * c.b;
                    ppDest.a = this.a * c.a;
                }

                return ppDest;
            };

            Color.prototype.divide = function (fScalar, ppDest) {
                if (typeof ppDest === "undefined") { ppDest = new Color; }
                if (akra.isNumber(fScalar)) {
                    var f = fScalar;
                    ppDest.r = this.r / f;
                    ppDest.g = this.g / f;
                    ppDest.b = this.b / f;
                    ppDest.a = this.a / f;
                } else {
                    var c = arguments[0];
                    ppDest.r = this.r / c.r;
                    ppDest.g = this.g / c.g;
                    ppDest.b = this.b / c.b;
                    ppDest.a = this.a / c.a;
                }

                return ppDest;
            };

            Color.prototype.setHSB = function (fHue, fSaturation, fBrightness) {
                // wrap hue
                if (fHue > 1.0) {
                    fHue -= fHue;
                } else if (fHue < 0.0) {
                    fHue += fHue + 1;
                }

                // clamp saturation / fBrightness
                fSaturation = akra.math.min(fSaturation, 1.0);
                fSaturation = akra.math.max(fSaturation, 0.0);
                fBrightness = akra.math.min(fBrightness, 1.0);
                fBrightness = akra.math.max(fBrightness, 0.0);

                if (fBrightness == 0.0) {
                    // early exit, this has to be black
                    this.r = this.g = this.b = 0.0;
                    return;
                }

                if (fSaturation == 0.0) {
                    // early exit, this has to be grey
                    this.r = this.g = this.b = fBrightness;
                    return;
                }

                var fHueDomain = fHue * 6.0;
                if (fHueDomain >= 6.0) {
                    // wrap around, and allow mathematical errors
                    fHueDomain = 0.0;
                }

                var domain = fHueDomain;
                var f1 = fBrightness * (1 - fSaturation);
                var f2 = fBrightness * (1 - fSaturation * (fHueDomain - domain));
                var f3 = fBrightness * (1 - fSaturation * (1 - (fHueDomain - domain)));

                switch (domain) {
                    case 0:
                        // red domain; green ascends
                        this.r = fBrightness;
                        this.g = f3;
                        this.b = f1;
                        break;
                    case 1:
                        // yellow domain; red descends
                        this.r = f2;
                        this.g = fBrightness;
                        this.b = f1;
                        break;
                    case 2:
                        // green domain; blue ascends
                        this.r = f1;
                        this.g = fBrightness;
                        this.b = f3;
                        break;
                    case 3:
                        // cyan domain; green descends
                        this.r = f1;
                        this.g = f2;
                        this.b = fBrightness;
                        break;
                    case 4:
                        // blue domain; red ascends
                        this.r = f3;
                        this.g = f1;
                        this.b = fBrightness;
                        break;
                    case 5:
                        // magenta domain; blue descends
                        this.r = fBrightness;
                        this.g = f1;
                        this.b = f2;
                        break;
                }

                return this;
            };

            Color.prototype.getHSB = function (pHsb) {
                if (typeof pHsb === "undefined") { pHsb = [0., 0., 0.]; }
                var vMin = akra.math.min(this.r, akra.math.min(this.g, this.b));
                var vMax = akra.math.max(this.r, akra.math.max(this.g, this.b));
                var delta = vMax - vMin;

                var brightness = vMax;
                var hue = 0.;
                var saturation;

                if (akra.math.isRealEqual(delta, 0.0, 1e-6)) {
                    // grey
                    hue = 0.;
                    saturation = 0.;
                } else {
                    // a colour
                    saturation = delta / vMax;

                    var deltaR = (((vMax - this.r) / 6.0) + (delta / 2.0)) / delta;
                    var deltaG = (((vMax - this.g) / 6.0) + (delta / 2.0)) / delta;
                    var deltaB = (((vMax - this.b) / 6.0) + (delta / 2.0)) / delta;

                    if (akra.math.isRealEqual(this.r, vMax))
                        hue = deltaB - deltaG;
                    else if (akra.math.isRealEqual(this.g, vMax))
                        hue = 0.3333333 + deltaR - deltaB;
                    else if (akra.math.isRealEqual(this.b, vMax))
                        hue = 0.6666667 + deltaG - deltaR;

                    if (hue < 0.0)
                        hue += 1.0;
                    if (hue > 1.0)
                        hue -= 1.0;
                }

                pHsb[0] = hue;
                pHsb[1] = saturation;
                pHsb[2] = brightness;

                return pHsb;
            };

            Color.prototype.toString = function () {
                return "{R: " + this.r + ", G: " + this.g + ", B: " + this.b + ", A: " + this.a + "} " + "( 0x" + this.getRgba().toString(16) + " )";
            };

            Color.toFloat32Array = function (pValue) {
                var pArr = new Float32Array(4);

                pArr[0] = pValue.r;
                pArr[1] = pValue.g;
                pArr[2] = pValue.b;
                pArr[3] = pValue.a;

                return pArr;
            };

            Color.isEqual = function (c1, c2) {
                return c1.r === c2.r && c1.g === c2.g && c1.b === c2.b && c1.a === c2.a;
            };

            Color.temp = function (r, g, b, a) {
                iElement = (iElement === pBuffer.length - 1 ? 0 : iElement);
                var p = pBuffer[iElement++];
                return p.set.apply(p, arguments);
            };
            Color.BLACK = new Color(0);
            Color.WHITE = new Color(0xFF, 0xFF, 0xFF);
            Color.ZERO = new Color(0., 0., 0., 0.);
            return Color;
        })();
        color.Color = Color;

        pBuffer = akra.gen.array(256, Color);
        iElement = 0;
    })(akra.color || (akra.color = {}));
    var color = akra.color;
})(akra || (akra = {}));
/// <reference path="../idl/IPixelBox.ts" />
/// <reference path="../idl/IImg.ts" />
/// <reference path="../idl/EPixelFormats.ts" />
/// <reference path="../geometry/Box.ts" />
/// <reference path="../logger.ts" />
/// <reference path="../color/Color.ts" />
/// <reference path="../gen/generate.ts" />
/// <reference path="../config/config.ts" />
var akra;
(function (akra) {
    /// <reference path="pixelUtil.ts" />
    (function (pixelUtil) {
        var Box = akra.geometry.Box;
        var Color = akra.color.Color;

        var pBuffer;
        var iElement;

        var PixelBox = (function (_super) {
            __extends(PixelBox, _super);
            function PixelBox(iWidth, iHeight, iDepth, ePixelFormat, pPixelData) {
                if (typeof pPixelData === "undefined") { pPixelData = null; }
                _super.call(this);

                if (arguments.length === 0) {
                    this.data = null;
                    this.format = 0 /* UNKNOWN */;
                    this.setConsecutive();
                    return;
                }

                if (arguments.length >= 4) {
                    this.set(0, 0, 0, iWidth, iHeight, iDepth);
                    this.data = akra.isDef(arguments[4]) ? arguments[4] : null;
                    this.format = arguments[3];
                } else {
                    this.set(arguments[0]);
                    this.data = arguments[2];
                    this.format = arguments[1];
                }

                this.setConsecutive();
            }
            PixelBox.prototype.setConsecutive = function () {
                this.rowPitch = this.getWidth();
                this.slicePitch = this.getWidth() * this.getHeight();
            };

            PixelBox.prototype.getRowSkip = function () {
                return this.rowPitch - this.getWidth();
            };
            PixelBox.prototype.getSliceSkip = function () {
                return this.slicePitch - (this.getHeight() * this.rowPitch);
            };

            PixelBox.prototype.isConsecutive = function () {
                return this.rowPitch == this.getWidth() && this.slicePitch == this.getWidth() * this.getHeight();
            };

            PixelBox.prototype.getConsecutiveSize = function () {
                return pixelUtil.getMemorySize(this.getWidth(), this.getHeight(), this.getDepth(), this.format);
            };

            PixelBox.prototype.getSubBox = function (pDest, pDestPixelBox) {
                if (typeof pDestPixelBox === "undefined") { pDestPixelBox = null; }
                if (pixelUtil.isCompressed(this.format)) {
                    if (pDest.left == this.left && pDest.top == this.top && pDest.front == this.front && pDest.right == this.right && pDest.bottom == this.bottom && pDest.back == this.back) {
                        // Entire buffer is being queried
                        return this;
                    }

                    akra.logger.error("Cannot return subvolume of compressed PixelBuffer", "PixelBox::getSubVolume");
                }

                if (!this.contains(pDest)) {
                    akra.logger.error("Bounds out of range", "PixelBox::getSubVolume");
                }

                var elemSize = pixelUtil.getNumElemBytes(this.format);

                // Calculate new data origin
                // Notice how we do not propagate left/top/front from the incoming box, since
                // the returned pointer is already offset
                var rval = null;

                if (akra.isNull(pDestPixelBox)) {
                    rval = new PixelBox();
                } else {
                    rval = pDestPixelBox;
                }

                rval.setPosition(0, 0, pDest.getWidth(), pDest.getHeight(), 0, pDest.getDepth());
                rval.format = this.format;
                rval.data = this.data.subarray(((pDest.left - this.left) * elemSize) + ((pDest.top - this.top) * this.rowPitch * elemSize) + ((pDest.front - this.front) * this.slicePitch * elemSize));

                rval.rowPitch = this.rowPitch;
                rval.slicePitch = this.slicePitch;
                rval.format = this.format;

                return rval;
            };

            PixelBox.prototype.getColorAt = function (pColor, x, y, z) {
                if (typeof z === "undefined") { z = 0; }
                if (akra.isNull(pColor)) {
                    pColor = new Color(0.);
                }

                var pixelSize = pixelUtil.getNumElemBytes(this.format);
                var pixelOffset = pixelSize * (z * this.slicePitch + y * this.rowPitch + x);

                pixelUtil.unpackColour(pColor, this.format, this.data.subarray(pixelOffset, pixelOffset + pixelSize));

                return pColor;
            };

            PixelBox.prototype.setColorAt = function (pColor, x, y, z) {
                if (typeof z === "undefined") { z = 0; }
                var pixelSize = pixelUtil.getNumElemBytes(this.format);
                var pixelOffset = pixelSize * (z * this.slicePitch + y * this.rowPitch + x);
                pixelUtil.packColour(pColor, this.format, this.data.subarray(pixelOffset, pixelOffset + pixelSize));
            };

            PixelBox.prototype.scale = function (pDest, eFilter) {
                if (typeof eFilter === "undefined") { eFilter = 2 /* BILINEAR */; }
                return false;
            };

            PixelBox.prototype.refresh = function (pExtents, ePixelFormat, pPixelData) {
                this.left = pExtents.left;
                this.top = pExtents.top;
                this.front = pExtents.front;

                this.right = pExtents.right;
                this.bottom = pExtents.bottom;
                this.back = pExtents.back;

                this.data = pPixelData;
                this.format = ePixelFormat;

                this.setConsecutive();
            };

            PixelBox.prototype.toString = function () {
                if (akra.config.DEBUG) {
                    return "|---------------------------|\n" + _super.prototype.toString.call(this) + "\n" + "length: " + (this.data ? this.data.length : 0) + "\n" + "|---------------------------|";
                }
                return null;
            };

            PixelBox.temp = function () {
                iElement = (iElement === pBuffer.length - 1 ? 0 : iElement);
                var pPixelBox = pBuffer[iElement++];

                var pBox = null;
                var pPixelData = null;
                var ePixelFormat = 0 /* UNKNOWN */;

                switch (arguments.length) {
                    case 2:
                    case 3:
                        pBox = arguments[0];
                        ePixelFormat = arguments[1];
                        pPixelData = arguments[2] || null;
                        break;
                    case 4:
                    case 5:
                        pBox = Box.temp(0, 0, 0, arguments[0], arguments[1], arguments[2]);
                        ePixelFormat = arguments[3];
                        pPixelData = arguments[4] || null;
                        break;
                    default:
                        pBox = Box.temp(0, 0, 0, 1, 1, 1);
                        break;
                }

                pPixelBox.refresh(pBox, ePixelFormat, pPixelData);

                return pPixelBox;
            };
            return PixelBox;
        })(Box);
        pixelUtil.PixelBox = PixelBox;

        pBuffer = akra.gen.array(20, PixelBox);
        iElement = 0;
    })(akra.pixelUtil || (akra.pixelUtil = {}));
    var pixelUtil = akra.pixelUtil;
})(akra || (akra = {}));
/// <reference path="../idl/EPixelFormats.ts" />
/// <reference path="../idl/IPixelFormatDescription.ts" />
/// <reference path="../idl/IPair.ts" />
/// <reference path="../idl/IColor.ts" />
/// <reference path="../common.ts" />
/// <reference path="../logger.ts" />
/// <reference path="../math/math.ts" />
/// <reference path="../bf/bf.ts" />
/// <reference path="../mem.ts" />
var akra;
(function (akra) {
    /// <reference path="PixelBox.ts" />
    (function (pixelUtil) {
        var dynamic_cast_f32_ptr = function (uint8_data, n) {
            return (new Float32Array(uint8_data.buffer, uint8_data.byteOffset, n));
        };
        var dynamic_cast_u16_ptr = function (uint8_data, n) {
            return (new Uint16Array(uint8_data.buffer, uint8_data.byteOffset, n));
        };
        var dynamic_cast_u32_ptr = function (uint8_data, n) {
            return (new Uint32Array(uint8_data.buffer, uint8_data.byteOffset, n));
        };
        var dynamic_cast_i8_ptr = function (uint8_data, n) {
            return (new Int8Array(uint8_data.buffer, uint8_data.byteOffset, n));
        };
        var dynamic_cast_i16_ptr = function (uint8_data, n) {
            return (new Int16Array(uint8_data.buffer, uint8_data.byteOffset, n));
        };
        var dynamic_cast_i32_ptr = function (uint8_data, n) {
            return (new Int32Array(uint8_data.buffer, uint8_data.byteOffset, n));
        };

        function fillPixelFormats(pData) {
            var pPixelFormats = [];

            for (var i = 0; i < pData.length; ++i) {
                var pEl = pData[i];
                pPixelFormats.push({
                    name: pEl[0],
                    elemBytes: pEl[1],
                    flags: pEl[2],
                    componentType: pEl[3],
                    componentCount: pEl[4],
                    rbits: pEl[5],
                    gbits: pEl[6],
                    bbits: pEl[7],
                    abits: pEl[8],
                    rmask: pEl[9],
                    gmask: pEl[10],
                    bmask: pEl[11],
                    amask: pEl[12],
                    rshift: pEl[13],
                    gshift: pEl[14],
                    bshift: pEl[15],
                    ashift: pEl[16]
                });
            }

            return pPixelFormats;
        }

        var pPixelFormats = fillPixelFormats([
            [
                "PF_UNKNOWN",
                /* Bytes per element */
                0,
                /* Flags */
                0,
                0 /* BYTE */, 0,
                /* rbits, gbits, bbits, abits */
                0, 0, 0, 0,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_L8",
                /* Bytes per element */
                1,
                32 /* LUMINANCE */ | 16 /* NATIVEENDIAN */,
                0 /* BYTE */, 1,
                /* rbits, gbits, bbits, abits */
                8, 0, 0, 0,
                /* Masks and shifts */
                0xFF, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_L16",
                /* Bytes per element */
                2,
                32 /* LUMINANCE */ | 16 /* NATIVEENDIAN */,
                1 /* SHORT */, 1,
                /* rbits, gbits, bbits, abits */
                16, 0, 0, 0,
                /* Masks and shifts */
                0xFFFF, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_A8",
                /* Bytes per element */
                1,
                1 /* HASALPHA */ | 16 /* NATIVEENDIAN */,
                0 /* BYTE */, 1,
                /* rbits, gbits, bbits, abits */
                0, 0, 0, 8,
                /* Masks and shifts */
                0, 0, 0, 0xFF, 0, 0, 0, 0
            ],
            [
                "PF_A4L4",
                /* Bytes per element */
                1,
                1 /* HASALPHA */ | 32 /* LUMINANCE */ | 16 /* NATIVEENDIAN */,
                0 /* BYTE */, 2,
                /* rbits, gbits, bbits, abits */
                4, 0, 0, 4,
                /* Masks and shifts */
                0x0F, 0, 0, 0xF0, 0, 0, 0, 4
            ],
            [
                "PF_BYTE_LA",
                /* Bytes per element */
                2,
                1 /* HASALPHA */ | 32 /* LUMINANCE */,
                0 /* BYTE */, 2,
                /* rbits, gbits, bbits, abits */
                8, 0, 0, 8,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_R5G6B5",
                /* Bytes per element */
                2,
                16 /* NATIVEENDIAN */,
                0 /* BYTE */, 3,
                /* rbits, gbits, bbits, abits */
                5, 6, 5, 0,
                /* Masks and shifts */
                0xF800, 0x07E0, 0x001F, 0,
                11, 5, 0, 0
            ],
            [
                "PF_B5G6R5",
                /* Bytes per element */
                2,
                16 /* NATIVEENDIAN */,
                0 /* BYTE */, 3,
                /* rbits, gbits, bbits, abits */
                5, 6, 5, 0,
                /* Masks and shifts */
                0x001F, 0x07E0, 0xF800, 0,
                0, 5, 11, 0
            ],
            [
                "PF_A4R4G4B4",
                /* Bytes per element */
                2,
                1 /* HASALPHA */ | 16 /* NATIVEENDIAN */,
                0 /* BYTE */, 4,
                /* rbits, gbits, bbits, abits */
                4, 4, 4, 4,
                /* Masks and shifts */
                0x0F00, 0x00F0, 0x000F, 0xF000,
                8, 4, 0, 12
            ],
            [
                "PF_A1R5G5B5",
                /* Bytes per element */
                2,
                1 /* HASALPHA */ | 16 /* NATIVEENDIAN */,
                0 /* BYTE */, 4,
                /* rbits, gbits, bbits, abits */
                5, 5, 5, 1,
                /* Masks and shifts */
                0x7C00, 0x03E0, 0x001F, 0x8000,
                10, 5, 0, 15
            ],
            [
                "PF_R8G8B8",
                /* Bytes per element */
                3,
                16 /* NATIVEENDIAN */,
                0 /* BYTE */, 3,
                /* rbits, gbits, bbits, abits */
                8, 8, 8, 0,
                /* Masks and shifts */
                0xFF0000, 0x00FF00, 0x0000FF, 0,
                16, 8, 0, 0
            ],
            [
                "PF_B8G8R8",
                /* Bytes per element */
                3,
                16 /* NATIVEENDIAN */,
                0 /* BYTE */, 3,
                /* rbits, gbits, bbits, abits */
                8, 8, 8, 0,
                /* Masks and shifts */
                0x0000FF, 0x00FF00, 0xFF0000, 0,
                0, 8, 16, 0
            ],
            [
                "PF_A8R8G8B8",
                /* Bytes per element */
                4,
                1 /* HASALPHA */ | 16 /* NATIVEENDIAN */,
                0 /* BYTE */, 4,
                /* rbits, gbits, bbits, abits */
                8, 8, 8, 8,
                /* Masks and shifts */
                0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000,
                16, 8, 0, 24
            ],
            [
                "PF_A8B8G8R8",
                /* Bytes per element */
                4,
                1 /* HASALPHA */ | 16 /* NATIVEENDIAN */,
                0 /* BYTE */, 4,
                /* rbits, gbits, bbits, abits */
                8, 8, 8, 8,
                /* Masks and shifts */
                0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000,
                0, 8, 16, 24
            ],
            [
                "PF_B8G8R8A8",
                /* Bytes per element */
                4,
                1 /* HASALPHA */ | 16 /* NATIVEENDIAN */,
                0 /* BYTE */, 4,
                /* rbits, gbits, bbits, abits */
                8, 8, 8, 8,
                /* Masks and shifts */
                0x0000FF00, 0x00FF0000, 0xFF000000, 0x000000FF,
                8, 16, 24, 0
            ],
            [
                "PF_A2R10G10B10",
                /* Bytes per element */
                4,
                1 /* HASALPHA */ | 16 /* NATIVEENDIAN */,
                0 /* BYTE */, 4,
                /* rbits, gbits, bbits, abits */
                10, 10, 10, 2,
                /* Masks and shifts */
                0x3FF00000, 0x000FFC00, 0x000003FF, 0xC0000000,
                20, 10, 0, 30
            ],
            [
                "PF_A2B10G10R10",
                /* Bytes per element */
                4,
                1 /* HASALPHA */ | 16 /* NATIVEENDIAN */,
                0 /* BYTE */, 4,
                /* rbits, gbits, bbits, abits */
                10, 10, 10, 2,
                /* Masks and shifts */
                0x000003FF, 0x000FFC00, 0x3FF00000, 0xC0000000,
                0, 10, 20, 30
            ],
            [
                "PF_DXT1",
                /* Bytes per element */
                0,
                2 /* COMPRESSED */ | 1 /* HASALPHA */,
                0 /* BYTE */, 3,
                /* rbits, gbits, bbits, abits */
                0, 0, 0, 0,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_DXT2",
                /* Bytes per element */
                0,
                2 /* COMPRESSED */ | 1 /* HASALPHA */,
                0 /* BYTE */, 4,
                /* rbits, gbits, bbits, abits */
                0, 0, 0, 0,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_DXT3",
                /* Bytes per element */
                0,
                2 /* COMPRESSED */ | 1 /* HASALPHA */,
                0 /* BYTE */, 4,
                /* rbits, gbits, bbits, abits */
                0, 0, 0, 0,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_DXT4",
                /* Bytes per element */
                0,
                2 /* COMPRESSED */ | 1 /* HASALPHA */,
                0 /* BYTE */, 4,
                /* rbits, gbits, bbits, abits */
                0, 0, 0, 0,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_DXT5",
                /* Bytes per element */
                0,
                2 /* COMPRESSED */ | 1 /* HASALPHA */,
                0 /* BYTE */, 4,
                /* rbits, gbits, bbits, abits */
                0, 0, 0, 0,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_FLOAT16_RGB",
                /* Bytes per element */
                6,
                4 /* FLOAT */,
                3 /* FLOAT16 */, 3,
                /* rbits, gbits, bbits, abits */
                16, 16, 16, 0,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_FLOAT16_RGBA",
                /* Bytes per element */
                8,
                4 /* FLOAT */ | 1 /* HASALPHA */,
                3 /* FLOAT16 */, 4,
                /* rbits, gbits, bbits, abits */
                16, 16, 16, 16,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_FLOAT32_RGB",
                /* Bytes per element */
                12,
                4 /* FLOAT */,
                4 /* FLOAT32 */, 3,
                /* rbits, gbits, bbits, abits */
                32, 32, 32, 0,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_FLOAT32_RGBA",
                /* Bytes per element */
                16,
                4 /* FLOAT */ | 1 /* HASALPHA */,
                4 /* FLOAT32 */, 4,
                /* rbits, gbits, bbits, abits */
                32, 32, 32, 32,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_X8R8G8B8",
                /* Bytes per element */
                4,
                16 /* NATIVEENDIAN */,
                0 /* BYTE */, 3,
                /* rbits, gbits, bbits, abits */
                8, 8, 8, 0,
                /* Masks and shifts */
                0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000,
                16, 8, 0, 24
            ],
            [
                "PF_X8B8G8R8",
                /* Bytes per element */
                4,
                16 /* NATIVEENDIAN */,
                0 /* BYTE */, 3,
                /* rbits, gbits, bbits, abits */
                8, 8, 8, 0,
                /* Masks and shifts */
                0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000,
                0, 8, 16, 24
            ],
            [
                "PF_R8G8B8A8",
                /* Bytes per element */
                4,
                1 /* HASALPHA */ | 16 /* NATIVEENDIAN */,
                0 /* BYTE */, 4,
                /* rbits, gbits, bbits, abits */
                8, 8, 8, 8,
                /* Masks and shifts */
                0xFF000000, 0x00FF0000, 0x0000FF00, 0x000000FF,
                24, 16, 8, 0
            ],
            [
                "PF_FLOAT32_DEPTH",
                /* Bytes per element */
                4,
                8 /* DEPTH */,
                4 /* FLOAT32 */, 1,
                /* rbits, gbits, bbits, abits */
                0, 0, 0, 0,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_SHORT_RGBA",
                /* Bytes per element */
                8,
                1 /* HASALPHA */,
                1 /* SHORT */, 4,
                /* rbits, gbits, bbits, abits */
                16, 16, 16, 16,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_R3G3B2",
                /* Bytes per element */
                1,
                16 /* NATIVEENDIAN */,
                0 /* BYTE */, 3,
                /* rbits, gbits, bbits, abits */
                3, 3, 2, 0,
                /* Masks and shifts */
                0xE0, 0x1C, 0x03, 0,
                5, 2, 0, 0
            ],
            [
                "PF_FLOAT16_R",
                /* Bytes per element */
                2,
                4 /* FLOAT */,
                3 /* FLOAT16 */, 1,
                /* rbits, gbits, bbits, abits */
                16, 0, 0, 0,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_FLOAT32_R",
                /* Bytes per element */
                4,
                4 /* FLOAT */,
                4 /* FLOAT32 */, 1,
                /* rbits, gbits, bbits, abits */
                32, 0, 0, 0,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_SHORT_GR",
                /* Bytes per element */
                4,
                16 /* NATIVEENDIAN */,
                1 /* SHORT */, 2,
                /* rbits, gbits, bbits, abits */
                16, 16, 0, 0,
                /* Masks and shifts */
                0x0000FFFF, 0xFFFF0000, 0, 0,
                0, 16, 0, 0
            ],
            [
                "PF_FLOAT16_GR",
                /* Bytes per element */
                4,
                4 /* FLOAT */,
                3 /* FLOAT16 */, 2,
                /* rbits, gbits, bbits, abits */
                16, 16, 0, 0,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_FLOAT32_GR",
                /* Bytes per element */
                8,
                4 /* FLOAT */,
                4 /* FLOAT32 */, 2,
                /* rbits, gbits, bbits, abits */
                32, 32, 0, 0,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_SHORT_RGB",
                /* Bytes per element */
                6,
                /* Flags */
                0,
                1 /* SHORT */, 3,
                /* rbits, gbits, bbits, abits */
                16, 16, 16, 0,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_PVRTC_RGB2",
                /* Bytes per element */
                0,
                2 /* COMPRESSED */,
                0 /* BYTE */, 3,
                /* rbits, gbits, bbits, abits */
                0, 0, 0, 0,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_PVRTC_RGBA2",
                /* Bytes per element */
                0,
                2 /* COMPRESSED */ | 1 /* HASALPHA */,
                0 /* BYTE */, 4,
                /* rbits, gbits, bbits, abits */
                0, 0, 0, 0,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_PVRTC_RGB4",
                /* Bytes per element */
                0,
                2 /* COMPRESSED */,
                0 /* BYTE */, 3,
                /* rbits, gbits, bbits, abits */
                0, 0, 0, 0,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_PVRTC_RGBA4",
                /* Bytes per element */
                0,
                2 /* COMPRESSED */ | 1 /* HASALPHA */,
                0 /* BYTE */, 4,
                /* rbits, gbits, bbits, abits */
                0, 0, 0, 0,
                /* Masks and shifts */
                0, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_R8",
                /* Bytes per element */
                1,
                16 /* NATIVEENDIAN */,
                0 /* BYTE */, 1,
                /* rbits, gbits, bbits, abits */
                8, 0, 0, 0,
                /* Masks and shifts */
                0xFF0000, 0, 0, 0,
                0, 0, 0, 0
            ],
            [
                "PF_RG8",
                /* Bytes per element */
                2,
                16 /* NATIVEENDIAN */,
                0 /* BYTE */, 2,
                /* rbits, gbits, bbits, abits */
                8, 8, 0, 0,
                /* Masks and shifts */
                0xFF0000, 0x00FF00, 0, 0,
                8, 0, 0, 0
            ],
            [
                "PF_DEPTH_BYTE",
                /* Bytes per element */
                1,
                8 /* DEPTH */,
                0 /* BYTE */, 1,
                /* rbits, gbits, bbits, abits */
                8, 0, 0, 0,
                /* Masks and shifts */
                0xFF, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_DEPTH_SHORT",
                /* Bytes per element */
                2,
                8 /* DEPTH */,
                1 /* SHORT */, 1,
                /* rbits, gbits, bbits, abits */
                16, 0, 0, 0,
                /* Masks and shifts */
                0xFFFF, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_DEPTH_INT",
                /* Bytes per element */
                4,
                8 /* DEPTH */,
                2 /* INT */, 1,
                /* rbits, gbits, bbits, abits */
                32, 0, 0, 0,
                /* Masks and shifts */
                0xFFFFFFFF, 0, 0, 0, 0, 0, 0, 0
            ],
            [
                "PF_DEPTH24STENCIL8",
                /* Bytes per element */
                4,
                8 /* DEPTH */ | 64 /* STENCIL */,
                2 /* INT */, 1,
                /* rbits, gbits, bbits, abits */
                24, 8, 0, 0,
                /* Masks and shifts */
                0x00FFFFFF, 0xFF000000, 0, 0,
                0, 24, 0, 0
            ]
        ]);

        var _pColorValue = { r: 0., g: 0., b: 0., a: 1. };

        function getDescriptionFor(eFmt) {
            var ord = eFmt;
            akra.logger.assert(ord >= 0 && ord < 48 /* TOTAL */, "getDescriptionFor:" + ord);

            return pPixelFormats[ord];
        }
        pixelUtil.getDescriptionFor = getDescriptionFor;

        /** Returns the size in bytes of an element of the given pixel format.
        @return
        The size in bytes of an element. See Remarks.
        @remarks
        Passing PF_UNKNOWN will result in returning a size of 0 bytes.
        */
        function getNumElemBytes(eFormat) {
            return getDescriptionFor(eFormat).elemBytes;
        }
        pixelUtil.getNumElemBytes = getNumElemBytes;

        /** Returns the size in bits of an element of the given pixel format.
        @return
        The size in bits of an element. See Remarks.
        @remarks
        Passing PF_UNKNOWN will result in returning a size of 0 bits.
        */
        function getNumElemBits(eFormat) {
            return getDescriptionFor(eFormat).elemBytes * 8;
        }
        pixelUtil.getNumElemBits = getNumElemBits;

        /** Returns the size in memory of a region with the given extents and pixel
        format with consecutive memory layout.
        @param width
        The width of the area
        @param height
        The height of the area
        @param depth
        The depth of the area
        @param format
        The format of the area
        @return
        The size in bytes
        @remarks
        In case that the format is non-compressed, this simply returns
        width*height*depth*PixelUtil::getNumElemBytes(format). In the compressed
        case, this does serious magic.
        */
        function getMemorySize(iWidth, iHeight, iDepth, eFormat) {
            if (isCompressed(eFormat)) {
                switch (eFormat) {
                    case 17 /* DXT1 */:
                        return Math.floor((iWidth + 3) / 4) * Math.floor((iHeight + 3) / 4) * 8 * iDepth;
                    case 18 /* DXT2 */:
                    case 19 /* DXT3 */:
                    case 20 /* DXT4 */:
                    case 21 /* DXT5 */:
                        return Math.floor((iWidth + 3) / 4) * Math.floor((iHeight + 3) / 4) * 16 * iDepth;

                    case 38 /* PVRTC_RGB2 */:
                    case 39 /* PVRTC_RGBA2 */:
                        akra.logger.assert(iDepth == 1);
                        return (akra.math.max(iWidth, 16) * akra.math.max(iHeight, 8) * 2 + 7) / 8;
                    case 40 /* PVRTC_RGB4 */:
                    case 41 /* PVRTC_RGBA4 */:
                        akra.logger.assert(iDepth == 1);
                        return (akra.math.max(iWidth, 8) * akra.math.max(iHeight, 8) * 4 + 7) / 8;
                    default:
                        akra.logger.error("Invalid compressed pixel format", "PixelUtil::getMemorySize");
                }
            } else {
                return iWidth * iHeight * iDepth * getNumElemBytes(eFormat);
            }
        }
        pixelUtil.getMemorySize = getMemorySize;

        /** Returns the property flags for this pixel format
        @return
        A bitfield combination of PFF_HASALPHA, PFF_ISCOMPRESSED,
        PFF_FLOAT, PFF_DEPTH, PFF_NATIVEENDIAN, PFF_LUMINANCE
        @remarks
        This replaces the separate functions for formatHasAlpha, formatIsFloat, ...
        */
        function getFlags(eFormat) {
            return getDescriptionFor(eFormat).flags;
        }
        pixelUtil.getFlags = getFlags;

        /** Shortcut method to determine if the format has an alpha component */
        function hasAlpha(eFormat) {
            return (getFlags(eFormat) & 1 /* HASALPHA */) > 0;
        }
        pixelUtil.hasAlpha = hasAlpha;

        /** Shortcut method to determine if the format is floating point */
        function isFloatingPoint(eFormat) {
            return (getFlags(eFormat) & 4 /* FLOAT */) > 0;
        }
        pixelUtil.isFloatingPoint = isFloatingPoint;

        /** Shortcut method to determine if the format is compressed */
        function isCompressed(eFormat) {
            return (getFlags(eFormat) & 2 /* COMPRESSED */) > 0;
        }
        pixelUtil.isCompressed = isCompressed;

        /** Shortcut method to determine if the format is a depth format. */
        function isDepth(eFormat) {
            return (getFlags(eFormat) & 8 /* DEPTH */) > 0;
        }
        pixelUtil.isDepth = isDepth;

        /** Shortcut method to determine if the format is in native endian format. */
        function isNativeEndian(eFormat) {
            return (getFlags(eFormat) & 16 /* NATIVEENDIAN */) > 0;
        }
        pixelUtil.isNativeEndian = isNativeEndian;

        /** Shortcut method to determine if the format is a luminance format. */
        function isLuminance(eFormat) {
            return (getFlags(eFormat) & 32 /* LUMINANCE */) > 0;
        }
        pixelUtil.isLuminance = isLuminance;

        /** Return wether a certain image extent is valid for this image format.
        @param width
        The width of the area
        @param height
        The height of the area
        @param depth
        The depth of the area
        @param format
        The format of the area
        @remarks For non-compressed formats, this is always true. For DXT formats,
        only sizes with a width and height multiple of 4 and depth 1 are allowed.
        */
        function isValidExtent(iWidth, iHeight, iDepth, eFormat) {
            if (isCompressed(eFormat)) {
                switch (eFormat) {
                    case 17 /* DXT1 */:
                    case 18 /* DXT2 */:
                    case 19 /* DXT3 */:
                    case 20 /* DXT4 */:
                    case 21 /* DXT5 */:
                        return ((iWidth & 3) == 0 && (iHeight & 3) == 0 && iDepth == 1);
                    default:
                        return true;
                }
            } else {
                return true;
            }
        }
        pixelUtil.isValidExtent = isValidExtent;

        /** Gives the number of bits (RGBA) for a format. See remarks.
        @remarks      For non-colour formats (dxt, depth) this returns [0,0,0,0].
        */
        function getBitDepths(eFormat) {
            /** @const */ var des = getDescriptionFor(eFormat);
            var rgba = [];

            rgba[0] = des.rbits;
            rgba[1] = des.gbits;
            rgba[2] = des.bbits;
            rgba[3] = des.abits;

            return rgba;
        }
        pixelUtil.getBitDepths = getBitDepths;

        /** Gives the masks for the R, G, B and A component
        @note			Only valid for native endian formats
        */
        function getBitMasks(eFormat) {
            /** @const */ var des = getDescriptionFor(eFormat);
            var rgba = [];

            rgba[0] = des.rmask;
            rgba[1] = des.gmask;
            rgba[2] = des.bmask;
            rgba[3] = des.amask;

            return rgba;
        }
        pixelUtil.getBitMasks = getBitMasks;

        /** Gives the bit shifts for R, G, B and A component
        @note			Only valid for native endian formats
        */
        function getBitShifts(eFormat) {
            /** @const */ var des = getDescriptionFor(eFormat);
            var rgba = [];

            rgba[0] = des.rshift;
            rgba[1] = des.gshift;
            rgba[2] = des.bshift;
            rgba[3] = des.ashift;

            return rgba;
        }
        pixelUtil.getBitShifts = getBitShifts;

        /** Gets the name of an image format
        */
        function getFormatName(eSrcFormat) {
            return getDescriptionFor(eSrcFormat).name;
        }
        pixelUtil.getFormatName = getFormatName;

        /** Returns wether the format can be packed or unpacked with the packColour()
        and unpackColour() functions. This is generally not true for compressed and
        depth formats as they are special. It can only be true for formats with a
        fixed element size.
        @return
        true if yes, otherwise false
        */
        function isAccessible(eSrcFormat) {
            if (eSrcFormat == 0 /* UNKNOWN */)
                return false;
            var flags = getFlags(eSrcFormat);
            return !((flags & 2 /* COMPRESSED */) || (flags & 8 /* DEPTH */));
        }
        pixelUtil.isAccessible = isAccessible;

        /** Returns the component type for a certain pixel format. Returns PCT_BYTE
        in case there is no clear component type like with compressed formats.
        This is one of PCT_BYTE, PCT_SHORT, PCT_FLOAT16, PCT_FLOAT32.
        */
        function getComponentType(eFmt) {
            return getDescriptionFor(eFmt).componentType;
        }
        pixelUtil.getComponentType = getComponentType;

        /** Returns the component count for a certain pixel format. Returns 3(no alpha) or
        4 (has alpha) in case there is no clear component type like with compressed formats.
        */
        function getComponentCount(eFmt) {
            return getDescriptionFor(eFmt).componentCount;
        }
        pixelUtil.getComponentCount = getComponentCount;

        function getComponentTypeBits(eFormat) {
            var eType = getComponentType(eFormat);

            switch (eType) {
                case 0 /* BYTE */:
                    return 8;
                case 1 /* SHORT */:
                    return 16;
                case 3 /* FLOAT16 */:
                    return 16;
                case 4 /* FLOAT32 */:
                    return 32;
            }

            return 0;
        }
        pixelUtil.getComponentTypeBits = getComponentTypeBits;

        /** Gets the format from given name.
        @param  name            The string of format name
        @param  accessibleOnly  If true, non-accessible format will treat as invalid format,
        otherwise, all supported format are valid.
        @param  caseSensitive   Should be set true if string match should use case sensitivity.
        @return                The format match the format name, or PF_UNKNOWN if is invalid name.
        */
        function getFormatFromName(sName, isAccessibleOnly, isCaseSensitive) {
            if (typeof isAccessibleOnly === "undefined") { isAccessibleOnly = false; }
            if (typeof isCaseSensitive === "undefined") { isCaseSensitive = false; }
            var tmp = sName;

            if (!isCaseSensitive) {
                // We are stored upper-case format names.
                tmp = tmp.toUpperCase();
            }

            for (var i = 0; i < 48 /* TOTAL */; ++i) {
                var ePf = i;
                if (!isAccessibleOnly || isAccessible(ePf)) {
                    if (tmp == getFormatName(ePf))
                        return ePf;
                }
            }

            return 0 /* UNKNOWN */;
        }
        pixelUtil.getFormatFromName = getFormatFromName;

        /** Gets the BNF expression of the pixel-formats.
        @note                   The string returned by this function is intended to be used as a BNF expression
        to work with Compiler2Pass.
        @param  accessibleOnly  If true, only accessible pixel format will take into account, otherwise all
        pixel formats list in EPixelFormats enumeration will being returned.
        @return                A string contains the BNF expression.
        */
        function getBNFExpressionOfPixelFormats(isAccessibleOnly) {
            // Collect format names sorted by length, it's required by BNF compiler
            // that similar tokens need longer ones comes first.
            if (typeof isAccessibleOnly === "undefined") { isAccessibleOnly = false; }
            var formatNames = [];
            for (var i = 0; i < 48 /* TOTAL */; ++i) {
                var ePf = (i);
                if (!isAccessibleOnly || isAccessible(ePf)) {
                    var formatName = getFormatName(ePf);
                    formatNames.push({ first: formatName.length, second: formatName });
                }
            }

            // Populate the BNF expression in reverse order
            var result = "";

            for (var j in formatNames) {
                if (!akra.isEmpty(result))
                    result += " | ";
                result += "'" + formatNames[j] + "'";
            }

            return result;
        }
        pixelUtil.getBNFExpressionOfPixelFormats = getBNFExpressionOfPixelFormats;

        /** Returns the similar format but acoording with given bit depths.
        @param fmt      The original foamt.
        @param integerBits Preferred bit depth (pixel bits) for integer pixel format.
        Available values: 0, 16 and 32, where 0 (the default) means as it is.
        @param floatBits Preferred bit depth (channel bits) for float pixel format.
        Available values: 0, 16 and 32, where 0 (the default) means as it is.
        @return        The format that similar original format with bit depth according
        with preferred bit depth, or original format if no conversion occurring.
        */
        function getFormatForBitDepths(eFmt, iIntegerBits, iFloatBits) {
            switch (iIntegerBits) {
                case 16:
                    switch (eFmt) {
                        case 10 /* R8G8B8 */:
                        case 26 /* X8R8G8B8 */:
                            return 6 /* R5G6B5 */;

                        case 11 /* B8G8R8 */:
                        case 27 /* X8B8G8R8 */:
                            return 7 /* B5G6R5 */;

                        case 12 /* A8R8G8B8 */:
                        case 28 /* R8G8B8A8 */:
                        case 13 /* A8B8G8R8 */:
                        case 14 /* B8G8R8A8 */:
                            return 8 /* A4R4G4B4 */;

                        case 15 /* A2R10G10B10 */:
                        case 16 /* A2B10G10R10 */:
                            return 9 /* A1R5G5B5 */;

                        default:
                            break;
                    }
                    break;

                case 32:
                    switch (eFmt) {
                        case 6 /* R5G6B5 */:
                            return 26 /* X8R8G8B8 */;

                        case 7 /* B5G6R5 */:
                            return 27 /* X8B8G8R8 */;

                        case 8 /* A4R4G4B4 */:
                            return 12 /* A8R8G8B8 */;

                        case 9 /* A1R5G5B5 */:
                            return 15 /* A2R10G10B10 */;

                        default:
                            break;
                    }
                    break;

                default:
                    break;
            }

            switch (iFloatBits) {
                case 16:
                    switch (eFmt) {
                        case 33 /* FLOAT32_R */:
                            return 32 /* FLOAT16_R */;

                        case 24 /* FLOAT32_RGB */:
                            return 22 /* FLOAT16_RGB */;

                        case 25 /* FLOAT32_RGBA */:
                            return 23 /* FLOAT16_RGBA */;

                        default:
                            break;
                    }
                    break;

                case 32:
                    switch (eFmt) {
                        case 32 /* FLOAT16_R */:
                            return 33 /* FLOAT32_R */;

                        case 22 /* FLOAT16_RGB */:
                            return 24 /* FLOAT32_RGB */;

                        case 23 /* FLOAT16_RGBA */:
                            return 25 /* FLOAT32_RGBA */;

                        default:
                            break;
                    }
                    break;

                default:
                    break;
            }

            return eFmt;
        }
        pixelUtil.getFormatForBitDepths = getFormatForBitDepths;

        /** Pack a colour value to memory
        @param colour	The colour
        @param pf		Pixelformat in which to write the colour
        @param dest		Destination memory location
        */
        function packColour(cColour, ePf, pDest) {
            packColourFloat(cColour.r, cColour.g, cColour.b, cColour.a, ePf, pDest);
        }
        pixelUtil.packColour = packColour;

        /** Pack a colour value to memory
        @param r,g,b,a	The four colour components, range 0x00 to 0xFF
        @param pf		Pixelformat in which to write the colour
        @param dest		Destination memory location
        */
        function packColourUint(r, g, b, a, ePf, pDest) {
            // if (arguments.length < 4) {
            // 	var cColour: IColor = arguments[0];
            // 	packColour(cColour.r, cColour.g, cColour.b, cColour.a, ePf, pDest);
            // 	return;
            // }
            /** @const */ var des = getDescriptionFor(ePf);
            if (des.flags & 16 /* NATIVEENDIAN */) {
                // Shortcut for integer formats packing
                var value = ((akra.bf.fixedToFixed(r, 8, des.rbits) << des.rshift) & des.rmask) | ((akra.bf.fixedToFixed(g, 8, des.gbits) << des.gshift) & des.gmask) | ((akra.bf.fixedToFixed(b, 8, des.bbits) << des.bshift) & des.bmask) | ((akra.bf.fixedToFixed(a, 8, des.abits) << des.ashift) & des.amask);

                // And write to memory
                akra.bf.intWrite(pDest, des.elemBytes, value);
            } else {
                // Convert to float
                packColourFloat(r / 255.0, g / 255.0, b / 255.0, a / 255.0, ePf, pDest);
            }
        }
        pixelUtil.packColourUint = packColourUint;

        /** Pack a colour value to memory
        @param r,g,b,a	The four colour components, range 0.0f to 1.0f
        (an exception to this case exists for floating point pixel
        formats, which don't clamp to 0.0f..1.0f)
        @param pf		Pixelformat in which to write the colour
        @param dest		Destination memory location
        */
        function packColourFloat(r, g, b, a, ePf, pDest) {
            // Catch-it-all here
            /** @const */ var des = getDescriptionFor(ePf);
            if (des.flags & 16 /* NATIVEENDIAN */) {
                // Do the packing
                //std::cerr << dest << " " << r << " " << g <<  " " << b << " " << a << std::endl;
                /** @const */ var value = ((akra.bf.floatToFixed(r, des.rbits) << des.rshift) & des.rmask) | ((akra.bf.floatToFixed(g, des.gbits) << des.gshift) & des.gmask) | ((akra.bf.floatToFixed(b, des.bbits) << des.bshift) & des.bmask) | ((akra.bf.floatToFixed(a, des.abits) << des.ashift) & des.amask);

                // And write to memory
                akra.bf.intWrite(pDest, des.elemBytes, value);
            } else {
                switch (ePf) {
                    case 33 /* FLOAT32_R */:
                        dynamic_cast_f32_ptr(pDest, 1)[0] = r;
                        break;
                    case 36 /* FLOAT32_GR */:
                        dynamic_cast_f32_ptr(pDest, 1)[0] = g;
                        dynamic_cast_f32_ptr(pDest, 2)[1] = r;
                        break;
                    case 24 /* FLOAT32_RGB */:
                        dynamic_cast_f32_ptr(pDest, 1)[0] = r;
                        dynamic_cast_f32_ptr(pDest, 2)[1] = g;
                        dynamic_cast_f32_ptr(pDest, 3)[2] = b;
                        break;
                    case 25 /* FLOAT32_RGBA */:
                        dynamic_cast_f32_ptr(pDest, 1)[0] = r;
                        dynamic_cast_f32_ptr(pDest, 2)[1] = g;
                        dynamic_cast_f32_ptr(pDest, 3)[2] = b;
                        dynamic_cast_f32_ptr(pDest, 4)[3] = a;
                        break;
                    case 32 /* FLOAT16_R */:
                        dynamic_cast_u16_ptr(pDest, 1)[0] = akra.bf.floatToHalf(r);
                        break;
                    case 35 /* FLOAT16_GR */:
                        dynamic_cast_u16_ptr(pDest, 1)[0] = akra.bf.floatToHalf(g);
                        dynamic_cast_u16_ptr(pDest, 2)[1] = akra.bf.floatToHalf(r);
                        break;
                    case 22 /* FLOAT16_RGB */:
                        dynamic_cast_u16_ptr(pDest, 1)[0] = akra.bf.floatToHalf(r);
                        dynamic_cast_u16_ptr(pDest, 2)[1] = akra.bf.floatToHalf(g);
                        dynamic_cast_u16_ptr(pDest, 3)[2] = akra.bf.floatToHalf(b);
                        break;
                    case 23 /* FLOAT16_RGBA */:
                        dynamic_cast_u16_ptr(pDest, 1)[0] = akra.bf.floatToHalf(r);
                        dynamic_cast_u16_ptr(pDest, 2)[1] = akra.bf.floatToHalf(g);
                        dynamic_cast_u16_ptr(pDest, 3)[2] = akra.bf.floatToHalf(b);
                        dynamic_cast_u16_ptr(pDest, 4)[3] = akra.bf.floatToHalf(a);
                        break;
                    case 37 /* SHORT_RGB */:
                        dynamic_cast_u16_ptr(pDest, 1)[0] = akra.bf.floatToFixed(r, 16);
                        dynamic_cast_u16_ptr(pDest, 2)[1] = akra.bf.floatToFixed(g, 16);
                        dynamic_cast_u16_ptr(pDest, 3)[2] = akra.bf.floatToFixed(b, 16);
                        break;
                    case 30 /* SHORT_RGBA */:
                        dynamic_cast_u16_ptr(pDest, 1)[0] = akra.bf.floatToFixed(r, 16);
                        dynamic_cast_u16_ptr(pDest, 2)[1] = akra.bf.floatToFixed(g, 16);
                        dynamic_cast_u16_ptr(pDest, 3)[2] = akra.bf.floatToFixed(b, 16);
                        dynamic_cast_u16_ptr(pDest, 4)[3] = akra.bf.floatToFixed(a, 16);
                        break;
                    case 5 /* BYTE_LA */:
                        pDest[0] = akra.bf.floatToFixed(r, 8);
                        pDest[1] = akra.bf.floatToFixed(a, 8);
                        break;
                    default:
                        // Not yet supported
                        akra.logger.error("pack to " + getFormatName(ePf) + " not implemented", "PixelUtil::packColour");
                        break;
                }
            }
        }
        pixelUtil.packColourFloat = packColourFloat;

        /** Unpack a colour value from memory
        @param colour	The colour is returned here
        @param pf		Pixelformat in which to read the colour
        @param src		Source memory location
        */
        function unpackColour(cColour, ePf, pSrc) {
            unpackColourFloat(cColour, ePf, pSrc);
        }
        pixelUtil.unpackColour = unpackColour;

        /** Unpack a colour value from memory
        @param r,g,b,a	The colour is returned here (as byte)
        @param pf		Pixelformat in which to read the colour
        @param src		Source memory location
        @remarks 	This function returns the colour components in 8 bit precision,
        this will lose precision when coming from PF_A2R10G10B10 or floating
        point formats.
        */
        function unpackColourUint(rgba, ePf, pSrc) {
            /** @const */ var des = getDescriptionFor(ePf);
            var r = 0, g = 0, b = 0, a = 0;

            if (des.flags & 16 /* NATIVEENDIAN */) {
                // Shortcut for integer formats unpacking
                /** @const */ var value = akra.bf.intRead(pSrc, des.elemBytes);
                if (des.flags & 32 /* LUMINANCE */) {
                    // Luminance format -- only rbits used
                    r = g = b = akra.bf.fixedToFixed((value & des.rmask) >> des.rshift, des.rbits, 8);
                } else {
                    r = akra.bf.fixedToFixed((value & des.rmask) >> des.rshift, des.rbits, 8);
                    g = akra.bf.fixedToFixed((value & des.gmask) >> des.gshift, des.gbits, 8);
                    b = akra.bf.fixedToFixed((value & des.bmask) >> des.bshift, des.bbits, 8);
                }
                if (des.flags & 1 /* HASALPHA */) {
                    a = akra.bf.fixedToFixed((value & des.amask) >> des.ashift, des.abits, 8);
                } else {
                    a = 255; /* No alpha, default a component to full*/
                }
            } else {
                // Do the operation with the more generic floating point
                var pRGBA = _pColorValue;
                unpackColourFloat(pRGBA, ePf, pSrc);

                r = akra.bf.floatToFixed(pRGBA.r, 8);
                g = akra.bf.floatToFixed(pRGBA.g, 8);
                b = akra.bf.floatToFixed(pRGBA.b, 8);
                a = akra.bf.floatToFixed(pRGBA.a, 8);
            }

            rgba[0] = r;
            rgba[1] = g;
            rgba[2] = b;
            rgba[3] = a;
        }
        pixelUtil.unpackColourUint = unpackColourUint;

        /** Unpack a colour value from memory
        @param r,g,b,a	The colour is returned here (as float)
        @param pf		Pixelformat in which to read the colour
        @param src		Source memory location
        */
        function unpackColourFloat(rgba, ePf, pSrc) {
            /** @const */ var des = getDescriptionFor(ePf);
            var r = 0., g = 0., b = 0., a = 0.;

            if (des.flags & 16 /* NATIVEENDIAN */) {
                // Shortcut for integer formats unpacking
                /** @const */ var value = akra.bf.intRead(pSrc, des.elemBytes);

                if (des.flags & 32 /* LUMINANCE */) {
                    // Luminance format -- only rbits used
                    r = g = b = akra.bf.fixedToFloat((value & des.rmask) >>> des.rshift, des.rbits);
                } else {
                    r = akra.bf.fixedToFloat((value & des.rmask) >>> des.rshift, des.rbits);
                    g = akra.bf.fixedToFloat((value & des.gmask) >>> des.gshift, des.gbits);
                    b = akra.bf.fixedToFloat((value & des.bmask) >>> des.bshift, des.bbits);
                }

                if (des.flags & 1 /* HASALPHA */) {
                    a = akra.bf.fixedToFloat((value & des.amask) >>> des.ashift, des.abits);
                } else {
                    a = 1.0; /* No alpha, default a component to full*/
                }
            } else {
                switch (ePf) {
                    case 29 /* FLOAT32_DEPTH */:
                    case 33 /* FLOAT32_R */:
                        r = g = b = dynamic_cast_f32_ptr(pSrc, 1)[0];
                        a = 1.0;
                        break;
                    case 36 /* FLOAT32_GR */:
                        g = dynamic_cast_f32_ptr(pSrc, 1)[0];
                        r = b = dynamic_cast_f32_ptr(pSrc, 2)[1];
                        a = 1.0;
                        break;
                    case 24 /* FLOAT32_RGB */:
                        r = dynamic_cast_f32_ptr(pSrc, 1)[0];
                        g = dynamic_cast_f32_ptr(pSrc, 2)[1];
                        b = dynamic_cast_f32_ptr(pSrc, 3)[2];
                        a = 1.0;
                        break;
                    case 25 /* FLOAT32_RGBA */:
                        r = dynamic_cast_f32_ptr(pSrc, 1)[0];
                        g = dynamic_cast_f32_ptr(pSrc, 2)[1];
                        b = dynamic_cast_f32_ptr(pSrc, 3)[2];
                        a = dynamic_cast_f32_ptr(pSrc, 4)[3];
                        break;
                    case 32 /* FLOAT16_R */:
                        r = g = b = akra.bf.halfToFloat((dynamic_cast_u16_ptr(pSrc, 1))[0]);
                        a = 1.0;
                        break;
                    case 35 /* FLOAT16_GR */:
                        g = akra.bf.halfToFloat((dynamic_cast_u16_ptr(pSrc, 1))[0]);
                        r = b = akra.bf.halfToFloat((dynamic_cast_u16_ptr(pSrc, 2))[1]);
                        a = 1.0;
                        break;
                    case 22 /* FLOAT16_RGB */:
                        r = akra.bf.halfToFloat((dynamic_cast_u16_ptr(pSrc, 1))[0]);
                        g = akra.bf.halfToFloat((dynamic_cast_u16_ptr(pSrc, 1))[1]);
                        b = akra.bf.halfToFloat((dynamic_cast_u16_ptr(pSrc, 2))[2]);
                        a = 1.0;
                        break;
                    case 23 /* FLOAT16_RGBA */:
                        r = akra.bf.halfToFloat((dynamic_cast_u16_ptr(pSrc, 1))[0]);
                        g = akra.bf.halfToFloat((dynamic_cast_u16_ptr(pSrc, 2))[1]);
                        b = akra.bf.halfToFloat((dynamic_cast_u16_ptr(pSrc, 3))[2]);
                        a = akra.bf.halfToFloat((dynamic_cast_u16_ptr(pSrc, 4))[3]);
                        break;
                    case 37 /* SHORT_RGB */:
                        r = akra.bf.fixedToFloat((dynamic_cast_u16_ptr(pSrc, 1))[0], 16);
                        g = akra.bf.fixedToFloat((dynamic_cast_u16_ptr(pSrc, 2))[1], 16);
                        b = akra.bf.fixedToFloat((dynamic_cast_u16_ptr(pSrc, 3))[2], 16);
                        a = 1.0;
                        break;
                    case 30 /* SHORT_RGBA */:
                        r = akra.bf.fixedToFloat((dynamic_cast_u16_ptr(pSrc, 1))[0], 16);
                        g = akra.bf.fixedToFloat((dynamic_cast_u16_ptr(pSrc, 2))[1], 16);
                        b = akra.bf.fixedToFloat((dynamic_cast_u16_ptr(pSrc, 3))[2], 16);
                        a = akra.bf.fixedToFloat((dynamic_cast_u16_ptr(pSrc, 4))[3], 16);
                        break;
                    case 5 /* BYTE_LA */:
                        r = g = b = akra.bf.fixedToFloat((pSrc)[0], 8);
                        a = akra.bf.fixedToFloat((pSrc)[1], 8);
                        break;
                    default:
                        // Not yet supported
                        akra.logger.error("unpack from " + getFormatName(ePf) + " not implemented", "PixelUtil::unpackColour");
                        break;
                }
            }

            rgba.r = r;
            rgba.g = g;
            rgba.b = b;
            rgba.a = a;
        }
        pixelUtil.unpackColourFloat = unpackColourFloat;

        

        

        function bulkPixelConversion(pSrc, eSrcFormat, pDest, eDstFormat, iCount) {
            var src = null, dst = null;

            if (arguments.length > 2) {
                src = new pixelUtil.PixelBox(iCount, 1, 1, eSrcFormat, pSrc);
                dst = new pixelUtil.PixelBox(iCount, 1, 1, eDstFormat, pDest);
            } else {
                src = arguments[0];
                dst = arguments[1];
            }

            if (src.getWidth() !== dst.getWidth() || src.getHeight() !== dst.getHeight() || src.getDepth() !== dst.getDepth()) {
                akra.logger.critical("Size dest and src pictures is different");
                return;
            }

            // Check for compressed formats, we don't support decompression, compression or recoding
            if (isCompressed(src.format) || isCompressed(dst.format)) {
                if (src.format == dst.format) {
                    //_memcpy(dst.data.buffer, src.data.buffer, src.getConsecutiveSize());
                    dst.data.set(src.data.subarray(0, src.getConsecutiveSize()));
                    return;
                } else {
                    akra.logger.error("This method can not be used to compress or decompress images", "PixelUtil::bulkPixelConversion");
                }
            }

            // The easy case
            if (src.format == dst.format) {
                // Everything consecutive?
                if (src.isConsecutive() && dst.isConsecutive()) {
                    //_memcpy(dst.data.buffer, src.data.buffer, src.getConsecutiveSize());
                    dst.data.set(src.data.subarray(0, src.getConsecutiveSize()));
                    return;
                }

                var srcPixelSize = getNumElemBytes(src.format);
                var dstPixelSize = getNumElemBytes(dst.format);

                var srcptr = src.data.subarray((src.left + src.top * src.rowPitch + src.front * src.slicePitch) * srcPixelSize);
                var dstptr = dst.data.subarray((dst.left + dst.top * dst.rowPitch + dst.front * dst.slicePitch) * dstPixelSize);

                // Calculate pitches+skips in bytes
                var srcRowPitchBytes = src.rowPitch * srcPixelSize;

                //var size_t srcRowSkipBytes = src.getRowSkip()*srcPixelSize;
                var srcSliceSkipBytes = src.getSliceSkip() * srcPixelSize;

                var dstRowPitchBytes = dst.rowPitch * dstPixelSize;

                //var size_t dstRowSkipBytes = dst.getRowSkip()*dstPixelSize;
                var dstSliceSkipBytes = dst.getSliceSkip() * dstPixelSize;

                // Otherwise, copy per row
                /** @const */ var rowSize = src.getWidth() * srcPixelSize;

                for (var z = src.front; z < src.back; z++) {
                    for (var y = src.top; y < src.bottom; y++) {
                        //_memcpy(dstptr.buffer, srcptr.buffer, rowSize);
                        dstptr.set(srcptr.subarray(0, rowSize));

                        srcptr = srcptr.subarray(srcRowPitchBytes);
                        dstptr = dstptr.subarray(dstRowPitchBytes);
                    }

                    srcptr = srcptr.subarray(srcSliceSkipBytes);
                    dstptr = dstptr.subarray(dstSliceSkipBytes);
                }

                return;
            }

            // Converting to PF_X8R8G8B8 is exactly the same as converting to
            // PF_A8R8G8B8. (same with PF_X8B8G8R8 and PF_A8B8G8R8)
            if (dst.format == 26 /* X8R8G8B8 */ || dst.format == 27 /* X8B8G8R8 */) {
                // Do the same conversion, with EPixelFormats.A8R8G8B8, which has a lot of
                // optimized conversions
                var tempdst = dst;
                tempdst.format = (dst.format == 26 /* X8R8G8B8 */) ? 12 /* A8R8G8B8 */ : 13 /* A8B8G8R8 */;
                bulkPixelConversion(src, tempdst);
                return;
            }

            // Converting from EPixelFormats.X8R8G8B8 is exactly the same as converting from
            // EPixelFormats.A8R8G8B8, given that the destination format does not have alpha.
            if ((src.format == 26 /* X8R8G8B8 */ || src.format == 27 /* X8B8G8R8 */) && !hasAlpha(dst.format)) {
                // Do the same conversion, with EPixelFormats.A8R8G8B8, which has a lot of
                // optimized conversions
                var tempsrc = src;
                tempsrc.format = src.format == 26 /* X8R8G8B8 */ ? 12 /* A8R8G8B8 */ : 13 /* A8B8G8R8 */;
                bulkPixelConversion(tempsrc, dst);
                return;
            }

            var srcPixelSize = getNumElemBytes(src.format);
            var dstPixelSize = getNumElemBytes(dst.format);

            var srcptr = src.data.subarray((src.left + src.top * src.rowPitch + src.front * src.slicePitch) * srcPixelSize);
            var dstptr = dst.data.subarray((dst.left + dst.top * dst.rowPitch + dst.front * dst.slicePitch) * dstPixelSize);

            // Old way, not taking into account box dimensions
            //uint8 *srcptr = static_cast<uint8*>(src.data), *dstptr = static_cast<uint8*>(dst.data);
            // Calculate pitches+skips in bytes
            var srcRowSkipBytes = src.getRowSkip() * srcPixelSize;
            var srcSliceSkipBytes = src.getSliceSkip() * srcPixelSize;
            var dstRowSkipBytes = dst.getRowSkip() * dstPixelSize;
            var dstSliceSkipBytes = dst.getSliceSkip() * dstPixelSize;

            // The brute force fallback
            // var r: float = 0, g: float = 0, b: float = 0, a: float = 1;
            var rgba = _pColorValue;
            for (var z = src.front; z < src.back; z++) {
                for (var y = src.top; y < src.bottom; y++) {
                    for (var x = src.left; x < src.right; x++) {
                        unpackColourFloat(rgba, src.format, srcptr);
                        packColourFloat(rgba.r, rgba.g, rgba.b, rgba.a, dst.format, dstptr);
                        srcptr = srcptr.subarray(srcPixelSize);
                        dstptr = dstptr.subarray(dstPixelSize);
                    }
                    srcptr = srcptr.subarray(srcRowSkipBytes);
                    dstptr = dstptr.subarray(dstRowSkipBytes);
                }
                srcptr = srcptr.subarray(srcSliceSkipBytes);
                dstptr = dstptr.subarray(dstSliceSkipBytes);
            }
        }
        pixelUtil.bulkPixelConversion = bulkPixelConversion;

        function calculateSizeForImage(nMipLevels, nFaces, iWidth, iHeight, iDepth, eFormat) {
            var iSize = 0;
            var mip = 0;

            for (mip = 0; mip < nMipLevels; ++mip) {
                iSize += getMemorySize(iWidth, iHeight, iDepth, eFormat) * nFaces;
                if (iWidth !== 1)
                    iWidth /= 2;
                if (iHeight !== 1)
                    iHeight /= 2;
                if (iDepth !== 1)
                    iDepth /= 2;
            }

            return iSize;
        }
        pixelUtil.calculateSizeForImage = calculateSizeForImage;
    })(akra.pixelUtil || (akra.pixelUtil = {}));
    var pixelUtil = akra.pixelUtil;
})(akra || (akra = {}));
/// <reference path="../idl/3d-party/webgl.d.ts" />
/// <reference path="../idl/EPixelFormats.ts" />
/// <reference path="../idl/IHardwareBuffer.ts" />
/// <reference path="../idl/IPixelBox.ts" />
/// <reference path="../idl/EPrimitiveTypes.ts" />
var akra;
(function (akra) {
    /// <reference path="../common.ts" />
    /// <reference path="../logger.ts" />
    /// <reference path="../debug.ts" />
    /// <reference path="../bf/bf.ts" />
    /// <reference path="../math/math.ts" />
    /// <reference path="../pixelUtil/pixelUtil.ts" />
    (function (webgl) {
        webgl.maxTextureSize = 0;
        webgl.maxCubeMapTextureSize = 0;
        webgl.maxViewPortSize = 0;

        webgl.maxTextureImageUnits = 0;
        webgl.maxVertexAttributes = 0;
        webgl.maxVertexTextureImageUnits = 0;
        webgl.maxCombinedTextureImageUnits = 0;

        webgl.maxColorAttachments = 1;

        webgl.stencilBits = 0;
        webgl.colorBits = [0, 0, 0];
        webgl.alphaBits = 0;
        webgl.multisampleType = 0.;

        webgl.shaderVersion = 0;
        webgl.hasNonPowerOf2Textures = false;

        var isSupported = false;
        var pSupportedExtensionList = null;

        //todo: replace with constants (use <const> keyword)
        //WebGL Extensions
        webgl.OES_TEXTURE_FLOAT = "OES_texture_float";
        webgl.OES_TEXTURE_HALF_FLOAT = "OES_texture_half_float";
        webgl.OES_STANDARD_DERIVATIVES = "OES_standard_derivatives";
        webgl.OES_VERTEX_ARRAY_OBJECT = "OES_vertex_array_object";
        webgl.OES_ELEMENT_INDEX_UINT = "OES_element_index_uint";
        webgl.WEBGL_DEBUG_RENDERER_INFO = "WEBGL_debug_renderer_info";
        webgl.WEBGL_DEBUG_SHADERS = "WEBGL_debug_shaders";
        webgl.EXT_TEXTURE_FILTER_ANISOTROPIC = "EXT_texture_filter_anisotropic";

        //draft
        webgl.WEBGL_LOSE_CONTEXT = "WEBGL_lose_context";
        webgl.WEBGL_DEPTH_TEXTURE = "WEBGL_depth_texture";
        webgl.WEBGL_COMPRESSED_TEXTURE_S3TC = "WEBGL_compressed_texture_s3tc";
        webgl.WEBGL_COMPRESSED_TEXTURE_ATC = "WEBGL_compressed_texture_atc";
        webgl.WEBGL_COMPRESSED_TEXTURE_PVRTC = "WEBGL_compressed_texture_pvrtc";
        webgl.WEBGL_COLOR_BUFFER_FLOAT = "WEBGL_color_buffer_float";
        webgl.EXT_COLOR_BUFFER_HALF_FLOAT = "EXT_color_buffer_half_float";

        //Future
        webgl.EXT_TEXTURE_RG = "EXT_texture_rg";
        webgl.OES_DEPTH24 = "OES_depth24";
        webgl.OES_DEPTH32 = "OES_depth32";
        webgl.OES_PACKED_DEPTH_STENCIL = "OES_packed_depth_stencil";
        webgl.EXT_TEXTURE_NPOT_2D_MIPMAP = "EXT_texture_npot_2D_mipmap";

        webgl.GLSL_VS_SHADER_MIN = "void main(void){gl_Position = vec4(0., 0., 0., 1.);}";
        webgl.GLSL_FS_SHADER_MIN = "void main(void){}";

        function makeDebugContext(pWebGLContext) {
            if (akra.isDef(window.WebGLDebugUtils)) {
                pWebGLContext = WebGLDebugUtils.makeDebugContext(pWebGLContext, function (err, funcName, args) {
                    throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to: " + funcName;
                }, function (funcName, args) {
                    akra.logger.log("gl." + funcName + "(" + WebGLDebugUtils.glFunctionArgsToString(funcName, args) + ")");
                });
            }

            return pWebGLContext;
        }

        function loadExtension(pWebGLContext, sExtName) {
            var pWebGLExtentionList = pWebGLContext.extentionList = pWebGLContext.extentionList || {};
            var pWebGLExtension;

            if (isExtensionInBlackList(sExtName)) {
                return false;
            }

            if (!hasExtension(sExtName)) {
                akra.logger.warn("Extension " + sExtName + " unsupported for this platform.");
                return false;
            }

            pWebGLExtension = pWebGLContext.getExtension(sExtName);

            if (pWebGLExtension) {
                if (akra.isDefAndNotNull(pWebGLExtentionList[sExtName])) {
                    return true;
                }

                pWebGLExtentionList[sExtName] = pWebGLExtension;

                for (var j in pWebGLExtension) {
                    if (akra.isFunction(pWebGLExtension[j])) {
                        pWebGLContext[j] = function () {
                            pWebGLContext[j] = new Function("var t = this.extentionList[" + sExtName + "];" + "t." + j + ".apply(t, arguments);");
                        };
                    } else {
                        pWebGLContext[j] = pWebGLExtension[j];
                    }
                }

                return true;
            }

            akra.logger.warn("cannot load extension: ", sExtName);
            return false;
        }
        webgl.loadExtension = loadExtension;

        function isExtensionInBlackList(sExtName) {
            var pBlackList = akra.config.webgl.extensionsBlackList;

            for (var j = 0; j < pBlackList.length; ++j) {
                if (sExtName.toLowerCase().indexOf(pBlackList[j].toLowerCase()) !== -1) {
                    return true;
                }
            }

            return false;
        }

        function setupContext(pWebGLContext) {
            //test context not created yet
            if (akra.isNull(pSupportedExtensionList)) {
                return pWebGLContext;
            }

            for (var i = 0; i < pSupportedExtensionList.length; ++i) {
                var sExtName = pSupportedExtensionList[i];

                if (!loadExtension(pWebGLContext, sExtName)) {
                    pSupportedExtensionList.splice(i, 1);
                }
            }

            return pWebGLContext;
        }

        webgl.isEnabled = function () {
            return isSupported;
        };

        function createContext(pCanvas, pOptions) {
            if (typeof pCanvas === "undefined") { pCanvas = document.createElement("canvas"); }
            var pWebGLContext = null;

            try  {
                pWebGLContext = pCanvas.getContext("webgl", pOptions) || pCanvas.getContext("experimental-webgl", pOptions);
            } catch (e) {
                if (akra.config.DEBUG) {
                    throw e;
                }
            }

            if (akra.isDefAndNotNull(pWebGLContext)) {
                if (window["WebGLDebugUtils"] && akra.config.WEBGL_DEBUG) {
                    return makeDebugContext(setupContext(pWebGLContext));
                } else {
                    return setupContext(pWebGLContext);
                }
            }

            //debug.warn("cannot get 3d device");
            return null;
        }
        webgl.createContext = createContext;

        (function (pWebGLContext) {
            if (!pWebGLContext) {
                return;
            }

            webgl.maxTextureSize = pWebGLContext.getParameter(3379 /* MAX_TEXTURE_SIZE */);
            webgl.maxCubeMapTextureSize = pWebGLContext.getParameter(34076 /* MAX_CUBE_MAP_TEXTURE_SIZE */);
            webgl.maxViewPortSize = pWebGLContext.getParameter(3386 /* MAX_VIEWPORT_DIMS */);

            webgl.maxTextureImageUnits = pWebGLContext.getParameter(34930 /* MAX_TEXTURE_IMAGE_UNITS */);
            webgl.maxVertexAttributes = pWebGLContext.getParameter(34921 /* MAX_VERTEX_ATTRIBS */);
            webgl.maxVertexTextureImageUnits = pWebGLContext.getParameter(35660 /* MAX_VERTEX_TEXTURE_IMAGE_UNITS */);
            webgl.maxCombinedTextureImageUnits = pWebGLContext.getParameter(35661 /* MAX_COMBINED_TEXTURE_IMAGE_UNITS */);

            webgl.stencilBits = pWebGLContext.getParameter(3415 /* STENCIL_BITS */);
            webgl.colorBits = [
                pWebGLContext.getParameter(3410 /* RED_BITS */),
                pWebGLContext.getParameter(3411 /* GREEN_BITS */),
                pWebGLContext.getParameter(3412 /* BLUE_BITS */)
            ];

            webgl.alphaBits = pWebGLContext.getParameter(3413 /* ALPHA_BITS */);
            webgl.multisampleType = pWebGLContext.getParameter(32938 /* SAMPLE_COVERAGE_VALUE */);

            pSupportedExtensionList = pWebGLContext.getSupportedExtensions();

            for (var i = 0; i < pSupportedExtensionList.length; ++i) {
                var sExtName = pSupportedExtensionList[i];

                if (isExtensionInBlackList(sExtName)) {
                    akra.logger.info(sExtName + " extension ignored because it is in the black list.");
                    pSupportedExtensionList.splice(i, 1);
                }
            }

            if (akra.config.DEBUG) {
                //pSupportedExtensionList.push(WEBGL.DEBUG_SHADERS, WEBGL.DEBUG_RENDERER_INFO);
            }

            isSupported = true;
        })(createContext());

        function hasExtension(sExtName) {
            for (var i = 0; i < pSupportedExtensionList.length; ++i) {
                if (pSupportedExtensionList[i].search(sExtName) != -1) {
                    return true;
                }
            }

            return false;
        }
        webgl.hasExtension = hasExtension;

        function getWebGLUsage(iFlags) {
            if (akra.bf.testAny(iFlags, 2 /* DYNAMIC */)) {
                return 35048 /* DYNAMIC_DRAW */;
            } else if (akra.bf.testAny(iFlags, 128 /* STREAM */)) {
                return 35040 /* STREAM_DRAW */;
            }

            return 35044 /* STATIC_DRAW */;
        }
        webgl.getWebGLUsage = getWebGLUsage;

        function getWebGLFormat(eFormat) {
            switch (eFormat) {
                case 1 /* L8 */:
                case 2 /* L16 */:
                    return 6409 /* LUMINANCE */;

                case 3 /* A8 */:
                    return 6406 /* ALPHA */;

                case 4 /* A4L4 */:
                case 5 /* BYTE_LA */:
                    return 6410 /* LUMINANCE_ALPHA */;

                case 6 /* R5G6B5 */:
                    return 0;
                case 7 /* B5G6R5 */:
                    return 6407 /* RGB */;
                case 31 /* R3G3B2 */:
                    return 0;
                case 8 /* A4R4G4B4 */:
                case 9 /* A1R5G5B5 */:
                    return 6408 /* RGBA */;

                case 10 /* R8G8B8 */:
                case 11 /* B8G8R8 */:
                    return 6407 /* RGB */;

                case 12 /* A8R8G8B8 */:
                case 13 /* A8B8G8R8 */:
                    return 6408 /* RGBA */;

                case 14 /* B8G8R8A8 */:
                case 28 /* R8G8B8A8 */:
                case 26 /* X8R8G8B8 */:
                case 27 /* X8B8G8R8 */:
                    return 6408 /* RGBA */;

                case 15 /* A2R10G10B10 */:
                    return 0;
                case 16 /* A2B10G10R10 */:
                    return 6408 /* RGBA */;

                case 17 /* DXT1 */:
                    return 33777 /* COMPRESSED_RGBA_S3TC_DXT1_EXT */;
                case 18 /* DXT2 */:
                    return 0;
                case 19 /* DXT3 */:
                    return 33778 /* COMPRESSED_RGBA_S3TC_DXT3_EXT */;
                case 20 /* DXT4 */:
                    return 0;
                case 21 /* DXT5 */:
                    return 33779 /* COMPRESSED_RGBA_S3TC_DXT5_EXT */;
                case 32 /* FLOAT16_R */:
                    return 0;
                case 22 /* FLOAT16_RGB */:
                    return 6407 /* RGB */;
                case 23 /* FLOAT16_RGBA */:
                    return 6408 /* RGBA */;
                case 33 /* FLOAT32_R */:
                    return 0;
                case 24 /* FLOAT32_RGB */:
                    return 6407 /* RGB */;
                case 25 /* FLOAT32_RGBA */:
                    return 6408 /* RGBA */;
                case 35 /* FLOAT16_GR */:
                case 36 /* FLOAT32_GR */:
                    return 0;

                case 29 /* FLOAT32_DEPTH */:
                case 46 /* DEPTH32 */:
                case 45 /* DEPTH16 */:
                case 44 /* DEPTH8 */:
                    return 6402 /* DEPTH_COMPONENT */;

                case 47 /* DEPTH24STENCIL8 */:
                    return 34041 /* DEPTH_STENCIL */;

                case 30 /* SHORT_RGBA */:
                    return 6408 /* RGBA */;
                case 34 /* SHORT_GR */:
                    return 0;
                case 37 /* SHORT_RGB */:
                    return 6407 /* RGB */;

                case 38 /* PVRTC_RGB2 */:
                    return 35841 /* COMPRESSED_RGB_PVRTC_2BPPV1_IMG */;
                case 39 /* PVRTC_RGBA2 */:
                    return 35843 /* COMPRESSED_RGBA_PVRTC_2BPPV1_IMG */;
                case 40 /* PVRTC_RGB4 */:
                    return 35840 /* COMPRESSED_RGB_PVRTC_4BPPV1_IMG */;
                case 41 /* PVRTC_RGBA4 */:
                    return 35842 /* COMPRESSED_RGBA_PVRTC_4BPPV1_IMG */;

                case 42 /* R8 */:
                case 43 /* RG8 */:
                    return 0;

                default:
                    akra.logger.warn("getWebGLFormat unknown format", eFormat);
                    return 0;
            }
        }
        webgl.getWebGLFormat = getWebGLFormat;

        function isWebGLFormatSupport(eFormat) {
            switch (eFormat) {
                case 17 /* DXT1 */:
                case 19 /* DXT3 */:
                case 21 /* DXT5 */:
                    return hasExtension(webgl.WEBGL_COMPRESSED_TEXTURE_S3TC);
                case 38 /* PVRTC_RGB2 */:
                case 39 /* PVRTC_RGBA2 */:
                case 40 /* PVRTC_RGB4 */:
                case 41 /* PVRTC_RGBA4 */:
                    return hasExtension(webgl.WEBGL_COMPRESSED_TEXTURE_PVRTC);
                case 46 /* DEPTH32 */:
                case 45 /* DEPTH16 */:
                case 47 /* DEPTH24STENCIL8 */:
                    return hasExtension(webgl.WEBGL_DEPTH_TEXTURE);
                case 46 /* DEPTH32 */:
                case 45 /* DEPTH16 */:
                case 47 /* DEPTH24STENCIL8 */:
                    return hasExtension(webgl.WEBGL_DEPTH_TEXTURE);
                case 22 /* FLOAT16_RGB */:
                case 23 /* FLOAT16_RGBA */:
                    return hasExtension(webgl.OES_TEXTURE_HALF_FLOAT);
                case 24 /* FLOAT32_RGB */:
                case 25 /* FLOAT32_RGBA */:
                    return hasExtension(webgl.OES_TEXTURE_FLOAT);
            }

            if (getWebGLFormat(eFormat) && getWebGLDataType(eFormat)) {
                // switch(eFormat)
                // {
                //     case EPixelFormats.FLOAT32_DEPTH:
                //     case EPixelFormats.L16:
                //         return false;
                // }
                return true;
            }

            return false;
        }
        webgl.isWebGLFormatSupport = isWebGLFormatSupport;

        function getWebglElementType(eType) {
            switch (eType) {
                case 5120 /* BYTE */:
                    return 5120 /* BYTE */;
                case 5121 /* UNSIGNED_BYTE */:
                    return 5121 /* UNSIGNED_BYTE */;
                case 5122 /* SHORT */:
                    return 5122 /* SHORT */;
                case 5123 /* UNSIGNED_SHORT */:
                    return 5123 /* UNSIGNED_SHORT */;
                case 5124 /* INT */:
                    return 5124 /* INT */;
                case 5125 /* UNSIGNED_INT */:
                    return 5125 /* UNSIGNED_INT */;
                case 5126 /* FLOAT */:
                    return 5126 /* FLOAT */;
                default:
                    akra.logger.critical("getWebglElementType unknown data type");
                    return 0;
            }
        }
        webgl.getWebglElementType = getWebglElementType;

        function getWebGLDataType(eFormat) {
            switch (eFormat) {
                case 1 /* L8 */:
                    return 5121 /* UNSIGNED_BYTE */;
                case 2 /* L16 */:
                    //return gl.UNSIGNED_SHORT;
                    return 5121 /* UNSIGNED_BYTE */;

                case 3 /* A8 */:
                    return 5121 /* UNSIGNED_BYTE */;

                case 4 /* A4L4 */:
                    return 0;
                case 5 /* BYTE_LA */:
                    return 5121 /* UNSIGNED_BYTE */;

                case 6 /* R5G6B5 */:
                case 7 /* B5G6R5 */:
                    return 33635 /* UNSIGNED_SHORT_5_6_5 */;
                case 31 /* R3G3B2 */:
                    return 0;
                case 8 /* A4R4G4B4 */:
                    return 32819 /* UNSIGNED_SHORT_4_4_4_4 */;
                case 9 /* A1R5G5B5 */:
                    return 32820 /* UNSIGNED_SHORT_5_5_5_1 */;

                case 10 /* R8G8B8 */:
                case 11 /* B8G8R8 */:
                case 12 /* A8R8G8B8 */:
                case 13 /* A8B8G8R8 */:
                case 14 /* B8G8R8A8 */:
                case 28 /* R8G8B8A8 */:
                case 26 /* X8R8G8B8 */:
                case 27 /* X8B8G8R8 */:
                    return 5121 /* UNSIGNED_BYTE */;

                case 15 /* A2R10G10B10 */:
                    return 0;
                case 16 /* A2B10G10R10 */:
                    return 0;

                case 17 /* DXT1 */:
                case 18 /* DXT2 */:
                case 19 /* DXT3 */:
                case 20 /* DXT4 */:
                case 21 /* DXT5 */:
                    return 0;

                case 32 /* FLOAT16_R */:
                case 22 /* FLOAT16_RGB */:
                case 23 /* FLOAT16_RGBA */:
                    return 36193 /* HALF_FLOAT_OES */;

                case 33 /* FLOAT32_R */:
                case 24 /* FLOAT32_RGB */:
                case 25 /* FLOAT32_RGBA */:
                case 35 /* FLOAT16_GR */:
                case 36 /* FLOAT32_GR */:
                    return 5126 /* FLOAT */;

                case 29 /* FLOAT32_DEPTH */:
                    return 5126 /* FLOAT */;

                case 44 /* DEPTH8 */:
                    return 5121 /* UNSIGNED_BYTE */;
                case 45 /* DEPTH16 */:
                    return 5123 /* UNSIGNED_SHORT */;
                case 46 /* DEPTH32 */:
                    return 5125 /* UNSIGNED_INT */;
                case 47 /* DEPTH24STENCIL8 */:
                    return 33639 /* UNSIGNED_INT_24_8_WEBGL */;

                case 30 /* SHORT_RGBA */:
                case 34 /* SHORT_GR */:
                case 37 /* SHORT_RGB */:
                    return 5123 /* UNSIGNED_SHORT */;

                case 38 /* PVRTC_RGB2 */:
                case 39 /* PVRTC_RGBA2 */:
                case 40 /* PVRTC_RGB4 */:
                case 41 /* PVRTC_RGBA4 */:
                    return 0;

                case 42 /* R8 */:
                case 43 /* RG8 */:
                    return 5121 /* UNSIGNED_BYTE */;

                default:
                    akra.logger.critical("getWebGLFormat unknown format");
                    return 0;
            }
        }
        webgl.getWebGLDataType = getWebGLDataType;

        function getWebGLInternalFormat(eFormat) {
            if (!akra.pixelUtil.isCompressed(eFormat)) {
                return getWebGLFormat(eFormat);
            } else {
                switch (eFormat) {
                    case 17 /* DXT1 */:
                        return 33777 /* COMPRESSED_RGBA_S3TC_DXT1_EXT */;
                    case 18 /* DXT2 */:
                        return 0;
                    case 19 /* DXT3 */:
                        return 33778 /* COMPRESSED_RGBA_S3TC_DXT3_EXT */;
                    case 20 /* DXT4 */:
                        return 0;
                    case 21 /* DXT5 */:
                        return 33779 /* COMPRESSED_RGBA_S3TC_DXT5_EXT */;
                    case 38 /* PVRTC_RGB2 */:
                        return 35841 /* COMPRESSED_RGB_PVRTC_2BPPV1_IMG */;
                    case 39 /* PVRTC_RGBA2 */:
                        return 35843 /* COMPRESSED_RGBA_PVRTC_2BPPV1_IMG */;
                    case 40 /* PVRTC_RGB4 */:
                        return 35840 /* COMPRESSED_RGB_PVRTC_4BPPV1_IMG */;
                    case 41 /* PVRTC_RGBA4 */:
                        return 35842 /* COMPRESSED_RGBA_PVRTC_4BPPV1_IMG */;
                }
            }
        }
        webgl.getWebGLInternalFormat = getWebGLInternalFormat;

        function getWebGLPrimitiveType(eType) {
            switch (eType) {
                case 0 /* POINTLIST */:
                    return 0 /* POINTS */;
                case 1 /* LINELIST */:
                    return 1 /* LINES */;
                case 2 /* LINELOOP */:
                    return 2 /* LINE_LOOP */;
                case 3 /* LINESTRIP */:
                    return 3 /* LINE_STRIP */;
                case 4 /* TRIANGLELIST */:
                    return 4 /* TRIANGLES */;
                case 5 /* TRIANGLESTRIP */:
                    return 5 /* TRIANGLE_STRIP */;
                case 6 /* TRIANGLEFAN */:
                    return 6 /* TRIANGLE_FAN */;
            }

            return 0 /* POINTS */;
        }
        webgl.getWebGLPrimitiveType = getWebGLPrimitiveType;

        // Takes the AKRA pixel format and returns the type that must be provided to WebGL as internal format.
        // If no match exists, returns the closest match.
        function getClosestWebGLInternalFormat(eFormat) {
            var iGLFormat = getWebGLInternalFormat(eFormat);

            if (iGLFormat === 0 /* NONE */) {
                return 6408 /* RGBA */;
            }

            return iGLFormat;
        }
        webgl.getClosestWebGLInternalFormat = getClosestWebGLInternalFormat;

        /**
        * Convert GL format to EPixelFormat.
        */
        function getClosestAkraFormat(iGLFormat, iGLDataType) {
            switch (iGLFormat) {
                case 35841 /* COMPRESSED_RGB_PVRTC_2BPPV1_IMG */:
                    return hasExtension(webgl.WEBGL_COMPRESSED_TEXTURE_PVRTC) ? 38 /* PVRTC_RGB2 */ : 12 /* A8R8G8B8 */;
                case 35843 /* COMPRESSED_RGBA_PVRTC_2BPPV1_IMG */:
                    return hasExtension(webgl.WEBGL_COMPRESSED_TEXTURE_PVRTC) ? 39 /* PVRTC_RGBA2 */ : 12 /* A8R8G8B8 */;
                case 35840 /* COMPRESSED_RGB_PVRTC_4BPPV1_IMG */:
                    return hasExtension(webgl.WEBGL_COMPRESSED_TEXTURE_PVRTC) ? 40 /* PVRTC_RGB4 */ : 12 /* A8R8G8B8 */;
                case 35842 /* COMPRESSED_RGBA_PVRTC_4BPPV1_IMG */:
                    return hasExtension(webgl.WEBGL_COMPRESSED_TEXTURE_PVRTC) ? 41 /* PVRTC_RGBA4 */ : 12 /* A8R8G8B8 */;

                case 6409 /* LUMINANCE */:
                    return 1 /* L8 */;
                case 6406 /* ALPHA */:
                    return 3 /* A8 */;
                case 6410 /* LUMINANCE_ALPHA */:
                    return 5 /* BYTE_LA */;

                case 6407 /* RGB */:
                    switch (iGLDataType) {
                        case 33635 /* UNSIGNED_SHORT_5_6_5 */:
                            return 7 /* B5G6R5 */;
                        default:
                            return 10 /* R8G8B8 */;
                    }

                case 6408 /* RGBA */:
                    switch (iGLDataType) {
                        case 32820 /* UNSIGNED_SHORT_5_5_5_1 */:
                            return 9 /* A1R5G5B5 */;
                        case 32819 /* UNSIGNED_SHORT_4_4_4_4 */:
                            return 8 /* A4R4G4B4 */;
                        case 5126 /* FLOAT */:
                            return 25 /* FLOAT32_RGBA */;
                        default:
                            return 28 /* R8G8B8A8 */;
                    }

                case 32993 /* BGRA */:
                    return 13 /* A8B8G8R8 */;

                case 33776 /* COMPRESSED_RGB_S3TC_DXT1_EXT */:
                case 33777 /* COMPRESSED_RGBA_S3TC_DXT1_EXT */:
                    return hasExtension(webgl.WEBGL_COMPRESSED_TEXTURE_S3TC) ? 17 /* DXT1 */ : 12 /* A8R8G8B8 */;

                case 33778 /* COMPRESSED_RGBA_S3TC_DXT3_EXT */:
                    return hasExtension(webgl.WEBGL_COMPRESSED_TEXTURE_S3TC) ? 19 /* DXT3 */ : 12 /* A8R8G8B8 */;
                case 33779 /* COMPRESSED_RGBA_S3TC_DXT5_EXT */:
                    return hasExtension(webgl.WEBGL_COMPRESSED_TEXTURE_S3TC) ? 21 /* DXT5 */ : 12 /* A8R8G8B8 */;

                case 33321 /* R8_EXT */:
                    return hasExtension(webgl.EXT_TEXTURE_RG) ? 42 /* R8 */ : 12 /* A8R8G8B8 */;
                case 33323 /* RG8_EXT */:
                    return hasExtension(webgl.EXT_TEXTURE_RG) ? 43 /* RG8 */ : 12 /* A8R8G8B8 */;

                case 6402 /* DEPTH_COMPONENT */:
                    switch (iGLDataType) {
                        case 5126 /* FLOAT */:
                            return 29 /* FLOAT32_DEPTH */;
                        case 5125 /* UNSIGNED_INT */:
                            return 46 /* DEPTH32 */;
                        case 5123 /* UNSIGNED_SHORT */:
                            return 45 /* DEPTH16 */;
                        case 5121 /* UNSIGNED_BYTE */:
                            return 44 /* DEPTH8 */;
                    }

                case 34041 /* DEPTH_STENCIL */:
                    return 47 /* DEPTH24STENCIL8 */;

                default:
                    //TODO: not supported
                    return 12 /* A8R8G8B8 */;
            }
        }
        webgl.getClosestAkraFormat = getClosestAkraFormat;

        function optionalPO2(iValue) {
            if (webgl.hasNonPowerOf2Textures) {
                return iValue;
            } else {
                return akra.math.ceilingPowerOfTwo(iValue);
            }
        }
        webgl.optionalPO2 = optionalPO2;

        function convertToWebGLformat(pSource, pDest) {
            // Always need to convert PF_A4R4G4B4, GL expects the colors to be in the
            // reverse order
            if (pDest.format == 8 /* A4R4G4B4 */) {
                // Convert PF_A4R4G4B4 -> PF_B4G4R4A4
                // Reverse pixel order
                var iSrcPtr = (pSource.left + pSource.top * pSource.rowPitch + pSource.front * pSource.slicePitch);
                var iDstPtr = (pDest.left + pDest.top * pDest.rowPitch + pDest.front * pDest.slicePitch);
                var iSrcSliceSkip = pSource.getSliceSkip();
                var iDstSliceSkip = pDest.getSliceSkip();
                var k = pSource.right - pSource.left;
                var x = 0, y = 0, z = 0;

                for (z = pSource.front; z < pSource.back; z++) {
                    for (y = pSource.top; y < pSource.bottom; y++) {
                        for (x = 0; x < k; x++) {
                            pDest[iDstPtr + x] = ((pSource[iSrcPtr + x] & 0x000F) << 12) | ((pSource[iSrcPtr + x] & 0x00F0) << 4) | ((pSource[iSrcPtr + x] & 0x0F00) >> 4) | ((pSource[iSrcPtr + x] & 0xF000) >> 12); /* A*/
                        }

                        iSrcPtr += pSource.rowPitch;
                        iDstPtr += pDest.rowPitch;
                    }

                    iSrcPtr += iSrcSliceSkip;
                    iDstPtr += iDstSliceSkip;
                }
            }
        }
        webgl.convertToWebGLformat = convertToWebGLformat;

        function checkFBOAttachmentFormat(eFormat) {
            if (eFormat === 28 /* R8G8B8A8 */ || eFormat === 10 /* R8G8B8 */) {
                return true;
            } else if (eFormat === 13 /* A8B8G8R8 */) {
                return true;
            } else if (eFormat === 25 /* FLOAT32_RGBA */) {
                // return hasExtension(WEBGL.COLOR_BUFFER_FLOAT);
                return hasExtension(webgl.OES_TEXTURE_FLOAT);
            } else if (eFormat === 23 /* FLOAT16_RGBA */) {
                // return hasExtension(EXT_COLOR_BUFFER_HALF_FLOAT);
                return hasExtension(webgl.OES_TEXTURE_HALF_FLOAT);
            } else if (eFormat === 46 /* DEPTH32 */) {
                return true;
            } else {
                return false;
            }
        }
        webgl.checkFBOAttachmentFormat = checkFBOAttachmentFormat;

        function checkReadPixelFormat(eFormat) {
            if (eFormat === 28 /* R8G8B8A8 */ || eFormat === 10 /* R8G8B8 */) {
                return true;
            } else if (eFormat === 25 /* FLOAT32_RGBA */) {
                //hasExtension(WEBGL.COLOR_BUFFER_FLOAT) || hasExtension(EXT_COLOR_BUFFER_HALF_FLOAT);
                return false;
            } else {
                return false;
            }
        }
        webgl.checkReadPixelFormat = checkReadPixelFormat;

        function checkCopyTexImage(eFormat) {
            switch (eFormat) {
                case 28 /* R8G8B8A8 */:
                case 10 /* R8G8B8 */:
                case 1 /* L8 */:
                case 2 /* L16 */:
                case 3 /* A8 */:
                    return true;

                default:
                    return false;
            }
        }
        webgl.checkCopyTexImage = checkCopyTexImage;

        function getSupportedAlternative(eFormat) {
            if (checkFBOAttachmentFormat(eFormat)) {
                return eFormat;
            }

            /// Find first alternative
            var pct = akra.pixelUtil.getComponentType(eFormat);

            switch (pct) {
                case 0 /* BYTE */:
                    eFormat = 12 /* A8R8G8B8 */;
                    break;
                case 1 /* SHORT */:
                    eFormat = 30 /* SHORT_RGBA */;
                    break;
                case 3 /* FLOAT16 */:
                    eFormat = 23 /* FLOAT16_RGBA */;
                    break;
                case 4 /* FLOAT32 */:
                    eFormat = 25 /* FLOAT32_RGBA */;
                    break;
                case 5 /* COUNT */:
                default:
                    break;
            }

            if (checkFBOAttachmentFormat(eFormat)) {
                return eFormat;
            }

            /// If none at all, return to default
            return 12 /* A8R8G8B8 */;
        }
        webgl.getSupportedAlternative = getSupportedAlternative;
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
/// <reference path="../idl/IApiInfo.ts" />
/// <reference path="../idl/3d-party/zip.d.ts" />
/// <reference path="../common.ts" />
/// <reference path="../util/Singleton.ts" />
/// <reference path="../webgl/webgl.ts" />
/// <reference path="../logger.ts" />
var akra;
(function (akra) {
    (function (info) {
        var Singleton = akra.util.Singleton;

        window["requestFileSystem"] = window["requestFileSystem"] || window["webkitRequestFileSystem"];

        var ApiInfo = (function (_super) {
            __extends(ApiInfo, _super);
            function ApiInfo() {
                _super.call(this);
                this._bWebAudio = false;
                this._bFile = false;
                this._bFileSystem = false;
                this._bWebWorker = false;
                this._bTransferableObjects = false;
                this._bLocalStorage = false;
                this._bWebSocket = false;
                this._bGamepad = false;
                this._bPromise = false;

                this._bWebAudio = (window["AudioContext"] && window["webkitAudioContext"] ? true : false);
                this._bFile = (window["File"] && window["FileReader"] && window["FileList"] && window["Blob"] ? true : false);
                this._bFileSystem = (this._bFile && window["URL"] && window["requestFileSystem"] ? true : false);
                this._bWebWorker = akra.isDef(window["Worker"]);
                this._bLocalStorage = akra.isDef(window["localStorage"]);
                this._bWebSocket = akra.isDef(window["WebSocket"]);
                this._bGamepad = !!navigator["webkitGetGamepads"] || !!navigator["webkitGamepads"] || (navigator.userAgent.indexOf('Firefox/') != -1);
                this._bPromise = akra.isDefAndNotNull(window["Promise"]);
            }
            ApiInfo.prototype.getWebGL = function () {
                return akra.webgl.isEnabled();
            };

            ApiInfo.prototype.getTransferableObjects = function () {
                if (!this._bTransferableObjects) {
                    this._bTransferableObjects = (this._bWebWorker && this.chechTransferableObjects() ? true : false);
                }

                return this._bTransferableObjects;
            };

            ApiInfo.prototype.getFile = function () {
                return this._bFile;
            };

            ApiInfo.prototype.getFileSystem = function () {
                return this._bFileSystem;
            };

            ApiInfo.prototype.getWebAudio = function () {
                return this._bWebAudio;
            };

            ApiInfo.prototype.getWebWorker = function () {
                return this._bWebWorker;
            };

            ApiInfo.prototype.getLocalStorage = function () {
                return this._bLocalStorage;
            };

            ApiInfo.prototype.getWebSocket = function () {
                return this._bWebSocket;
            };

            ApiInfo.prototype.getGamepad = function () {
                return this._bGamepad;
            };

            ApiInfo.prototype.getZip = function () {
                return akra.isDefAndNotNull(window["zip"]);
            };

            ApiInfo.prototype.getPromise = function () {
                return this._bPromise;
            };

            ApiInfo.prototype.chechTransferableObjects = function () {
                var pBlob = new Blob(["onmessage = function(e) { postMessage(true); }"], { "type": "text\/javascript" });
                var sBlobURL = window.URL.createObjectURL(pBlob);
                var pWorker = new Worker(sBlobURL);

                var pBuffer = new ArrayBuffer(1);

                try  {
                    pWorker.postMessage(pBuffer, [pBuffer]);
                } catch (e) {
                    akra.logger.log('transferable objects not supported in your browser...');
                }

                pWorker.terminate();

                if (pBuffer.byteLength) {
                    return false;
                }

                return true;
            };
            return ApiInfo;
        })(Singleton);
        info.ApiInfo = ApiInfo;
    })(akra.info || (akra.info = {}));
    var info = akra.info;
})(akra || (akra = {}));
/// <reference path="../idl/IScreenInfo.ts" />
var akra;
(function (akra) {
    (function (info) {
        var ScreenInfo = (function () {
            function ScreenInfo() {
                this._pScreen = window["screen"];
            }
            ScreenInfo.prototype.getWidth = function () {
                return this._pScreen.width;
            };

            ScreenInfo.prototype.getHeight = function () {
                return this._pScreen.height;
            };

            ScreenInfo.prototype.getAspect = function () {
                return this._pScreen.width / this._pScreen.height;
            };

            ScreenInfo.prototype.getPixelDepth = function () {
                return this._pScreen.pixelDepth;
            };

            ScreenInfo.prototype.getColorDepth = function () {
                return this._pScreen.colorDepth;
            };

            ScreenInfo.prototype.getAvailHeight = function () {
                return this._pScreen.availHeight;
            };

            ScreenInfo.prototype.getAvailWidth = function () {
                return this._pScreen.availWidth;
            };
            return ScreenInfo;
        })();
        info.ScreenInfo = ScreenInfo;
    })(akra.info || (akra.info = {}));
    var info = akra.info;
})(akra || (akra = {}));
/// <reference path="idl/IEventProvider.ts" />
/// <reference path="common.ts" />
var akra;
(function (akra) {
    var Signal = (function () {
        /**
        * @param pSender Object, that will be emit signal.
        * @param eType Signal type.
        */
        function Signal(pSender, eType) {
            if (typeof eType === "undefined") { eType = 1 /* BROADCAST */; }
            this._pBroadcastListeners = null;
            this._nBroadcastListenersCount = 0;
            this._pUnicastListener = null;
            this._pSender = null;
            this._eType = 1 /* BROADCAST */;
            this._fnForerunnerTrigger = null;
            this._pSyncSignal = null;
            this._sForerunnerTriggerName = null;
            this._pSender = pSender;
            this._eType = eType;

            if (this._eType === 1 /* BROADCAST */) {
                this._pBroadcastListeners = [];
            }
            //if (!isNull(this._pSender)) {
            //	this._sSenderCallbackName = this.findCallbacknameForListener(this._pSender, this._fnSenderCallback);
            //}
        }
        Signal.prototype.getListeners = function (eEventType) {
            if (eEventType == 1 /* BROADCAST */) {
                return this._pBroadcastListeners;
            }

            if (!akra.isNull(this._pUnicastListener)) {
                return [this._pUnicastListener];
            }

            return [];
        };

        Signal.prototype.getSender = function () {
            return this._pSender;
        };

        Signal.prototype.getType = function () {
            return this._eType;
        };

        /** @param fn Must be method of signal sender */
        Signal.prototype.setForerunner = function (fn) {
            //debug.assert(this.isMethodExistsInSenderPrototype(fn), "Callback must be a part of sender proto.");
            this._fnForerunnerTrigger = fn;

            if (this._pSender !== null) {
                this._sForerunnerTriggerName = this.findCallbacknameForListener(this._pSender, fn);
            }
        };

        Signal.prototype.connect = function () {
            var pListener = this.fromParamsToListener(arguments);

            if (pListener === null) {
                return false;
            }

            if (pListener.type === 0 /* UNICAST */) {
                if (this._pUnicastListener !== null) {
                    this.clearListener(pListener);
                    return false;
                }

                this._pUnicastListener = pListener;
            } else {
                if (this.indexOfBroadcastListener(pListener.reciever, pListener.callback) >= 0) {
                    akra.debug.warn("Listener already exists: ", "listener:", pListener, "sender:", this.getSender());
                    this.clearListener(pListener);
                    return false;
                }

                this._pBroadcastListeners[this._nBroadcastListenersCount++] = pListener;
            }

            return true;
        };

        Signal.prototype.disconnect = function () {
            var pTmpListener = this.fromParamsToListener(arguments);
            var bResult = false;

            if (pTmpListener === null) {
                return false;
            }

            if (pTmpListener.type === 0 /* UNICAST */) {
                if (pTmpListener.reciever === this._pUnicastListener.reciever && pTmpListener.callback === this._pUnicastListener.callback) {
                    this.clearListener(this._pUnicastListener);
                    this._pUnicastListener = null;
                    bResult = true;
                }
            } else {
                var index = this.indexOfBroadcastListener(pTmpListener.reciever, pTmpListener.callback);
                if (index >= 0) {
                    this.clearListener(this._pBroadcastListeners.splice(index, 1)[0]);
                    this._nBroadcastListenersCount--;
                    bResult = true;
                }
            }

            this.clearListener(pTmpListener);
            return bResult;
        };

        Signal.prototype.emit = function () {
            var pListener = null;
            var nListeners = this._eType === 1 /* BROADCAST */ ? this._nBroadcastListenersCount : 1;

            switch (arguments.length) {
                case 0:
                    if (this._pSyncSignal !== null) {
                        var pOriginalSender = this._pSyncSignal.getSender();

                        if (this._pSyncSignal.getSender() !== null) {
                            this._pSyncSignal._setSender(this._pSender);
                        }

                        this._pSyncSignal.emit();

                        this._pSyncSignal._setSender(pOriginalSender);
                    }

                    if (this._fnForerunnerTrigger !== null) {
                        if (this._pSender === null) {
                            this._fnForerunnerTrigger();
                        } else if (this._sForerunnerTriggerName !== null) {
                            this._pSender[this._sForerunnerTriggerName]();
                        } else {
                            this._fnForerunnerTrigger.call(this._pSender);
                        }
                    }

                    if (this._eType === 0 /* UNICAST */ && this._pUnicastListener !== null) {
                        pListener = this._pUnicastListener;
                        if (pListener.reciever === null) {
                            pListener.callback(this._pSender);
                        } else if (pListener.callbackName !== null) {
                            pListener.reciever[pListener.callbackName](this._pSender);
                        } else {
                            pListener.callback.call(pListener.reciever, this._pSender);
                        }
                    } else {
                        for (var i = 0; i < this._nBroadcastListenersCount; i++) {
                            pListener = this._pBroadcastListeners[i];
                            if (pListener === null)
                                continue;
                            if (pListener.reciever === null) {
                                pListener.callback(this._pSender);
                            } else if (pListener.callbackName !== null) {
                                pListener.reciever[pListener.callbackName](this._pSender);
                            } else {
                                pListener.callback.call(pListener.reciever, this._pSender);
                            }
                        }
                    }

                    return;
                case 1:
                    if (this._pSyncSignal !== null) {
                        var pOriginalSender = this._pSyncSignal.getSender();

                        if (this._pSyncSignal.getSender() !== null) {
                            this._pSyncSignal._setSender(this._pSender);
                        }

                        this._pSyncSignal.emit(arguments[0]);

                        this._pSyncSignal._setSender(pOriginalSender);
                    }

                    if (this._fnForerunnerTrigger !== null) {
                        if (this._pSender === null) {
                            this._fnForerunnerTrigger(arguments[0]);
                        } else if (this._sForerunnerTriggerName !== null) {
                            this._pSender[this._sForerunnerTriggerName](arguments[0]);
                        } else {
                            this._fnForerunnerTrigger.call(this._pSender, arguments[0]);
                        }
                    }

                    if (this._eType === 0 /* UNICAST */ && this._pUnicastListener !== null) {
                        pListener = this._pUnicastListener;
                        if (pListener.reciever === null) {
                            pListener.callback(this._pSender, arguments[0]);
                        } else if (pListener.callbackName !== null) {
                            pListener.reciever[pListener.callbackName](this._pSender, arguments[0]);
                        } else {
                            pListener.callback.call(pListener.reciever, this._pSender, arguments[0]);
                        }
                    } else {
                        for (var i = 0; i < this._nBroadcastListenersCount; i++) {
                            pListener = this._pBroadcastListeners[i];
                            if (pListener === null)
                                continue;
                            if (pListener.reciever === null) {
                                pListener.callback(this._pSender, arguments[0]);
                            } else if (pListener.callbackName !== null) {
                                pListener.reciever[pListener.callbackName](this._pSender, arguments[0]);
                            } else {
                                pListener.callback.call(pListener.reciever, this._pSender, arguments[0]);
                            }
                        }
                    }

                    return;
                case 2:
                    if (this._pSyncSignal !== null) {
                        var pOriginalSender = this._pSyncSignal.getSender();

                        if (this._pSyncSignal.getSender() !== null) {
                            this._pSyncSignal._setSender(this._pSender);
                        }

                        this._pSyncSignal.emit(arguments[0], arguments[1]);

                        this._pSyncSignal._setSender(pOriginalSender);
                    }

                    if (this._fnForerunnerTrigger !== null) {
                        if (this._pSender === null) {
                            this._fnForerunnerTrigger(arguments[0], arguments[1]);
                        } else if (this._sForerunnerTriggerName !== null) {
                            this._pSender[this._sForerunnerTriggerName](arguments[0], arguments[1]);
                        } else {
                            this._fnForerunnerTrigger.call(this._pSender, arguments[0], arguments[1]);
                        }
                    }

                    if (this._eType === 0 /* UNICAST */ && this._pUnicastListener !== null) {
                        pListener = this._pUnicastListener;
                        if (pListener.reciever === null) {
                            pListener.callback(this._pSender, arguments[0], arguments[1]);
                        } else if (pListener.callbackName !== null) {
                            pListener.reciever[pListener.callbackName](this._pSender, arguments[0], arguments[1]);
                        } else {
                            pListener.callback.call(pListener.reciever, this._pSender, arguments[0], arguments[1]);
                        }
                    } else {
                        for (var i = 0; i < this._nBroadcastListenersCount; i++) {
                            pListener = this._pBroadcastListeners[i];
                            if (pListener === null)
                                continue;
                            if (pListener.reciever === null) {
                                pListener.callback(this._pSender, arguments[0], arguments[1]);
                            } else if (pListener.callbackName !== null) {
                                pListener.reciever[pListener.callbackName](this._pSender, arguments[0], arguments[1]);
                            } else {
                                pListener.callback.call(pListener.reciever, this._pSender, arguments[0], arguments[1]);
                            }
                        }
                    }

                    return;
                case 3:
                    if (this._pSyncSignal !== null) {
                        var pOriginalSender = this._pSyncSignal.getSender();

                        if (this._pSyncSignal.getSender() !== null) {
                            this._pSyncSignal._setSender(this._pSender);
                        }

                        this._pSyncSignal.emit(arguments[0], arguments[1], arguments[2]);

                        this._pSyncSignal._setSender(pOriginalSender);
                    }

                    if (this._fnForerunnerTrigger !== null) {
                        if (this._pSender === null) {
                            this._fnForerunnerTrigger(arguments[0], arguments[1], arguments[2]);
                        } else if (this._sForerunnerTriggerName !== null) {
                            this._pSender[this._sForerunnerTriggerName](arguments[0], arguments[1], arguments[2]);
                        } else {
                            this._fnForerunnerTrigger.call(this._pSender, arguments[0], arguments[1], arguments[2]);
                        }
                    }

                    if (this._eType === 0 /* UNICAST */ && this._pUnicastListener !== null) {
                        pListener = this._pUnicastListener;
                        if (pListener.reciever === null) {
                            pListener.callback(this._pSender, arguments[0], arguments[1], arguments[2]);
                        } else if (pListener.callbackName !== null) {
                            pListener.reciever[pListener.callbackName](this._pSender, arguments[0], arguments[1], arguments[2]);
                        } else {
                            pListener.callback.call(pListener.reciever, this._pSender, arguments[0], arguments[1], arguments[2]);
                        }
                    } else {
                        for (var i = 0; i < this._nBroadcastListenersCount; i++) {
                            pListener = this._pBroadcastListeners[i];
                            if (pListener === null)
                                continue;
                            if (pListener.reciever === null) {
                                pListener.callback(this._pSender, arguments[0], arguments[1], arguments[2]);
                            } else if (pListener.callbackName !== null) {
                                pListener.reciever[pListener.callbackName](this._pSender, arguments[0], arguments[1], arguments[2]);
                            } else {
                                pListener.callback.call(pListener.reciever, this._pSender, arguments[0], arguments[1], arguments[2]);
                            }
                        }
                    }

                    return;
                case 4:
                    if (this._pSyncSignal !== null) {
                        var pOriginalSender = this._pSyncSignal.getSender();

                        if (this._pSyncSignal.getSender() !== null) {
                            this._pSyncSignal._setSender(this._pSender);
                        }

                        this._pSyncSignal.emit(arguments[0], arguments[1], arguments[2], arguments[3]);

                        this._pSyncSignal._setSender(pOriginalSender);
                    }

                    if (this._fnForerunnerTrigger !== null) {
                        if (this._pSender === null) {
                            this._fnForerunnerTrigger(arguments[0], arguments[1], arguments[2], arguments[3]);
                        } else if (this._sForerunnerTriggerName !== null) {
                            this._pSender[this._sForerunnerTriggerName](arguments[0], arguments[1], arguments[2], arguments[3]);
                        } else {
                            this._fnForerunnerTrigger.call(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3]);
                        }
                    }

                    if (this._eType === 0 /* UNICAST */ && this._pUnicastListener !== null) {
                        pListener = this._pUnicastListener;
                        if (pListener.reciever === null) {
                            pListener.callback(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3]);
                        } else if (pListener.callbackName !== null) {
                            pListener.reciever[pListener.callbackName](this._pSender, arguments[0], arguments[1], arguments[2], arguments[3]);
                        } else {
                            pListener.callback.call(pListener.reciever, this._pSender, arguments[0], arguments[1], arguments[2], arguments[3]);
                        }
                    } else {
                        for (var i = 0; i < this._nBroadcastListenersCount; i++) {
                            pListener = this._pBroadcastListeners[i];
                            if (pListener === null)
                                continue;
                            if (pListener.reciever === null) {
                                pListener.callback(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3]);
                            } else if (pListener.callbackName !== null) {
                                pListener.reciever[pListener.callbackName](this._pSender, arguments[0], arguments[1], arguments[2], arguments[3]);
                            } else {
                                pListener.callback.call(pListener.reciever, this._pSender, arguments[0], arguments[1], arguments[2], arguments[3]);
                            }
                        }
                    }

                    return;
                case 5:
                    if (this._pSyncSignal !== null) {
                        var pOriginalSender = this._pSyncSignal.getSender();

                        if (this._pSyncSignal.getSender() !== null) {
                            this._pSyncSignal._setSender(this._pSender);
                        }

                        this._pSyncSignal.emit(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);

                        this._pSyncSignal._setSender(pOriginalSender);
                    }

                    if (this._fnForerunnerTrigger !== null) {
                        if (this._pSender === null) {
                            this._fnForerunnerTrigger(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
                        } else if (this._sForerunnerTriggerName !== null) {
                            this._pSender[this._sForerunnerTriggerName](arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
                        } else {
                            this._fnForerunnerTrigger.call(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
                        }
                    }

                    if (this._eType === 0 /* UNICAST */ && this._pUnicastListener !== null) {
                        pListener = this._pUnicastListener;
                        if (pListener.reciever === null) {
                            pListener.callback(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
                        } else if (pListener.callbackName !== null) {
                            pListener.reciever[pListener.callbackName](this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
                        } else {
                            pListener.callback.call(pListener.reciever, this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
                        }
                    } else {
                        for (var i = 0; i < this._nBroadcastListenersCount; i++) {
                            pListener = this._pBroadcastListeners[i];
                            if (pListener === null)
                                continue;
                            if (pListener.reciever === null) {
                                pListener.callback(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
                            } else if (pListener.callbackName !== null) {
                                pListener.reciever[pListener.callbackName](this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
                            } else {
                                pListener.callback.call(pListener.reciever, this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
                            }
                        }
                    }

                    return;
                case 6:
                    if (this._pSyncSignal !== null) {
                        var pOriginalSender = this._pSyncSignal.getSender();

                        if (this._pSyncSignal.getSender() !== null) {
                            this._pSyncSignal._setSender(this._pSender);
                        }

                        this._pSyncSignal.emit(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);

                        this._pSyncSignal._setSender(pOriginalSender);
                    }

                    if (this._fnForerunnerTrigger !== null) {
                        if (this._pSender === null) {
                            this._fnForerunnerTrigger(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                        } else if (this._sForerunnerTriggerName !== null) {
                            this._pSender[this._sForerunnerTriggerName](arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                        } else {
                            this._fnForerunnerTrigger.call(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                        }
                    }

                    if (this._eType === 0 /* UNICAST */ && this._pUnicastListener !== null) {
                        pListener = this._pUnicastListener;
                        if (pListener.reciever === null) {
                            pListener.callback(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                        } else if (pListener.callbackName !== null) {
                            pListener.reciever[pListener.callbackName](this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                        } else {
                            pListener.callback.call(pListener.reciever, this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                        }
                    } else {
                        for (var i = 0; i < this._nBroadcastListenersCount; i++) {
                            pListener = this._pBroadcastListeners[i];
                            if (pListener === null)
                                continue;
                            if (pListener.reciever === null) {
                                pListener.callback(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                            } else if (pListener.callbackName !== null) {
                                pListener.reciever[pListener.callbackName](this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                            } else {
                                pListener.callback.call(pListener.reciever, this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                            }
                        }
                    }

                    return;
                case 7:
                    if (this._pSyncSignal !== null) {
                        var pOriginalSender = this._pSyncSignal.getSender();

                        if (this._pSyncSignal.getSender() !== null) {
                            this._pSyncSignal._setSender(this._pSender);
                        }

                        this._pSyncSignal.emit(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6]);

                        this._pSyncSignal._setSender(pOriginalSender);
                    }

                    if (this._fnForerunnerTrigger !== null) {
                        if (this._pSender === null) {
                            this._fnForerunnerTrigger(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6]);
                        } else if (this._sForerunnerTriggerName !== null) {
                            this._pSender[this._sForerunnerTriggerName](arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6]);
                        } else {
                            this._fnForerunnerTrigger.call(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6]);
                        }
                    }

                    if (this._eType === 0 /* UNICAST */ && this._pUnicastListener !== null) {
                        pListener = this._pUnicastListener;
                        if (pListener.reciever === null) {
                            pListener.callback(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6]);
                        } else if (pListener.callbackName !== null) {
                            pListener.reciever[pListener.callbackName](this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6]);
                        } else {
                            pListener.callback.call(pListener.reciever, this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6]);
                        }
                    } else {
                        for (var i = 0; i < this._nBroadcastListenersCount; i++) {
                            pListener = this._pBroadcastListeners[i];
                            if (pListener === null)
                                continue;
                            if (pListener.reciever === null) {
                                pListener.callback(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6]);
                            } else if (pListener.callbackName !== null) {
                                pListener.reciever[pListener.callbackName](this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6]);
                            } else {
                                pListener.callback.call(pListener.reciever, this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6]);
                            }
                        }
                    }

                    return;
                case 8:
                    if (this._pSyncSignal !== null) {
                        var pOriginalSender = this._pSyncSignal.getSender();

                        if (this._pSyncSignal.getSender() !== null) {
                            this._pSyncSignal._setSender(this._pSender);
                        }

                        this._pSyncSignal.emit(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7]);

                        this._pSyncSignal._setSender(pOriginalSender);
                    }

                    if (this._fnForerunnerTrigger !== null) {
                        if (this._pSender === null) {
                            this._fnForerunnerTrigger(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7]);
                        } else if (this._sForerunnerTriggerName !== null) {
                            this._pSender[this._sForerunnerTriggerName](arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7]);
                        } else {
                            this._fnForerunnerTrigger.call(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7]);
                        }
                    }

                    if (this._eType === 0 /* UNICAST */ && this._pUnicastListener !== null) {
                        pListener = this._pUnicastListener;
                        if (pListener.reciever === null) {
                            pListener.callback(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7]);
                        } else if (pListener.callbackName !== null) {
                            pListener.reciever[pListener.callbackName](this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7]);
                        } else {
                            pListener.callback.call(pListener.reciever, this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7]);
                        }
                    } else {
                        for (var i = 0; i < this._nBroadcastListenersCount; i++) {
                            pListener = this._pBroadcastListeners[i];
                            if (pListener === null)
                                continue;
                            if (pListener.reciever === null) {
                                pListener.callback(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7]);
                            } else if (pListener.callbackName !== null) {
                                pListener.reciever[pListener.callbackName](this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7]);
                            } else {
                                pListener.callback.call(pListener.reciever, this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7]);
                            }
                        }
                    }

                    return;
                case 9:
                    if (this._pSyncSignal !== null) {
                        var pOriginalSender = this._pSyncSignal.getSender();

                        if (this._pSyncSignal.getSender() !== null) {
                            this._pSyncSignal._setSender(this._pSender);
                        }

                        this._pSyncSignal.emit(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]);

                        this._pSyncSignal._setSender(pOriginalSender);
                    }

                    if (this._fnForerunnerTrigger !== null) {
                        if (this._pSender === null) {
                            this._fnForerunnerTrigger(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]);
                        } else if (this._sForerunnerTriggerName !== null) {
                            this._pSender[this._sForerunnerTriggerName](arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]);
                        } else {
                            this._fnForerunnerTrigger.call(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]);
                        }
                    }

                    if (this._eType === 0 /* UNICAST */ && this._pUnicastListener !== null) {
                        pListener = this._pUnicastListener;
                        if (pListener.reciever === null) {
                            pListener.callback(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]);
                        } else if (pListener.callbackName !== null) {
                            pListener.reciever[pListener.callbackName](this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]);
                        } else {
                            pListener.callback.call(pListener.reciever, this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]);
                        }
                    } else {
                        for (var i = 0; i < this._nBroadcastListenersCount; i++) {
                            pListener = this._pBroadcastListeners[i];
                            if (pListener === null)
                                continue;
                            if (pListener.reciever === null) {
                                pListener.callback(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]);
                            } else if (pListener.callbackName !== null) {
                                pListener.reciever[pListener.callbackName](this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]);
                            } else {
                                pListener.callback.call(pListener.reciever, this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]);
                            }
                        }
                    }

                    return;
                case 10:
                    if (this._pSyncSignal !== null) {
                        var pOriginalSender = this._pSyncSignal.getSender();

                        if (this._pSyncSignal.getSender() !== null) {
                            this._pSyncSignal._setSender(this._pSender);
                        }

                        this._pSyncSignal.emit(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8], arguments[9]);

                        this._pSyncSignal._setSender(pOriginalSender);
                    }

                    if (this._fnForerunnerTrigger !== null) {
                        if (this._pSender === null) {
                            this._fnForerunnerTrigger(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8], arguments[9]);
                        } else if (this._sForerunnerTriggerName !== null) {
                            this._pSender[this._sForerunnerTriggerName](arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8], arguments[9]);
                        } else {
                            this._fnForerunnerTrigger.call(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8], arguments[9]);
                        }
                    }

                    if (this._eType === 0 /* UNICAST */ && this._pUnicastListener !== null) {
                        pListener = this._pUnicastListener;
                        if (pListener.reciever === null) {
                            pListener.callback(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8], arguments[9]);
                        } else if (pListener.callbackName !== null) {
                            pListener.reciever[pListener.callbackName](this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8], arguments[9]);
                        } else {
                            pListener.callback.call(pListener.reciever, this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8], arguments[9]);
                        }
                    } else {
                        for (var i = 0; i < this._nBroadcastListenersCount; i++) {
                            pListener = this._pBroadcastListeners[i];
                            if (pListener === null)
                                continue;
                            if (pListener.reciever === null) {
                                pListener.callback(this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8], arguments[9]);
                            } else if (pListener.callbackName !== null) {
                                pListener.reciever[pListener.callbackName](this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8], arguments[9]);
                            } else {
                                pListener.callback.call(pListener.reciever, this._pSender, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8], arguments[9]);
                            }
                        }
                    }

                    return;
                default:
                    var args = [];
                    for (var _i = 0; _i < (arguments.length); _i++) {
                        args[_i] = arguments[_i];
                    }

                    if (this._pSyncSignal !== null) {
                        var pOriginalSender = this._pSyncSignal.getSender();

                        if (this._pSyncSignal.getSender() !== null) {
                            this._pSyncSignal._setSender(this._pSender);
                        }

                        this._pSyncSignal.emit.apply(this._pSyncSignal, args);

                        this._pSyncSignal._setSender(pOriginalSender);
                    }

                    if (this._fnForerunnerTrigger !== null) {
                        this._fnForerunnerTrigger.apply(this._pSender, args);
                    }

                    args.unshift(this._pSender);

                    if (this._eType === 0 /* UNICAST */ && this._pUnicastListener !== null) {
                        pListener = this._pUnicastListener;
                        pListener.callback.apply(pListener.reciever, args);
                    } else {
                        for (var i = 0; i < nListeners; i++) {
                            pListener = this._pBroadcastListeners[i];
                            if (pListener === null)
                                continue;
                            pListener.callback.apply(pListener.reciever, args);
                        }
                    }

                    return;
            }
        };

        Signal.prototype.clear = function () {
            for (var i = 0; i < this._nBroadcastListenersCount; i++) {
                this.clearListener(this._pBroadcastListeners[i]);
                this._pBroadcastListeners[i] = null;
            }

            this._nBroadcastListenersCount = 0;

            this.clearListener(this._pUnicastListener);
            this._pUnicastListener = null;
        };

        Signal.prototype.hasListeners = function () {
            return this._nBroadcastListenersCount > 0 || this._pUnicastListener !== null;
        };

        Signal.prototype._syncSignal = function (pSignal) {
            this._pSyncSignal = pSignal;
        };

        Signal.prototype._setSender = function (pSender) {
            this._pSender = pSender;
        };

        Signal.prototype.fromParamsToListener = function (pArguments) {
            var pReciever = null;
            var fnCallback = null;
            var sCallbackName = null;
            var pSignal = null;
            var eType = this._eType;

            switch (pArguments.length) {
                case 1:
                    if (akra.isFunction(pArguments[0])) {
                        fnCallback = pArguments[0];
                    } else {
                        pSignal = pArguments[0];
                        pReciever = pSignal;
                        fnCallback = pSignal.emit;
                        sCallbackName = "emit";
                    }
                    break;
                case 2:
                    if (akra.isNumber(pArguments[1])) {
                        fnCallback = pArguments[0];
                        eType = pArguments[1];
                    } else {
                        pReciever = pArguments[0];
                        fnCallback = pArguments[1];
                    }
                    break;
                case 3:
                    pReciever = pArguments[0];
                    fnCallback = pArguments[1];
                    eType = pArguments[2];
                    break;
            }

            if (typeof (fnCallback) === "string") {
                if (pReciever === null) {
                    return null;
                }

                fnCallback = pReciever[fnCallback];
                sCallbackName = fnCallback;
            } else if (!akra.isNull(pReciever)) {
                sCallbackName = this.findCallbacknameForListener(pReciever, fnCallback);
            }

            if (eType !== this._eType || fnCallback === undefined || fnCallback === null) {
                return null;
            }

            var pListener = this.getEmptyListener();
            pListener.reciever = pReciever;
            pListener.callback = fnCallback;
            pListener.type = eType;

            pListener.callbackName = sCallbackName;

            return pListener;
        };

        Signal.prototype.findCallbacknameForListener = function (pReciever, fnCallback) {
            if (!akra.isNull(fnCallback)) {
                for (var i in pReciever) {
                    if (pReciever[i] === fnCallback) {
                        return i;
                    }
                }
            }

            return null;
        };
        Signal.prototype.indexOfBroadcastListener = function (pReciever, fnCallback) {
            for (var i = 0; i < this._nBroadcastListenersCount; i++) {
                if (this._pBroadcastListeners[i].reciever === pReciever && this._pBroadcastListeners[i].callback === fnCallback) {
                    return i;
                }
            }

            return -1;
        };

        Signal.prototype.getEmptyListener = function () {
            if (Signal._nEmptyListenersCount > 0) {
                var pListener = Signal._pEmptyListenersList[--Signal._nEmptyListenersCount];
                Signal._pEmptyListenersList[Signal._nEmptyListenersCount] = null;
                return pListener;
            } else {
                return {
                    reciever: null,
                    callback: null,
                    type: 0,
                    callbackName: null
                };
            }
        };

        Signal.prototype.clearListener = function (pListener) {
            if (pListener === null) {
                return;
            }

            pListener.reciever = null;
            pListener.callback = null;
            pListener.type = 0;

            pListener.callbackName = null;

            Signal._pEmptyListenersList[Signal._nEmptyListenersCount++] = pListener;
        };

        // Проверяем, существует ли функция в прототипе сендера, чтобы не подавались noname
        // функции в сигналы и в качестве fnForerunner
        Signal.prototype.isMethodExistsInSenderPrototype = function (fn) {
            if (akra.isNull(this._pSender)) {
                return true;
            }

            for (var p in this._pSender) {
                if (this._pSender[p] === fn) {
                    return true;
                }
            }

            return false;
        };
        Signal._pEmptyListenersList = [];
        Signal._nEmptyListenersCount = 0;
        return Signal;
    })();
    akra.Signal = Signal;

    var MuteSignal = (function (_super) {
        __extends(MuteSignal, _super);
        function MuteSignal() {
            _super.apply(this, arguments);
        }
        MuteSignal.prototype.emit = function () {
        };
        return MuteSignal;
    })(Signal);
    akra.MuteSignal = MuteSignal;
})(akra || (akra = {}));
/// <reference path="../idl/IEventProvider.ts" />
/// <reference path="../events.ts" />
/// <reference path="../guid.ts" />
var akra;
(function (akra) {
    (function (info) {
        var C_HIDDEN, C_VISIBILITYCHANGE;

        if (typeof document['hidden'] !== "undefined") {
            C_HIDDEN = "hidden";
            C_VISIBILITYCHANGE = "visibilitychange";
        } else if (typeof document['mozHidden'] !== "undefined") {
            C_HIDDEN = "mozHidden";
            C_VISIBILITYCHANGE = "mozvisibilitychange";
        } else if (typeof document['msHidden'] !== "undefined") {
            C_HIDDEN = "msHidden";
            C_VISIBILITYCHANGE = "msvisibilitychange";
        } else if (typeof document['webkitHidden'] !== "undefined") {
            C_HIDDEN = "webkitHidden";
            C_VISIBILITYCHANGE = "webkitvisibilitychange";
        }

        /**
        * @see https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API
        */
        var VisibilityInfo = (function () {
            function VisibilityInfo() {
                var _this = this;
                this.guid = akra.guid();
                this._bDocumentVisible = true;
                if (!this.isSupported()) {
                    return;
                }

                this.setupSignals();

                // Handle page visibility change
                document.addEventListener(C_VISIBILITYCHANGE, function () {
                    _this._onVisibilityChange(!document[C_HIDDEN]);
                }, false);
            }
            VisibilityInfo.prototype.setupSignals = function () {
                this.visibilityChanged = new akra.Signal(this);
            };

            /** Is visibility api supported? */
            VisibilityInfo.prototype.isSupported = function () {
                akra.debug.assert(akra.isDef(C_HIDDEN) && akra.isDef(document.addEventListener), "This demo requires a browser, such as Google Chrome or Firefox, that supports the Page Visibility API.");

                return akra.isDef(C_HIDDEN) && akra.isDef(document.addEventListener);
            };

            /** Indicate, whether page visible. */
            VisibilityInfo.prototype.isVisible = function () {
                return this._bDocumentVisible;
            };

            VisibilityInfo.prototype._onVisibilityChange = function (bVisible) {
                this._bDocumentVisible = bVisible;

                akra.debug.log("PAGE VISIBLE: ", bVisible ? "TRUE" : "FALSE");

                this.visibilityChanged.emit(bVisible);
            };

            /** Indicates whether the HTML element visible. */
            VisibilityInfo.isHTMLElementVisible = function (pElement) {
                if (pElement.offsetParent === null) {
                    return false;
                }

                var pStyle = window.getComputedStyle(pElement);
                if (pStyle.display === 'none') {
                    return false;
                }

                return !pElement.hidden;
            };
            return VisibilityInfo;
        })();
        info.VisibilityInfo = VisibilityInfo;
    })(akra.info || (akra.info = {}));
    var info = akra.info;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (info) {
        //FIXME: move determImageExtension to Image codec
        function determImageExtension(url, cb) {
            akra.io.fopen(url, 1 /* IN */ | 32 /* BIN */).read(function (e, pData) {
                if (akra.isNull(e)) {
                    var pU8Data = new Uint8Array(pData);
                    cb(null, pU8Data, readInfoFromData(pU8Data));
                } else {
                    cb(e, null, null);
                }
            });
        }
        info.determImageExtension = determImageExtension;

        function str(pData, iOffset, iLength) {
            if (typeof iOffset === "undefined") { iOffset = 0; }
            if (typeof iLength === "undefined") { iLength = pData.length; }
            pData = pData.subarray(iOffset, iOffset + iLength);

            var s = "";

            for (var i = 0; i < pData.length; ++i) {
                s += String.fromCharCode(pData[i]);
            }

            return s;
        }

        function readInfoFromData(pData) {
            var offset = 0;

            if (pData[0] == 0xFF && pData[1] == 0xD8) {
                return "JPG";
            }

            if (pData[0] == 0x89 && str(pData, 1, 3).toUpperCase() == "PNG") {
                return "PNG";
            }

            if (str(pData, 0, 3).toUpperCase() == "GIF") {
                return "GIF";
            }

            if (pData[0] == 0x42 && pData[1] == 0x4D) {
                return "BMP";
            }

            return null;
        }
    })(akra.info || (akra.info = {}));
    var info = akra.info;
})(akra || (akra = {}));
/// <reference path="../idl/ICanvasInfo.ts" />
/// <reference path="../idl/IURI.ts" />
/// <reference path="../path/path.ts" />
/// <reference path="../uri/uri.ts" />
var akra;
(function (akra) {
    /// <reference path="BrowserInfo.ts" />
    /// <reference path="ApiInfo.ts" />
    /// <reference path="ScreenInfo.ts" />
    /// <reference path="VisibilityInfo.ts" />
    /// <reference path="ImageInfo.ts" />
    (function (info) {
        function canvas(id) {
            var pCanvas = akra.isString(id) ? document.getElementById(id) : id;

            return {
                width: pCanvas.offsetWidth,
                height: pCanvas.offsetHeight,
                id: pCanvas.id
            };
        }
        info.canvas = canvas;

        info.browser = new info.BrowserInfo;
        info.api = new info.ApiInfo;
        info.screen = new info.ScreenInfo;
        info.visibility = new info.VisibilityInfo;
        info.uri = akra.uri.parse(document.location.href);

        (function (is) {
            /**
            * show status - online or offline
            */
            var online;

            /**
            * perform test on mobile device
            */
            var mobile = (/mobile|iphone|ipad|ipod|android|blackberry|mini|windows\sce|palm/i).test(navigator.userAgent.toLowerCase());
            var linux = info.browser.getOS() === 'Linux';
            var windows = info.browser.getOS() === 'Windows';
            var mac = info.browser.getOS() === 'Mac';
            var iPhone = info.browser.getOS() === 'iPhone';

            var Opera = info.browser.getName() === "Opera";
        })(info.is || (info.is = {}));
        var is = info.is;

        //TODO: move it to [akra.info.is] module, when typescript access this.
        Object.defineProperty(akra.info.is, 'online', {
            get: function () {
                return navigator.onLine;
            }
        });
    })(akra.info || (akra.info = {}));
    var info = akra.info;
})(akra || (akra = {}));
/// <reference path="../idl/IThreadManager.ts" />
/// <reference path="../idl/IThread.ts" />
/// <reference path="../config/config.ts" />
/// <reference path="../logger.ts" />
/// <reference path="../time.ts" />
/// <reference path="../guid.ts" />
/// <reference path="../info/info.ts" />
/// <reference path="../events.ts" />
var akra;
(function (akra) {
    (function (threading) {
        var AEThreadStatuses;
        (function (AEThreadStatuses) {
            AEThreadStatuses[AEThreadStatuses["k_WorkerBusy"] = 0] = "k_WorkerBusy";
            AEThreadStatuses[AEThreadStatuses["k_WorkerFree"] = 1] = "k_WorkerFree";
        })(AEThreadStatuses || (AEThreadStatuses = {}));

        var Manager = (function () {
            /** @param sScript URL to script, that will be used during Worker initialization. */
            function Manager(sScript) {
                if (typeof sScript === "undefined") { sScript = null; }
                this.guid = akra.guid();
                this._pWorkerList = [];
                this._pStatsList = [];
                this._pWaiters = [];
                this._iSysRoutine = -1;
                this.setupSignals();

                this._sDefaultScript = sScript;

                for (var i = 0; i < akra.config.threading.min; ++i) {
                    this.createThread();
                }
            }
            Manager.prototype.setupSignals = function () {
                this.threadReleased = this.threadReleased || new akra.Signal(this);
            };

            Manager.prototype.startSystemRoutine = function () {
                var _this = this;
                if (this._iSysRoutine > 0) {
                    return;
                }

                this._iSysRoutine = setInterval(function () {
                    var pStats;
                    var iNow = akra.time();

                    for (var i = 0, n = _this._pStatsList.length; i < n; ++i) {
                        pStats = _this._pStatsList[i];

                        if (pStats.releaseTime > 0 && iNow - pStats.releaseTime > akra.config.threading.idleTime * 1000) {
                            if (_this.terminateThread(i)) {
                                akra.debug.log("Thread " + i + " terminated. (" + i + "/" + n + ")");
                                i--, n--;
                                continue;
                            }

                            akra.logger.warn("Thread must be removed: " + i);
                        }
                    }
                    ;
                }, 5000);

                akra.debug.log("Routine " + akra.path.parse(this._sDefaultScript).getFileName() + " started.");
            };

            Manager.prototype.stopSystemRoutine = function () {
                clearInterval(this._iSysRoutine);
                akra.debug.log("Routine " + akra.path.parse(this._sDefaultScript).getFileName() + " stoped.");
            };

            Manager.prototype.createThread = function () {
                //console.log((new Error).stack)
                if (this._pWorkerList.length === akra.config.threading.max) {
                    akra.debug.log("Reached limit the number of threads.");
                    return false;
                }

                if (!akra.info.api.getWebWorker()) {
                    akra.logger.critical("WebWorker unsupported.");
                    return false;
                }

                var pWorker = (new Worker(this._sDefaultScript));

                pWorker.id = this._pWorkerList.length;
                pWorker.send = pWorker.postMessage;

                this._pWorkerList.push(pWorker);
                this._pStatsList.push({
                    status: 1 /* k_WorkerFree */,
                    creationTime: akra.time(),
                    releaseTime: akra.time()
                });

                if (this._pWorkerList.length == 1) {
                    this.startSystemRoutine();
                }

                return true;
            };

            Manager.prototype.occupyThread = function () {
                var pStats;
                for (var i = 0, n = this._pWorkerList.length; i < n; ++i) {
                    pStats = this._pStatsList[i];
                    if (pStats.status == 1 /* k_WorkerFree */) {
                        pStats.status = 0 /* k_WorkerBusy */;
                        pStats.releaseTime = 0;
                        return this._pWorkerList[i];
                    }
                }

                if (this.createThread()) {
                    return this.occupyThread();
                } else {
                    return null;
                }
            };

            Manager.prototype.terminateThread = function (iThread) {
                var pStats = this._pStatsList[iThread];
                var pWorker = this._pWorkerList[iThread];

                if (!akra.isDefAndNotNull(pWorker) && pStats.status != 1 /* k_WorkerFree */) {
                    return false;
                }

                pWorker.terminate();

                this._pStatsList.splice(iThread, 1);
                this._pWorkerList.splice(iThread, 1);

                if (this._pWorkerList.length == 0) {
                    this.stopSystemRoutine();
                }

                return true;
            };

            Manager.prototype.checkWaiters = function (pThread) {
                if (typeof pThread === "undefined") { pThread = null; }
                if (this._pWaiters.length == 0) {
                    return;
                }

                if (akra.isNull(pThread)) {
                    pThread = this.occupyThread();
                }

                if (!akra.isNull(pThread)) {
                    (this._pWaiters.shift())(pThread);
                    return;
                }

                // console.log("unreleased threads: ", this.countUnreleasedThreds());
                return;
            };

            // private countUnreleasedThreds(): uint {
            // 	var t = 0;
            // 	var pStats: IThreadStats;
            // 	for (var i: int = 0, n: int = this._pWorkerList.length; i < n; ++i) {
            // 		pStats = this._pStatsList[i];
            //		 if (pStats.status != AEThreadStatuses.k_WorkerFree) {
            //		 	t ++;
            //		 }
            //	 }
            //	 return t;
            // }
            Manager.prototype.waitForThread = function (fnWaiter) {
                if (!akra.isFunction(fnWaiter)) {
                    return -1;
                }

                this._pWaiters.push(fnWaiter);
                this.checkWaiters();

                return this._pWaiters.length;
            };

            Manager.prototype.releaseThread = function (pThread) {
                var iThread;
                var pStats;

                if (!akra.isInt(pThread)) {
                    iThread = pThread.id;
                } else {
                    iThread = pThread;
                }

                if (akra.isDef(this._pStatsList[iThread])) {
                    pStats = this._pStatsList[iThread];

                    pStats.status = 1 /* k_WorkerFree */;
                    pStats.releaseTime = akra.time();

                    this.checkWaiters();
                    return true;
                }

                return false;
            };

            Manager.prototype.initialize = function () {
                return true;
            };
            Manager.prototype.destroy = function () {
            };
            return Manager;
        })();
        threading.Manager = Manager;
    })(akra.threading || (akra.threading = {}));
    var threading = akra.threading;
})(akra || (akra = {}));
/// <reference path="ThreadManager.ts" />
/// <reference path="../idl/IFile.ts" />
/// <reference path="../idl/IThread.ts" />
/// <reference path="../idl/EFileTransferModes.ts" />
var akra;
(function (akra) {
    /// <reference path="../config/config.ts" />
    /// <reference path="../threading/threading.ts" />
    /// <reference path="../path/path.ts" />
    /// <reference path="../uri/uri.ts" />
    /// <reference path="../logger.ts" />
    /// <reference path="io.ts" />
    /// <reference path="../info/info.ts" />
    /// <reference path="../math/math.ts" />
    (function (io) {
        (function (EFileActions) {
            EFileActions[EFileActions["k_Open"] = 1] = "k_Open";
            EFileActions[EFileActions["k_Read"] = 2] = "k_Read";
            EFileActions[EFileActions["k_Write"] = 3] = "k_Write";
            EFileActions[EFileActions["k_Clear"] = 4] = "k_Clear";
            EFileActions[EFileActions["k_Exists"] = 5] = "k_Exists";
            EFileActions[EFileActions["k_Remove"] = 6] = "k_Remove";
        })(io.EFileActions || (io.EFileActions = {}));
        var EFileActions = io.EFileActions;

        var cio = akra.config.io;

        var sRemote = cio.tfile.remote.content;
        var sLocal = cio.tfile.local.content;

        if (cio.tfile.local.format === "String") {
            //attachment contain inline thread file dataa
            sLocal = akra.conv.toURL("var $INTERFACE_DEFINED = true;\n" + cio.tfile.local.content + "\n" + cio.tfile.iface.content, "application/javascript");
        } else {
            sLocal = akra.config.data + sLocal;
        }

        if (cio.tfile.remote.format === "String") {
            //attachment contain inline thread file dataa
            sRemote = akra.conv.toURL("var $INTERFACE_DEFINED = true;\n" + cio.tfile.remote.content + "\n" + cio.tfile.iface.content, "application/javascript");
        } else {
            sRemote = akra.config.data + sRemote;
        }

        var TFile = (function () {
            function TFile(sFilename, sMode, cb) {
                this.guid = akra.guid();
                this._pUri = null;
                this._nCursorPosition = 0;
                this._bOpened = false;
                this._eTransferMode = 0 /* k_Normal */;
                this._pFileMeta = null;
                this._isLocal = false;
                this.setupSignals();

                if (akra.isDef(sMode)) {
                    this._iMode = akra.isString(sMode) ? io.filemode(sMode) : sMode;
                }

                this.setAndValidateUri(akra.uri.parse(sFilename));

                if (akra.info.api.getTransferableObjects()) {
                    this._eTransferMode = 1 /* k_Fast */;
                }

                //OPERA MOVED TO WEBKIT, and this TRAP not more be needed!
                // else if (info.browser.name == "Opera") {
                // 	this._eTransferMode = EFileTransferModes.k_Slow;
                // }
                if (akra.isDefAndNotNull(cb)) {
                    this.open(sFilename, sMode, cb);
                }
            }
            TFile.prototype.setupSignals = function () {
                this.opened = this.opened || new akra.Signal(this);
                this.closed = this.closed || new akra.Signal(this);
                this.renamed = this.renamed || new akra.Signal(this);
            };

            TFile.prototype.getPath = function () {
                return this._pUri.toString();
            };

            TFile.prototype.getName = function () {
                return akra.path.parse(this._pUri.getPath()).getBaseName();
            };

            TFile.prototype.getByteLength = function () {
                return this._pFileMeta ? this._pFileMeta.size : 0;
            };

            TFile.prototype.getMode = function () {
                return this._iMode;
            };

            TFile.prototype.setMode = function (mode) {
                this._iMode = akra.isString(mode) ? io.filemode(mode) : mode;
            };

            TFile.prototype.getPosition = function () {
                akra.logger.assert(akra.isDefAndNotNull(this._pFileMeta), "There is no file handle open.");
                return this._nCursorPosition;
            };

            TFile.prototype.setPosition = function (iOffset) {
                akra.logger.assert(akra.isDefAndNotNull(this._pFileMeta), "There is no file handle open.");
                this._nCursorPosition = iOffset;
            };

            TFile.prototype.open = function (sFilename, iMode, cb) {
                var _this = this;
                var pFile = this;
                var hasMode = !akra.isFunction(iMode);

                if (arguments.length < 3) {
                    if (akra.isString(arguments[0])) {
                        this.setAndValidateUri(akra.uri.parse(sFilename));
                        cb = arguments[1];
                    } else if (akra.isInt(arguments[0])) {
                        this._iMode = arguments[0];
                        cb = arguments[1];
                    } else {
                        cb = arguments[0];
                    }

                    akra.logger.assert(akra.isDefAndNotNull(this._pUri), "No filename provided.");

                    this.open(this._pUri.toString(), this._iMode, cb);

                    return;
                }

                cb = arguments[hasMode ? 2 : 1];
                cb = cb || TFile.defaultCallback;

                if (this.isOpened()) {
                    akra.logger.warn("file already opened: " + this.getName());
                    cb.call(pFile, null, this._pFileMeta);
                }

                this.setAndValidateUri(akra.uri.parse(arguments[0]));

                if (hasMode) {
                    this._iMode = (akra.isString(arguments[1]) ? io.filemode(arguments[1]) : arguments[1]);
                }

                this.update(function (err) {
                    if (err) {
                        akra.logger.warn("file update err", err);
                        cb.call(pFile, err);
                        return;
                    }

                    if (io.isAppend(_this._iMode)) {
                        _this.setPosition(_this.getByteLength());
                    }

                    cb.call(pFile, null, _this._pFileMeta);
                });
            };

            TFile.prototype.close = function () {
                this._pUri = null;
                this._iMode = 1 /* IN */ | 2 /* OUT */;
                this._nCursorPosition = 0;
                this._pFileMeta = null;
            };

            TFile.prototype.checkIfNotOpen = function (method, callback, pArgs) {
                var _this = this;
                if (typeof pArgs === "undefined") { pArgs = null; }
                if (!this.isOpened()) {
                    this.open(function (e) {
                        if (e) {
                            if (callback) {
                                callback(e);
                            }
                        }

                        if (!akra.isNull(pArgs)) {
                            method.apply(_this, pArgs);
                        } else {
                            method.call(_this, callback);
                        }
                    });

                    return true;
                }

                return false;
            };

            TFile.prototype.clear = function (cb) {
                if (typeof cb === "undefined") { cb = TFile.defaultCallback; }
                if (this.checkIfNotOpen(this.clear, cb)) {
                    return;
                }

                var pCommand = {
                    act: 4 /* k_Clear */,
                    name: this.getPath(),
                    mode: this._iMode
                };

                this.execCommand(pCommand, cb);
            };

            TFile.prototype.read = function (cb, fnProgress) {
                if (typeof cb === "undefined") { cb = TFile.defaultCallback; }
                if (this.checkIfNotOpen(this.read, cb, arguments)) {
                    return;
                }

                var pFile = this;
                var eTransferMode = this._eTransferMode;

                akra.logger.assert(io.canRead(this._iMode), "The file is not readable.");

                var pCommand = {
                    act: 2 /* k_Read */,
                    name: this.getPath(),
                    mode: this._iMode,
                    pos: this._nCursorPosition,
                    transfer: this._eTransferMode,
                    progress: akra.isDefAndNotNull(fnProgress)
                };

                var fnCallbackSystem = function (err, pData) {
                    if (err) {
                        cb.call(pFile, err);
                        return;
                    }

                    if (pData.progress) {
                        fnProgress(pData.loaded, pData.total);
                        return false;
                    }

                    pFile.atEnd();
                    cb.call(pFile, null, pData.data);
                };

                this.execCommand(pCommand, fnCallbackSystem);
            };

            TFile.prototype.write = function (pData, cb, sContentType) {
                var _this = this;
                if (typeof cb === "undefined") { cb = TFile.defaultCallback; }
                if (this.checkIfNotOpen(this.write, cb, arguments)) {
                    return;
                }

                var iMode = this._iMode;
                var pCommand;
                var fnCallbackSystem = function (err, pMeta) {
                    if (err) {
                        cb.call(_this, err);
                        return;
                    }

                    _this.setPosition(_this.getPosition() + (akra.isString(pData) ? pData.length : pData.byteLength));
                    _this._pFileMeta = pMeta;

                    cb.call(_this, null, pMeta);
                };

                akra.logger.assert(io.canWrite(iMode), "The file is not writable.");

                sContentType = sContentType || (io.isBinary(iMode) ? "application/octet-stream" : "text/plain");

                pCommand = {
                    act: 3 /* k_Write */,
                    name: this.getPath(),
                    mode: this._iMode,
                    data: pData,
                    contentType: sContentType,
                    pos: this._nCursorPosition
                };

                if (!akra.isString(pData)) {
                    this.execCommand(pCommand, fnCallbackSystem, [pData]);
                } else {
                    this.execCommand(pCommand, fnCallbackSystem);
                }
            };

            TFile.prototype.move = function (sFilename, cb) {
                if (typeof cb === "undefined") { cb = TFile.defaultCallback; }
                var pFile = this;
                var sPath = this.getPath();

                this.copy(sFilename, function (e, pCopy) {
                    if (e) {
                        return cb.call(pFile, e);
                    }

                    pFile.remove(function (e) {
                        pFile.close();
                        pFile.open(sFilename);

                        cb.call(pFile, e, pFile.getPath(), sPath);
                    });
                });
            };

            //copy file
            TFile.prototype.copy = function (sFilename, cb) {
                if (typeof cb === "undefined") { cb = TFile.defaultCallback; }
                var iMode = 1 /* IN */ | 2 /* OUT */ | 16 /* TRUNC */;
                var pFile = this;
                var pCopy;

                if (io.isBinary(this._iMode)) {
                    iMode |= 32 /* BIN */;
                }

                pCopy = io.fopen(sFilename, iMode);

                pCopy.open(function (err) {
                    if (err) {
                        return cb.call(pFile, err, null);
                    }

                    pFile.read(function (e, pData) {
                        pCopy.write(pData, function (e, pMeta) {
                            if (!e) {
                                pCopy.close();
                            }

                            cb.call(pFile, e, pCopy, pMeta);
                        });
                    });
                });
            };

            TFile.prototype.rename = function (sFilename, cb) {
                var _this = this;
                if (typeof cb === "undefined") { cb = TFile.defaultCallback; }
                var pName = akra.path.parse(sFilename);
                var sNamePrev = this.getName();

                akra.logger.assert(!pName.getDirName(), "only filename can be specified.");

                this.move(akra.path.parse(this._pUri.getPath()).getDirName() + "/" + pName.getBaseName(), function (e) {
                    _this.renamed.emit(_this.getName(), sNamePrev);
                    cb.call(_this, _this.getName(), sNamePrev);
                });
            };

            TFile.prototype.remove = function (cb) {
                var _this = this;
                if (typeof cb === "undefined") { cb = TFile.defaultCallback; }
                if (this.checkIfNotOpen(this.remove, cb)) {
                    return;
                }

                var pCommand = {
                    act: 6 /* k_Remove */,
                    name: this.getPath(),
                    mode: this._iMode
                };

                this.execCommand(pCommand, function (e) {
                    if (!e) {
                        _this.close();
                    }

                    cb.call(_this, e);
                });
            };

            //return current position
            TFile.prototype.atEnd = function () {
                this.setPosition(this.getByteLength());
                return this._nCursorPosition;
            };

            //return current position;
            TFile.prototype.seek = function (iOffset) {
                akra.logger.assert(akra.isDefAndNotNull(this._pFileMeta), "There is no file handle open.");

                var nSeek = this._nCursorPosition + iOffset;
                if (nSeek < 0) {
                    nSeek = this.getByteLength() - (akra.math.abs(nSeek) % this.getByteLength());
                }

                akra.logger.assert(nSeek >= 0 && nSeek <= this.getByteLength(), "Invalid offset parameter");

                this._nCursorPosition = nSeek;

                return this._nCursorPosition;
            };

            TFile.prototype.isOpened = function () {
                return this._pFileMeta !== null;
            };

            TFile.prototype.isExists = function (cb) {
                var pCommand = {
                    act: 5 /* k_Exists */,
                    name: this.getPath(),
                    mode: this._iMode
                };

                this.execCommand(pCommand, cb);
            };

            TFile.prototype.isLocal = function () {
                return this._isLocal;
            };

            TFile.prototype.getMetaData = function (cb) {
                akra.logger.assert(akra.isDefAndNotNull(this._pFileMeta), "There is no file handle open.");
                cb(null, this._pFileMeta);
            };

            TFile.prototype.setAndValidateUri = function (sFilename) {
                var pUri = akra.uri.parse(sFilename);
                var pUriLocal;

                if (pUri.getScheme() === "filesystem:") {
                    pUriLocal = akra.uri.parse(pUri.getPath());

                    // console.log(pUriLocal.toString());
                    akra.logger.assert(!(pUriLocal.getProtocol() && pUriLocal.getHost() != akra.info.uri.getHost()), "It supports only local files within the current domain.");

                    var pFolders = pUriLocal.getPath().split('/');

                    if (pFolders[0] == "" || pFolders[0] == ".") {
                        pFolders = pFolders.slice(1);
                    }

                    akra.logger.assert(pFolders[0] === "temporary", "Supported only \"temporary\" filesystems. " + pUri.toString());

                    //removing "temporary" from path...
                    pFolders = pFolders.slice(1);

                    this._pUri = akra.uri.parse(pFolders.join("/"));

                    // console.log(sFilename.toString(), "===>", this._pUri.toString());
                    this._isLocal = true;
                } else {
                    this._pUri = pUri;
                }
            };

            TFile.prototype.update = function (cb) {
                var _this = this;
                if (typeof cb === "undefined") { cb = TFile.defaultCallback; }
                var pCommand = {
                    act: 1 /* k_Open */,
                    name: this._pUri.toString(),
                    mode: this._iMode
                };

                var fnCallbackSystem = function (err, pMeta) {
                    _this._pFileMeta = pMeta;
                    cb.call(_this, err, _this);
                };

                this.execCommand(pCommand, fnCallbackSystem);
            };

            TFile.prototype.execCommand = function (pCommand, cb, pTransferables) {
                TFile.execCommand(this, this.isLocal(), pCommand, cb, pTransferables);
            };

            TFile.execCommand = function (pFile, isLocal, pCommand, cb, pTransferables) {
                // var pFile: IFile = this;
                var pManager = isLocal ? TFile.localManager : TFile.remoteManager;
                pManager.waitForThread(function (pThread) {
                    pThread.onmessage = function (e) {
                        if (cb.call(pFile, null, e.data) === false) {
                            return;
                        }

                        pThread.onmessage = null;
                        pManager.releaseThread(pThread);
                    };

                    pThread.onerror = function (e) {
                        pThread.onmessage = null;
                        cb.call(pFile, e);
                        pManager.releaseThread(pThread);
                    };

                    if (akra.isDef(pTransferables)) {
                        // console.log(pCommand, pTransferables);
                        pThread.send(pCommand, pTransferables);
                    } else {
                        pThread.send(pCommand);
                    }
                });
            };
            TFile.localManager = new akra.threading.Manager(sLocal);
            TFile.remoteManager = new akra.threading.Manager(sRemote);

            TFile.defaultCallback = function (err) {
                if (err) {
                    throw err;
                }
            };
            return TFile;
        })();
        io.TFile = TFile;
    })(akra.io || (akra.io = {}));
    var io = akra.io;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;

    
})(akra || (akra = {}));
var akra;
(function (akra) {
    // (-2147483646);
    akra.MIN_INT32 = 0xffffffff;

    // ( 2147483647);
    akra.MAX_INT32 = 0x7fffffff;

    // (-32768);
    akra.MIN_INT16 = 0xffff;

    // ( 32767);
    akra.MAX_INT16 = 0x7fff;

    // (-128);
    akra.MIN_INT8 = 0xff;

    // ( 127);
    akra.MAX_INT8 = 0x7f;

    akra.MIN_UINT32 = 0;
    akra.MAX_UINT32 = 0xffffffff;
    akra.MIN_UINT16 = 0;
    akra.MAX_UINT16 = 0xffff;
    akra.MIN_UINT8 = 0;
    akra.MAX_UINT8 = 0xff;

    akra.SIZE_FLOAT64 = 8;
    akra.SIZE_REAL64 = 8;
    akra.SIZE_FLOAT32 = 4;
    akra.SIZE_REAL32 = 4;
    akra.SIZE_INT32 = 4;
    akra.SIZE_UINT32 = 4;
    akra.SIZE_INT16 = 2;
    akra.SIZE_UINT16 = 2;
    akra.SIZE_INT8 = 1;
    akra.SIZE_UINT8 = 1;
    akra.SIZE_BYTE = 1;
    akra.SIZE_UBYTE = 1;

    //1.7976931348623157e+308
    akra.MAX_FLOAT64 = Number.MAX_VALUE;

    //-1.7976931348623157e+308
    akra.MIN_FLOAT64 = -Number.MAX_VALUE;

    //5e-324
    akra.TINY_FLOAT64 = Number.MIN_VALUE;

    //    export const MAX_REAL64: number = Number.MAX_VALUE;   //1.7976931348623157e+308
    //    export const MIN_REAL64: number = -Number.MAX_VALUE;  //-1.7976931348623157e+308
    //    export const TINY_REAL64: number = Number.MIN_VALUE;  //5e-324
    //3.4e38
    akra.MAX_FLOAT32 = 3.4e38;

    //-3.4e38
    akra.MIN_FLOAT32 = -3.4e38;

    //1.5e-45
    akra.TINY_FLOAT32 = 1.5e-45;
})(akra || (akra = {}));
/// <reference path="../idl/IBinWriter.ts" />
/// <reference path="../idl/IBinReader.ts" />
/// <reference path="../logger.ts" />
/// <reference path="../conv/conv.ts" />
/// <reference path="../limit.ts" />
/// <reference path="../math/math.ts" />
var akra;
(function (akra) {
    /**
    * Как исполльзовать:
    * var bw = new BinWriter();	  //создаем экземпляр класса
    *						STRING
    * bw.string("abc");			  //запигшет строку
    * bw.stringArray(["abc", "abc"]) //запишет массив строк
    *						UINT
    * bw.uint8(1)			 //варовняет до 4 байт uint и запишет
    * bw.uint16(1)			//варовняет до 4 байт uint и запишет
    * bw.uint32(1)			//запишет uint32
    * bw.uint8Array([1, 2])   //запишет массив uint8 где каждое число будет занимать
    *						 //1 байт и выровняет общую длинну массива до 4
    * bw.uint16Array([1, 2])  //запишет массив uint16 где каждое число будет занимать
    *						 //2 байта и выровняет общую длинну массива до 4
    * bw.uint32Array([1, 2])  //запишет массив uint32 где каждое число будет занимать
    *						 //4 байта
    *						INT
    * bw.int8(1)			  //варовняет до 4 байт int и запишет
    * bw.int16(1)			 //варовняет до 4 байт int и запишет
    * bw.int32(1)			 //запишет int32
    * bw.int8Array([1, 2])	//запишет массив int8 где каждое число будет занимать
    *						 //1 байт и выровняет общую длинну массива до 4
    * bw.int16Array([1, 2])   //запишет массив int16 где каждое число будет занимать
    *						 //2 байта и выровняет общую длинну массива до 4
    * bw.int32Array([1, 2])   //запишет массив int32 где каждое число будет занимать
    *						 //4 байта
    *						 FLOAT
    * bw.float64(1.1)			 //запишет float64
    * bw.float32(1.1)			 //запишет float32
    * bw.float32Array([1.2, 2.3]) //запишет массив float32
    * bw.float64Array([1.2, 2.3]) //запишет массив float64
    *
    * bw.data()			 //возвратит массив типа ArrayBuffer где бедет лежать все записанные данные
    * bw.dataAsString()	 //соберет все данные в строку и вернет
    * bw.dataAsUint8Array() //соберет все данные в массив Uint8 и вернет
    */
    (function (io) {
        var BinWriter = (function () {
            function BinWriter() {
                /**
                * Двумерный массив куда заносятся данные.
                * @private
                * @type Uint8Array[]
                */
                this._pArrData = [];
                /**
                * Счетчик общего количества байт.
                * @private
                * @type int
                */
                this._iCountData = 0;
            }
            BinWriter.prototype.getByteLength = function () {
                return this._iCountData;
            };

            /******************************************************************************/
            /*								 string									 */
            /******************************************************************************/
            /**
            * @property string(str)
            * Запись строки. Перед строкой записывается длинна строки в тип uint32. Если
            * передано null или undefined то длинна строки записывается как 0xffffffff.
            * Это сделано для того что при дальнейшем считывании такая строка будет
            * возвращена как null.
            * @memberof BinWriter
            * @tparam String str строка. Все не строковые типы преобразуются к строке.
            */
            BinWriter.prototype.string = function (str) {
                if (!akra.isDefAndNotNull(str)) {
                    this.uint32(akra.MAX_UINT32);
                    return;
                }

                str = String(str);

                // LOG("string: ", str);
                var sUTF8String = akra.conv.toUTF8(str);
                var iStrLen = sUTF8String.length;
                var arrUTF8string = BinWriter.rawStringToBuffer(sUTF8String);

                akra.debug.assert(iStrLen <= akra.math.pow(2, 32) - 1, "Это значение не влезет в тип string");

                this.uint32(iStrLen);

                var iBitesToAdd = ((4 - (iStrLen % 4) == 4)) ? 0 : (4 - (iStrLen % 4));

                this._pArrData[this._pArrData.length] = arrUTF8string;
                this._iCountData += (iStrLen + iBitesToAdd);
                //trace('string', str);
            };

            /******************************************************************************/
            /*								   uintX									*/
            /******************************************************************************/
            /**
            * @property uintX(iValue, iX)
            * Запись числа типа uint(8, 16, 32). Если число занимает меньше 4 байт то оно
            * выравнивается до 4 байт. Если передан null то число принимается равным 0.
            * Если передано любое другое не числовое значение то выводится ошибка.
            * @memberof BinWriter
            * @tparam uint iValue число.
            * @tparam int iX - 8, 16, 32 количество бит.
            */
            BinWriter.prototype.uintX = function (iValue, iX) {
                if (akra.isNull(iValue)) {
                    iValue = 0;
                }

                // LOG("uint" + iX + ": ", iValue);
                akra.debug.assert(akra.isNumber(iValue));

                akra.debug.assert(0 <= iValue && iValue <= Math.pow(2, iX), "Out of Int range value:" + iX);
                var arrTmpBuf = null;

                switch (iX) {
                    case 8:
                        arrTmpBuf = new Uint8Array(4);
                        arrTmpBuf[0] = iValue;
                        break;
                    case 16:
                        arrTmpBuf = new Uint16Array(2);
                        arrTmpBuf[0] = iValue;
                        break;
                    case 32:
                        arrTmpBuf = new Uint32Array(1);
                        arrTmpBuf[0] = iValue;
                        break;
                    default:
                        akra.logger.error("Передано недопустимое значение длинны. Допустимые значения 8, 16, 32.");
                        break;
                }

                //trace('uint' + iX, iValue);
                //if(iX == 8)
                //  this._pArrData[this._pArrData.length] = arrTmpBuf;
                //else
                this._pArrData[this._pArrData.length] = new Uint8Array(arrTmpBuf.buffer);
                this._iCountData += 4;
            };

            /**
            * @property uint8(iValue)
            * Запись числа типа uint8. Оно выравнивается до 4 байт. Если передан null то
            * число принимается равным 0. Если передано любое другое не числовое значение
            * то выводится ошибка.
            * Сокращенная запись функции uintX(iValue, 8).
            * @memberof BinWriter
            * @tparam uint iValue число.
            */
            BinWriter.prototype.uint8 = function (iValue) {
                this.uintX(iValue, 8);
            };

            /**
            * @property uint16(iValue)
            * Запись числа типа uint16. Оно выравнивается до 4 байт. Если передан null то
            * число принимается равным 0. Если передано любое другое не числовое значение
            * то выводится ошибка.
            * Сокращенная запись функции uintX(iValue, 16).
            * @memberof BinWriter
            * @tparam uint iValue число.
            */
            BinWriter.prototype.uint16 = function (iValue) {
                this.uintX(iValue, 16);
            };

            /**
            * @property uint32(iValue)
            * Запись числа типа uint8. Если передан null то число принимается равным 0.
            * Если передано любое другое не числовое значение то выводится ошибка.
            * Сокращенная запись функции uintX(iValue, 32).
            * @memberof BinWriter
            * @tparam uint iValue число.
            */
            BinWriter.prototype.uint32 = function (iValue) {
                this.uintX(iValue, 32);
            };

            /**
            * @property boolean(bValue)
            * Запись числа типа boolean. В зависимости от bValue записывается либо 1 либо ноль.
            * Если передано любое другое не числовое значение то выводится ошибка.
            * Сокращенная запись функции uintX(bValue? 1: 0, 8).
            * @memberof BinWriter
            * @tparam boolean bValue число.
            */
            BinWriter.prototype.boolean = function (bValue) {
                // LOG(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BOOL >>> ");
                this.uintX(bValue ? 1 : 0, 8);
            };

            /******************************************************************************/
            /*					   writeArrayElementUintX							   */
            /******************************************************************************/
            /**
            * @property writeArrayElementUintX(iValue, iX)
            * Запись числа типа uint(8, 16, 32). Используется для записи элементов массивов.
            * В отличии от uintX число не выравнивается до 4 байт, а записывается ровно
            * столько байт сколько передано во втором параметре в функцию. Вторым
            * параметром передается колчиество бит а не байт. Если передан null то число
            * принимается равным 0. Если передано любое другое не числовое значение то
            * выводится ошибка.
            * @memberof BinWriter
            * @tparam uint iValue число.
            * @tparam int iX - 8, 16, 32 количество бит.
            */
            BinWriter.prototype.writeArrayElementUintX = function (iValue, iX) {
                if (akra.isNull(iValue)) {
                    iValue = 0;
                }

                // LOG("array uint", iX, ": ", iValue);
                akra.debug.assert(akra.isNumber(iValue));
                akra.debug.assert(0 <= iValue && iValue <= Math.pow(2, iX), "Это значение не влезет в тип uint" + iX);

                var arrTmpBuf = null;

                switch (iX) {
                    case 8:
                        arrTmpBuf = new Uint8Array(1);
                        arrTmpBuf[0] = iValue;
                        break;
                    case 16:
                        arrTmpBuf = new Uint16Array(1);
                        arrTmpBuf[0] = iValue;
                        break;
                    case 32:
                        arrTmpBuf = new Uint32Array(1);
                        arrTmpBuf[0] = iValue;
                        break;
                    default:
                        akra.logger.error("Передано недопустимое значение длинны. Допустимые значения 8, 16, 32.");
                        break;
                }

                if (iX == 8) {
                    this._pArrData[this._pArrData.length] = arrTmpBuf;
                } else {
                    this._pArrData[this._pArrData.length] = new Uint8Array(arrTmpBuf.buffer);
                }

                this._iCountData += (iX / 8);
            };

            /******************************************************************************/
            /*									intX									*/
            /******************************************************************************/
            /**
            * @property intX(iValue, iX)
            * Запись числа типа int(8, 16, 32). Если число занимает меньше 4 байт то оно
            * выравнивается до 4 байт. Если передан null то число принимается равным 0.
            * Если передано любое другое не числовое значение то выводится ошибка.
            * @memberof BinWriter
            * @tparam int iValue число.
            * @tparam int iX - 8, 16, 32 количество бит.
            */
            BinWriter.prototype.intX = function (iValue, iX) {
                if (akra.isNull(iValue)) {
                    iValue = 0;
                }

                // LOG("int", iX, ": ", iValue);
                akra.debug.assert(akra.isNumber(iValue));
                akra.debug.assert(-Math.pow(2, iX - 1) <= iValue && iValue <= Math.pow(2, iX - 1) - 1, "Это значение не влезет в тип int" + iX);

                var arrTmpBuf = null;

                switch (iX) {
                    case 8:
                        arrTmpBuf = new Int8Array(4);
                        arrTmpBuf[0] = iValue;
                        break;
                    case 16:
                        arrTmpBuf = new Int16Array(2);
                        arrTmpBuf[0] = iValue;
                        break;
                    case 32:
                        arrTmpBuf = new Int32Array(1);
                        arrTmpBuf[0] = iValue;
                        break;
                    default:
                        akra.logger.error("Передано недопустимое значение длинны. Допустимые значения 8, 16, 32.");
                        break;
                }

                //trace('int' + iX, iValue);
                this._pArrData[this._pArrData.length] = new Uint8Array(arrTmpBuf.buffer);
                this._iCountData += 4;
            };

            /**
            * @property int8(iValue)
            * Запись числа типа int8. Оно выравнивается до 4 байт. Если передан null то
            * число принимается равным 0. Если передано любое другое не числовое значение
            * то выводится ошибка.
            * Сокращенная запись функции intX(iValue, 8).
            * @memberof BinWriter
            * @tparam uint iValue число.
            */
            BinWriter.prototype.int8 = function (iValue) {
                this.intX(iValue, 8);
            };

            /**
            * @property int16(iValue)
            * Запись числа типа uint16. Оно выравнивается до 4 байт. Если передан null то
            * число принимается равным 0. Если передано любое другое не числовое значение
            * то выводится ошибка.
            * Сокращенная запись функции intX(iValue, 16).
            * @memberof BinWriter
            * @tparam int iValue число.
            */
            BinWriter.prototype.int16 = function (iValue) {
                this.intX(iValue, 16);
            };

            /**
            * @property uint32(iValue)
            * Запись числа типа uint8. Если передан null то число принимается равным 0.
            * Если передано любое другое не числовое значение то выводится ошибка.
            * Сокращенная запись функции intX(iValue, 32).
            * @memberof BinWriter
            * @tparam int iValue число.
            */
            BinWriter.prototype.int32 = function (iValue) {
                this.intX(iValue, 32);
            };

            /******************************************************************************/
            /*						  writeArrayElementIntX							*/
            /******************************************************************************/
            /**
            * @property writeArrayElementIntX(iValue, iX)
            * Запись числа типа int(8, 16, 32). Используется для записи элементов массивов.
            * В отличии от intX число не выравнивается до 4 байт, а записывается ровно
            * столько байт сколько передано во втором параметре в функцию. Вторым
            * параметром передается колчиество бит а не байт. Если передан null то число
            * принимается равным 0. Если передано любое другое не числовое значение то
            * выводится ошибка.
            * @memberof BinWriter
            * @tparam int iValue число.
            * @tparam int iX - 8, 16, 32 количество бит.
            */
            BinWriter.prototype.writeArrayElementIntX = function (iValue, iX) {
                if (akra.isNull(iValue)) {
                    iValue = 0;
                }

                // LOG("array int", iX, ": ", iValue);
                akra.debug.assert(akra.isNumber(iValue));
                akra.debug.assert(-Math.pow(2, iX - 1) <= iValue && iValue <= Math.pow(2, iX - 1) - 1, "Это значение не влезет в тип int" + iX);

                var arrTmpBuf = null;

                switch (iX) {
                    case 8:
                        arrTmpBuf = new Int8Array(1);
                        arrTmpBuf[0] = iValue;
                        break;
                    case 16:
                        arrTmpBuf = new Int16Array(1);
                        arrTmpBuf[0] = iValue;
                        break;
                    case 32:
                        arrTmpBuf = new Int32Array(1);
                        arrTmpBuf[0] = iValue;
                        break;
                    default:
                        akra.logger.error("Передано недопустимое значение длинны. Допустимые значения 8, 16, 32.");
                        break;
                }
                this._pArrData[this._pArrData.length] = new Uint8Array(arrTmpBuf.buffer);
                this._iCountData += (iX / 8);
            };

            /******************************************************************************/
            /*								  floatX									*/
            /******************************************************************************/
            /**
            * @property floatX(fValue, iX)
            * Запись числа типа float(32, 64). выравнивания не происходит т.к. они уже
            * выравнены до 4. Если передан null то число принимается равным 0.
            * Если передано любое другое не числовое значение то выводится ошибка.
            * @memberof BinWriter
            * @tparam float fValue число.
            * @tparam int iX - 32, 64 количество бит.
            */
            BinWriter.prototype.floatX = function (fValue, iX) {
                if (akra.isNull(fValue)) {
                    fValue = 0;
                }

                akra.debug.assert(akra.isNumber(fValue));

                //debug.assert(typeof(fValue) == 'number', "Не является числом");
                // LOG("float", iX, ": ", fValue);
                var arrTmpBuf = null;

                switch (iX) {
                    case 32:
                        arrTmpBuf = new Float32Array(1);
                        arrTmpBuf[0] = fValue;
                        break;
                    case 64:
                        arrTmpBuf = new Float64Array(1);
                        arrTmpBuf[0] = fValue;
                        break;
                    default:
                        akra.logger.error("Передано недопустимое значение длинны. Допустимые значения 32, 64.");
                        break;
                }

                //trace('float' + iX, fValue);
                this._pArrData[this._pArrData.length] = new Uint8Array(arrTmpBuf.buffer);
                this._iCountData += (iX / 8);
            };

            /**
            * @property float32(fValue)
            * Запись числа типа float32. Если передан null то число принимается равным 0.
            * Если передано любое другое не числовое значение то выводится ошибка.
            * Сокращенная запись функции floatX(fValue, 32).
            * @memberof BinWriter
            * @tparam float fValue число.
            */
            BinWriter.prototype.float32 = function (fValue) {
                this.floatX(fValue, 32);
            };

            /**
            * @property float64(fValue)
            * Запись числа типа float64. Если передан null то число принимается равным 0.
            * Если передано любое другое не числовое значение то выводится ошибка.
            * Сокращенная запись функции floatX(fValue, 64).
            * @memberof BinWriter
            * @tparam float fValue число.
            */
            BinWriter.prototype.float64 = function (fValue) {
                this.floatX(fValue, 64);
            };

            /******************************************************************************/
            /*							 stringArray									*/
            /******************************************************************************/
            /**
            * @property stringArray(arrString)
            * Записывает массив строк использую дял каждого элемента функцию this.string
            * Да начала записи элементов записывает общее количество элементов как число
            * uint32. Если в качестве параметра функции передано null или undefined
            * то количество элементов записывается равным 0xffffffff.
            * @memberof BinWriter
            * @tparam Array arrString массив строк.
            */
            BinWriter.prototype.stringArray = function (arrString) {
                if (!akra.isDefAndNotNull(arrString)) {
                    this.uint32(0xffffffff);
                    return;
                }

                this.uint32(arrString.length);
                for (var i = 0; i < arrString.length; i++) {
                    this.string(arrString[i]);
                }
            };

            /******************************************************************************/
            /*							 uintXArray									 */
            /******************************************************************************/
            /**
            * @property uintXArray(arrUint, iX)
            * Записывает массив чисел uint(8, 16, 32) использую для каждого элемента функцию
            *  writeArrayElementUintX. До начала записи элементов записывает общее
            *  количество элементов как число uint32. Если в качестве параметра функции
            * передано null или undefined то количество элементов записывается
            * равным 0xffffffff. Общее количество байт в массиве выравнивается к 4.
            * Все массивы приводятся к нужному типу Uint(iX)Array.
            * @memberof BinWriter
            * @tparam Uint(iX)Array arrUint массив uint(iX).
            * @tparam int iX размер элемента в битах (8, 16, 32).
            */
            BinWriter.prototype.uintXArray = function (arrUint, iX) {
                if (!akra.isDefAndNotNull(arrUint)) {
                    this.uint32(0xffffffff);
                    return;
                }

                var iUintArrLength = arrUint.byteLength;
                var iBitesToAdd;
                var arrTmpUint = null;

                switch (iX) {
                    case 8:
                        iBitesToAdd = ((4 - (iUintArrLength % 4) == 4)) ? 0 : (4 - (iUintArrLength % 4));
                        if (iBitesToAdd > 0 || !(arrUint instanceof Uint8Array)) {
                            arrTmpUint = new Uint8Array(iUintArrLength + iBitesToAdd);
                            arrTmpUint.set(arrUint);
                        } else {
                            arrTmpUint = arrUint;
                        }
                        break;
                    case 16:
                        iUintArrLength /= 2;
                        iBitesToAdd = ((2 - (iUintArrLength % 2) == 2)) ? 0 : (2 - (iUintArrLength % 2));
                        if (iBitesToAdd > 0 || !(arrUint instanceof Uint16Array)) {
                            arrTmpUint = new Uint16Array(iUintArrLength + iBitesToAdd);
                            arrTmpUint.set(arrUint);
                        } else {
                            arrTmpUint = arrUint;
                        }
                        break;
                    case 32:
                        iUintArrLength /= 4;
                        if (!(arrUint instanceof Uint32Array)) {
                            arrTmpUint = new Uint32Array(arrUint);
                        } else {
                            arrTmpUint = arrUint;
                        }
                        break;
                }

                this.uint32(iUintArrLength);

                for (var i = 0, n = arrTmpUint.byteLength / (iX / 8); i < n; i++) {
                    this.writeArrayElementUintX(arrTmpUint[i], iX);
                }
            };

            /**
            * @property uint8Array(arrUint)
            * Запись массива типа Uint8Array. До начала записи элементов записывает общее
            * количество элементов как число uint32. Если в качестве параметра функции
            * передано null или undefined то количество элементов записывается
            * равным 0xffffffff. Общее количество байт в массиве выравнивается до 4.
            * Сокращенная запись функции uintXArray(arrUint, 8).
            * @memberof BinWriter
            * @tparam Uint8Array arrUint массив uint8.
            */
            BinWriter.prototype.uint8Array = function (arrUint) {
                this.uintXArray(arrUint, 8);
            };

            /**
            * @property uint16Array(arrUint)
            * Запись массива типа Uint16Array. До начала записи элементов записывает общее
            * количество элементов как число uint32. Если в качестве параметра функции
            * передано null или undefined то количество элементов записывается
            * равным 0xffffffff. Общее количество байт в массиве выравнивается до 4.
            * Сокращенная запись функции uintXArray(arrUint, 16).
            * @memberof BinWriter
            * @tparam Uint16Array arrUint массив uint16.
            */
            BinWriter.prototype.uint16Array = function (arrUint) {
                this.uintXArray(arrUint, 16);
            };

            /**
            * @property uint32Array(arrUint)
            * Запись массива типа Uint32Array. До начала записи элементов записывает общее
            * количество элементов как число uint32. Если в качестве параметра функции
            * передано null или undefined то количество элементов записывается
            * равным 0xffffffff.
            * Сокращенная запись функции uintXArray(arrUint, 32).
            * @memberof BinWriter
            * @tparam Uint32Array arrUint массив uint32.
            */
            BinWriter.prototype.uint32Array = function (arrUint) {
                this.uintXArray(arrUint, 32);
            };

            /******************************************************************************/
            /*							   intXArray									*/
            /******************************************************************************/
            /**
            * @property intXArray(arrInt, iX)
            * Записывает массив чисел int(8, 16, 32) использую для каждого элемента функцию
            *  writeArrayElementIntX. До начала записи элементов записывает общее
            *  количество элементов как число int32. Если в качестве параметра функции
            * передано null или undefined то количество элементов записывается
            * равным 0xffffffff. Общее количество байт в массиве выравнивается к 4.
            * Все массивы приводятся к нужному типу Int(iX)Array.
            * @memberof BinWriter
            * @tparam Int(iX)Array arrUint массив int(iX).
            * @tparam int iX размер элемента в битах (8, 16, 32).
            */
            BinWriter.prototype.intXArray = function (arrInt, iX) {
                if (!akra.isDefAndNotNull(arrInt)) {
                    this.uint32(0xffffffff);
                    return;
                }

                var iIntArrLength = 0;
                var iBitesToAdd = 0;
                var arrTmpInt = null;

                switch (iX) {
                    case 8:
                        iIntArrLength = arrInt.length;
                        iBitesToAdd = ((4 - (iIntArrLength % 4) == 4)) ? 0 : (4 - (iIntArrLength % 4));
                        if (iBitesToAdd > 0 || !(arrInt instanceof Int8Array)) {
                            arrTmpInt = new Int8Array(iIntArrLength + iBitesToAdd);
                            arrTmpInt.set(arrInt);
                        } else {
                            arrTmpInt = arrInt;
                        }
                        break;
                    case 16:
                        iIntArrLength = arrInt.length;
                        iBitesToAdd = ((2 - (iIntArrLength % 2) == 2)) ? 0 : (2 - (iIntArrLength % 2));
                        if (iBitesToAdd > 0 || !(arrInt instanceof Int16Array)) {
                            arrTmpInt = new Int16Array(iIntArrLength + iBitesToAdd);
                            arrTmpInt.set(arrInt);
                        } else {
                            arrTmpInt = arrInt;
                        }
                        break;
                    case 32:
                        iIntArrLength = arrInt.length;
                        if (!(arrInt instanceof Int32Array)) {
                            arrTmpInt = new Int32Array(arrInt);
                        } else {
                            arrTmpInt = arrInt;
                        }
                        break;
                }

                this.uint32(iIntArrLength);

                for (var i = 0, n = arrTmpInt.byteLength / (iX / 8); i < n; i++) {
                    this.writeArrayElementIntX(arrTmpInt[i], iX);
                }
            };

            /**
            * @property int8Array(arrInt)
            * Запись массива типа Int8Array. До начала записи элементов записывает общее
            * количество элементов как число uint32. Если в качестве параметра функции
            * передано null или undefined то количество элементов записывается
            * равным 0xffffffff. Общее количество байт в массиве выравнивается до 4.
            * Сокращенная запись функции intXArray(arrInt, 8).
            * @memberof BinWriter
            * @tparam Int8Array arrInt массив int8.
            */
            BinWriter.prototype.int8Array = function (arrInt) {
                this.intXArray(arrInt, 8);
            };

            /**
            * @property int16Array(arrInt)
            * Запись массива типа Int16Array. До начала записи элементов записывает общее
            * количество элементов как число uint32. Если в качестве параметра функции
            * передано null или undefined то количество элементов записывается
            * равным 0xffffffff. Общее количество байт в массиве выравнивается до 4.
            * Сокращенная запись функции intXArray(arrInt, 16).
            * @memberof BinWriter
            * @tparam Int16Array arrInt массив int16.
            */
            BinWriter.prototype.int16Array = function (arrInt) {
                this.intXArray(arrInt, 16);
            };

            /**
            * @property int32Array(arrInt)
            * Запись массива типа Int32Array. До начала записи элементов записывает общее
            * количество элементов как число uint32. Если в качестве параметра функции
            * передано null или undefined то количество элементов записывается
            * равным 0xffffffff.
            * Сокращенная запись функции intXArray(arrInt, 32).
            * @memberof BinWriter
            * @tparam Int32Array arrInt массив int32.
            */
            BinWriter.prototype.int32Array = function (arrInt) {
                this.intXArray(arrInt, 32);
            };

            /******************************************************************************/
            /*							  floatXArray								   */
            /******************************************************************************/
            /**
            * @property floatXArray(arrFloat, iX)
            * Записывает массив чисел float(32, 64) использую для каждого элемента функцию
            *  floatX. До начала записи элементов записывает общее
            *  количество элементов как число int32. Если в качестве параметра функции
            * передано null или undefined то количество элементов записывается
            * равным 0xffffffff.
            * Все массивы приводятся к нужному типу Float(iX)Array.
            * @memberof BinWriter
            * @tparam Float(iX)Array arrFloat массив float(iX).
            * @tparam int iX размер элемента в битах (32, 64).
            */
            BinWriter.prototype.floatXArray = function (arrFloat, iX) {
                if (!akra.isDefAndNotNull(arrFloat)) {
                    this.uint32(0xffffffff);
                    return;
                }

                switch (iX) {
                    case 32:
                        if (!(arrFloat instanceof Float32Array)) {
                            arrFloat = new Float32Array(arrFloat);
                        }
                        break;
                    case 64:
                        if (!(arrFloat instanceof Float64Array)) {
                            arrFloat = new Float64Array(arrFloat);
                        }
                        break;
                }
                var iFloatArrLength = arrFloat.byteLength / (iX / 8);
                this.uint32(iFloatArrLength);

                for (var i = 0, n = iFloatArrLength; i < n; i++) {
                    this.floatX(arrFloat[i], iX);
                }
            };

            /**
            * @property float32Array(arrFloat)
            * Запись массива типа Float32Array. До начала записи элементов записывает общее
            * количество элементов как число uint32. Если в качестве параметра функции
            * передано null или undefined то количество элементов записывается
            * равным 0xffffffff.
            * Все переданные массивы приводятся к типу Float32Array.
            * Сокращенная запись функции floatXArray(arrFloat, 32).
            * @memberof BinWriter
            * @tparam Float32Array arrFloat массив float32.
            */
            BinWriter.prototype.float32Array = function (arrFloat) {
                this.floatXArray(arrFloat, 32);
            };

            /**
            * @property float64Array(arrFloat)
            * Запись массива типа Float64Array. До начала записи элементов записывает общее
            * количество элементов как число uint32. Если в качестве параметра функции
            * передано null или undefined то количество элементов записывается
            * равным 0xffffffff.
            * Все переданные массивы приводятся к типу Float64Array.
            * Сокращенная запись функции floatXArray(arrFloat, 64).
            * @memberof BinWriter
            * @tparam Float64Array arrFloat массив float64.
            */
            BinWriter.prototype.float64Array = function (arrFloat) {
                this.floatXArray(arrFloat, 64);
            };

            /**
            * @property data()
            * Берет все данные из массива _pArrData и записывает их в массив
            * типа ArrayBuffer.
            * @memberof BinWriter
            * @treturn ArrayBuffer.
            */
            BinWriter.prototype.data = function () {
                return this.dataAsUint8Array().buffer;
            };

            /**
            * @property data()
            * Берет все данные из массива _pArrData и записывает их в строку.
            * @memberof BinWriter
            * @treturn String.
            */
            BinWriter.prototype.dataAsString = function () {
                var tmpArrBuffer = this.dataAsUint8Array();
                var sString = "";

                for (var n = 0; n < tmpArrBuffer.length; ++n) {
                    var charCode = String.fromCharCode(tmpArrBuffer[n]);
                    sString = sString + charCode;
                }

                return sString;
            };

            /**
            * @property toUint8Array()
            * Берет все данные из массива _pArrData и вернет Uint8Array.
            * @memberof BinWriter
            * @treturn Uint8Array.
            */
            BinWriter.prototype.dataAsUint8Array = function () {
                var arrUint8 = new Uint8Array(this._iCountData);

                for (var i = 0, k = 0; i < this._pArrData.length; i++) {
                    for (var n = 0; n < this._pArrData[i].length; n++) {
                        arrUint8[k++] = this._pArrData[i][n];
                    }
                }

                return arrUint8;
            };

            /**
            * @property rawStringToBuffer()
            * Берет строку и преобразует ее в массив Uint8Array.
            * @memberof BinWriter
            * @treturn Uint8Array.
            */
            BinWriter.rawStringToBuffer = function (str) {
                var idx;
                var len = str.length;
                var iBitesToAdd = ((4 - (len % 4) == 4)) ? 0 : (4 - (len % 4));
                var arr = new Array(len + iBitesToAdd);

                for (idx = 0; idx < len; ++idx) {
                    arr[idx] = str.charCodeAt(idx); /* & 0xFF;*/
                }
                return new Uint8Array(arr);
            };
            return BinWriter;
        })();
        io.BinWriter = BinWriter;
    })(akra.io || (akra.io = {}));
    var io = akra.io;
})(akra || (akra = {}));
/// <reference path="../idl/IPacker.ts" />
/// <reference path="../idl/IMap.ts" />
/// <reference path="../idl/IPackerFormat.ts" />
/// <reference path="BinWriter.ts" />
/// <reference path="../logger.ts" />
/// <reference path="../limit.ts" />
var akra;
(function (akra) {
    (function (io) {
        var Packer = (function (_super) {
            __extends(Packer, _super);
            function Packer(pTemplate) {
                _super.call(this);
                this._pHashTable = {};
                this.x = 0;
                this._pTemplate = pTemplate;
            }
            Packer.prototype.getTemplate = function () {
                return this._pTemplate;
            };

            Packer.prototype.memof = function (pObject, iAddr, sType) {
                if (sType === "Number") {
                    return;
                }

                var pTable = this._pHashTable;
                var pCell = pTable[sType];

                if (!akra.isDef(pCell)) {
                    pCell = pTable[sType] = [];
                }

                pCell.push(pObject, iAddr);
            };

            Packer.prototype.addr = function (pObject, sType) {
                if (sType === "Number") {
                    return -1;
                }

                var pTable = this._pHashTable;
                var iAddr;
                var pCell = pTable[sType];

                if (akra.isDef(pCell)) {
                    for (var i = 0, n = pCell.length / 2; i < n; ++i) {
                        var j = 2 * i;

                        if (pCell[j] === pObject) {
                            return pCell[j + 1];
                        }
                    }
                }

                return -1;
            };

            Packer.prototype.nullPtr = function () {
                return this.uint32(akra.MAX_UINT32);
            };

            Packer.prototype.rollback = function (n) {
                if (typeof n === "undefined") { n = 1; }
                if (n === -1) {
                    n = this._pArrData.length;
                }

                var pRollback = new Array(n);
                var iRollbackLength = 0;

                for (var i = 0; i < n; ++i) {
                    pRollback[i] = this._pArrData.pop();
                    iRollbackLength += pRollback[i].byteLength;
                }

                this._iCountData -= iRollbackLength;

                return pRollback;
            };

            Packer.prototype.append = function (pData) {
                if (akra.isArray(pData)) {
                    for (var i = 0; i < pData.length; ++i) {
                        this._pArrData.push(pData[i]);
                        this._iCountData += pData[i].byteLength;
                    }
                } else {
                    if (akra.isArrayBuffer(pData)) {
                        pData = new Uint8Array(pData);
                    }
                    this._pArrData.push(pData);
                    this._iCountData += pData.byteLength;
                }
            };

            Packer.prototype.writeData = function (pObject, sType) {
                var pTemplate = this.getTemplate();
                var pProperties = pTemplate.properties(sType);
                var fnWriter = null;

                fnWriter = pProperties.write;

                this.x++;
                if (this.x % 1000 == 0)
                    console.log((this.getByteLength() / (1024 * 1024)).toFixed(2), "mb");

                if (!akra.isNull(fnWriter)) {
                    if (fnWriter.call(this, pObject) === false) {
                        akra.logger.error("cannot write type: " + sType);
                    }

                    return true;
                }

                akra.debug.assert(akra.isDefAndNotNull(pProperties), "unknown object <" + sType + "> type cannot be writed");
                return true;
            };

            Packer.prototype.write = function (pObject, sType) {
                if (typeof sType === "undefined") { sType = null; }
                var pProperties;
                var iAddr, iType;
                var pTemplate = this.getTemplate();

                if (akra.isNull(pObject)) {
                    this.nullPtr();
                    return false;
                }

                if (akra.isNull(sType)) {
                    sType = pTemplate.detectType(pObject);
                }

                pProperties = pTemplate.properties(sType);
                iType = pTemplate.getTypeId(sType);

                if (!akra.isDef(pObject) || !akra.isDef(iType)) {
                    this.nullPtr();
                    return false;
                }

                iAddr = this.addr(pObject, sType);

                if (iAddr < 0) {
                    iAddr = this.getByteLength() + 4 + 4;

                    this.uint32(iAddr);
                    this.uint32(iType);

                    if (this.writeData(pObject, sType)) {
                        this.memof(pObject, iAddr, sType);
                    } else {
                        this.rollback(2);
                        this.nullPtr();
                    }
                } else {
                    this.uint32(iAddr);
                    this.uint32(iType);
                }

                return true;
            };
            return Packer;
        })(io.BinWriter);
        io.Packer = Packer;
    })(akra.io || (akra.io = {}));
    var io = akra.io;
})(akra || (akra = {}));
/// <reference path="IBinReader.ts" />
/// <reference path="IPackerFormat.ts" />
/// <reference path="../idl/IBinReader.ts" />
/// <reference path="../idl/IBinWriter.ts" />
/// <reference path="../logger.ts" />
/// <reference path="../conv/conv.ts" />
var akra;
(function (akra) {
    /**
    * Usage:
    * var br = new Binreader(data); type of data is ArrayBuffer
    * var string = bw.string();
    * var array = bw.stringArray()
    * var value = bw.uint8()
    * var value = bw.uint16()
    * var value = bw.uint32()
    * var array = bw.uint8Array()
    * var array = bw.uint16Array()
    * var array = bw.uint32Array()
    * var value = bw.int8()
    * var value = bw.int16()
    * var value = bw.int32()
    * var array = bw.int8Array()
    * var array = bw.int16Array()
    * var array = bw.int32Array()
    * var value = bw.float64()
    * var value = bw.float32()
    * var array = bw.float32Array()
    * var array = bw.float64Array()
    */
    /**
    * Работает заебись, докуменитировать лень.
    */
    (function (io) {
        var BinReader = (function () {
            function BinReader(pBuffer, iByteOffset, iByteLength) {
                if (!akra.isDef(iByteOffset)) {
                    iByteOffset = 0;
                }
                if (!akra.isDef(iByteLength)) {
                    iByteLength = pBuffer.byteLength;
                }

                this._pDataView = new DataView(akra.isArrayBuffer(pBuffer) ? pBuffer : pBuffer.data(), iByteOffset, iByteLength);
                this._iPosition = 0;
            }
            BinReader.prototype.string = function (sDefault) {
                if (typeof sDefault === "undefined") { sDefault = null; }
                var iStringLength = this.uint32();
                var iBitesToAdd;

                if (iStringLength == akra.MAX_INT32) {
                    return sDefault;
                }

                iBitesToAdd = ((4 - (iStringLength % 4) == 4)) ? 0 : (4 - (iStringLength % 4));
                iStringLength += iBitesToAdd;

                //Out of array limits
                akra.logger.assert((this._iPosition + iStringLength - 1) < this._pDataView.byteLength);

                var pBuffer = new Uint8Array(iStringLength);

                for (var i = 0; i < iStringLength; i++) {
                    pBuffer[i] = this._pDataView.getUint8(this._iPosition + i);
                }

                this._iPosition += iStringLength;
                var sString = "", charCode, code;

                for (var n = 0; n < pBuffer.length; ++n) {
                    code = pBuffer[n];

                    if (code == 0) {
                        break;
                    }

                    charCode = String.fromCharCode(code);
                    sString = sString + charCode;
                }

                sString = akra.conv.fromUTF8(sString);

                /*sString.substr(0, iStringLength);//sString;//*/
                return sString;
            };

            BinReader.prototype.uint32 = function () {
                var i = this._pDataView.getUint32(this._iPosition, true);
                this._iPosition += 4;

                // LOG("uint32:", i);
                return i;
            };

            BinReader.prototype.uint16 = function () {
                var i = this._pDataView.getUint16(this._iPosition, true);
                this._iPosition += 4;
                return i;
            };

            BinReader.prototype.uint8 = function () {
                var i = this._pDataView.getUint8(this._iPosition);
                this._iPosition += 4;
                return i;
            };

            BinReader.prototype.boolean = function () {
                return this.uint8() > 0;
            };

            BinReader.prototype.int32 = function () {
                var i = this._pDataView.getInt32(this._iPosition, true);
                this._iPosition += 4;
                return i;
            };

            BinReader.prototype.int16 = function () {
                var i = this._pDataView.getInt16(this._iPosition, true);
                this._iPosition += 4;
                return i;
            };

            BinReader.prototype.int8 = function () {
                var i = this._pDataView.getInt8(this._iPosition);
                this._iPosition += 4;
                return i;
            };

            BinReader.prototype.float64 = function () {
                var f = this._pDataView.getFloat64(this._iPosition, true);
                this._iPosition += 8;
                return f;
            };

            BinReader.prototype.float32 = function () {
                var f = this._pDataView.getFloat32(this._iPosition, true);
                this._iPosition += 4;

                // LOG("float32:", f);
                return f;
            };

            BinReader.prototype.stringArray = function () {
                var iLength = this.uint32();

                if (iLength == akra.MAX_INT32) {
                    return null;
                }

                var pArray = new Array(iLength);

                for (var i = 0; i < iLength; i++) {
                    pArray[i] = this.string();
                }

                return pArray;
            };

            BinReader.prototype.uint32Array = function () {
                return this.uintXArray(32);
            };

            BinReader.prototype.uint16Array = function () {
                return this.uintXArray(16);
            };

            BinReader.prototype.uint8Array = function () {
                return this.uintXArray(8);
            };

            BinReader.prototype.int32Array = function () {
                return this.intXArray(32);
            };

            BinReader.prototype.int16Array = function () {
                return this.intXArray(16);
            };

            BinReader.prototype.int8Array = function () {
                return this.intXArray(8);
            };

            BinReader.prototype.float64Array = function () {
                return this.floatXArray(64);
            };

            BinReader.prototype.float32Array = function () {
                return this.floatXArray(32);
            };

            BinReader.prototype.uintXArray = function (iX) {
                var iLength = this.uint32();

                if (iLength == akra.MAX_INT32) {
                    return null;
                }

                var iBytes = iX / 8;
                var pArray;

                switch (iBytes) {
                    case 1:
                        pArray = new Uint8Array(iLength);

                        for (var i = 0; i < iLength; i++) {
                            pArray[i] = this._pDataView.getUint8(this._iPosition + i * iBytes);
                        }

                        break;
                    case 2:
                        pArray = new Uint16Array(iLength);

                        for (var i = 0; i < iLength; i++) {
                            pArray[i] = this._pDataView.getUint16(this._iPosition + i * iBytes, true);
                        }

                        break;
                    case 4:
                        pArray = new Uint32Array(iLength);

                        for (var i = 0; i < iLength; i++) {
                            pArray[i] = this._pDataView.getUint32(this._iPosition + i * iBytes, true);
                        }

                        break;
                    default:
                        akra.logger.error("unsupported array length detected: " + iBytes);
                }

                var iByteLength = iBytes * iLength;
                iByteLength += -iByteLength & 3;

                this._iPosition += iByteLength;

                return pArray;
            };

            BinReader.prototype.intXArray = function (iX) {
                var iLength = this.uint32();

                if (iLength == akra.MAX_INT32) {
                    return null;
                }

                var iBytes = iX / 8;
                var pArray;

                switch (iBytes) {
                    case 1:
                        pArray = new Int8Array(iLength);

                        for (var i = 0; i < iLength; i++) {
                            pArray[i] = this._pDataView.getInt8(this._iPosition + i * iBytes);
                        }

                        break;
                    case 2:
                        pArray = new Int16Array(iLength);

                        for (var i = 0; i < iLength; i++) {
                            pArray[i] = this._pDataView.getInt16(this._iPosition + i * iBytes, true);
                        }

                        break;
                    case 4:
                        pArray = new Int32Array(iLength);

                        for (var i = 0; i < iLength; i++) {
                            pArray[i] = this._pDataView.getInt32(this._iPosition + i * iBytes, true);
                        }

                        break;
                    default:
                        akra.logger.error("unsupported array length detected: " + iBytes);
                }

                var iByteLength = iBytes * iLength;
                iByteLength += -iByteLength & 3;

                this._iPosition += iByteLength;

                return pArray;
            };

            BinReader.prototype.floatXArray = function (iX) {
                var iLength = this.uint32();

                if (iLength == akra.MAX_INT32) {
                    return null;
                }

                var iBytes = iX / 8;
                var pArray;

                switch (iBytes) {
                    case 4:
                        pArray = new Float32Array(iLength);

                        for (var i = 0; i < iLength; i++) {
                            pArray[i] = this._pDataView.getFloat32(this._iPosition + i * iBytes, true);
                        }

                        break;
                    case 8:
                        pArray = new Float64Array(iLength);

                        for (var i = 0; i < iLength; i++) {
                            pArray[i] = this._pDataView.getFloat64(this._iPosition + i * iBytes, true);
                        }

                        break;
                    default:
                        akra.logger.error("unsupported array length detected: " + iBytes);
                }

                var iByteLength = iBytes * iLength;
                iByteLength += -iByteLength & 3;

                this._iPosition += iByteLength;

                return pArray;
            };
            return BinReader;
        })();
        io.BinReader = BinReader;
    })(akra.io || (akra.io = {}));
    var io = akra.io;
})(akra || (akra = {}));
/// <reference path="../idl/IUnPacker.ts" />
/// <reference path="../idl/IMap.ts" />
/// <reference path="../idl/IPackerFormat.ts" />
/// <reference path="BinReader.ts" />
/// <reference path="../limit.ts" />
/// <reference path="../logger.ts" />
var akra;
(function (akra) {
    (function (io) {
        var UnPacker = (function (_super) {
            __extends(UnPacker, _super);
            function UnPacker(pBuffer, pTemlate) {
                _super.call(this, pBuffer);
                this._pHashTable = {};
                this._pPositions = [];
            }
            UnPacker.prototype.getTemplate = function () {
                return this._pTemplate;
            };

            UnPacker.prototype.pushPosition = function (iPosition) {
                this._pPositions.push(this._iPosition);
                this._iPosition = iPosition;
            };

            UnPacker.prototype.popPosition = function () {
                this._iPosition = this._pPositions.pop();
            };

            UnPacker.prototype.memof = function (pObject, iAddr) {
                this._pHashTable[iAddr] = pObject;
            };

            UnPacker.prototype.memread = function (iAddr) {
                return this._pHashTable[iAddr] || null;
            };

            UnPacker.prototype.readPtr = function (iAddr, sType, pObject) {
                if (typeof pObject === "undefined") { pObject = null; }
                if (iAddr === akra.MAX_UINT32) {
                    return null;
                }

                var pTmp = this.memread(iAddr);
                var isReadNext = false;
                var fnReader = null;
                var pTemplate = this.getTemplate();
                var pProperties;

                if (akra.isDefAndNotNull(pTmp)) {
                    return pTmp;
                }

                if (iAddr === this._iPosition) {
                    isReadNext = true;
                } else {
                    //set new position
                    this.pushPosition(iAddr);
                }

                pProperties = pTemplate.properties(sType);

                akra.debug.assert(akra.isDefAndNotNull(pProperties), "unknown object <" + sType + "> type cannot be readed");

                fnReader = pProperties.read;

                //read primal type
                if (akra.isDefAndNotNull(fnReader)) {
                    pTmp = fnReader.call(this, pObject);
                    this.memof(pTmp, iAddr);

                    //restore prev. position
                    if (!isReadNext) {
                        this.popPosition();
                    }

                    return pTmp;
                }

                akra.logger.critical("unhandled case!");
                return null;
            };

            UnPacker.prototype.read = function () {
                var iAddr = this.uint32();

                if (iAddr === akra.MAX_UINT32) {
                    return null;
                }

                var iType = this.uint32();
                var sType = this.getTemplate().getType(iType);

                return this.readPtr(iAddr, sType);
            };
            return UnPacker;
        })(io.BinReader);
        io.UnPacker = UnPacker;
    })(akra.io || (akra.io = {}));
    var io = akra.io;
})(akra || (akra = {}));
/// <reference path="../idl/IPackerFormat.ts" />
/// <reference path="../logger.ts" />
var akra;
(function (akra) {
    (function (io) {
        var PackerTemplate = (function () {
            function PackerTemplate(pData) {
                this._pData = {};
                this._nTypes = 0;
                this._pNum2Tpl = {};
                this._pTpl2Num = {};
                if (akra.isDef(pData)) {
                    this.set(pData);
                }
            }
            PackerTemplate.prototype.getType = function (iType) {
                akra.debug.assert(akra.isDef(this._pNum2Tpl[iType]), "unknown type detected: " + iType);
                return this._pNum2Tpl[iType];
            };

            PackerTemplate.prototype.getTypeId = function (sType) {
                akra.debug.assert(akra.isDef(this._pTpl2Num[sType]), "unknown type detected: " + sType);
                return this._pTpl2Num[sType];
            };

            PackerTemplate.prototype.set = function (pFormat) {
                var iType;

                for (var i in pFormat) {
                    this._pData[i] = pFormat[i];

                    iType = this._nTypes++;

                    this._pNum2Tpl[iType] = i;
                    this._pTpl2Num[i] = iType;
                }
            };

            PackerTemplate.prototype.detectType = function (pObject) {
                return PackerTemplate.getClass(pObject);
            };

            PackerTemplate.prototype.resolveType = function (sType) {
                var pTemplates = this._pData;
                var pProperties;
                var sProperties;

                while (akra.isString(sProperties = pTemplates[sType])) {
                    sType = sProperties;
                }

                akra.debug.assert(!akra.isString(sProperties), "cannot resolve type: " + sType);

                return sType;
            };

            PackerTemplate.prototype.properties = function (sType) {
                var pProperties = this._pData[sType];

                if (akra.isString(pProperties)) {
                    return this.properties(this.resolveType(sType));
                }

                return pProperties;
            };

            PackerTemplate.prototype.data = function () {
                return this._pData;
            };

            PackerTemplate.getClass = function (pObj) {
                if (pObj && akra.isObject(pObj) && Object.prototype.toString.call(pObj) !== "[object Array]" && akra.isDefAndNotNull(pObj.constructor) && pObj != window) {
                    var arr = pObj.constructor.toString().match(/function\s*(\w+)/);

                    if (!akra.isNull(arr) && arr.length == 2) {
                        return arr[1];
                    }
                }

                var sType = akra.typeOf(pObj);

                if (sType === "array" && akra.isDef(pObj.$type)) {
                    sType = pObj.$type;
                }

                return sType[0].toUpperCase() + sType.substr(1);
            };
            return PackerTemplate;
        })();
        io.PackerTemplate = PackerTemplate;
    })(akra.io || (akra.io = {}));
    var io = akra.io;
})(akra || (akra = {}));
/// <reference path="../../idl/IPackerFormat.ts" />
/// <reference path="../../logger.ts" />
/// <reference path="../PackerTemplate.ts" />
var akra;
(function (akra) {
    (function (io) {
        (function (templates) {
            templates.common = new io.PackerTemplate;

            templates.common.set({
                "Float32Array": {
                    write: function (pData) {
                        this.float32Array(pData);
                    },
                    read: function () {
                        return this.float32Array();
                    }
                },
                "Float64Array": {
                    write: function (pData) {
                        this.float64Array(pData);
                    },
                    read: function () {
                        return this.float64Array();
                    }
                },
                "Int32Array": {
                    write: function (pData) {
                        this.int32Array(pData);
                    },
                    read: function () {
                        return this.int32Array();
                    }
                },
                "Int16Array": {
                    write: function (pData) {
                        this.int16Array(pData);
                    },
                    read: function () {
                        return this.int16Array();
                    }
                },
                "Int8Array": {
                    write: function (pData) {
                        this.int8Array(pData);
                    },
                    read: function () {
                        return this.int8Array();
                    }
                },
                "Uint32Array": {
                    write: function (pData) {
                        this.uint32Array(pData);
                    },
                    read: function () {
                        return this.uint32Array();
                    }
                },
                "Uint16Array": {
                    write: function (pData) {
                        this.uint16Array(pData);
                    },
                    read: function () {
                        return this.uint16Array();
                    }
                },
                "Uint8Array": {
                    write: function (pData) {
                        this.uint8Array(pData);
                    },
                    read: function () {
                        return this.uint8Array();
                    }
                },
                "String": {
                    write: function (str) {
                        this.string(str);
                    },
                    read: function () {
                        return this.string();
                    }
                },
                //float
                "Float64": {
                    write: function (val) {
                        this.float64(val);
                    },
                    read: function () {
                        return this.float64();
                    }
                },
                "Float32": {
                    write: function (val) {
                        this.float32(val);
                    },
                    read: function () {
                        return this.float32();
                    }
                },
                //int
                "Int32": {
                    write: function (val) {
                        this.int32(val);
                    },
                    read: function () {
                        return this.int32();
                    }
                },
                "Int16": {
                    write: function (val) {
                        this.int16(val);
                    },
                    read: function () {
                        return this.int16();
                    }
                },
                "Int8": {
                    write: function (val) {
                        this.int8(val);
                    },
                    read: function () {
                        return this.int8();
                    }
                },
                //uint
                "Uint32": {
                    write: function (val) {
                        this.uint32(val);
                    },
                    read: function () {
                        return this.uint32();
                    }
                },
                "Uint16": {
                    write: function (val) {
                        this.uint16(val);
                    },
                    read: function () {
                        return this.uint16();
                    }
                },
                "Uint8": {
                    write: function (val) {
                        this.uint8(val);
                    },
                    read: function () {
                        return this.uint8();
                    }
                },
                "Boolean": {
                    write: function (b) {
                        this.boolean(b);
                    },
                    read: function () {
                        return this.boolean();
                    }
                },
                "Object": {
                    write: function (object) {
                        if (akra.isArray(object)) {
                            this.boolean(true); /*is array*/
                            this.uint32(object.length);

                            for (var i = 0; i < object.length; ++i) {
                                this.write(object[i]);
                            }
                        } else {
                            this.boolean(false); /*is not array*/
                            this.stringArray(Object.keys(object));

                            for (var key in object) {
                                this.write(object[key]);
                            }
                        }
                    },
                    read: function (object) {
                        var isArray = this.boolean();
                        var keys;
                        var n;

                        if (isArray) {
                            n = this.uint32();
                            object = object || new Array(n);

                            for (var i = 0; i < n; ++i) {
                                object[i] = this.read();
                            }
                        } else {
                            object = object || {};
                            keys = this.stringArray();

                            for (var i = 0; i < keys.length; ++i) {
                                object[keys[i]] = this.read();
                            }
                        }

                        return object;
                    }
                },
                "Function": {
                    write: function (fn) {
                        var sFunc = String(fn.valueOf());
                        var sBody = sFunc.substr(sFunc.indexOf("{") + 1, sFunc.lastIndexOf("}") - sFunc.indexOf("{") - 1);
                        var pArgs = sFunc.substr(sFunc.indexOf("(") + 1, sFunc.indexOf(")") - sFunc.indexOf("(") - 1).match(/[$A-Z_][0-9A-Z_$]*/gi);

                        //var sName: string = null;
                        //var pMatches: string[] = sFunc.match(/(function\s+)([_$a-zA-Z][_$a-zA-Z0-9]*)(?=\s*\()/gi);
                        // if (isDefAndNotNull(pMatches) && pMatches.length > 2) {
                        // 	sName = pMatches[2];
                        // }
                        //this.string(sName);
                        this.stringArray(pArgs);
                        this.string(sBody);
                    },
                    read: function () {
                        return new Function(this.stringArray(), this.string());
                    }
                },
                "Number": "Float32",
                "Float": "Float32",
                "Int": "Int32",
                "Uint": "Uint32",
                "Array": "Object"
            });
        })(io.templates || (io.templates = {}));
        var templates = io.templates;
    })(akra.io || (akra.io = {}));
    var io = akra.io;
})(akra || (akra = {}));
/// <reference path="../idl/EIO.ts" />
/// <reference path="../idl/IFile.ts" />
var akra;
(function (akra) {
    /// <reference path="TFile.ts" />
    /// <reference path="Packer.ts" />
    /// <reference path="UnPacker.ts" />
    /// <reference path="BinReader.ts" />
    /// <reference path="BinWriter.ts" />
    /// <reference path="../bf/bf.ts" />
    /// <reference path="../info/info.ts" />
    /// <reference path="../uri/uri.ts" />
    /// <reference path="templates/common.ts" />
    (function (io) {
        function canCreate(mode) {
            return akra.bf.testBit(mode, 1);
        }
        io.canCreate = canCreate;
        function canRead(mode) {
            return akra.bf.testBit(mode, 0);
        }
        io.canRead = canRead;
        function canWrite(mode) {
            return akra.bf.testBit(mode, 1);
        }
        io.canWrite = canWrite;

        function isAppend(mode) {
            return akra.bf.testBit(mode, 3);
        }
        io.isAppend = isAppend;
        function isTrunc(mode) {
            return akra.bf.testBit(mode, 4);
        }
        io.isTrunc = isTrunc;
        function isBinary(mode) {
            return akra.bf.testBit(mode, 5);
        }
        io.isBinary = isBinary;
        function isText(mode) {
            return akra.bf.testBit(mode, 6);
        }
        io.isText = isText;
        function isJson(mode) {
            return akra.bf.testBit(mode, 7);
        }
        io.isJson = isJson;
        function isUrl(mode) {
            return akra.bf.testBit(mode, 8);
        }
        io.isUrl = isUrl;

        /*local and remote via thread*/
        /*local file via local files system(async)*/
        /*local file via local files system(async)*/
        function filemode(sMode) {
            switch (sMode.toLowerCase()) {
                case "a+u":
                    return 1 /* IN */ | 2 /* OUT */ | 8 /* APP */ | 256 /* URL */;
                case "w+u":
                    return 1 /* IN */ | 2 /* OUT */ | 16 /* TRUNC */ | 256 /* URL */;
                case "r+u":
                    return 1 /* IN */ | 2 /* OUT */ | 256 /* URL */;

                case "au":
                    return 8 /* APP */ | 256 /* URL */;
                case "wu":
                    return 2 /* OUT */ | 256 /* URL */;
                case "ru":
                    return 1 /* IN */ | 256 /* URL */;

                case "a+j":
                    return 1 /* IN */ | 2 /* OUT */ | 8 /* APP */ | 128 /* JSON */;
                case "w+j":
                    return 1 /* IN */ | 2 /* OUT */ | 16 /* TRUNC */ | 128 /* JSON */;
                case "r+j":
                    return 1 /* IN */ | 2 /* OUT */ | 128 /* JSON */;

                case "aj":
                    return 8 /* APP */ | 128 /* JSON */;
                case "wj":
                    return 2 /* OUT */ | 128 /* JSON */;
                case "rj":
                    return 1 /* IN */ | 128 /* JSON */;

                case "a+t":
                    return 1 /* IN */ | 2 /* OUT */ | 8 /* APP */ | 64 /* TEXT */;
                case "w+t":
                    return 1 /* IN */ | 2 /* OUT */ | 16 /* TRUNC */ | 64 /* TEXT */;
                case "r+t":
                    return 1 /* IN */ | 2 /* OUT */ | 64 /* TEXT */;

                case "at":
                    return 8 /* APP */ | 64 /* TEXT */;
                case "wt":
                    return 2 /* OUT */ | 64 /* TEXT */;
                case "rt":
                    return 1 /* IN */ | 64 /* TEXT */;

                case "a+b":
                    return 1 /* IN */ | 2 /* OUT */ | 8 /* APP */ | 32 /* BIN */;
                case "w+b":
                    return 1 /* IN */ | 2 /* OUT */ | 16 /* TRUNC */ | 32 /* BIN */;
                case "r+b":
                    return 1 /* IN */ | 2 /* OUT */ | 32 /* BIN */;

                case "ab":
                    return 8 /* APP */ | 32 /* BIN */;
                case "wb":
                    return 2 /* OUT */ | 32 /* BIN */;
                case "rb":
                    return 1 /* IN */ | 32 /* BIN */;

                case "a+":
                    return 1 /* IN */ | 2 /* OUT */ | 8 /* APP */;
                case "w+":
                    return 1 /* IN */ | 2 /* OUT */ | 16 /* TRUNC */;
                case "r+":
                    return 1 /* IN */ | 2 /* OUT */;

                case "a":
                    return 8 /* APP */ | 2 /* OUT */;
                case "w":
                    return 2 /* OUT */;
                case "r":
                default:
                    return 1 /* IN */;
            }
        }
        io.filemode = filemode;

        if (akra.config.DEBUG && !akra.info.api.getFileSystem()) {
            akra.debug.warn("Local file system not supported.");
        }

        function fopen(sUri, pMode) {
            if (typeof pMode === "undefined") { pMode = 1 /* IN */; }
            sUri = akra.uri.resolve(sUri);

            akra.logger.assert(akra.info.api.getWebWorker(), "WebWorker API must have. :(");

            var sScheme = akra.uri.parse(sUri).getScheme();

            akra.logger.assert(!(!akra.info.api.getFileSystem() && sScheme === "filesystem:"), "File system not suppoted.");

            return new io.TFile(sUri, pMode);
        }
        io.fopen = fopen;

        function dump(pObject, pTemplate) {
            if (typeof pTemplate === "undefined") { pTemplate = null; }
            var pPacker = new io.Packer(pTemplate || io.templates.common);
            pPacker.write(pObject);
            return pPacker.data();
        }
        io.dump = dump;

        function undump(pBuffer, pTemplate) {
            if (typeof pTemplate === "undefined") { pTemplate = null; }
            if (!akra.isDefAndNotNull(pBuffer)) {
                return null;
            }
            var pUnPacker = new io.UnPacker(pBuffer, pTemplate);
            return pUnPacker.read();
        }
        io.undump = undump;
    })(akra.io || (akra.io = {}));
    var io = akra.io;
})(akra || (akra = {}));
/// <reference path="../idl/IDocument.ts" />
/// <reference path="../idl/IAnimationController.ts" />
/// <reference path="../idl/IAnimation.ts" />
/// <reference path="../idl/IAnimationBlend.ts" />
/// <reference path="../idl/IAnimationContainer.ts" />
/// <reference path="../idl/IAnimationTrack.ts" />
/// <reference path="../idl/3d-party/FileSaver.d.ts" />
var akra;
(function (akra) {
    /// <reference path="../logger.ts" />
    /// <reference path="../debug.ts" />
    /// <reference path="../conv/conv.ts" />
    /// <reference path="../math/math.ts" />
    /// <reference path="../io/io.ts" />
    /// <reference path="../info/info.ts" />
    (function (exchange) {
        var Exporter = (function () {
            function Exporter() {
                this._pLibrary = {};
                this._pDocument = null;
                //записаны ли сцены в документе?
                this._bScenesWrited = false;
                //assset
                this._sTitle = null;
                this._sSubject = null;
                this._pKeywords = null;
                //contributor
                this._sAuthor = null;
                this._sComments = null;
                this._sCopyright = null;
                this._sSourceData = null;
            }
            Exporter.prototype.writeAnimation = function (pAnimation) {
                switch (pAnimation.getType()) {
                    case 0 /* ANIMATION */:
                        this.makeEntry(3 /* k_Animation */, pAnimation);
                        break;
                    case 4 /* BLEND */:
                        this.makeEntry(4 /* k_AnimationBlend */, pAnimation);
                        break;
                    case 3 /* CONTAINER */:
                        this.makeEntry(5 /* k_AnimationContainer */, pAnimation);
                        break;
                    default:
                        akra.logger.critical("unknown animation detected!");
                }
            };

            Exporter.prototype.writeController = function (pController) {
                this.makeEntry(2 /* k_Controller */, pController);
            };

            Exporter.prototype.writeMaterial = function (pMaterial) {
                this.makeEntry(7 /* k_Material */, pMaterial);
            };

            Exporter.prototype.clear = function () {
                this._bScenesWrited = false;
                this._pLibrary = {};
            };

            Exporter.prototype.findLibraryEntry = function (iGuid) {
                return this._pLibrary[iGuid];
            };

            Exporter.prototype.findEntry = function (iGuid) {
                return this.findLibraryEntry(iGuid).entry;
            };

            Exporter.prototype.findEntryData = function (iGuid) {
                return this.findLibraryEntry(iGuid).data;
            };

            Exporter.prototype.isSceneWrited = function () {
                return this._bScenesWrited;
            };

            Exporter.prototype.isEntryExists = function (iGuid) {
                return akra.isDefAndNotNull(this._pLibrary[iGuid]);
            };

            Exporter.prototype.makeEntry = function (eType, pData) {
                if (!this.isEntryExists(pData.guid)) {
                    this.writeEntry(eType, { guid: pData.guid, data: pData, entry: null });
                }
            };

            Exporter.prototype.writeEntry = function (eType, pEntry) {
                if (akra.isDefAndNotNull(pEntry.entry)) {
                    return;
                }

                akra.logger.assert(this.encodeEntry(eType, pEntry), "cannot encode entry with type: " + eType);
                this._pLibrary[pEntry.guid] = pEntry;
                pEntry.entry.guid = pEntry.guid;
            };

            Exporter.prototype.encodeEntry = function (eType, pEntry) {
                switch (eType) {
                    case 2 /* k_Controller */:
                        pEntry.entry = this.encodeControllerEntry(pEntry.data);
                        break;
                    case 3 /* k_Animation */:
                        pEntry.entry = this.encodeAnimationEntry(pEntry.data);
                        break;
                    case 4 /* k_AnimationBlend */:
                        pEntry.entry = this.encodeAnimationBlendEntry(pEntry.data);
                        break;
                    case 5 /* k_AnimationContainer */:
                        pEntry.entry = this.encodeAnimationContainerEntry(pEntry.data);
                        break;
                    case 7 /* k_Material */:
                        pEntry.entry = this.encodeMaterialEntry(pEntry.data);
                        break;
                    default:
                        akra.logger.warn("unknown entry type detected: " + eType);
                }

                return akra.isDefAndNotNull(pEntry.entry);
            };

            Exporter.prototype.encodeAnimationBaseEntry = function (pAnimation) {
                var pEntry = {
                    name: pAnimation.getName(),
                    targets: [],
                    type: 0 /* k_Unknown */,
                    extra: null
                };

                var pTargets = pAnimation.getTargetList();

                for (var i = 0; i < pTargets.length; ++i) {
                    if (this.isSceneWrited()) {
                        akra.logger.critical("TODO: scene writed");
                    }

                    pEntry.targets.push({ name: pTargets[i].name, target: null });
                }

                return pEntry;
            };

            Exporter.prototype.encodeAnimationFrameEntry = function (pFrame) {
                var pEntry = {
                    time: pFrame.time,
                    weight: pFrame.weight,
                    matrix: [],
                    type: pFrame.type
                };

                pEntry.matrix['$type'] = "Float32Array";

                var pMatrix = pFrame.toMatrix();

                for (var i = 0; i < pMatrix.data.length; ++i) {
                    pEntry.matrix.push(pMatrix.data[i]);
                }

                return pEntry;
            };

            Exporter.prototype.encodeAnimationTrack = function (pTrack) {
                var pEntry = {
                    interpolation: 0,
                    keyframes: [],
                    targetName: pTrack.getTargetName(),
                    target: null
                };

                if (this.isSceneWrited()) {
                    akra.logger.critical("TODO: write track target");
                }

                for (var i = 0; i < pTrack.getTotalFrames(); ++i) {
                    var pFrame = this.encodeAnimationFrameEntry(pTrack.getKeyFrame(i));
                    pEntry.keyframes.push(pFrame);
                }
                ;

                return pEntry;
            };

            Exporter.prototype.encodeAnimationEntry = function (pAnimation) {
                var pEntry = this.encodeAnimationBaseEntry(pAnimation);
                pEntry.tracks = [];
                pEntry.type = 3 /* k_Animation */;

                for (var i = 0; i < pAnimation.getTotalTracks(); ++i) {
                    var pTrack = this.encodeAnimationTrack(pAnimation.getTrack(i));
                    pEntry.tracks.push(pTrack);
                }
                ;

                return pEntry;
            };

            Exporter.prototype.encodeAnimationContainerEntry = function (pContainer) {
                var pAnimation = pContainer.getAnimation();

                var pEntry = this.encodeAnimationBaseEntry(pContainer);

                pEntry.enable = pContainer.isEnabled();
                pEntry.startTime = pContainer.getStartTime();
                pEntry.speed = pContainer.getSpeed();
                pEntry.loop = pContainer.inLoop();
                pEntry.reverse = pContainer.isReversed();
                pEntry.pause = pContainer.isPaused();
                pEntry.leftInfinity = pContainer.inLeftInfinity();
                pEntry.rightInfinity = pContainer.inRightInfinity();

                pEntry.animation = pAnimation.guid;
                pEntry.type = 5 /* k_AnimationContainer */;

                this.writeAnimation(pAnimation);

                return pEntry;
            };

            Exporter.prototype.encodeAnimationBlendEntry = function (pBlend) {
                var pEntry = this.encodeAnimationBaseEntry(pBlend);

                pEntry.animations = [];
                pEntry.type = 4 /* k_AnimationBlend */;

                for (var i = 0, n = pBlend.getTotalAnimations(); i < n; ++i) {
                    var pAnimation = pBlend.getAnimation(i);

                    var pBlendElement = {
                        animation: pAnimation.guid,
                        weight: pBlend.getAnimationWeight(i),
                        // acceleration: pBlend.getAnimationAcceleration(i),
                        mask: pBlend.getAnimationMask(i)
                    };

                    this.writeAnimation(pAnimation);
                    pEntry.animations.push(pBlendElement);
                }

                return pEntry;
            };

            Exporter.prototype.encodeControllerEntry = function (pController) {
                var pEntry = {
                    type: 2 /* k_Controller */,
                    animations: [],
                    options: 0,
                    name: pController.name
                };

                for (var i = 0, n = pController.getTotalAnimations(); i < n; ++i) {
                    var pAnimation = pController.getAnimation(i);
                    this.writeAnimation(pAnimation);
                    pEntry.animations.push(pAnimation.guid);
                }

                return pEntry;
            };

            Exporter.prototype.encodeMaterialEntry = function (pMaterial) {
                var pEntry = {
                    type: 7 /* k_Material */,
                    name: pMaterial.name,
                    diffuse: this.encodeColorEntry(pMaterial.diffuse),
                    specular: this.encodeColorEntry(pMaterial.specular),
                    emissive: this.encodeColorEntry(pMaterial.emissive),
                    transparency: pMaterial.transparency,
                    shininess: pMaterial.shininess
                };

                return pEntry;
            };

            Exporter.prototype.encodeColorEntry = function (pColor) {
                var pEntry = [];
                pEntry[0] = pColor.r;
                pEntry[1] = pColor.g;
                pEntry[2] = pColor.b;
                pEntry[3] = pColor.a;
                return pEntry;
            };

            Exporter.prototype.toolInfo = function () {
                return [
                    Exporter.TOOL,
                    "Version " + Exporter.VERSION,
                    "Browser " + akra.info.browser.getName() + ", " + akra.info.browser.getVersion() + " (" + akra.info.browser.getOS() + ")"
                ].join(";");
            };

            Exporter.prototype.createUnit = function () {
                return {
                    name: "meter",
                    meter: 1.
                };
            };

            Exporter.prototype.createContributor = function () {
                return {
                    author: this._sAuthor,
                    authoringTool: this.toolInfo(),
                    comments: this._sComments,
                    copyright: this._sCopyright,
                    sourceData: this._sSourceData
                };
            };

            Exporter.prototype.createAsset = function () {
                return {
                    unit: this.createUnit(),
                    upAxis: Exporter.UP_AXIS,
                    title: this._sTitle,
                    subject: this._sSubject,
                    created: Exporter.getDate(),
                    modified: Exporter.getDate(),
                    contributor: this.createContributor(),
                    keywords: this._pKeywords
                };
            };

            Exporter.prototype.createDocument = function () {
                var pDocument = {
                    asset: this.createAsset(),
                    library: [],
                    scenes: null
                };

                var pLibrary = this._pLibrary;

                for (var iGuid in pLibrary) {
                    var pLibEntry = pLibrary[iGuid];
                    pDocument.library.push(pLibEntry.entry);
                }

                return pDocument;
            };

            Exporter.prototype.export = function (eFormat) {
                if (typeof eFormat === "undefined") { eFormat = 0 /* JSON */; }
                var pDocument = this.createDocument();

                if (eFormat === 0 /* JSON */) {
                    return Exporter.exportAsJSON(pDocument);
                } else if (eFormat === 1 /* BINARY_JSON */) {
                    return Exporter.exportAsJSONBinary(pDocument);
                }

                return null;
            };

            Exporter.prototype.saveAs = function (sName, eFormat) {
                saveAs(this.export(eFormat), sName);
            };

            Exporter.exportAsJSON = function (pDocument) {
                return new Blob([JSON.stringify(pDocument, null, "\t")], { type: "application/json;charset=utf-8" });
            };

            Exporter.exportAsJSONBinary = function (pDocument) {
                return new Blob([akra.io.dump(pDocument)], { type: "application/octet-stream" });
            };

            Exporter.getDate = function () {
                return (new Date()).toString();
            };
            Exporter.VERSION = "0.0.1";
            Exporter.UP_AXIS = "Y_UP";
            Exporter.TOOL = "Akra Engine exporter";
            return Exporter;
        })();
        exchange.Exporter = Exporter;
    })(akra.exchange || (akra.exchange = {}));
    var exchange = akra.exchange;
})(akra || (akra = {}));
/// <reference path="../idl/IFrame.ts" />
/// <reference path="../math/math.ts" />
var akra;
(function (akra) {
    /// <reference path="../debug.ts" />
    (function (animation) {
        var Quat4 = akra.math.Quat4;
        var Vec3 = akra.math.Vec3;
        var Mat4 = akra.math.Mat4;

        var pPositionBuffer;
        var iPositionElement;

        var pMatrixBuffer;
        var iMatrixElement;

        var Frame = (function () {
            function Frame(eType, fTime, fWeight) {
                if (typeof fTime === "undefined") { fTime = 0.0; }
                if (typeof fWeight === "undefined") { fWeight = 1.0; }
                this.type = eType;
                this.time = fTime;
                this.weight = fWeight;
            }
            Frame.prototype.reset = function () {
                this.weight = 0.0;
                this.time = 0.0;

                return this;
            };

            Frame.prototype.add = function (pFrame, isFirst) {
                akra.debug.error("You cannot use Frame class directly.");
                return this;
            };

            Frame.prototype.set = function (pFrame) {
                this.weight = pFrame.weight;
                this.time = pFrame.time;

                return this;
            };

            Frame.prototype.mult = function (fScalar) {
                this.weight *= fScalar;

                return this;
            };

            Frame.prototype.normilize = function () {
                akra.debug.error("You cannot use Frame class directly.");
                return this;
            };

            Frame.prototype.interpolate = function (pStartFrame, pEndFrame, fBlend) {
                akra.debug.error("You cannot use Frame class directly.");
                return this;
            };
            return Frame;
        })();
        animation.Frame = Frame;

        //complex world position frame
        var PositionFrame = (function (_super) {
            __extends(PositionFrame, _super);
            function PositionFrame(fTime, pMatrix, fWeight) {
                _super.call(this, 1 /* SPHERICAL */);
                this.matrix = null;
                this.rotation = new Quat4;
                this.scale = new Vec3;
                this.translation = new Vec3;

                switch (arguments.length) {
                    case 0:
                        this.matrix = new Mat4;
                        return;
                    case 3:
                        this.weight = fWeight;
                    case 2:
                        this.matrix = pMatrix;
                    case 1:
                        this.time = fTime;
                }
                ;

                akra.logger.assert(this.matrix.decompose(this.rotation, this.scale, this.translation), "could not decompose matrix");
            }
            PositionFrame.prototype.toMatrix = function () {
                return this.rotation.toMat4(this.matrix).setTranslation(this.translation).scaleRight(this.scale);
            };

            PositionFrame.prototype.reset = function () {
                _super.prototype.reset.call(this);

                this.rotation.x = this.rotation.y = this.rotation.z = 0;
                this.rotation.w = 1.0;

                this.translation.x = this.translation.y = this.translation.z = 0;

                this.scale.x = this.scale.y = this.scale.z = 0;

                return this;
            };

            PositionFrame.prototype.set = function (pFrame) {
                _super.prototype.set.call(this, pFrame);

                this.rotation.set(pFrame.rotation);
                this.scale.set(pFrame.scale);
                this.translation.set(pFrame.translation);

                return this;
            };

            /**
            * Adding frame data with own weight.
            * @note Frame must be normilized after this modification!
            */
            PositionFrame.prototype.add = function (pFrame, isFirst) {
                var fWeight = pFrame.weight;

                //only lerp supported
                this.scale.x += pFrame.scale.x * fWeight;
                this.scale.y += pFrame.scale.y * fWeight;
                this.scale.z += pFrame.scale.z * fWeight;

                //only lerp supported
                this.translation.x += pFrame.translation.x * fWeight;
                this.translation.y += pFrame.translation.y * fWeight;
                this.translation.z += pFrame.translation.z * fWeight;

                this.weight += fWeight;

                if (isFirst) {
                    this.rotation.set(pFrame.rotation);
                    return this;
                }

                switch (this.type) {
                    case 0 /* LINEAR */:
                        this.rotation.mix(pFrame.rotation, fWeight / this.weight);
                        break;
                    case 1 /* SPHERICAL */:
                        this.rotation.smix(pFrame.rotation, fWeight / this.weight);
                        break;
                }

                return this;
            };

            PositionFrame.prototype.normilize = function () {
                var fScalar = 1.0 / this.weight;

                this.scale.x *= fScalar;
                this.scale.y *= fScalar;
                this.scale.z *= fScalar;

                this.translation.x *= fScalar;
                this.translation.y *= fScalar;
                this.translation.z *= fScalar;

                return this;
            };

            PositionFrame.prototype.interpolate = function (pStartFrame, pEndFrame, fBlend) {
                pStartFrame.translation.mix(pEndFrame.translation, fBlend, this.translation);
                pStartFrame.scale.mix(pEndFrame.scale, fBlend, this.scale);

                switch (pStartFrame.type) {
                    case 0 /* LINEAR */:
                        pStartFrame.rotation.mix(pEndFrame.rotation, fBlend, this.rotation);
                        break;
                    case 1 /* SPHERICAL */:
                        pStartFrame.rotation.smix(pEndFrame.rotation, fBlend, this.rotation);
                        break;
                }

                return this;
            };

            PositionFrame.temp = function () {
                iPositionElement = (iPositionElement === pPositionBuffer.length - 1 ? 0 : iPositionElement);

                //var p = pPositionBuffer[iPositionElement++];
                //return p.set.apply(p, arguments);
                return pPositionBuffer[iPositionElement++].reset();
            };
            return PositionFrame;
        })(Frame);
        animation.PositionFrame = PositionFrame;

        var MatrixFrame = (function (_super) {
            __extends(MatrixFrame, _super);
            function MatrixFrame(fTime, pMatrix, fWeight) {
                _super.call(this, 0 /* LINEAR */);
                this.matrix = null;

                switch (arguments.length) {
                    case 0:
                        this.matrix = new Mat4;
                        return;
                    case 3:
                        this.weight = fWeight;
                    case 2:
                        this.matrix = pMatrix;
                    case 1:
                        this.time = fTime;
                }
                ;
            }
            MatrixFrame.prototype.reset = function () {
                _super.prototype.reset.call(this);
                this.matrix.set(0.);

                return this;
            };

            MatrixFrame.prototype.set = function (pFrame) {
                _super.prototype.set.call(this, pFrame);

                //FIXME: расписать побыстрее
                this.matrix.set(pFrame.matrix);

                return this;
            };

            MatrixFrame.prototype.toMatrix = function () {
                return this.matrix;
            };

            MatrixFrame.prototype.add = function (pFrame, isFirst) {
                var pMatData = pFrame.matrix.data;
                var fWeight = pFrame.weight;
                var pResData = this.matrix.data;

                for (var i = 0; i < 16; ++i) {
                    pResData[i] += pMatData[i] * fWeight;
                }

                this.weight += fWeight;
                return this;
            };

            MatrixFrame.prototype.normilize = function () {
                var fScalar = 1.0 / this.weight;
                this.matrix.scaleLeft(fScalar);

                return this;
            };

            MatrixFrame.prototype.interpolate = function (pStartFrame, pEndFrame, fBlend) {
                akra.debug.assert(this.type === 0 /* LINEAR */, "only LERP interpolation supported for matrix frames");

                var pResultData = this.matrix.data;
                var pStartData = pStartFrame.matrix.data;
                var pEndData = pEndFrame.matrix.data;
                var fBlendInv = 1. - fBlend;

                for (var i = 0; i < 16; i++) {
                    pResultData[i] = pEndData[i] * fBlend + pStartData[i] * fBlendInv;
                }

                return this;
            };

            MatrixFrame.temp = function () {
                iMatrixElement = (iMatrixElement === pMatrixBuffer.length - 1 ? 0 : iMatrixElement);

                //var p = pMatrixBuffer[iMatrixElement++];
                //return p.set.apply(p, arguments);
                return pMatrixBuffer[iMatrixElement++].reset();
            };
            return MatrixFrame;
        })(Frame);
        animation.MatrixFrame = MatrixFrame;

        pPositionBuffer = akra.gen.array(4 * 4096, PositionFrame);
        iPositionElement = 0;

        pMatrixBuffer = akra.gen.array(4 * 4096, MatrixFrame);
        iMatrixElement = 0;
    })(akra.animation || (akra.animation = {}));
    var animation = akra.animation;
})(akra || (akra = {}));
/// <reference path="../idl/IAnimationParameter.ts" />
/// <reference path="Frame.ts" />
var akra;
(function (akra) {
    (function (animation) {
        var Parameter = (function () {
            function Parameter() {
                this._pKeyFrames = [];
            }
            Parameter.prototype.getTotalFrames = function () {
                return this._pKeyFrames.length;
            };

            Parameter.prototype.getDuration = function () {
                return (this._pKeyFrames.last).time;
            };

            Parameter.prototype.getFirst = function () {
                return (this._pKeyFrames.first).time;
            };

            Parameter.prototype.keyFrame = function (pFrame) {
                var iFrame;

                var pKeyFrames = this._pKeyFrames;
                var nTotalFrames = pKeyFrames.length;

                if (nTotalFrames && (iFrame = this.findKeyFrame(pFrame.time)) >= 0) {
                    pKeyFrames.splice(iFrame, 0, pFrame);
                } else {
                    pKeyFrames.push(pFrame);
                }

                return true;
            };

            Parameter.prototype.getKeyFrame = function (iFrame) {
                akra.debug.assert(iFrame < this.getTotalFrames(), "iFrame must be less then number of total jey frames.");

                return this._pKeyFrames[iFrame];
            };

            Parameter.prototype.findKeyFrame = function (fTime) {
                var pKeyFrames = this._pKeyFrames;
                var nTotalFrames = pKeyFrames.length;

                if (pKeyFrames[nTotalFrames - 1].time == fTime) {
                    return nTotalFrames - 1;
                } else {
                    for (var i = nTotalFrames - 1; i >= 0; i--) {
                        if (pKeyFrames[i].time > fTime && pKeyFrames[i - 1].time <= fTime) {
                            return i - 1;
                        }
                    }
                }

                return -1;
            };

            Parameter.prototype.frame = function (fTime) {
                var iKey1 = 0, iKey2 = 0;
                var fScalar;
                var fTimeDiff;

                var pKeys = this._pKeyFrames;
                var nKeys = pKeys.length;
                var pFrame = animation.PositionFrame.temp();

                akra.debug.assert(nKeys > 0, 'no frames :(');

                if (nKeys === 1) {
                    pFrame.set(pKeys[0]);
                } else {
                    //TODO: реализовать эвристики для бинарного поиска
                    if (fTime >= this._pKeyFrames[nKeys - 1].time) {
                        iKey1 = nKeys - 1;
                    } else {
                        var p = 0;
                        var q = nKeys - 1;

                        while (p < q) {
                            var s = (p + q) >> 1;
                            var fKeyTime = this._pKeyFrames[s].time;

                            if (fTime >= fKeyTime) {
                                if (fTime === fKeyTime || fTime < this._pKeyFrames[s + 1].time) {
                                    iKey1 = s;
                                    break;
                                }

                                p = s + 1;
                            } else {
                                q = s;
                            }
                        }
                    }

                    iKey2 = (iKey1 >= (nKeys - 1)) ? iKey1 : iKey1 + 1;

                    fTimeDiff = pKeys[iKey2].time - pKeys[iKey1].time;

                    if (!fTimeDiff) {
                        fTimeDiff = 1.;
                    }

                    fScalar = (fTime - pKeys[iKey1].time) / fTimeDiff;

                    pFrame.interpolate(this._pKeyFrames[iKey1], this._pKeyFrames[iKey2], fScalar);
                }

                pFrame.time = fTime;
                pFrame.weight = 1.0;

                return pFrame;
            };
            return Parameter;
        })();
        animation.Parameter = Parameter;

        function createParameter() {
            return new Parameter();
        }
        animation.createParameter = createParameter;
    })(akra.animation || (akra.animation = {}));
    var animation = akra.animation;
})(akra || (akra = {}));
/// <reference path="../idl/IAnimationTrack.ts" />
/// <reference path="../idl/IScene.ts" />
/// <reference path="../idl/ISceneNode.ts" />
/// <reference path="../idl/IMat4.ts" />
/// <reference path="../idl/ISkeleton.ts" />
var akra;
(function (akra) {
    /// <reference path="Parameter.ts" />
    (function (animation) {
        var Track = (function (_super) {
            __extends(Track, _super);
            function Track(sTarget) {
                if (typeof sTarget === "undefined") { sTarget = null; }
                _super.call(this);
                this._sTarget = null;
                this._pTarget = null;
                this._sTarget = sTarget;
            }
            Track.prototype.getTarget = function () {
                return this._pTarget;
            };

            Track.prototype.getTargetName = function () {
                return this._sTarget;
            };

            Track.prototype.setTargetName = function (sValue) {
                this._sTarget = sValue;
            };

            Track.prototype.keyFrame = function (fTime, pMatrix) {
                var pFrame;

                if (arguments.length > 1) {
                    pFrame = new animation.PositionFrame(fTime, pMatrix);
                } else {
                    pFrame = arguments[0];
                }

                return _super.prototype.keyFrame.call(this, pFrame);
            };

            Track.prototype.bind = function (pJoint, pSkeleton) {
                var pNode = null, pRootNode;

                var sJoint;

                switch (arguments.length) {
                    case 2:
                        //bind by pair <String joint, Skeleton skeleton>
                        sJoint = pJoint;

                        this._sTarget = sJoint;
                        pNode = pSkeleton.findJoint(sJoint);
                        break;
                    default:
                        //bind by <Skeleton skeleton>
                        if (!akra.isDef(arguments[0].getType())) {
                            if (this._sTarget == null) {
                                return false;
                            }

                            pSkeleton = arguments[0];
                            pNode = pSkeleton.findJoint(this._sTarget);
                        } else {
                            pRootNode = arguments[0];
                            pNode = pRootNode.findEntity(this.getTargetName());
                        }
                }

                this._pTarget = pNode;

                return akra.isDefAndNotNull(pNode);
            };

            Track.prototype.toString = function () {
                if (akra.config.DEBUG) {
                    var s = "target: " + this.getTargetName() + ", from: " + this.getFirst() + "sec. , duration: " + this.getDuration() + " sec. , frames: " + this.getTotalFrames();
                    return s;
                }

                return null;
            };
            return Track;
        })(animation.Parameter);

        function createTrack(sTarget) {
            if (typeof sTarget === "undefined") { sTarget = null; }
            return new Track(sTarget);
        }
        animation.createTrack = createTrack;
    })(akra.animation || (akra.animation = {}));
    var animation = akra.animation;
})(akra || (akra = {}));
/// <reference path="../idl/IReferenceCounter.ts" />
var akra;
(function (akra) {
    /// <reference path="../limit.ts" />
    /// <reference path="../logger.ts" />
    /// <reference path="../limit.ts" />
    (function (util) {
        var ReferenceCounter = (function () {
            function ReferenceCounter(pSrc) {
                this.nReferenceCount = 0;
            }
            ReferenceCounter.prototype.referenceCount = function () {
                return this.nReferenceCount;
            };

            ReferenceCounter.prototype.destructor = function () {
                akra.logger.assert(this.nReferenceCount === 0, "object is used");
            };

            ReferenceCounter.prototype.release = function () {
                akra.logger.assert(this.nReferenceCount > 0, "object is used");
                this.nReferenceCount--;
                return this.nReferenceCount;
            };

            ReferenceCounter.prototype.addRef = function () {
                akra.logger.assert(this.nReferenceCount != akra.MIN_INT32, "reference fail");

                this.nReferenceCount++;

                return this.nReferenceCount;
            };

            ReferenceCounter.prototype.eq = function (pSrc) {
                return this;
            };
            return ReferenceCounter;
        })();
        util.ReferenceCounter = ReferenceCounter;
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
/// <reference path="../idl/IEntity.ts" />
/// <reference path="../idl/IExplorerFunc.ts" />
var akra;
(function (akra) {
    /// <reference path="../logger.ts" />
    /// <reference path="../debug.ts" />
    /// <reference path="../bf/bf.ts" />
    /// <reference path="../events.ts" />
    /// <reference path="../config/config.ts" />
    /// <reference path="../guid.ts" />
    /// <reference path="ReferenceCounter.ts" />
    (function (util) {
        var EEntityStates;
        (function (EEntityStates) {
            //обновился ли сам узел?
            EEntityStates[EEntityStates["k_Updated"] = 0x01] = "k_Updated";

            //есть ли среди потомков обновленные узлы
            EEntityStates[EEntityStates["k_DescendantsUpdtated"] = 0x02] = "k_DescendantsUpdtated";

            //если ли обновленные узлы среди братьев или их потомках
            EEntityStates[EEntityStates["k_SiblingsUpdated"] = 0x04] = "k_SiblingsUpdated";
        })(EEntityStates || (EEntityStates = {}));

        var Entity = (function (_super) {
            __extends(Entity, _super);
            function Entity(eType) {
                _super.call(this);
                this.guid = akra.guid();
                this._sName = null;
                this._pParent = null;
                this._pSibling = null;
                this._pChild = null;
                this._eType = 0 /* UNKNOWN */;
                this._iStateFlags = 0;
                this.setupSignals();

                this._eType = eType;
            }
            Entity.prototype.getName = function () {
                return this._sName;
            };

            Entity.prototype.setName = function (sName) {
                this._sName = sName;
            };

            Entity.prototype.getParent = function () {
                return this._pParent;
            };

            Entity.prototype.setParent = function (pParent) {
                this.attachToParent(pParent);
            };

            Entity.prototype.getSibling = function () {
                return this._pSibling;
            };

            Entity.prototype.setSibling = function (pSibling) {
                this._pSibling = pSibling;
            };

            Entity.prototype.getChild = function () {
                return this._pChild;
            };

            Entity.prototype.setChild = function (pChild) {
                this._pChild = pChild;
            };

            Entity.prototype.getType = function () {
                return this._eType;
            };

            Entity.prototype.getRightSibling = function () {
                var pSibling = this.getSibling();

                if (pSibling) {
                    while (pSibling.getSibling()) {
                        pSibling = pSibling.getSibling();
                    }

                    return pSibling;
                }

                return this;
            };

            Entity.prototype.getDepth = function () {
                var iDepth = -1;
                for (var pEntity = this; pEntity; pEntity = pEntity.getParent(), ++iDepth) {
                }
                ;
                return iDepth;
            };

            Entity.prototype.setupSignals = function () {
                this.attached = this.attached || new akra.Signal(this);
                this.detached = this.detached || new akra.Signal(this);
                this.childAdded = this.childAdded || new akra.Signal(this);
                this.childRemoved = this.childRemoved || new akra.Signal(this);
            };

            Entity.prototype.getRoot = function () {
                for (var pEntity = this, iDepth = -1; pEntity.getParent(); pEntity = pEntity.getParent(), ++iDepth) {
                }
                ;
                return pEntity;
            };

            Entity.prototype.destroy = function (bRecursive, bPromoteChildren) {
                if (typeof bRecursive === "undefined") { bRecursive = false; }
                if (typeof bPromoteChildren === "undefined") { bPromoteChildren = true; }
                if (bRecursive) {
                    if (this._pSibling) {
                        this._pSibling.destroy(true);
                    }

                    if (this._pChild) {
                        this._pChild.destroy(true);
                    }
                }

                // destroy anything attached to this node
                //	destroySceneObject();
                // promote any children up to our parent
                if (bPromoteChildren && !bRecursive) {
                    this.promoteChildren();
                }

                // now remove ourselves from our parent
                this.detachFromParent();

                // we should now be removed from the tree, and have no dependants
                akra.debug.assert(this.referenceCount() == 0, "Attempting to delete a scene node which is still in use");
                akra.debug.assert(this._pSibling == null, "Failure Destroying Node");
                akra.debug.assert(this._pChild == null, "Failure Destroying Node");
            };

            Entity.prototype.findEntity = function (sName) {
                var pEntity = null;

                if (this._sName === sName) {
                    return this;
                }

                if (this._pSibling) {
                    pEntity = this._pSibling.findEntity(sName);
                }

                if (pEntity == null && this._pChild) {
                    pEntity = this._pChild.findEntity(sName);
                }

                return pEntity;
            };

            Entity.prototype.explore = function (fn, bWithSiblings) {
                if (typeof bWithSiblings === "undefined") { bWithSiblings = false; }
                if (fn(this) === false) {
                    return;
                }

                if (this._pSibling && bWithSiblings) {
                    this._pSibling.explore(fn, true);
                }

                if (this._pChild) {
                    this._pChild.explore(fn, true);
                }
            };

            Entity.prototype.childOf = function (pParent) {
                for (var pEntity = this; pEntity; pEntity = pEntity.getParent()) {
                    if (pEntity.getParent() === pParent) {
                        return true;
                    }
                }

                return false;
            };

            Entity.prototype.children = function () {
                var pChildren = [];
                var pChild = this.getChild();

                while (!akra.isNull(pChild)) {
                    pChildren.push(pChild);
                    pChild = pChild.getSibling();
                }

                return pChildren;
            };

            Entity.prototype.childAt = function (i) {
                var pChild = this.getChild();
                var n = 0;

                while (!akra.isNull(pChild)) {
                    if (n == i) {
                        return pChild;
                    }
                    n++;
                    pChild = pChild.getSibling();
                }

                return pChild;
            };

            /**
            * Returns the current number of siblings of this object.
            */
            Entity.prototype.siblingCount = function () {
                var iCount = 0;

                if (this._pParent) {
                    var pNextSibling = this._pParent.getChild();
                    if (pNextSibling) {
                        while (pNextSibling) {
                            pNextSibling = pNextSibling.getSibling();
                            ++iCount;
                        }
                    }
                }

                return iCount;
            };

            Entity.prototype.descCount = function () {
                var n = this.childCount();
                var pChild = this.getChild();

                while (!akra.isNull(pChild)) {
                    n += pChild.descCount();
                    pChild = pChild.getSibling();
                }

                return n;
            };

            /**
            * Returns the current number of children of this object
            */
            Entity.prototype.childCount = function () {
                var iCount = 0;
                var pChild = this.getChild();

                while (!akra.isNull(pChild)) {
                    iCount++;
                    pChild = pChild.getSibling();
                }

                // var pNextChild: IEntity = this.child;
                // if (pNextChild) {
                //	 ++ iCount;
                //	 while (pNextChild) {
                //		 pNextChild = pNextChild.sibling;
                //		 ++ iCount;
                //	 }
                // }
                return iCount;
            };

            Entity.prototype.isUpdated = function () {
                return akra.bf.testAll(this._iStateFlags, 1 /* k_Updated */);
            };

            Entity.prototype.hasUpdatedSubNodes = function () {
                return akra.bf.testAll(this._iStateFlags, 2 /* k_DescendantsUpdtated */);
            };

            Entity.prototype.recursiveUpdate = function () {
                // var bUpdated: boolean = false;
                // update myself
                if (this.update()) {
                    this._iStateFlags = akra.bf.setAll(this._iStateFlags, 1 /* k_Updated */);
                    // bUpdated = true;
                }

                // update my sibling
                if (this._pSibling && this._pSibling.recursiveUpdate()) {
                    this._iStateFlags = akra.bf.setAll(this._iStateFlags, 4 /* k_SiblingsUpdated */);
                    // bUpdated = true;
                }

                // update my child
                if (this._pChild && this._pChild.recursiveUpdate()) {
                    this._iStateFlags = akra.bf.setAll(this._iStateFlags, 2 /* k_DescendantsUpdtated */);
                    // bUpdated = true;
                }

                return (this._iStateFlags != 0);
            };

            Entity.prototype.recursivePreUpdate = function () {
                // clear the flags from the previous update
                this.prepareForUpdate();

                // update my sibling
                if (this._pSibling) {
                    this._pSibling.recursivePreUpdate();
                }

                // update my child
                if (this._pChild) {
                    this._pChild.recursivePreUpdate();
                }
            };

            Entity.prototype.prepareForUpdate = function () {
                this._iStateFlags = 0;
            };

            /** Parent is not undef */
            Entity.prototype.hasParent = function () {
                return akra.isDefAndNotNull(this._pParent);
            };

            /** Child is not undef*/
            Entity.prototype.hasChild = function () {
                return akra.isDefAndNotNull(this._pChild);
            };

            /** Sibling is not undef */
            Entity.prototype.hasSibling = function () {
                return akra.isDefAndNotNull(this._pSibling);
            };

            /**
            * Checks to see if the provided item is a sibling of this object
            */
            Entity.prototype.isASibling = function (pSibling) {
                if (!pSibling) {
                    return false;
                }

                // if the sibling we are looking for is me, or my FirstSibling, return true
                if (this == pSibling || this._pSibling == pSibling) {
                    return true;
                }

                // if we have a sibling, continue searching
                if (this._pSibling) {
                    return this._pSibling.isASibling(pSibling);
                }

                // it's not us, and we have no sibling to check. This is not a sibling of ours.
                return false;
            };

            /** Checks to see if the provided item is a child of this object. (one branch depth only) */
            Entity.prototype.isAChild = function (pChild) {
                if (!pChild) {
                    return (false);
                }

                // if the sibling we are looking for is my FirstChild return true
                if (this._pChild == pChild) {
                    return (true);
                }

                // if we have a child, continue searching
                if (this._pChild) {
                    return (this._pChild.isASibling(pChild));
                }

                // it's not us, and we have no child to check. This is not a sibling of ours.
                return (false);
            };

            /**
            * Checks to see if the provided item is a child or sibling of this object. If SearchEntireTree
            * is TRUE, the check is done recursivly through all siblings and children. SearchEntireTree
            * is FALSE by default.
            */
            Entity.prototype.isInFamily = function (pEntity, bSearchEntireTree) {
                if (!pEntity) {
                    return (false);
                }

                // if the model we are looking for is me or my immediate family, return true
                if (this == pEntity || this._pChild == pEntity || this._pSibling == pEntity) {
                    return (true);
                }

                // if not set to seach entire tree, just check my siblings and kids
                if (!bSearchEntireTree) {
                    if (this.isASibling(pEntity)) {
                        return (true);
                    }
                    if (this._pChild && this._pChild.isASibling(pEntity)) {
                        return (true);
                    }
                } else {
                    if (this._pSibling && this._pSibling.isInFamily(pEntity, bSearchEntireTree)) {
                        return (true);
                    }

                    if (this._pChild && this._pChild.isInFamily(pEntity, bSearchEntireTree)) {
                        return (true);
                    }
                }

                return (false);
            };

            /**
            * Adds the provided ModelSpace object to the descendant list of this object. The provided
            * ModelSpace object is removed from any parent it may already belong to.
            */
            Entity.prototype.addSibling = function (pSibling) {
                if (pSibling) {
                    // replace objects current sibling pointer with this new one
                    pSibling.setSibling(this._pSibling);
                    this.setSibling(pSibling);
                }

                return pSibling;
            };

            /**
            * Adds the provided ModelSpace object to the descendant list of this object. The provided
            * ModelSpace object is removed from any parent it may already belong to.
            */
            Entity.prototype.addChild = function (pChild) {
                if (pChild) {
                    // Replace the new child's sibling pointer with our old first child.
                    pChild.setSibling(this._pChild);

                    // the new child becomes our first child pointer.
                    this._pChild = pChild;
                    this.childAdded.emit(pChild);
                }

                return pChild;
            };

            /**
            * Removes a specified child object from this parent object. If the child is not the
            * FirstChild of this object, all of the Children are searched to find the object to remove.
            */
            Entity.prototype.removeChild = function (pChild) {
                if (this._pChild && pChild) {
                    if (this._pChild == pChild) {
                        this._pChild = pChild.getSibling();
                        pChild.setSibling(null);
                    } else {
                        var pTempNode = this._pChild;

                        while (pTempNode && (pTempNode.getSibling() != pChild)) {
                            pTempNode = pTempNode.getSibling();
                        }

                        // if we found the proper item, set it's FirstSibling to be the FirstSibling of the child
                        // we are removing
                        if (pTempNode) {
                            pTempNode.setSibling(pChild.getSibling());
                            pChild.setSibling(null);
                        }
                    }

                    this.childRemoved.emit(pChild);
                }

                return pChild;
            };

            /** Removes all Children from this parent object */
            Entity.prototype.removeAllChildren = function () {
                while (!akra.isNull(this._pChild)) {
                    var pNextSibling = this._pChild.getSibling();
                    this._pChild.detachFromParent();
                    this._pChild = pNextSibling;
                }
            };

            /** Attaches this object ot a new parent. Same as calling the parent's addChild() routine. */
            Entity.prototype.attachToParent = function (pParent) {
                var pParentPrev = this.getParent();

                if (pParent != this._pParent) {
                    this.detachFromParent();

                    if (pParent) {
                        if (pParent.addChild(this)) {
                            this._pParent = pParent;
                            this._pParent.addRef();
                            this.attached.emit();
                            return true;
                        }

                        return this.attachToParent(pParentPrev);
                    }
                }

                var x = null;

                return false;
            };

            Entity.prototype.detachFromParent = function () {
                // tell our current parent to release us
                if (this._pParent) {
                    this._pParent.removeChild(this);

                    //TODO: разобраться что за херня!!!!
                    if (this._pParent) {
                        this._pParent.release();
                    }

                    this._pParent = null;

                    // my world matrix is now my local matrix
                    this.detached.emit();
                    return true;
                }

                return false;
            };

            /**
            * Attaches this object's children to it's parent, promoting them up the tree
            */
            Entity.prototype.promoteChildren = function () {
                while (!akra.isNull(this._pChild)) {
                    var pNextSibling = this._pChild.getSibling();
                    this._pChild.attachToParent(this._pParent);
                    this._pChild = pNextSibling;
                }
            };

            Entity.prototype.relocateChildren = function (pParent) {
                if (pParent != this) {
                    while (!akra.isNull(this._pChild)) {
                        var pNextSibling = this._pChild.getSibling();
                        this._pChild.attachToParent(pParent);
                        this._pChild = pNextSibling;
                    }
                }
            };

            Entity.prototype.update = function () {
                return false;
            };

            Entity.prototype.toString = function (isRecursive, iDepth) {
                if (typeof isRecursive === "undefined") { isRecursive = false; }
                if (typeof iDepth === "undefined") { iDepth = 0; }
                if (akra.config.DEBUG) {
                    if (!isRecursive) {
                        return '<entity' + (this._sName ? ' ' + this._sName : "") + '>';
                    }

                    var pChild = this.getChild();
                    var s = "";

                    for (var i = 0; i < iDepth; ++i) {
                        s += ':  ';
                    }

                    s += '+----[depth: ' + this.getDepth() + ']' + this.toString() + '\n';

                    if (pChild) {
                        s += pChild.toString(true, iDepth + 1);
                    }

                    return s;
                }

                return null;
            };
            return Entity;
        })(util.ReferenceCounter);
        util.Entity = Entity;
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
/// <reference path="../idl/INode.ts" />
/// <reference path="../util/Entity.ts" />
/// <reference path="../math/math.ts" />
/// <reference path="../bf/bf.ts" />
var akra;
(function (akra) {
    (function (scene) {
        (function (ENodeUpdateFlags) {
            ENodeUpdateFlags[ENodeUpdateFlags["k_SetForDestruction"] = 0] = "k_SetForDestruction";

            //if changed scale, otation or position
            ENodeUpdateFlags[ENodeUpdateFlags["k_NewOrientation"] = 1] = "k_NewOrientation";

            // k_NewTranslation,
            // k_NewScale,
            ENodeUpdateFlags[ENodeUpdateFlags["k_NewWorldMatrix"] = 2] = "k_NewWorldMatrix";
            ENodeUpdateFlags[ENodeUpdateFlags["k_NewLocalMatrix"] = 3] = "k_NewLocalMatrix";
            ENodeUpdateFlags[ENodeUpdateFlags["k_RebuildInverseWorldMatrix"] = 4] = "k_RebuildInverseWorldMatrix";
            ENodeUpdateFlags[ENodeUpdateFlags["k_RebuildNormalMatrix"] = 5] = "k_RebuildNormalMatrix";
        })(scene.ENodeUpdateFlags || (scene.ENodeUpdateFlags = {}));
        var ENodeUpdateFlags = scene.ENodeUpdateFlags;

        var __11 = akra.math.__11;
        var __12 = akra.math.__12;
        var __13 = akra.math.__13;
        var __14 = akra.math.__14;

        var __21 = akra.math.__21;
        var __22 = akra.math.__22;
        var __23 = akra.math.__23;
        var __24 = akra.math.__24;

        var __31 = akra.math.__31;
        var __32 = akra.math.__32;
        var __33 = akra.math.__33;
        var __34 = akra.math.__34;

        var __41 = akra.math.__41;
        var __42 = akra.math.__42;
        var __43 = akra.math.__43;
        var __44 = akra.math.__44;

        var Mat4 = akra.math.Mat4;
        var Vec3 = akra.math.Vec3;
        var Quat4 = akra.math.Quat4;
        var Mat3 = akra.math.Mat3;
        var Vec4 = akra.math.Vec4;

        var Node = (function (_super) {
            __extends(Node, _super);
            function Node() {
                _super.apply(this, arguments);
                this._m4fLocalMatrix = null;
                this._m4fWorldMatrix = null;
                this._m4fInverseWorldMatrix = null;
                this._m3fNormalMatrix = null;
                this._v3fWorldPosition = null;
                this._qRotation = null;
                this._v3fTranslation = null;
                this._v3fScale = null;
                this._iUpdateFlags = 0;
                this._eInheritance = 1 /* POSITION */;
            }
            Node.prototype.create = function () {
                return true;
            };

            Node.prototype.getLocalOrientation = function () {
                return this._qRotation;
            };

            Node.prototype.setLocalOrientation = function (qOrient) {
                this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 1 /* k_NewOrientation */);
                this._qRotation.set(qOrient);
                return this;
            };

            Node.prototype.getLocalPosition = function () {
                return this._v3fTranslation;
            };

            Node.prototype.setLocalPosition = function (v3fPosition) {
                this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 1 /* k_NewOrientation */);
                this._v3fTranslation.set(v3fPosition);
                return this;
            };

            Node.prototype.getLocalScale = function () {
                return this._v3fScale;
            };

            Node.prototype.setLocalScale = function (v3fScale) {
                this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 1 /* k_NewOrientation */);
                this._v3fScale.set(v3fScale);
                return this;
            };

            Node.prototype.getLocalMatrix = function () {
                return this._m4fLocalMatrix;
            };

            Node.prototype.setLocalMatrix = function (m4fLocalMatrix) {
                this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 3 /* k_NewLocalMatrix */);
                this._m4fLocalMatrix.set(m4fLocalMatrix);
                return this;
            };

            Node.prototype.getWorldMatrix = function () {
                return this._m4fWorldMatrix;
            };

            Node.prototype.getWorldPosition = function () {
                return this._v3fWorldPosition;
            };

            Node.prototype.getWorldOrientation = function () {
                //TODO: calc right world orient.
                return null;
            };

            Node.prototype.getWorldScale = function () {
                //TODO: calc right world scale.
                return this.getLocalScale();
            };

            //  get worldRotation(): IQuat4 {
            // 	logger.assert((<Node>this._pParent).worldMatrix.toMat3(Node._m3fTemp1).decompose(Node._q4fTemp1, Node._v3fTemp1),
            //             		"could not decompose.");
            // 	//FIXME: use correct way to get world rotation
            // 	return Node._q4fTemp1;
            // }
            Node.prototype.getInverseWorldMatrix = function () {
                if (akra.bf.testBit(this._iUpdateFlags, 4 /* k_RebuildInverseWorldMatrix */)) {
                    this._m4fWorldMatrix.inverse(this._m4fInverseWorldMatrix);
                    this._iUpdateFlags = akra.bf.clearBit(this._iUpdateFlags, 4 /* k_RebuildInverseWorldMatrix */);
                }

                return this._m4fInverseWorldMatrix;
            };

            Node.prototype.getNormalMatrix = function () {
                if (akra.bf.testBit(this._iUpdateFlags, 5 /* k_RebuildNormalMatrix */)) {
                    this._m4fWorldMatrix.toMat3(this._m3fNormalMatrix).inverse().transpose();

                    this._iUpdateFlags = akra.bf.clearBit(this._iUpdateFlags, 5 /* k_RebuildNormalMatrix */);
                }

                return this._m3fNormalMatrix;
            };

            Node.prototype.getVectorUp = function () {
                var vec = this._m4fWorldMatrix.multiplyVec4(akra.math.Vec4.temp(0., 1., 0., 0.));
                return new akra.math.Vec3(vec.x, vec.y, vec.z);
            };

            Node.prototype.getVectorRight = function () {
                var vec = this._m4fWorldMatrix.multiplyVec4(akra.math.Vec4.temp(-1., 0., 0., 0.));
                return new akra.math.Vec3(vec.x, vec.y, vec.z);
            };

            Node.prototype.getVectorForward = function () {
                var vec = this._m4fWorldMatrix.multiplyVec4(akra.math.Vec4.temp(0., 0., 1., 0.));
                return new akra.math.Vec3(vec.x, vec.y, vec.z);
            };

            Node.prototype.getTempVectorUp = function () {
                var vec = this._m4fWorldMatrix.multiplyVec4(akra.math.Vec4.temp(0., 1., 0., 0.));
                return akra.math.Vec3.temp(vec.x, vec.y, vec.z);
            };

            Node.prototype.getTempVectorRight = function () {
                var vec = this._m4fWorldMatrix.multiplyVec4(akra.math.Vec4.temp(-1., 0., 0., 0.));
                return akra.math.Vec3.temp(vec.x, vec.y, vec.z);
            };

            Node.prototype.getTempVectorForward = function () {
                var vec = this._m4fWorldMatrix.multiplyVec4(akra.math.Vec4.temp(0., 0., 1., 0.));
                return akra.math.Vec3.temp(vec.x, vec.y, vec.z);
            };

            Node.prototype.update = function () {
                // derived classes update the local matrix
                // then call this base function to complete
                // the update
                return this.recalcWorldMatrix();
            };

            Node.prototype.prepareForUpdate = function () {
                _super.prototype.prepareForUpdate.call(this);

                // clear the temporary flags
                this._iUpdateFlags = akra.bf.clearAll(this._iUpdateFlags, akra.bf.flag(3 /* k_NewLocalMatrix */) | akra.bf.flag(1 /* k_NewOrientation */) | akra.bf.flag(2 /* k_NewWorldMatrix */));
            };

            Node.prototype.setInheritance = function (eInheritance) {
                this._eInheritance = eInheritance;
            };

            Node.prototype.getInheritance = function () {
                return this._eInheritance;
            };

            Node.prototype.isWorldMatrixNew = function () {
                return akra.bf.testBit(this._iUpdateFlags, 2 /* k_NewWorldMatrix */);
            };

            Node.prototype.isLocalMatrixNew = function () {
                return akra.bf.testBit(this._iUpdateFlags, 3 /* k_NewLocalMatrix */);
            };

            Node.prototype.recalcWorldMatrix = function () {
                var isParentMoved = this._pParent && this._pParent.isWorldMatrixNew();
                var isOrientModified = akra.bf.testBit(this._iUpdateFlags, 1 /* k_NewOrientation */);
                var isLocalModified = akra.bf.testBit(this._iUpdateFlags, 3 /* k_NewLocalMatrix */);

                if (isOrientModified || isParentMoved || isLocalModified) {
                    var m4fLocal = this._m4fLocalMatrix;
                    var m4fWorld = this._m4fWorldMatrix;

                    var m4fOrient = Node._m4fTemp1;
                    var v3fTemp = Node._v3fTemp1;

                    var pWorldData = m4fWorld.data;
                    var pOrientData = m4fOrient.data;

                    this._qRotation.toMat4(m4fOrient);

                    m4fOrient.setTranslation(this._v3fTranslation);
                    m4fOrient.scaleRight(this._v3fScale);
                    m4fOrient.multiply(m4fLocal);

                    //console.log("recalc: " + this.toString() + " : " + this._eInheritance);
                    //console.error(m4fOrient.toString());
                    if (this._pParent && this._eInheritance !== 0 /* NONE */) {
                        var m4fParent = this._pParent.getWorldMatrix();
                        var pParentData = m4fParent.data;

                        if (this._eInheritance === 4 /* ALL */) {
                            m4fParent.multiply(m4fOrient, m4fWorld);
                        } else if (this._eInheritance === 1 /* POSITION */) {
                            m4fWorld.set(m4fOrient);

                            pWorldData[__14] = pParentData[__14] + pOrientData[__14];
                            pWorldData[__24] = pParentData[__24] + pOrientData[__24];
                            pWorldData[__34] = pParentData[__34] + pOrientData[__34];
                        } else if (this._eInheritance === 3 /* ROTPOSITION */) {
                            //FIXME: add faster way to compute this inheritance...
                            akra.logger.assert(m4fParent.toMat3(Node._m3fTemp1).decompose(Node._q4fTemp1, Node._v3fTemp1), "could not decompose.");

                            var m4fParentNoScale = Node._q4fTemp1.toMat4(Node._m4fTemp2);

                            m4fParentNoScale.data[__14] = pParentData[__14];
                            m4fParentNoScale.data[__24] = pParentData[__24];
                            m4fParentNoScale.data[__34] = pParentData[__34];

                            m4fParentNoScale.multiply(m4fOrient, m4fWorld);
                        } else if (this._eInheritance === 2 /* ROTSCALE */) {
                            //3x3 parent world matrix
                            var p11 = pParentData[__11], p12 = pParentData[__12], p13 = pParentData[__13];
                            var p21 = pParentData[__21], p22 = pParentData[__22], p23 = pParentData[__23];
                            var p31 = pParentData[__31], p32 = pParentData[__32], p33 = pParentData[__33];

                            //3x3 local matrix
                            var l11 = pOrientData[__11], l12 = pOrientData[__12], l13 = pOrientData[__13];
                            var l21 = pOrientData[__21], l22 = pOrientData[__22], l23 = pOrientData[__23];
                            var l31 = pOrientData[__31], l32 = pOrientData[__32], l33 = pOrientData[__33];

                            //parent x local with local world pos.
                            pWorldData[__11] = p11 * l11 + p12 * l21 + p13 * l31;
                            pWorldData[__12] = p11 * l12 + p12 * l22 + p13 * l32;
                            pWorldData[__13] = p11 * l13 + p12 * l23 + p13 * l33;
                            pWorldData[__14] = pOrientData[__14];
                            pWorldData[__21] = p21 * l11 + p22 * l21 + p23 * l31;
                            pWorldData[__22] = p21 * l12 + p22 * l22 + p23 * l32;
                            pWorldData[__23] = p21 * l13 + p22 * l23 + p23 * l33;
                            pWorldData[__24] = pOrientData[__24];
                            pWorldData[__31] = p31 * l11 + p32 * l21 + p33 * l31;
                            pWorldData[__32] = p31 * l12 + p32 * l22 + p33 * l32;
                            pWorldData[__33] = p31 * l13 + p32 * l23 + p33 * l33;
                            pWorldData[__34] = pOrientData[__34];

                            pWorldData[__41] = pOrientData[__41];
                            pWorldData[__42] = pOrientData[__42];
                            pWorldData[__43] = pOrientData[__43];
                            pWorldData[__44] = pOrientData[__44];
                        }
                    } else {
                        m4fWorld.set(m4fOrient);
                    }

                    this._v3fWorldPosition.x = pWorldData[__14];
                    this._v3fWorldPosition.y = pWorldData[__24];
                    this._v3fWorldPosition.z = pWorldData[__34];

                    // set the flag that our world matrix has changed
                    this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 2 /* k_NewWorldMatrix */);

                    // and it's inverse & vectors are out of date
                    this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 4 /* k_RebuildInverseWorldMatrix */);
                    this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 5 /* k_RebuildNormalMatrix */);

                    //this._iUpdateFlags = bf.clearAll(this._iUpdateFlags, bf.flag(ENodeUpdateFlags.k_NewLocalMatrix) |
                    //	bf.flag(ENodeUpdateFlags.k_NewOrientation));
                    return true;
                }

                return false;
            };

            Node.prototype.setWorldPosition = function (fX, fY, fZ) {
                var pPos = arguments.length === 1 ? arguments[0] : Vec3.temp(fX, fY, fZ);

                //target world matrix
                var Au = Mat4.temp(1.);
                Au.setTranslation(pPos);

                //original translation matrices of this node
                var A0 = Mat4.temp(1.);
                A0.setTranslation(this.getWorldPosition());

                //inversed A0
                var A0inv = A0.inverse(Mat4.temp());

                //transformation matrix A0 to Au
                var C = Au.multiply(A0inv, Mat4.temp());

                //parent world matrix
                var Mp = akra.isNull(this.getParent()) ? Mat4.temp(1.) : Mat4.temp(this.getParent().getWorldMatrix());

                //this orientation matrix (orientation + sclae + translation)
                var Mo = Mat4.temp();

                //assemble local orientaion matrix
                this.getLocalOrientation().toMat4(Mo);
                Mo.setTranslation(this.getLocalPosition());
                Mo.scaleRight(this.getLocalScale());

                //this local matrix
                var Ml = Mat4.temp(this.getLocalMatrix());

                //inversed parent world matrix
                var Mpinv = Mp.inverse(Mat4.temp());

                //inversed this orientation matrix
                var Moinv = Mo.inverse(Mat4.temp());

                //transformation matrix Ml to Mlc
                var Cc = Moinv.multiply(Mpinv, Mat4.temp()).multiply(C).multiply(Mp).multiply(Mo);

                //modified local matrix, that translate node to pPos world position
                var Mlc = Cc.multiply(Ml, Mat4.temp());

                this._m4fLocalMatrix.setTranslation(Mlc.getTranslation());

                this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 3 /* k_NewLocalMatrix */);
                return this;
            };

            Node.prototype.setPosition = function (fX, fY, fZ) {
                var pPos = arguments.length === 1 ? arguments[0] : Vec3.temp(fX, fY, fZ);
                var v3fTranslation = this._v3fTranslation;

                v3fTranslation.set(pPos);

                this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 1 /* k_NewOrientation */);
                return this;
            };

            Node.prototype.setRelPosition = function (fX, fY, fZ) {
                var pPos = arguments.length === 1 ? arguments[0] : Vec3.temp(fX, fY, fZ);
                var v3fTranslation = this._v3fTranslation;

                this._qRotation.multiplyVec3(pPos);
                v3fTranslation.set(pPos);

                this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 1 /* k_NewOrientation */);
                return this;
            };

            Node.prototype.addPosition = function (fX, fY, fZ) {
                var pPos = arguments.length === 1 ? arguments[0] : Vec3.temp(fX, fY, fZ);
                var v3fTranslation = this._v3fTranslation;

                v3fTranslation.add(pPos);

                this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 1 /* k_NewOrientation */);
                return this;
            };

            Node.prototype.addRelPosition = function (fX, fY, fZ) {
                var pPos = arguments.length === 1 ? arguments[0] : Vec3.temp(fX, fY, fZ);
                var v3fTranslation = this._v3fTranslation;

                this._qRotation.multiplyVec3(pPos);
                v3fTranslation.add(pPos);

                this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 1 /* k_NewOrientation */);
                return this;
            };

            Node.prototype.setRotationByMatrix = function (matrix) {
                matrix.toQuat4(this._qRotation);
                this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 1 /* k_NewOrientation */);
                return this;
            };

            Node.prototype.setRotationByAxisAngle = function (v3fAxis, fAngle) {
                Quat4.fromAxisAngle(v3fAxis, fAngle, this._qRotation);
                this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 1 /* k_NewOrientation */);
                return this;
            };

            Node.prototype.setRotationByForwardUp = function (v3fForward, v3fUp) {
                Quat4.fromForwardUp(v3fForward, v3fUp, this._qRotation);
                this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 1 /* k_NewOrientation */);
                return this;
            };

            Node.prototype.setRotationByEulerAngles = function (fYaw, fPitch, fRoll) {
                Quat4.fromYawPitchRoll(fYaw, fPitch, fRoll, this._qRotation);
                this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 1 /* k_NewOrientation */);
                return this;
            };

            Node.prototype.setRotationByXYZAxis = function (fX, fY, fZ) {
                Quat4.fromYawPitchRoll(fY, fX, fZ, this._qRotation);
                this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 1 /* k_NewOrientation */);
                return this;
            };

            Node.prototype.setRotation = function (q4fRotation) {
                this._qRotation.set(q4fRotation);
                this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 1 /* k_NewOrientation */);
                return this;
            };

            Node.prototype.addRelRotationByMatrix = function (matrix) {
                this.addRelRotation(arguments[0].toQuat4(Node._q4fTemp1));
                return this;
            };

            Node.prototype.addRelRotationByAxisAngle = function (v3fAxis, fAngle) {
                this.addRelRotation(Quat4.fromAxisAngle(v3fAxis, fAngle, Node._q4fTemp1));
                return this;
            };

            Node.prototype.addRelRotationByForwardUp = function (v3fForward, v3fUp) {
                this.addRelRotation(Quat4.fromForwardUp(v3fForward, v3fUp, Node._q4fTemp1));
                return this;
            };

            Node.prototype.addRelRotationByEulerAngles = function (fYaw, fPitch, fRoll) {
                this.addRelRotation(Quat4.fromYawPitchRoll(fYaw, fPitch, fRoll, Node._q4fTemp1));
                return this;
            };

            Node.prototype.addRelRotationByXYZAxis = function (fX, fY, fZ) {
                this.addRelRotation(Quat4.fromYawPitchRoll(fY, fX, fZ, Node._q4fTemp1));
                return this;
            };

            Node.prototype.addRelRotation = function (q4fRotation) {
                this._qRotation.multiply(q4fRotation);
                this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 1 /* k_NewOrientation */);
                return this;
            };

            Node.prototype.addRotationByMatrix = function (matrix) {
                this.addRotation(arguments[0].toQuat4(Node._q4fTemp1));
                return this;
            };

            Node.prototype.addRotationByAxisAngle = function (v3fAxis, fAngle) {
                this.addRotation(Quat4.fromAxisAngle(v3fAxis, fAngle, Node._q4fTemp1));
                return this;
            };

            Node.prototype.addRotationByForwardUp = function (v3fForward, v3fUp) {
                this.addRotation(Quat4.fromForwardUp(v3fForward, v3fUp, Node._q4fTemp1));
                return this;
            };

            Node.prototype.addRotationByEulerAngles = function (fYaw, fPitch, fRoll) {
                this.addRotation(Quat4.fromYawPitchRoll(fYaw, fPitch, fRoll, Node._q4fTemp1));
                return this;
            };

            Node.prototype.addRotationByXYZAxis = function (fX, fY, fZ) {
                this.addRotation(Quat4.fromYawPitchRoll(fY, fX, fZ, Node._q4fTemp1));
                return this;
            };

            Node.prototype.addRotation = function (q4fRotation) {
                q4fRotation.multiply(this._qRotation, this._qRotation);
                this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 1 /* k_NewOrientation */);
                return this;
            };

            Node.prototype.addOrbitRotationByMatrix = function (matrix) {
                this.addOrbitRotation(arguments[0].toQuat4(Node._q4fTemp1));
                return this;
            };

            Node.prototype.addOrbitRotationByAxisAngle = function (v3fAxis, fAngle) {
                this.addOrbitRotation(Quat4.fromAxisAngle(v3fAxis, fAngle, Node._q4fTemp1));
                return this;
            };

            Node.prototype.addOrbitRotationByForwardUp = function (v3fForward, v3fUp) {
                this.addOrbitRotation(Quat4.fromForwardUp(v3fForward, v3fUp, Node._q4fTemp1));
                return this;
            };

            Node.prototype.addOrbitRotationByEulerAngles = function (fYaw, fPitch, fRoll) {
                this.addOrbitRotation(Quat4.fromYawPitchRoll(fYaw, fPitch, fRoll, Node._q4fTemp1));
                return this;
            };

            Node.prototype.addOrbitRotationByXYZAxis = function (fX, fY, fZ) {
                this.addOrbitRotation(Quat4.fromYawPitchRoll(fY, fX, fZ, Node._q4fTemp1));
                return this;
            };

            Node.prototype.addOrbitRotation = function (q4fRotation) {
                q4fRotation.multiplyVec3(this._v3fTranslation);
                q4fRotation.multiply(this._qRotation, this._qRotation);
                this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 1 /* k_NewOrientation */);
                return this;
            };

            Node.prototype.scale = function (fX, fY, fZ) {
                var pScale = arguments.length === 1 ? (akra.isNumber(arguments[0]) ? Vec3.temp(fX) : arguments[0]) : Vec3.temp(fX, fY, fZ);
                var v3fScale = this._v3fScale;

                v3fScale.scale(pScale);

                this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 1 /* k_NewOrientation */);
                return this;
            };

            Node.prototype.lookAt = function (v3f) {
                var v3fFrom, v3fCenter, v3fUp;

                this.update();

                if (arguments.length < 3) {
                    v3fFrom = this.getWorldPosition();
                    v3fCenter = arguments[0];
                    v3fUp = arguments[1];
                } else {
                    v3fFrom = arguments[0];
                    v3fCenter = arguments[1];
                    v3fUp = arguments[2];
                }

                v3fUp = v3fUp || Vec3.temp(0., 1., 0.);

                var v3fParentPos = this.getParent().getWorldPosition();
                var m4fTemp = Mat4.lookAt(v3fFrom, v3fCenter, v3fUp, Mat4.temp()).inverse();
                var pData = m4fTemp.data;

                switch (this._eInheritance) {
                    case 4 /* ALL */:
                        this._pParent.getInverseWorldMatrix().multiply(m4fTemp, m4fTemp);
                        m4fTemp.toQuat4(this._qRotation);
                        this.setPosition(pData[__14], pData[__24], pData[__34]);
                        break;
                    case 2 /* ROTSCALE */:
                        var m3fTemp = m4fTemp.toMat3();
                        m3fTemp = this._pParent.getInverseWorldMatrix().toMat3().multiply(m3fTemp, Mat3.temp());
                        m3fTemp.toQuat4(this._qRotation);
                        this.setPosition(pData[__14], pData[__24], pData[__34]);
                        break;
                    default:
                        m4fTemp.toQuat4(this._qRotation);
                        this.setPosition(pData[__14] - v3fParentPos.x, pData[__24] - v3fParentPos.y, pData[__34] - v3fParentPos.z);
                }

                this.update();
                return this;
            };

            Node.prototype.attachToParent = function (pParent) {
                if (_super.prototype.attachToParent.call(this, pParent)) {
                    // adjust my local matrix to be relative to this new parent
                    var m4fInvertedParentMatrix = Mat4.temp();
                    this._pParent._m4fWorldMatrix.inverse(m4fInvertedParentMatrix);
                    this._iUpdateFlags = akra.bf.setBit(this._iUpdateFlags, 2 /* k_NewWorldMatrix */);

                    return true;
                }

                return false;
            };

            Node.prototype.detachFromParent = function () {
                if (_super.prototype.detachFromParent.call(this)) {
                    this._m4fWorldMatrix.identity();
                    return true;
                }

                return false;
            };

            Node.prototype.toString = function (isRecursive, iDepth) {
                if (typeof isRecursive === "undefined") { isRecursive = false; }
                if (typeof iDepth === "undefined") { iDepth = 0; }
                if (akra.config.DEBUG) {
                    if (!isRecursive) {
                        return '<node' + (this.getName() ? " " + this.getName() : "") + '>';
                    }

                    // var pSibling: IEntity = this.sibling;
                    var pChild = this.getChild();
                    var s = "";

                    for (var i = 0; i < iDepth; ++i) {
                        s += ':  ';
                    }

                    s += '+----[depth: ' + this.getDepth() + ']' + this.toString() + '\n';

                    while (pChild) {
                        s += pChild.toString(true, iDepth + 1);
                        pChild = pChild.getSibling();
                    }

                    // if (pSibling) {
                    // s += pSibling.toString(true, iDepth);
                    // }
                    //
                    return s;
                }
                return null;
            };

            Node._v3fTemp1 = new Vec3();
            Node._v4fTemp1 = new Vec4();
            Node._m3fTemp1 = new Mat3();
            Node._m4fTemp1 = new Mat4();
            Node._m4fTemp2 = new Mat4();
            Node._q4fTemp1 = new Quat4();
            return Node;
        })(akra.util.Entity);
        scene.Node = Node;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
/// <reference path="../idl/IEngine.ts" />
/// <reference path="../idl/IScene3d.ts" />
/// <reference path="../idl/ISceneNode.ts" />
/// <reference path="../idl/IAnimationController.ts" />
var akra;
(function (akra) {
    /// <reference path="../bf/bf.ts" />
    /// <reference path="../math/math.ts" />
    /// <reference path="Node.ts" />
    (function (scene) {
        var Mat4 = akra.math.Mat4;
        var Mat3 = akra.math.Mat3;
        var Vec3 = akra.math.Vec3;

        var Quat4 = akra.math.Quat4;

        var SceneNode = (function (_super) {
            __extends(SceneNode, _super);
            function SceneNode(pScene, eType) {
                if (typeof eType === "undefined") { eType = 3 /* SCENE_NODE */; }
                _super.call(this, eType);
                this._pScene = null;
                this._pAnimationControllers = null;
                this._iSceneNodeFlags = 0;

                this._pScene = pScene;
            }
            SceneNode.prototype.setupSignals = function () {
                this.frozen = this.frozen || new akra.Signal(this);
                this.hidden = this.hidden || new akra.Signal(this);

                _super.prototype.setupSignals.call(this);
            };

            SceneNode.prototype.getScene = function () {
                return this._pScene;
            };

            SceneNode.prototype.getTotalControllers = function () {
                return this._pAnimationControllers ? this._pAnimationControllers.length : 0;
            };

            SceneNode.prototype.getController = function (i) {
                if (typeof i === "undefined") { i = 0; }
                return akra.isNull(this._pAnimationControllers) || this._pAnimationControllers.length <= i ? null : this._pAnimationControllers[i];
            };

            SceneNode.prototype.addController = function (pController) {
                if (akra.isNull(this._pAnimationControllers)) {
                    this._pAnimationControllers = [];
                }

                if (this._pAnimationControllers.indexOf(pController) != -1) {
                    return;
                }

                pController.attach(this);
                this._pAnimationControllers.push(pController);
            };

            SceneNode.prototype.isFrozen = function () {
                return akra.bf.testAny(this._iSceneNodeFlags, (akra.bf.flag(1 /* FROZEN_SELF */) | akra.bf.flag(0 /* FROZEN_PARENT */)));
            };

            SceneNode.prototype.isSelfFrozen = function () {
                return akra.bf.testBit(this._iSceneNodeFlags, 1 /* FROZEN_SELF */);
            };

            SceneNode.prototype.isParentFrozen = function () {
                return akra.bf.testBit(this._iSceneNodeFlags, 0 /* FROZEN_PARENT */);
            };

            SceneNode.prototype.freeze = function (bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                this._iSceneNodeFlags = akra.bf.setBit(this._iSceneNodeFlags, 1 /* FROZEN_SELF */, bValue);
                this.frozen.emit(bValue);
            };

            SceneNode.prototype.isHidden = function () {
                return akra.bf.testAny(this._iSceneNodeFlags, (akra.bf.flag(3 /* HIDDEN_SELF */) | akra.bf.flag(2 /* HIDDEN_PARENT */)));
            };

            SceneNode.prototype.hide = function (bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                this._iSceneNodeFlags = akra.bf.setBit(this._iSceneNodeFlags, 3 /* HIDDEN_SELF */, bValue);
                this.hidden.emit(bValue);
            };

            SceneNode.prototype._parentFrozen = function (pParent, bValue) {
                this._iSceneNodeFlags = akra.bf.setBit(this._iSceneNodeFlags, 0 /* FROZEN_PARENT */, bValue);
            };

            SceneNode.prototype._parentHidden = function (pParent, bValue) {
                this._iSceneNodeFlags = akra.bf.setBit(this._iSceneNodeFlags, 2 /* HIDDEN_PARENT */, bValue);
            };

            SceneNode.prototype.create = function () {
                _super.prototype.create.call(this);

                this._m4fLocalMatrix = new Mat4(1);
                this._m4fWorldMatrix = new Mat4(1);
                this._m4fInverseWorldMatrix = new Mat4(1);
                this._m3fNormalMatrix = new Mat3(1);

                this._v3fWorldPosition = new Vec3();

                this._v3fTranslation = new Vec3(0);
                this._v3fScale = new Vec3(1);
                this._qRotation = new Quat4(0, 1);

                return true;
            };

            SceneNode.prototype.update = function () {
                var isOk = _super.prototype.update.call(this);

                if (!akra.isNull(this._pAnimationControllers)) {
                    for (var i = 0; i < this._pAnimationControllers.length; ++i) {
                        this._pAnimationControllers[i].update();
                    }
                }

                return isOk;
            };

            SceneNode.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
            };

            SceneNode.prototype.attachToParent = function (pParent) {
                if (pParent.getScene() !== this._pScene) {
                    akra.logger.warn("transfer of the scene node between trees scene - forbidden");
                    return false;
                }

                if (_super.prototype.attachToParent.call(this, pParent)) {
                    if (!akra.isNull(this.getParent())) {
                        this.getParent().frozen.connect(this, this._parentFrozen);

                        //this.connect(this.parent, SIGNAL(frozen), SLOT(_parentFrozen));
                        this.getParent().hidden.connect(this, this._parentHidden);
                        //this.connect(this.parent, SIGNAL(hidden), SLOT(_parentHidden));
                    }

                    return true;
                }

                return false;
            };

            SceneNode.prototype.detachFromParent = function () {
                if (_super.prototype.detachFromParent.call(this)) {
                    if (!akra.isNull(this.getParent())) {
                        this.getParent().frozen.disconnect(this, this._parentFrozen);

                        //this.disconnect(this.parent, SIGNAL(frozen), SLOT(_parentFrozen));
                        this.getParent().hidden.disconnect(this, this._parentHidden);
                        //this.disconnect(this.parent, SIGNAL(hidden), SLOT(_parentHidden));
                    }
                    return true;
                }

                return false;
            };

            SceneNode.prototype.toString = function (isRecursive, iDepth) {
                if (typeof isRecursive === "undefined") { isRecursive = false; }
                if (typeof iDepth === "undefined") { iDepth = 0; }
                if (!isRecursive) {
                    return "<scene_node" + (this.getName() ? " " + this.getName() : "") + ">";
                }

                return _super.prototype.toString.call(this, isRecursive, iDepth);
            };
            return SceneNode;
        })(scene.Node);
        scene.SceneNode = SceneNode;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
/// <reference path="../idl/IJoint.ts" />
/// <reference path="../idl/IEngine.ts" />
var akra;
(function (akra) {
    /// <reference path="../math/math.ts" />
    /// <reference path="SceneNode.ts" />
    (function (scene) {
        var Joint = (function (_super) {
            __extends(Joint, _super);
            // private _iUpdated: int = 0;
            // private _pEngine: IEngine = null;
            function Joint(pScene) {
                _super.call(this, pScene, 2 /* JOINT */);
                this._sBone = null;
            }
            Joint.prototype.getBoneName = function () {
                return this._sBone;
            };

            Joint.prototype.setBoneName = function (sBone) {
                this._sBone = sBone;
            };

            // getEngine(): IEngine {
            // 	return this._pEngine;
            // }
            Joint.prototype.create = function () {
                var isOk = _super.prototype.create.call(this);

                //maybe custom
                this.setInheritance(4 /* ALL */);
                return isOk;
            };

            Joint.prototype.toString = function (isRecursive, iDepth) {
                if (typeof isRecursive === "undefined") { isRecursive = false; }
                if (typeof iDepth === "undefined") { iDepth = 0; }
                isRecursive = isRecursive || false;

                if (!isRecursive) {
                    return "<joint" + (this._sName ? (' ' + this._sName) : "") + ">";
                }

                return scene.Node.prototype.toString.call(this, isRecursive, iDepth);
            };

            Joint.isJoint = function (pEntity) {
                return pEntity.getType() === 2 /* JOINT */;
            };
            return Joint;
        })(scene.SceneNode);
        scene.Joint = Joint;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
/// <reference path="../idl/IAnimationBase.ts" />
/// <reference path="../idl/ISceneNode.ts" />
/// <reference path="../idl/IPositionFrame.ts" />
/// <reference path="../idl/IAnimationTrack.ts" />
var akra;
(function (akra) {
    /// <reference path="../config/config.ts" />
    /// <reference path="../events.ts" />
    /// <reference path="../scene/Joint.ts" />
    (function (animation) {
        var Joint = akra.scene.Joint;

        var Base = (function () {
            function Base(eType, sName) {
                if (typeof sName === "undefined") { sName = null; }
                this.guid = akra.guid();
                this._pTargetMap = {};
                this._pTargetList = [];
                this._fDuration = 0.0;
                //first ever frame time of all targets
                this._fFirst = akra.MAX_UINT32;
                this.extra = null;
                this.setupSignals();

                this._sName = sName || ("animation-" + "-" + this.guid);
                this._eType = eType;
            }
            Base.prototype.setupSignals = function () {
                this.played = this.played || new akra.Signal(this);
                this.stoped = this.stoped || new akra.Signal(this);
                this.renamed = this.renamed || new akra.Signal(this);
            };

            Base.prototype.getType = function () {
                return this._eType;
            };

            Base.prototype.getDuration = function () {
                return this._fDuration;
            };

            Base.prototype.getFirst = function () {
                return this._fFirst;
            };

            Base.prototype.setDuration = function (fValue) {
                // LOG("new duration(", this.name, ") > " + fValue);
                this._fDuration = fValue;
            };

            Base.prototype.getName = function () {
                return this._sName;
            };

            Base.prototype.setName = function (sName) {
                if (sName == this._sName) {
                    return;
                }

                this._sName = sName;
                this.renamed.emit(sName);
            };

            Base.prototype.play = function (fRealTime) {
                this.played.emit(fRealTime);
            };

            Base.prototype.stop = function (fRealTime) {
                this.stoped.emit(fRealTime);
            };

            Base.prototype.isAttached = function () {
                if (this._pTargetList.length) {
                    return akra.isDefAndNotNull(this._pTargetList[0].target);
                }

                return false;
            };

            Base.prototype.attach = function (pTarget) {
                akra.debug.error("method AnimationBase::attach() must be overwritten.");
            };

            Base.prototype.frame = function (sName, fRealTime) {
                return null;
            };

            Base.prototype.apply = function (fRealTime) {
                var pTargetList = this._pTargetList;
                var pTarget = null;
                var pFrame = null;
                var pTransform = null;
                var bAffected = false;

                for (var i = 0; i < pTargetList.length; ++i) {
                    pFrame = this.frame(pTargetList[i].name, fRealTime);
                    pTarget = pTargetList[i].target;

                    if (!pFrame || !pTarget) {
                        continue;
                    }

                    pTransform = pFrame.toMatrix();
                    pTarget.setLocalMatrix(pTransform);
                    bAffected = true;
                }

                // console.log(bAffected);
                return bAffected;
            };

            Base.prototype.addTarget = function (sName, pTarget) {
                //pTarget = pTarget || null;
                if (typeof pTarget === "undefined") { pTarget = null; }
                var pPointer = this._pTargetMap[sName];

                if (pPointer) {
                    pPointer.target = pTarget || pPointer.target || null;
                    return pPointer;
                }

                pPointer = {
                    target: pTarget,
                    index: this._pTargetList.length,
                    name: sName
                };

                this._pTargetList.push(pPointer);
                this._pTargetMap[sName] = pPointer;

                return pPointer;
            };

            Base.prototype.setTarget = function (sName, pTarget) {
                var pPointer = this._pTargetMap[sName];
                pPointer.target = pTarget;
                return pPointer;
            };

            Base.prototype.getTarget = function (sTargetName) {
                return this._pTargetMap[sTargetName];
            };

            Base.prototype.getTargetList = function () {
                return this._pTargetList;
            };

            Base.prototype.getTargetByName = function (sName) {
                return this._pTargetMap[sName];
            };

            Base.prototype.targetNames = function () {
                var pTargets = this._pTargetList;
                var pTargetNames = [];

                for (var i = 0; i < pTargets.length; ++i) {
                    pTargetNames.push(pTargets[i].name);
                }

                return pTargetNames;
            };

            Base.prototype.targetList = function () {
                var pTargets = this._pTargetList;
                var pTargetList = [];

                for (var i = 0; i < pTargets.length; ++i) {
                    pTargetList.push(pTargets[i].target);
                }

                return pTargetList;
            };

            Base.prototype.jointList = function () {
                var pTargets = this._pTargetList;
                var pJointList = [];

                for (var i = 0; i < pTargets.length; ++i) {
                    if (Joint.isJoint(pTargets[i].target)) {
                        pJointList.push(pTargets[i].target);
                    }
                }

                return pJointList;
            };

            Base.prototype.grab = function (pAnimationBase, bRewrite) {
                if (typeof bRewrite === "undefined") { bRewrite = true; }
                var pAdoptTargets = pAnimationBase.getTargetList();

                for (var i = 0; i < pAdoptTargets.length; ++i) {
                    if (!pAdoptTargets[i].target) {
                        continue;
                    }

                    if (bRewrite || !this.getTarget(pAdoptTargets[i].name)) {
                        this.addTarget(pAdoptTargets[i].name, pAdoptTargets[i].target);
                    }
                }

                this._fFirst = akra.math.min(this.getFirst(), pAnimationBase.getFirst());
            };

            Base.prototype.createAnimationMask = function () {
                var pTargets = this.targetNames();
                var pMask = {};

                for (var i = 0; i < pTargets.length; ++i) {
                    pMask[pTargets[i]] = 1.0;
                }

                return pMask;
            };

            Base.prototype.toString = function () {
                if (akra.config.DEBUG) {
                    var s = "\n";
                    s += "name         : " + this.getName() + "\n";
                    s += "duration     : " + this.getDuration() + " sec\n";
                    s += "total targets: " + this.targetList().length.toString() + "\n";
                    return s;
                }

                return null;
            };
            return Base;
        })();
        animation.Base = Base;
    })(akra.animation || (akra.animation = {}));
    var animation = akra.animation;
})(akra || (akra = {}));
/// <reference path="../idl/IAnimation.ts" />
/// <reference path="../idl/ISceneNode.ts" />
/// <reference path="../idl/IPositionFrame.ts" />
/// <reference path="../idl/IAnimationTrack.ts" />
var akra;
(function (akra) {
    /// <reference path="../debug.ts" />
    /// <reference path="Base.ts" />
    (function (animation) {
        var Animation = (function (_super) {
            __extends(Animation, _super);
            function Animation(sName) {
                _super.call(this, 0 /* ANIMATION */, sName);
                this._pTracks = [];
            }
            Animation.prototype.getTotalTracks = function () {
                return this._pTracks.length;
            };

            Animation.prototype.push = function (pTrack) {
                this._pTracks.push(pTrack);
                this._fDuration = akra.math.max(this._fDuration, pTrack.getDuration());
                this._fFirst = akra.math.min(this.getFirst(), pTrack.getFirst());
                this.addTarget(pTrack.getTargetName());
            };

            Animation.prototype.attach = function (pTarget) {
                var pPointer;
                var pTracks = this._pTracks;

                for (var i = 0; i < pTracks.length; ++i) {
                    if (!pTracks[i].bind(pTarget)) {
                        akra.logger.log("cannot bind animation track [", i, "] to joint <", pTracks[i].getTarget(), ">");
                    } else {
                        pPointer = this.setTarget(pTracks[i].getTargetName(), pTracks[i].getTarget());
                        pPointer.track = pTracks[i];
                    }
                }
            };

            Animation.prototype.getTracks = function () {
                return this._pTracks;
            };

            Animation.prototype.getTrack = function (i) {
                return this._pTracks[i];
            };

            Animation.prototype.frame = function (sName, fTime) {
                var pPointer = this.getTargetByName(sName);

                if (!pPointer || !pPointer.track) {
                    return null;
                }

                return pPointer.track.frame(akra.math.clamp(fTime, 0, this._fDuration));
            };

            Animation.prototype.extend = function (pAnimation) {
                var pTracks = pAnimation.getTracks();

                for (var i = 0; i < pTracks.length; ++i) {
                    if (!this.getTarget(pTracks[i].getTargetName())) {
                        this.push(pTracks[i]);
                    }
                }
            };

            Animation.prototype.toString = function () {
                if (akra.config.DEBUG) {
                    var s = _super.prototype.toString.call(this);
                    s += "total tracks : " + this.getTotalTracks() + "\n";

                    for (var i = 0; i < this.getTotalTracks(); ++i) {
                        s += "\t" + i + ". " + this.getTrack(i) + "\n";
                    }

                    return s;
                }

                return null;
            };

            Animation.isAnimation = function (pAnimation) {
                return pAnimation.getType() === 0 /* ANIMATION */;
            };
            return Animation;
        })(animation.Base);
        animation.Animation = Animation;

        function createAnimation(sName) {
            return new Animation(sName);
        }
        animation.createAnimation = createAnimation;
    })(akra.animation || (akra.animation = {}));
    var animation = akra.animation;
})(akra || (akra = {}));
/// <reference path="../idl/IAnimationBlend.ts" />
var akra;
(function (akra) {
    /// <reference path="Base.ts" />
    /// <reference path="Frame.ts" />
    (function (_animation) {
        var Blend = (function (_super) {
            __extends(Blend, _super);
            function Blend(sName) {
                _super.call(this, 4 /* BLEND */, sName);
                //public duration: float = 0;
                this._pAnimationList = [];
            }
            Blend.prototype.setupSignals = function () {
                this.weightUpdated = this.weightUpdated || new akra.Signal(this);
                this.durationUpdated = this.durationUpdated || new akra.Signal(this);

                _super.prototype.setupSignals.call(this);
            };

            Blend.prototype.getTotalAnimations = function () {
                return this._pAnimationList.length;
            };

            Blend.prototype.play = function (fRealTime) {
                var pAnimationList = this._pAnimationList;
                var n = pAnimationList.length;

                for (var i = 0; i < n; ++i) {
                    pAnimationList[i].realTime = fRealTime;
                    pAnimationList[i].time = fRealTime * pAnimationList[i].acceleration;
                }

                this.played.emit(fRealTime);
            };

            Blend.prototype.stop = function () {
                this.stoped.emit(0.);
            };

            Blend.prototype.attach = function (pTarget) {
                var pAnimationList = this._pAnimationList;

                for (var i = 0; i < pAnimationList.length; ++i) {
                    var pAnim = pAnimationList[i].animation;
                    pAnim.attach(pTarget);
                    this.grab(pAnim, true);
                }
            };

            Blend.prototype.addAnimation = function (pAnimation, fWeight, pMask) {
                akra.debug.assert(akra.isDef(pAnimation), 'animation must be setted.');

                this._pAnimationList.push(null);
                var iAnimation = this._pAnimationList.length - 1;

                if (this.setAnimation(iAnimation, pAnimation, fWeight, pMask)) {
                    return iAnimation;
                }

                return -1;
            };

            Blend.prototype.setAnimation = function (iAnimation, pAnimation, fWeight, pMask) {
                if (typeof fWeight === "undefined") { fWeight = 1.0; }
                if (typeof pMask === "undefined") { pMask = null; }
                akra.debug.assert(iAnimation <= this._pAnimationList.length, 'invalid animation slot: ' + iAnimation + '/' + this._pAnimationList.length);

                var pPointer = this._pAnimationList[iAnimation];
                var pAnimationList = this._pAnimationList;

                if (!pAnimation) {
                    if (akra.isDefAndNotNull(pAnimationList[iAnimation])) {
                        pAnimationList[iAnimation] = null;
                        this.updateDuration();
                        return true;
                    }

                    return false;
                }

                if (!pPointer) {
                    pPointer = {
                        animation: pAnimation,
                        weight: fWeight,
                        mask: pMask,
                        acceleration: 1.0,
                        time: 0.0,
                        realTime: 0.0
                    };

                    if (_animation.Container.isContainer(pAnimation) || Blend.isBlend(pAnimation)) {
                        pAnimation.durationUpdated.connect(this, this._onDurationUpdate);
                    }

                    if (iAnimation == this._pAnimationList.length) {
                        pAnimationList.push(pPointer);
                    } else {
                        pAnimationList[iAnimation] = pPointer;
                    }
                } else {
                    return false;
                }

                this.grab(pAnimation);
                this.updateDuration();

                return true;
            };

            Blend.prototype.swapAnimations = function (i, j) {
                var pAnimationList = this._pAnimationList;
                var pPointerA = pAnimationList[i];
                var pPointerB = pAnimationList[j];

                if (!akra.isDefAndNotNull(pPointerA) || !akra.isDefAndNotNull(pPointerB)) {
                    return false;
                }

                pAnimationList[i] = pPointerB;
                pAnimationList[j] = pPointerA;

                return true;
            };

            Blend.prototype.removeAnimation = function (i) {
                if (this.setAnimation(i, null)) {
                    this._pAnimationList.splice(i, 1);
                    return true;
                }

                return false;
            };

            Blend.prototype._onDurationUpdate = function (pAnimation, fDuration) {
                this.updateDuration();
            };

            Blend.prototype.updateDuration = function () {
                var fWeight = 0;
                var fSumm = 0;
                var pAnimationList = this._pAnimationList;
                var n = pAnimationList.length;

                for (var i = 0; i < n; ++i) {
                    if (pAnimationList[i] === null) {
                        continue;
                    }

                    fSumm += pAnimationList[i].weight * pAnimationList[i].animation.getDuration();
                    fWeight += pAnimationList[i].weight;
                }

                if (fWeight === 0) {
                    this.setDuration(0);
                } else {
                    this.setDuration(fSumm / fWeight);

                    for (var i = 0; i < n; ++i) {
                        if (pAnimationList[i] === null) {
                            continue;
                        }

                        akra.debug.assert(!!this.getDuration(), "invalid duration used for acceleration calculation");
                        pAnimationList[i].acceleration = pAnimationList[i].animation.getDuration() / this.getDuration();
                    }
                }

                this.durationUpdated.emit(this.getDuration());
            };

            Blend.prototype.getAnimationIndex = function (sName) {
                var pAnimationList = this._pAnimationList;

                for (var i = 0; i < pAnimationList.length; i++) {
                    if (pAnimationList[i].animation.getName() === sName) {
                        return i;
                    }
                }
                ;

                return -1;
            };

            Blend.prototype.getAnimation = function (indexOrName) {
                var iAnimation = akra.isString(indexOrName) ? this.getAnimationIndex(indexOrName) : indexOrName;
                return this._pAnimationList[iAnimation].animation;
            };

            Blend.prototype.getAnimationWeight = function (indexOrName) {
                var iAnimation = indexOrName;
                if (akra.isString(indexOrName)) {
                    iAnimation = this.getAnimationIndex(indexOrName);
                }

                return this._pAnimationList[iAnimation].weight;
            };

            Blend.prototype.setWeights = function () {
                var pWeight = [];
                for (var _i = 0; _i < (arguments.length - 0); _i++) {
                    pWeight[_i] = arguments[_i + 0];
                }
                var fWeight;
                var isModified = false;
                var pAnimationList = this._pAnimationList;

                for (var i = 0; i < arguments.length; ++i) {
                    fWeight = arguments[i];

                    if (fWeight < 0 || fWeight === null || !pAnimationList[i]) {
                        continue;
                    }

                    if (pAnimationList[i].weight !== fWeight) {
                        pAnimationList[i].weight = fWeight;
                        isModified = true;
                    }
                }

                if (isModified) {
                    this.updateDuration();
                }

                return true;
            };

            Blend.prototype.setWeightSwitching = function (fWeight, iAnimationFrom, iAnimationTo) {
                var pAnimationList = this._pAnimationList;
                var isModified = false;
                var fWeightInv = 1. - fWeight;

                if (!pAnimationList[iAnimationFrom] || !pAnimationList[iAnimationTo]) {
                    return false;
                }

                if (pAnimationList[iAnimationFrom].weight !== fWeightInv) {
                    pAnimationList[iAnimationFrom].weight = fWeightInv;
                    isModified = true;
                }

                if (pAnimationList[iAnimationTo].weight !== fWeight) {
                    pAnimationList[iAnimationTo].weight = fWeight;
                    isModified = true;
                }

                if (isModified) {
                    this.updateDuration();
                }

                return true;
            };

            Blend.prototype.setAnimationWeight = function (indexOrNameOrWeight, fWeight) {
                var pAnimationList = this._pAnimationList;

                if (arguments.length === 1) {
                    fWeight = arguments[0];

                    for (var i = 0; i < pAnimationList.length; i++) {
                        pAnimationList[i].weight = fWeight;
                        this.weightUpdated.emit(i, fWeight);
                    }

                    this.updateDuration();
                } else {
                    var iAnimation = akra.isString(indexOrNameOrWeight) ? this.getAnimationIndex(indexOrNameOrWeight) : indexOrNameOrWeight;

                    //trace('set weight for animation: ', iAnimation, 'to ', fWeight);
                    if (pAnimationList[iAnimation].weight !== fWeight) {
                        pAnimationList[iAnimation].weight = fWeight;
                        this.updateDuration();
                        this.weightUpdated.emit(iAnimation, fWeight);
                    }
                }

                return true;
            };

            Blend.prototype.setAnimationMask = function (indexOrName, pMask) {
                var iAnimation = akra.isString(indexOrName) ? this.getAnimationIndex(indexOrName) : indexOrName;

                this._pAnimationList[iAnimation].mask = pMask;

                return true;
            };

            Blend.prototype.getAnimationMask = function (indexOrName) {
                var iAnimation = akra.isString(indexOrName) ? this.getAnimationIndex(indexOrName) : indexOrName;

                return this._pAnimationList[iAnimation].mask;
            };

            Blend.prototype.getAnimationAcceleration = function (indexOrName) {
                var iAnimation = akra.isString(indexOrName) ? this.getAnimationIndex(indexOrName) : indexOrName;

                return this._pAnimationList[iAnimation].acceleration;
            };

            Blend.prototype.createAnimationMask = function (iAnimation) {
                if (arguments.length === 0) {
                    return _super.prototype.createAnimationMask.call(this);
                }

                if (typeof arguments[0] === 'string') {
                    iAnimation = this.getAnimationIndex(arguments[0]);
                }

                var pAnimation = this._pAnimationList[iAnimation].animation;
                return pAnimation.createAnimationMask();
            };

            Blend.prototype.frame = function (sName, fRealTime) {
                var pAnimationList = this._pAnimationList;
                var pResultFrame = _animation.PositionFrame.temp();
                var pFrame;
                var pMask;
                var pPointer;
                var fAcceleration;

                var fBoneWeight;
                var fWeight;
                var iAnim = 0;

                for (var i = 0; i < pAnimationList.length; i++) {
                    pPointer = pAnimationList[i];

                    if (!pPointer) {
                        continue;
                    }

                    fAcceleration = pPointer.acceleration;

                    akra.debug.assert(!isNaN(fAcceleration) && akra.isDef(fAcceleration), "invalid acceleration");

                    pMask = pPointer.mask;
                    fBoneWeight = 1.0;

                    //для того чтобы циклы используемые выше работали корректно
                    if (fRealTime < pPointer.realTime) {
                        pPointer.time = 0;
                        pPointer.realTime = 0;
                    }

                    pPointer.time = pPointer.time + (fRealTime - pPointer.realTime) * fAcceleration;
                    pPointer.realTime = fRealTime;

                    akra.debug.assert(!isNaN(pPointer.time), "invalid time");

                    if (pMask) {
                        fBoneWeight = akra.isDef(pMask[sName]) ? pMask[sName] : 1.0;
                    }

                    fWeight = fBoneWeight * pPointer.weight;

                    if (fWeight > 0.0) {
                        pFrame = pPointer.animation.frame(sName, pPointer.time);

                        if (pFrame) {
                            iAnim++;

                            //first, if 1
                            pResultFrame.add(pFrame.mult(fWeight), iAnim === 1);
                        }
                    }
                }

                if (pResultFrame.weight === 0.0) {
                    return null;
                }

                return pResultFrame.normilize();
            };

            Blend.prototype.toString = function () {
                if (akra.config.DEBUG) {
                    var sDesc = "";

                    sDesc += ("BLEND NAME: " + this.getName()) + "\n";
                    sDesc += ("\t        duration: " + this.getDuration() + "ms") + "\n";
                    sDesc += ("\ttotal animations: " + this.getTotalAnimations()) + "\n";

                    var pList = this._pAnimationList;
                    pList.forEach(function (pElement) {
                        sDesc += "\t        animation: " + pElement.animation.getName() + ", duration: " + pElement.animation.getDuration() + ", weight: " + pElement.weight.toFixed(2) + ", acceleration: " + pElement.acceleration.toFixed(2) + "\n";
                    });

                    return sDesc;
                }

                return null;
            };

            Blend.isBlend = function (pAnimation) {
                return pAnimation.getType() === 4 /* BLEND */;
            };
            return Blend;
        })(_animation.Base);
        _animation.Blend = Blend;

        function createBlend(sName) {
            return new Blend(sName);
        }
        _animation.createBlend = createBlend;
    })(akra.animation || (akra.animation = {}));
    var animation = akra.animation;
})(akra || (akra = {}));
/// <reference path="../idl/IAnimationContainer.ts" />
/// <reference path="../idl/IPositionFrame.ts" />
/// <reference path="../idl/IAnimationBase.ts" />
var akra;
(function (akra) {
    /// <reference path="Base.ts" />
    (function (animation) {
        var Container = (function (_super) {
            __extends(Container, _super);
            function Container(pAnimation, sName) {
                _super.call(this, 3 /* CONTAINER */, sName);
                this._bEnable = true;
                this._fStartTime = 0;
                this._fSpeed = 1.0;
                this._bLoop = false;
                this._pAnimation = null;
                this._bReverse = false;
                //Время учитывающее циклы и прочее.
                this._fTrueTime = 0;
                //реальное время на сцене
                this._fRealTime = 0;
                //время с учетом ускорений
                this._fTime = 0;
                this._bPause = false;
                //определена ли анимация до первого и после последнего кадров
                this._bLeftInfinity = true;
                this._bRightInfinity = true;

                if (pAnimation) {
                    this.setAnimation(pAnimation);
                }
            }
            Container.prototype.setupSignals = function () {
                this.durationUpdated = this.durationUpdated || new akra.Signal(this);
                this.enterFrame = this.enterFrame || new akra.Signal(this);

                _super.prototype.setupSignals.call(this);
            };

            Container.prototype.getAnimationName = function () {
                return this._pAnimation.getName();
            };

            Container.prototype.getAnimationTime = function () {
                return this._fTrueTime;
            };

            Container.prototype.getTime = function () {
                return this._fTime;
            };

            Container.prototype.setStartTime = function (fRealTime) {
                this._fStartTime = fRealTime;
            };

            Container.prototype.getStartTime = function () {
                return this._fStartTime;
            };

            Container.prototype.setSpeed = function (fSpeed) {
                this._fSpeed = fSpeed;
                this.setDuration(this._pAnimation.getDuration() / fSpeed);

                this.durationUpdated.emit(this.getDuration());
            };

            Container.prototype.getSpeed = function () {
                return this._fSpeed;
            };

            Container.prototype.play = function (fRealTime) {
                this._fRealTime = fRealTime;
                this._fTime = 0;

                this.played.emit(this._fTime);
            };

            Container.prototype.stop = function () {
                this.stoped.emit(this._fTime);
            };

            Container.prototype.attach = function (pTarget) {
                if (!akra.isNull(this._pAnimation)) {
                    this._pAnimation.attach(pTarget);
                    this.grab(this._pAnimation, true);
                }
            };

            Container.prototype.setAnimation = function (pAnimation) {
                akra.debug.assert(!this._pAnimation, "anim. already exists");

                this._pAnimation = pAnimation;
                this.setSpeed(this.getSpeed());

                if (Container.isContainer(pAnimation) || animation.Blend.isBlend(pAnimation)) {
                    pAnimation.durationUpdated.connect(this, this._onDurationUpdate);
                }

                this.grab(pAnimation);
            };

            Container.prototype._onDurationUpdate = function (pAnimation, fDuration) {
                this.setSpeed(this.getSpeed());
            };

            Container.prototype.getAnimation = function () {
                return this._pAnimation;
            };

            Container.prototype.enable = function () {
                this._bEnable = true;
            };

            Container.prototype.disable = function () {
                this._bEnable = false;
            };

            Container.prototype.isEnabled = function () {
                return this._bEnable;
            };

            Container.prototype.leftInfinity = function (bValue) {
                this._bLeftInfinity = bValue;
            };

            Container.prototype.inLeftInfinity = function () {
                return this._bLeftInfinity;
            };

            Container.prototype.inRightInfinity = function () {
                return this._bRightInfinity;
            };

            Container.prototype.rightInfinity = function (bValue) {
                this._bRightInfinity = bValue;
            };

            Container.prototype.useLoop = function (bValue) {
                this._bLoop = bValue;
            };

            Container.prototype.inLoop = function () {
                return this._bLoop;
            };

            Container.prototype.reverse = function (bValue) {
                this._bReverse = bValue;
            };

            Container.prototype.isReversed = function () {
                return this._bReverse;
            };

            Container.prototype.pause = function (bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                this._fRealTime = -1;
                this._bPause = bValue;
            };

            Container.prototype.rewind = function (fRealTime) {
                // console.log("rewind > ", fRealTime);
                this._fTrueTime = 0;
                this._fTime = fRealTime;
            };

            Container.prototype.isPaused = function () {
                return this._bPause;
            };

            Container.prototype.calcTime = function (fRealTime) {
                akra.debug.assert(!isNaN(fRealTime), "invalid time");

                if (this._bPause) {
                    return;
                }

                //if loop switched and prev. fRealTime less than new fRealTime
                //for ex.: prev real time calced in loop, next - real time from now()
                if (this._fRealTime < 0 || this._fRealTime > fRealTime) {
                    this._fRealTime = fRealTime;
                }

                this._fTime = this._fTime + (fRealTime - this._fRealTime) * this._fSpeed;
                this._fRealTime = fRealTime;

                var fTime = this._fTime;

                if (this._bLoop) {
                    akra.debug.assert(!!this._pAnimation.getDuration(), "invalid animation duration:\n" + this._pAnimation.toString());

                    fTime = akra.math.mod(fTime, (this._pAnimation.getDuration()));
                    if (this._bReverse) {
                        fTime = this._pAnimation.getDuration() - fTime;
                    }
                }

                this._fTrueTime = fTime;
            };

            Container.prototype.frame = function (sName, fRealTime) {
                akra.debug.assert(!isNaN(fRealTime), "invalid time");

                if (!this._bEnable) {
                    return null;
                }

                if (this._fRealTime !== fRealTime) {
                    //only for first bone in list
                    this.calcTime(fRealTime);
                    this.enterFrame.emit(fRealTime, this._fTrueTime);
                }

                if (!this._bLeftInfinity && this._fTrueTime < this.getFirst()) {
                    return null;
                }

                if (!this._bRightInfinity && this._fTrueTime > this.getDuration()) {
                    return null;
                }

                return this._pAnimation.frame(sName, this._fTrueTime);
            };

            Container.isContainer = function (pAnimation) {
                return pAnimation.getType() === 3 /* CONTAINER */;
            };
            return Container;
        })(animation.Base);
        animation.Container = Container;

        function createContainer(pAnimation, sName) {
            return new Container(pAnimation, sName);
        }
        animation.createContainer = createContainer;
    })(akra.animation || (akra.animation = {}));
    var animation = akra.animation;
})(akra || (akra = {}));
/// <reference path="../idl/IMaterial.ts" />
/// <reference path="../color/Color.ts" />
/// <reference path="../config/config.ts" />
var akra;
(function (akra) {
    (function (material) {
        var Color = akra.color.Color;

        var Material = (function () {
            function Material(sName, pMat) {
                if (typeof sName === "undefined") { sName = null; }
                if (typeof pMat === "undefined") { pMat = null; }
                this.guid = akra.guid();
                this.name = null;
                this.diffuse = new Color;
                this.ambient = new Color;
                this.specular = new Color;
                this.emissive = new Color;
                this.transparency = 1.;
                this.shininess = 1.;
                this._pMatContainer = {
                    "DIFFUSE": new akra.math.Vec4(),
                    "AMBIENT": new akra.math.Vec4(),
                    "SPECULAR": new akra.math.Vec4(),
                    "EMISSIVE": new akra.math.Vec4(),
                    "SHININESS": 1.,
                    "TRANSPARENCY": 1.
                };
                this.name = sName;
                this.set(pMat);
            }
            Material.prototype.set = function (mat) {
                if (!akra.isNull(mat)) {
                    if (akra.isString(arguments[0])) {
                        switch (arguments[0]) {
                            case "gold":
                                this.specular.set(1., 0.71, 0.29);
                                this.diffuse.set(1.00, 0.86, 0.57);
                                break;
                            case "cooper":
                                this.specular.set(0.95, 0.64, 0.54);
                                this.diffuse.set(0.98, 0.82, 0.76);
                                break;
                            case "plastic":
                                this.specular.set(0.03);
                                this.diffuse.set(0.21);
                                break;
                            case "iron":
                                this.specular.set(0.56, 0.57, 0.58);
                                this.diffuse.set(0.77, 0.78, 0.78);
                                break;
                            case "aluminium":
                                this.specular.set(0.91, 0.92, 0.92);
                                this.diffuse.set(0.96, 0.96, 0.97);
                                break;
                            case "silver":
                                this.specular.set(0.95, 0.93, 0.88);
                                this.diffuse.set(10.98, 0.97, 0.95);
                                break;
                            case "water":
                                this.specular.set(0.02);
                                this.diffuse.set(0.15);
                                break;
                            case "glass":
                                this.specular.set(0.08);
                                this.diffuse.set(0.31);
                                break;
                            default:
                                akra.logger.error("unknonw material: " + arguments[0]);
                        }
                    } else {
                        this.diffuse.set(mat.diffuse);
                        this.ambient.set(mat.ambient);
                        this.specular.set(mat.specular);
                        this.emissive.set(mat.emissive);
                        this.shininess = mat.shininess;
                        this.transparency = mat.transparency;
                    }
                }

                return this;
            };

            Material.prototype.isEqual = function (pMat) {
                return Color.isEqual(this.diffuse, pMat.diffuse) && Color.isEqual(this.ambient, pMat.ambient) && Color.isEqual(this.specular, pMat.specular) && Color.isEqual(this.emissive, pMat.emissive) && this.shininess === pMat.shininess && this.transparency === pMat.transparency;
            };

            Material.prototype.isTransparent = function () {
                return this.transparency < 1.;
            };

            Material.prototype.toString = function () {
                if (akra.config.DEBUG) {
                    var s = "\nMATERIAL - " + this.name + "\n";

                    s += "------------------------------------\n";
                    s += "diffuse:      " + this.diffuse.toString() + "\n";
                    s += "ambient:      " + this.ambient.toString() + "\n";
                    s += "specular:     " + this.ambient.toString() + "\n";
                    s += "emissive:     " + this.emissive.toString() + "\n";
                    s += "shininess:    " + this.shininess + "\n";
                    s += "transparency: " + this.transparency + "\n";

                    return s;
                }

                return null;
            };

            Material.prototype._getMatContainer = function () {
                return this._pMatContainer;
            };
            return Material;
        })();
        material.Material = Material;
    })(akra.material || (akra.material = {}));
    var material = akra.material;
})(akra || (akra = {}));
/// <reference path="../config/config.ts" />
var akra;
(function (akra) {
    /// <reference path="Material.ts" />
    (function (material) {
        function create(sName, pMat) {
            if (typeof sName === "undefined") { sName = akra.config.material.name; }
            if (typeof pMat === "undefined") { pMat = (akra.config.material.default); }
            return new material.Material(sName, pMat);
        }
        material.create = create;
    })(akra.material || (akra.material = {}));
    var material = akra.material;
})(akra || (akra = {}));
/// <reference path="../idl/IDocument.ts" />
/// <reference path="../idl/IMap.ts" />
/// <reference path="../idl/IAnimationContainer.ts" />
/// <reference path="../idl/IAnimationBlend.ts" />
var akra;
(function (akra) {
    /// <reference path="../logger.ts" />
    /// <reference path="../debug.ts" />
    /// <reference path="../conv/conv.ts" />
    /// <reference path="../math/math.ts" />
    /// <reference path="../io/io.ts" />
    /// <reference path="../animation/Frame.ts" />
    /// <reference path="../animation/Track.ts" />
    /// <reference path="../animation/Animation.ts" />
    /// <reference path="../animation/Blend.ts" />
    /// <reference path="../animation/Container.ts" />
    /// <reference path="../material/materials.ts" />
    (function (exchange) {
        var Mat4 = akra.math.Mat4;

        var Importer = (function () {
            function Importer(_pEngine) {
                this._pEngine = _pEngine;
                this._pDocument = null;
                this._pLibrary = {};
            }
            Importer.prototype.getEngine = function () {
                return this._pEngine;
            };

            Importer.prototype.getDocument = function () {
                return this._pDocument;
            };

            Importer.prototype.getLibrary = function () {
                return this._pLibrary;
            };

            Importer.prototype.clear = function () {
                this._pDocument = null;
                this._pLibrary = {};
            };

            Importer.prototype.import = function (pData, eFormat) {
                if (typeof eFormat === "undefined") { eFormat = 0 /* JSON */; }
                if (eFormat !== 0 /* JSON */ && eFormat !== 1 /* BINARY_JSON */) {
                    akra.logger.critical("TODO: Add support for all formats");
                }

                if (eFormat === 0 /* JSON */) {
                    this.loadDocument(this.importFromJSON(pData));
                } else if (eFormat === 1 /* BINARY_JSON */) {
                    this.loadDocument(this.importFromBinaryJSON(pData));
                }

                return this;
            };

            Importer.prototype.loadDocument = function (pDocument) {
                this._pDocument = pDocument;
                this.updateLibrary();
                return this;
            };

            Importer.prototype.importFromBinaryJSON = function (pData) {
                return akra.io.undump(pData);
            };

            Importer.prototype.importFromJSON = function (pData) {
                var sData = null;

                if (akra.isArrayBuffer(pData)) {
                    sData = akra.conv.abtos(pData);
                } else if (akra.isString(pData)) {
                    sData = pData;
                } else if (akra.isBlob(pData)) {
                    akra.logger.critical("TODO: Blob support!");
                } else {
                    return pData;
                }

                return JSON.parse(sData);
            };

            Importer.prototype.updateLibrary = function () {
                var pDocument = this.getDocument();
                var pLibrary = this.getLibrary();

                for (var i = 0; i < pDocument.library.length; ++i) {
                    var pEntry = pDocument.library[i];
                    var iGuid = pEntry.guid;

                    pLibrary[iGuid] = { guid: iGuid, data: null, entry: pEntry };
                }
                ;
            };

            Importer.prototype.findEntries = function (eType, fnCallback) {
                var pLibrary = this.getLibrary();
                var i = 0;

                for (var iGuid in pLibrary) {
                    var pEntry = pLibrary[iGuid];

                    if (!akra.isNull(pEntry.entry) && pEntry.entry.type === eType) {
                        if (fnCallback.call(this, pEntry, i++) === false) {
                            return;
                        }
                    }
                }
            };

            Importer.prototype.findEntryByIndex = function (eType, i) {
                var pEntry = null;
                this.findEntries(eType, function (pLibEntry, n) {
                    pEntry = pLibEntry;

                    if (i === n) {
                        return false;
                    }
                });

                return pEntry;
            };

            Importer.prototype.find = function (eType, fnCallback) {
                var _this = this;
                this.findEntries(eType, function (pEntry, n) {
                    if (fnCallback.call(_this, pEntry.data, n) === false) {
                        return;
                    }
                });
            };

            Importer.prototype.findByIndex = function (eType, i) {
                if (typeof i === "undefined") { i = 0; }
                return this.findEntryByIndex(eType, i).data;
            };

            Importer.prototype.findFirst = function (eType) {
                return this.findByIndex(eType, 0);
            };

            Importer.prototype.getController = function (iContrller) {
                if (typeof iContrller === "undefined") { iContrller = 0; }
                return this.decodeEntry(this.findEntryByIndex(2 /* k_Controller */, iContrller).entry);
            };

            Importer.prototype.getMaterials = function () {
                var _this = this;
                var pMaterials = {};

                this.findEntries(7 /* k_Material */, function (pEntry) {
                    var pMat = _this.decodeEntry(pEntry.entry);
                    akra.debug.assert(!akra.isDefAndNotNull(pMaterials[pMat.name]), "material already exists");
                    pMaterials[pMat.name] = pMat;
                    return true;
                });

                return pMaterials;
            };

            Importer.prototype.decodeEntry = function (pEntry) {
                if (akra.isNull(pEntry)) {
                    return null;
                }

                var pData = this.getLibrary()[pEntry.guid].data;

                if (!akra.isNull(pData)) {
                    return pData;
                }

                switch (pEntry.type) {
                    case 2 /* k_Controller */:
                        pData = this.decodeControllerEntry(pEntry);
                        break;
                    case 3 /* k_Animation */:
                        pData = this.decodeAnimationEntry(pEntry);
                        break;
                    case 4 /* k_AnimationBlend */:
                        pData = this.decodeAnimationBlendEntry(pEntry);
                        break;
                    case 5 /* k_AnimationContainer */:
                        pData = this.decodeAnimationContainerEntry(pEntry);
                        break;

                    case 7 /* k_Material */:
                        pData = this.decodeMaterialEntry(pEntry);
                        break;
                }

                if (!akra.isNull(pData)) {
                    this.registerData(pEntry.guid, pData);
                    return pData;
                }

                akra.logger.warn("USED UNKNOWN TYPE FOR DECODING!!", pEntry.type);
                return null;
            };

            Importer.prototype.registerData = function (iGuid, pData) {
                var pLibEntry = this.getLibrary()[iGuid];
                pLibEntry.data = pData;
            };

            Importer.prototype.decodeInstance = function (iGuid) {
                var pLibEntry = this.getLibrary()[iGuid];

                if (!akra.isNull(pLibEntry.data)) {
                    return pLibEntry.data;
                }

                return this.decodeEntry(pLibEntry.entry);
            };

            Importer.prototype.decodeEntryList = function (pEntryList, fnCallback) {
                if (akra.isNull(pEntryList)) {
                    return;
                }

                for (var i = 0; i < pEntryList.length; ++i) {
                    fnCallback.call(this, this.decodeEntry(pEntryList[i]));
                }
            };

            Importer.prototype.decodeInstanceList = function (pInstances, fnCallback) {
                for (var i = 0; i < pInstances.length; ++i) {
                    fnCallback.call(this, this.decodeInstance(pInstances[i]), i);
                }
            };

            Importer.prototype.decodeMaterialEntry = function (pEntry) {
                var pMaterial = akra.material.create();

                pMaterial.name = pEntry.name;
                pMaterial.transparency = pEntry.transparency;
                pMaterial.shininess = pEntry.shininess;

                this.decodeColorEntry(pEntry.diffuse, pMaterial.diffuse);
                this.decodeColorEntry(pEntry.specular, pMaterial.specular);
                this.decodeColorEntry(pEntry.emissive, pMaterial.emissive);

                return pMaterial;
            };

            Importer.prototype.decodeColorEntry = function (pEntry, pDest) {
                if (typeof pDest === "undefined") { pDest = new akra.color.Color; }
                return pDest.set(pEntry[0], pEntry[1], pEntry[2], pEntry[3]);
            };

            Importer.prototype.decodeAnimationFrame = function (pEntry) {
                var pFrame = new akra.animation.PositionFrame(pEntry.time, new Mat4(pEntry.matrix), pEntry.weight);

                //FIXME: avoid capability problems
                pFrame.type = akra.isInt(pEntry.type) ? pEntry.type : 1 /* SPHERICAL */;
                return pFrame;
            };

            Importer.prototype.decodeAnimationTrack = function (pEntry) {
                var pTrack = akra.animation.createTrack(pEntry.targetName);

                for (var i = 0; i < pEntry.keyframes.length; ++i) {
                    pTrack.keyFrame(this.decodeAnimationFrame(pEntry.keyframes[i]));
                }
                ;

                return pTrack;
            };

            Importer.prototype.decodeAnimationEntry = function (pEntry) {
                var pAnimation = akra.animation.createAnimation(pEntry.name);

                pAnimation.extra = pEntry.extra;

                for (var i = 0; i < pEntry.tracks.length; ++i) {
                    pAnimation.push(this.decodeAnimationTrack(pEntry.tracks[i]));
                }
                ;

                return pAnimation;
            };

            Importer.prototype.decodeAnimationBlendEntry = function (pEntry) {
                var pBlend = akra.animation.createBlend(pEntry.name);

                pBlend.extra = pEntry.extra;

                for (var i = 0; i < pEntry.animations.length; ++i) {
                    var pElement = pEntry.animations[i];

                    var pAnimation = this.decodeInstance(pElement.animation);
                    var fWeight = pElement.weight;
                    var pMask = pElement.mask;

                    // var fAcceleration: float = pEntry.acceleration;
                    pBlend.setAnimation(i, pAnimation);
                    pBlend.setAnimationWeight(i, fWeight);
                    pBlend.setAnimationMask(i, pMask);
                }
                ;

                return pBlend;
            };

            Importer.prototype.decodeAnimationContainerEntry = function (pEntry) {
                var pAnimation = this.decodeInstance(pEntry.animation);
                var pContainer = akra.animation.createContainer(pAnimation, pEntry.name);

                pContainer.extra = pEntry.extra;

                //TODO: decode base entry!
                //TODO: set targets
                if (!pEntry.enable) {
                    pContainer.disable();
                }

                pContainer.setStartTime(pEntry.startTime);
                pContainer.setSpeed(pEntry.speed);
                pContainer.useLoop(pEntry.loop);
                pContainer.reverse(pEntry.reverse);
                pContainer.pause(pEntry.pause);
                pContainer.leftInfinity(pEntry.leftInfinity);
                pContainer.rightInfinity(pEntry.rightInfinity);

                return pContainer;
            };

            Importer.prototype.decodeControllerEntry = function (pEntry) {
                var pController = this.getEngine().createAnimationController(pEntry.name, pEntry.options);
                pController.name = pEntry.name;

                this.decodeInstanceList(pEntry.animations, function (pAnimation) {
                    pController.addAnimation(pAnimation);
                });

                return pController;
            };
            return Importer;
        })();
        exchange.Importer = Importer;
    })(akra.exchange || (akra.exchange = {}));
    var exchange = akra.exchange;
})(akra || (akra = {}));
/// <reference path="../idl/IResourceCode.ts" />
var akra;
(function (akra) {
    (function (pool) {
        var ResourceCode = (function () {
            function ResourceCode(iFamily, iType) {
                this._iValue = (4294967295 /* INVALID_CODE */);
                switch (arguments.length) {
                    case 0:
                        this._iValue = 4294967295 /* INVALID_CODE */;
                        break;
                    case 1:
                        if (arguments[0] instanceof ResourceCode) {
                            this._iValue = arguments[0].iValue;
                        } else {
                            this._iValue = arguments[0];
                        }
                        break;
                    case 2:
                        this.setFamily(arguments[0]);
                        this.setType(arguments[1]);
                        break;
                }
            }
            ResourceCode.prototype.getFamily = function () {
                return this._iValue >> 16;
            };

            ResourceCode.prototype.setFamily = function (iNewFamily) {
                this._iValue &= 0x0000FFFF;
                this._iValue |= iNewFamily << 16;
            };

            ResourceCode.prototype.getType = function () {
                return this._iValue & 0x0000FFFF;
            };

            ResourceCode.prototype.setType = function (iNewType) {
                this._iValue &= 0xFFFF0000;
                this._iValue |= iNewType & 0x0000FFFF;
            };

            ResourceCode.prototype.setInvalid = function () {
                this._iValue = 4294967295 /* INVALID_CODE */;
            };

            ResourceCode.prototype.less = function (pSrc) {
                return this._iValue < pSrc.valueOf();
            };

            ResourceCode.prototype.eq = function (pSrc) {
                this._iValue = pSrc.valueOf();
                return this;
            };

            ResourceCode.prototype.valueOf = function () {
                return this._iValue;
            };

            ResourceCode.prototype.toNumber = function () {
                return this._iValue;
            };
            return ResourceCode;
        })();
        pool.ResourceCode = ResourceCode;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="IEngine.ts" />
/// <reference path="IResourcePoolManager.ts" />
/// <reference path="../idl/IEngine.ts" />
/// <reference path="../idl/IDataPool.ts" />
/// <reference path="../idl/IResourcePoolItem.ts" />
/// <reference path="../idl/IResourcePoolManager.ts" />
var akra;
(function (akra) {
    /// <reference path="../debug.ts" />
    /// <reference path="../logger.ts" />
    /// <reference path="../limit.ts" />
    /// <reference path="../math/math.ts" />
    (function (pool) {
        var PoolGroup = (function () {
            function PoolGroup(pManager, tTemplate, iMaxCount) {
                /** Число свободных элементов группы */
                this.iTotalOpen = 0;
                /** Первый свободный элемент группы */
                this.iFirstOpen = 0;
                /** Колмичество элементов в группе */
                this.iMaxCount = 0;
                /** Список свободных элементов группы */
                this.pNextOpenList = null;
                /** Массив элементов группы */
                this.pMemberList = null;
                this.pManager = pManager;
                this.tTemplate = tTemplate;
                this.iMaxCount = iMaxCount;
            }
            PoolGroup.prototype.getManager = function () {
                return this.pManager;
            };

            /**
            * Возвращает количесвто свободных мест в группе
            * @
            */
            PoolGroup.prototype.getTotalOpen = function () {
                return this.iTotalOpen;
            };

            /**
            * Возвращает количесвто занятых мест в группе
            * @
            */
            PoolGroup.prototype.getTotalUsed = function () {
                return this.iMaxCount - this.iTotalOpen;
            };

            /**
            * Номер первого свободного элемента в группе
            * @
            */
            PoolGroup.prototype.getFirstOpen = function () {
                return this.iFirstOpen;
            };

            /** Создание группы, создается массив элементов, инициализирется список свободный и т.д. */
            PoolGroup.prototype.create = function () {
                var i;

                akra.debug.assert(this.pMemberList == null && this.pNextOpenList == null, "Group has already been created");

                this.pNextOpenList = new Array(this.iMaxCount);

                akra.debug.assert(this.pNextOpenList != null, "tragic memory allocation failure!");

                this.pMemberList = new Array(this.iMaxCount);

                for (i = 0; i < this.iMaxCount; i++) {
                    this.pMemberList[i] = new this.tTemplate(this.pManager);
                }

                akra.debug.assert(this.pNextOpenList != null, "tragic memory allocation failure!");

                for (i = 0; i < this.iMaxCount - 1; i++) {
                    this.pNextOpenList[i] = i + 1;
                }

                this.pNextOpenList[i] = i;
                this.iTotalOpen = this.iMaxCount;
                this.iFirstOpen = 0;
            };

            /**
            * Удаление группы: удаление массива элементов, списка совбодных элементов и т.д.
            * Выдается ошибка если группа не пуста
            * */
            PoolGroup.prototype.destroy = function () {
                akra.debug.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created");
                akra.debug.assert(this.iTotalOpen == this.iMaxCount, "Group is not empty");

                delete this.pMemberList;
                this.pMemberList = null;

                delete this.pNextOpenList;
                this.pNextOpenList = null;

                this.iTotalOpen = 0;
                this.iMaxCount = 0;
            };

            /** Возвращает номер следующего совбодного элемента в списке, и помечает его как используемый */
            PoolGroup.prototype.nextMember = function () {
                akra.debug.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created");
                akra.debug.assert(this.iTotalOpen != null, "no open slots");

                //Возвращает номер первого свободного элемента в группе,
                //и изменяет номер первого свободного на следующего свободного
                var iSlot = this.iFirstOpen;
                this.iFirstOpen = this.pNextOpenList[iSlot];
                this.iTotalOpen--;

                akra.debug.assert(this.iFirstOpen != PoolGroup.INVALID_INDEX, "Invalid Open Index");
                akra.debug.assert(this.isOpen(iSlot), "invalid index");

                //помечаем что элемент который отдали является используемым
                this.pNextOpenList[iSlot] = PoolGroup.INVALID_INDEX;

                return iSlot;
            };

            /** Добавляем новый элемент в список */
            PoolGroup.prototype.addMember = function (pMember) {
                var iSlot = this.nextMember();
                this.pMemberList[iSlot] = pMember;

                return iSlot;
            };

            /** Исключение элемента из списка по его номеру */
            PoolGroup.prototype.release = function (iIndex) {
                akra.debug.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created");
                akra.debug.assert(iIndex < this.iMaxCount, "invalid index");
                akra.debug.assert(this.isOpen(iIndex) == false, "invalid index to release");

                this.pNextOpenList[iIndex] = this.iTotalOpen > 0 ? this.iFirstOpen : iIndex;
                this.iTotalOpen++;
                this.iFirstOpen = iIndex;
            };

            /** Проверить свободна ли эта ячейка в группе */
            PoolGroup.prototype.isOpen = function (iIndex) {
                akra.debug.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created");
                akra.debug.assert(iIndex < this.iMaxCount, "invalid index");

                return this.pNextOpenList[iIndex] != PoolGroup.INVALID_INDEX;
            };

            /** Получение элемента по его номеру */
            PoolGroup.prototype.member = function (iIndex) {
                akra.debug.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created");
                akra.debug.assert(iIndex < this.iMaxCount, "invalid index");
                return this.pMemberList[iIndex];
            };

            PoolGroup.prototype.memberPtr = function (iIndex) {
                akra.debug.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created");
                akra.debug.assert(iIndex < this.iMaxCount, "invalid index");
                return this.pMemberList[iIndex];
            };

            PoolGroup.INVALID_INDEX = 0xffff;
            return PoolGroup;
        })();
        pool.PoolGroup = PoolGroup;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="../idl/IEngine.ts" />
/// <reference path="../idl/IDataPool.ts" />
/// <reference path="../idl/IResourcePoolItem.ts" />
/// <reference path="../idl/IResourcePoolManager.ts" />
var akra;
(function (akra) {
    /// <reference path="../debug.ts" />
    /// <reference path="../logger.ts" />
    /// <reference path="../limit.ts" />
    /// <reference path="../math/math.ts" />
    /// <reference path="PoolGroup.ts" />
    (function (pool) {
        var DataPool = (function () {
            function DataPool(pManager, tTemplate) {
                this.bInitialized = false;
                /** Массив групп */
                this.pGroupList = [];
                /** Общее число ячеек */
                this.iTotalMembers = 0;
                /** Количесвто свободных ячеек */
                this.iTotalOpen = 0;
                /** Количесвто элементов в группе */
                this.iGroupCount = 0;
                /**
                * Номер элемента состоит из номер группы сдвинутого на _iIndexShift
                * и номера элемента в этой группе, который можно вырезать маской _iIndexMask
                */
                this.iIndexMask = 0;
                /**
                * Номер элемента состоит из номер группы сдвинутого на _iIndexShift
                * и номера элемента в этой группе, который можно вырезать маской _iIndexMask
                */
                this.iIndexShift = 0;
                this.pManager = pManager;
                this.tTemplate = tTemplate;
            }
            DataPool.prototype.getManager = function () {
                return this.pManager;
            };

            DataPool.prototype.initialize = function (iGrowSize) {
                akra.debug.assert(this.isInitialized() == false, "the cDataPool is already initialized");

                this.bInitialized = true;
                this.iGroupCount = akra.math.nearestPowerOfTwo(iGrowSize);
                this.iIndexShift = akra.math.lowestBitSet(this.iGroupCount);
                this.iIndexShift = akra.math.clamp(this.iIndexShift, 1, 15);
                this.iGroupCount = 1 << this.iIndexShift;
                this.iIndexMask = this.iGroupCount - 1;
            };

            /** @ */
            DataPool.prototype.isInitialized = function () {
                return this.bInitialized;
            };

            DataPool.prototype.destroy = function () {
                this.clear();
                this.bInitialized = false;
            };

            DataPool.prototype.release = function (iHandle) {
                akra.debug.assert(this.isInitialized() == true, "the cDataPool is not initialized");

                if (this.isHandleValid(iHandle) == true) {
                    akra.debug.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created");

                    var iGroupIndex = this.getGroupNumber(iHandle);
                    var iItemIndex = this.getItemIndex(iHandle);

                    var pGroup = this.getGroup(iGroupIndex);
                    pGroup.release(iItemIndex);
                    var pGroupBack = this.pGroupList[this.pGroupList.length - 1];

                    if (pGroupBack.getTotalOpen() == this.iGroupCount) {
                        pGroupBack.destroy();
                        this.pGroupList.splice(this.pGroupList.length - 1, 1);
                    }

                    this.iTotalOpen++;
                }
            };

            DataPool.prototype.clear = function () {
                for (var iGroupIter = 0; iGroupIter < this.pGroupList.length; ++iGroupIter) {
                    this.pGroupList[iGroupIter].destroy();
                }

                // now clear the list itself
                this.pGroupList.clear();
            };

            DataPool.prototype.add = function (pMembers) {
                akra.debug.assert(this.isInitialized() == true, "the cDataPool is not initialized");

                var iGroupNumber = { value: 0 };

                var pOpenGroup = this.findOpenGroup(iGroupNumber);
                var iIndex = pOpenGroup.addMember(pMembers);

                this.iTotalOpen--;

                return this.buildHandle(iGroupNumber.value, iIndex);
            };

            DataPool.prototype.forEach = function (fFunction) {
                akra.debug.assert(this.isInitialized() == true, "the cDataPool is not initialized");

                // iterate through every group
                var iGroupNumber = 0;
                for (var iGroupIter = 0; iGroupIter < this.pGroupList.length; iGroupIter++) {
                    var nCallbackCount = this.pGroupList[iGroupIter].getTotalUsed();
                    var iItemIndex = 0;

                    while (nCallbackCount != 0 && iItemIndex < this.iGroupCount) {
                        if (this.pGroupList[iGroupIter].isOpen(iItemIndex) == false) {
                            fFunction(this, this.buildHandle(iGroupNumber, iItemIndex), this.pGroupList[iGroupIter].member(iItemIndex));
                            nCallbackCount--;
                        }

                        ++iItemIndex;
                    }

                    ++iGroupNumber;
                }
            };

            DataPool.prototype.nextHandle = function () {
                akra.debug.assert(this.isInitialized() == true, "the cDataPool is not initialized");

                var iGroupNumber = { value: 0 };
                var pOpenGroup = this.findOpenGroup(iGroupNumber);
                var iIndex = pOpenGroup.nextMember();

                this.iTotalOpen--;

                return this.buildHandle(iGroupNumber.value, iIndex);
            };

            DataPool.prototype.isHandleValid = function (iHandle) {
                akra.debug.assert(this.isInitialized() == true, "the cDataPool is not initialized");

                if (iHandle !== pool.PoolGroup.INVALID_INDEX) {
                    akra.debug.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created");

                    var pGroup = this.getGroup(this.getGroupNumber(iHandle));

                    return !pGroup.isOpen(this.getItemIndex(iHandle));
                }

                return false;
            };

            DataPool.prototype.get = function (iHandle) {
                akra.debug.assert(this.isInitialized() == true, "the cDataPool is not initialized");
                akra.debug.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created");

                var pGroup = this.getGroup(this.getGroupNumber(iHandle));
                var iItemIndex = this.getItemIndex(iHandle);

                return pGroup.member(iItemIndex);
            };

            DataPool.prototype.getPtr = function (iHandle) {
                akra.debug.assert(this.isInitialized() == true, "the cDataPool is not initialized");
                akra.debug.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created");

                var pGroup = this.getGroup(this.getGroupNumber(iHandle));
                var iItemIndex = this.getItemIndex(iHandle);

                return pGroup.memberPtr(iItemIndex);
            };

            DataPool.prototype.getGenericPtr = function (iHandle) {
                akra.debug.assert(this.isInitialized() == true, "the cDataPool is not initialized");

                return this.getPtr(iHandle);
            };

            /**
            * @
            * Получение номера группы по номеру элемента
            */
            DataPool.prototype.getGroupNumber = function (iHandle) {
                return iHandle >> this.iIndexShift;
            };

            /**
            * @
            * Получение номера элеменат в группе по его номеру
            */
            DataPool.prototype.getItemIndex = function (iHandle) {
                return iHandle & this.iIndexMask;
            };

            /**
            * @
            * Полученяи номера элеменат по его номеру группы и группе
            */
            DataPool.prototype.buildHandle = function (iGroup, iIndex) {
                return (iGroup << this.iIndexShift) + iIndex;
            };

            /** Добавление группы в пул */
            DataPool.prototype.addGroup = function () {
                // append a new group to the list to start things off
                var pNewGroup = new pool.PoolGroup(this.pManager, this.tTemplate, this.iGroupCount);
                this.pGroupList.push(pNewGroup);

                // gain access to the new group and innitialize it
                pNewGroup.create();

                // increment our internal counters
                this.iTotalMembers += this.iGroupCount;
                this.iTotalOpen += this.iGroupCount;

                return pNewGroup;
            };

            /** Поиск первой группы которая имеет свободную область */
            DataPool.prototype.findOpenGroup = function (pGroupNumber) {
                pGroupNumber.value = 0;

                for (var iGroupIter = 0; iGroupIter < this.pGroupList.length; iGroupIter++) {
                    if (this.pGroupList[iGroupIter].getTotalOpen() > 0) {
                        return this.pGroupList[iGroupIter];
                    }

                    pGroupNumber.value++;
                }

                //свободных областей нет, поэтому мы должны добавить новую группу в пул,
                //но пержде чем содавать убедимся что не достигли максимума
                akra.debug.assert((this.pGroupList.length + 1) < akra.MAX_UINT16, "the cDataPool is full!!!!");

                //добавим новую группу
                return this.addGroup();
            };

            /**
            * @
            * Возвращает группу по ее номеру
            */
            DataPool.prototype.getGroup = function (iIndex) {
                akra.debug.assert(iIndex < this.pGroupList.length, "Invalid group index requested");
                return this.pGroupList[iIndex];
            };
            return DataPool;
        })();
        pool.DataPool = DataPool;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="../idl/IEngine.ts" />
/// <reference path="../idl/IResourcePool.ts" />
/// <reference path="../idl/IResourcePoolItem.ts" />
/// <reference path="../idl/IDataPool.ts" />
/// <reference path="../idl/IResourceCode.ts" />
/// <reference path="../idl/IResourcePoolManager.ts" />
var akra;
(function (akra) {
    /// <reference path="../util/ReferenceCounter.ts" />
    /// <reference path="../events.ts" />
    /// <reference path="../guid.ts" />
    /// <reference path="ResourceCode.ts" />
    /// <reference path="PoolGroup.ts" />
    /// <reference path="DataPool.ts" />
    (function (pool) {
        var ResourcePool = (function (_super) {
            __extends(ResourcePool, _super);
            function ResourcePool(pManager, tTemplate) {
                _super.call(this);
                this.guid = akra.guid();
                this._pManager = null;
                /** Конструктор для создания данных в пуле ресурсов */
                this._tTemplate = null;
                this._sExt = null;
                this._pRegistrationCode = new pool.ResourceCode(4294967295 /* INVALID_CODE */);
                this._pNameMap = new Array();
                this._pDataPool = null;
                this.setupSignals();

                this._pManager = pManager;
                this._tTemplate = tTemplate;
                this._pDataPool = new pool.DataPool(this._pManager, tTemplate);
            }
            ResourcePool.prototype.setupSignals = function () {
                this.createdResource = this.createdResource || new akra.Signal(this);
            };

            ResourcePool.prototype.getFourcc = function () {
                return (this._sExt.charCodeAt(3) << 24) | (this._sExt.charCodeAt(2) << 16) | (this._sExt.charCodeAt(1) << 8) | (this._sExt.charCodeAt(0));
            };

            ResourcePool.prototype.setFourcc = function (iNewFourcc) {
                this._sExt = String.fromCharCode((iNewFourcc & 0x000000FF), (iNewFourcc & 0x0000FF00) >>> 8, (iNewFourcc & 0x00FF0000) >>> 16, (iNewFourcc & 0xFF000000) >>> 24);
            };

            ResourcePool.prototype.getManager = function () {
                return this._pManager;
            };

            /** Добавление данного пула в менеджер ресурсво по его коду */
            ResourcePool.prototype.registerResourcePool = function (pCode) {
                this._pRegistrationCode.eq(pCode);
                this._pManager.registerResourcePool(this._pRegistrationCode, this);
            };

            /** Удаление данного пула в менеджер ресурсво по его коду */
            ResourcePool.prototype.unregisterResourcePool = function () {
                this._pManager.unregisterResourcePool(this._pRegistrationCode);
                this._pRegistrationCode.setInvalid();
            };

            /** По имени ресурса возвращает его хендл */
            ResourcePool.prototype.findResourceHandle = function (sName) {
                // look up the name in our map
                var iNewHandle = pool.PoolGroup.INVALID_INDEX;

                for (var iHandle = 0; iHandle < this._pNameMap.length; ++iHandle) {
                    if (this._pNameMap[iHandle] === sName) {
                        return iHandle;
                    }
                }

                return iNewHandle;
            };

            /**
            * Get resource name by handle.
            * @
            */
            ResourcePool.prototype.findResourceName = function (iHandle) {
                return this._pNameMap[iHandle];
            };

            ResourcePool.prototype.setResourceName = function (iHandle, sName) {
                this._pNameMap[iHandle] = sName;
            };

            ResourcePool.prototype.initialize = function (iGrowSize) {
                this._pDataPool.initialize(iGrowSize);
            };

            /** @ */
            ResourcePool.prototype.destroy = function () {
                this._pDataPool.destroy();
            };

            ResourcePool.prototype.clean = function () {
                this._pDataPool.forEach(ResourcePool.callbackClean);
            };

            ResourcePool.prototype.destroyAll = function () {
                this._pDataPool.forEach(ResourcePool.callbackDestroy);
            };

            ResourcePool.prototype.restoreAll = function () {
                this._pDataPool.forEach(ResourcePool.callbackRestore);
            };

            ResourcePool.prototype.disableAll = function () {
                this._pDataPool.forEach(ResourcePool.callbackDisable);
            };

            /** @ */
            ResourcePool.prototype.isInitialized = function () {
                return this._pDataPool.isInitialized();
            };

            ResourcePool.prototype.createResource = function (sResourceName) {
                var iHandle = this.internalCreateResource(sResourceName);

                if (iHandle !== pool.PoolGroup.INVALID_INDEX) {
                    var pResource = this.getResource(iHandle);

                    pResource.setResourcePool(this);
                    pResource.setResourceHandle(iHandle);
                    pResource.setResourceCode(this._pRegistrationCode);

                    this.createdResource.emit(pResource);

                    return pResource;
                }

                return null;
            };

            ResourcePool.prototype.loadResource = function (sResourceName) {
                // does the resource already exist?
                var pResource = this.findResource(sResourceName);

                if (pResource == null) {
                    // create a new resource
                    pResource = this.createResource(sResourceName);

                    if (pResource != null) {
                        // attempt to load the desired data
                        if (pResource.loadResource(sResourceName)) {
                            // ok!
                            return pResource;
                        }

                        // loading failed.
                        // destroy the resource we created
                        // destroyResource(pResource);
                        pResource.release();
                        pResource = null;
                    }
                }

                return pResource;
            };

            ResourcePool.prototype.saveResource = function (pResource) {
                if (pResource != null) {
                    // save the resource using it's own name as the file path
                    return pResource.saveResource();
                }
                return false;
            };

            ResourcePool.prototype.destroyResource = function (pResource) {
                if (pResource != null) {
                    var iReferenceCount = pResource.referenceCount();

                    akra.debug.assert(iReferenceCount == 0, "destruction of non-zero reference count!");

                    if (iReferenceCount <= 0) {
                        var iHandle = pResource.getResourceHandle();
                        this.internalDestroyResource(iHandle);
                    }
                }
            };

            ResourcePool.prototype.findResource = function (sName) {
                for (var iHandle = 0; iHandle < this._pNameMap.length; ++iHandle) {
                    if (this._pNameMap[iHandle] == sName) {
                        if (iHandle != pool.PoolGroup.INVALID_INDEX) {
                            var pResource = this.getResource(iHandle);
                            return pResource;
                        }
                    }
                }

                return null;
            };

            ResourcePool.prototype.getResource = function (iHandle) {
                var pResource = this.internalGetResource(iHandle);

                if (pResource != null) {
                    pResource.addRef();
                }

                return pResource;
            };

            ResourcePool.prototype.getResources = function () {
                var pResources = [];

                for (var iHandleResource in this._pNameMap) {
                    pResources.push(this.getResource(parseInt(iHandleResource)));
                }

                return pResources;
            };

            ResourcePool.prototype.internalGetResource = function (iHandle) {
                return this._pDataPool.getPtr(iHandle);
            };

            ResourcePool.prototype.internalDestroyResource = function (iHandle) {
                // get a pointer to the resource and call it's destruction handler
                var pResource = this._pDataPool.getPtr(iHandle);

                pResource.destroyResource();

                delete this._pNameMap[iHandle];

                // free the resource slot associated with the handle
                this._pDataPool.release(iHandle);
            };

            ResourcePool.prototype.internalCreateResource = function (sResourceName) {
                var iHandle = this._pDataPool.nextHandle();

                for (var iter in this._pNameMap) {
                    akra.debug.assert((this._pNameMap[iter] != sResourceName), "A resource with this name already exists: " + sResourceName);
                }

                // add this resource name to our map of handles
                this._pNameMap[iHandle] = sResourceName;

                // get a pointer to the resource and call it's creation function
                var pResource = this._pDataPool.getPtr(iHandle);

                pResource.createResource();

                return iHandle;
            };

            ResourcePool.callbackDestroy = function (pPool, iHandle, pResource) {
                pResource.destroyResource();
            };

            ResourcePool.callbackDisable = function (pPool, iHandle, pResource) {
                pResource.disableResource();
            };

            ResourcePool.callbackRestore = function (pPool, iHandle, pResource) {
                pResource.restoreResource();
            };

            ResourcePool.callbackClean = function (pPool, iHandle, pResource) {
                if (pResource.referenceCount() == 0) {
                    pPool.release(iHandle);
                }
            };
            return ResourcePool;
        })(akra.util.ReferenceCounter);
        pool.ResourcePool = ResourcePool;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="../idl/IEngine.ts" />
/// <reference path="../idl/IResourceCode.ts" />
/// <reference path="../idl/IResourcePool.ts" />
/// <reference path="../idl/IResourcePoolManager.ts" />
/// <reference path="../idl/IResourceWatcherFunc.ts" />
/// <reference path="../idl/IResourceNotifyRoutineFunc.ts" />
/// <reference path="../idl/IResourcePoolItem.ts" />
var akra;
(function (akra) {
    /// <reference path="../util/ReferenceCounter.ts" />
    /// <reference path="../common.ts" />
    /// <reference path="../events.ts" />
    /// <reference path="../guid.ts" />
    /// <reference path="../gen/generate.ts" />
    /// <reference path="ResourceCode.ts" />
    (function (pool) {
        var ResourcePoolItem = (function (_super) {
            __extends(ResourcePoolItem, _super);
            /** Constructor of ResourcePoolItem class */
            function ResourcePoolItem() {
                _super.call(this);
                this.guid = akra.guid();
                this._pResourcePool = null;
                this._iResourceHandle = 0;
                this._iResourceFlags = 0;
                this._iResourceSyncFlags = 0xFFFFFF;
                this.setupSignals();

                //this.pManager = pManager;
                this._pResourceCode = new pool.ResourceCode(0);
                this._pCallbackSlots = akra.gen.array(4 /* TOTALRESOURCEFLAGS */);
            }
            ResourcePoolItem.prototype.setupSignals = function () {
                this.created = this.created || new akra.Signal(this);
                this.destroyed = this.destroyed || new akra.Signal(this);
                this.loaded = this.loaded || new akra.Signal(this);
                this.unloaded = this.unloaded || new akra.Signal(this);
                this.restored = this.restored || new akra.Signal(this);
                this.disabled = this.disabled || new akra.Signal(this);
                this.altered = this.altered || new akra.Signal(this);
                this.saved = this.saved || new akra.Signal(this);

                this.stateChanged = this.stateChanged || new akra.Signal(this);
            };

            ResourcePoolItem.prototype.getResourceCode = function () {
                return this._pResourceCode;
            };

            ResourcePoolItem.prototype.getResourcePool = function () {
                return this._pResourcePool;
            };

            ResourcePoolItem.prototype.getResourceHandle = function () {
                return this._iResourceHandle;
            };

            ResourcePoolItem.prototype.getResourceFlags = function () {
                return this._iResourceFlags;
            };

            ResourcePoolItem.prototype.getAlteredFlag = function () {
                return akra.bf.testBit(this._iResourceFlags, 3 /* ALTERED */);
            };

            ResourcePoolItem.prototype.getEngine = function () {
                var pManager = this.getManager();

                if (pManager) {
                    return pManager.getEngine();
                }

                return null;
            };

            ResourcePoolItem.prototype.getManager = function () {
                return this._pResourcePool.getManager();
            };

            ResourcePoolItem.prototype.createResource = function () {
                return false;
            };

            ResourcePoolItem.prototype.destroyResource = function () {
                return false;
            };

            ResourcePoolItem.prototype.disableResource = function () {
                return false;
            };

            ResourcePoolItem.prototype.restoreResource = function () {
                return false;
            };

            ResourcePoolItem.prototype.loadResource = function (sFilename) {
                if (typeof sFilename === "undefined") { sFilename = null; }
                return false;
            };

            ResourcePoolItem.prototype.saveResource = function (sFilename) {
                if (typeof sFilename === "undefined") { sFilename = null; }
                return false;
            };

            ResourcePoolItem.prototype.isSyncedTo = function (eSlot) {
                return !akra.isNull(this._pCallbackSlots[eSlot]) && this._pCallbackSlots[eSlot].length > 0;
            };

            /**
            * Find resources, that may affect the @eState of this resoyrces.
            */
            ResourcePoolItem.prototype.findRelatedResources = function (eState) {
                var pSlots = this._pCallbackSlots[eState];
                var pRelatedResources = [];

                if (pSlots) {
                    for (var i = 0; i < pSlots.length; ++i) {
                        pRelatedResources.push(pSlots[i].resource);
                    }
                }

                return pRelatedResources;
            };

            ResourcePoolItem.prototype.isSyncComplete = function (eSignal) {
                return akra.bf.testBit(this._iResourceSyncFlags, eSignal);
            };

            ResourcePoolItem.prototype.updateSyncState = function (eState) {
                var pSignSlots = this._pCallbackSlots[eState];

                for (var i = 0; i < pSignSlots.length; ++i) {
                    if (pSignSlots[i].state === false) {
                        akra.bf.setBit(this._iResourceSyncFlags, eState, false);
                        return;
                    }
                }

                akra.bf.setBit(this._iResourceSyncFlags, eState, true);
            };

            ResourcePoolItem.prototype.sync = function (pResourceItem, eSignal, eSlot) {
                var _this = this;
                eSlot = akra.isDef(eSlot) ? eSlot : eSignal;

                eSlot = ResourcePoolItem.parseEvent(eSlot);
                eSignal = ResourcePoolItem.parseEvent(eSignal);

                var pSlots = this._pCallbackSlots, pSignSlots = pSlots[eSlot] = pSlots[eSlot] || [];

                var n = pSignSlots.length;
                ;
                var fn;
                var bState;

                //current state of related resource
                bState = akra.bf.testBit(pResourceItem.getResourceFlags(), eSignal);

                fn = function (pResourceItem, eFlag, iResourceFlags, isSet) {
                    if (eFlag === eSignal) {
                        pSignSlots[n].state = isSet;

                        var bState = _this.isSyncComplete(eSlot);
                        _this.updateSyncState(eSlot);

                        if (_this.isSyncComplete(eSlot) !== bState) {
                            _this.notifyStateChanged(eSlot);
                        }
                    }
                };

                pSignSlots.push({
                    resource: pResourceItem,
                    state: bState,
                    fn: fn,
                    event: eSignal
                });

                fn.call(pResourceItem, eSignal, pResourceItem.getResourceFlags(), bState);
                pResourceItem.stateChanged.connect(fn);

                return true;
            };

            ResourcePoolItem.prototype.unsync = function (pResourceItem, eSignal, eSlot) {
                eSlot = akra.isDef(eSlot) ? eSlot : eSignal;
                eSlot = ResourcePoolItem.parseEvent(eSlot);
                eSignal = ResourcePoolItem.parseEvent(eSignal);

                var pSlots = this._pCallbackSlots, pSignSlots;
                var isRem = false;

                pSignSlots = pSlots[eSlot];

                for (var i = 0, n = pSignSlots.length; i < n; ++i) {
                    if (pSignSlots[i].resource === pResourceItem && pSignSlots[i].event == eSignal) {
                        pSignSlots[i].resource.stateChanged.disconnect(pSignSlots[i].fn);
                        pSignSlots.splice(i, 1);

                        --n;
                        --i;

                        isRem = true;
                    }
                }

                var bPrevValue = this.isSyncComplete(eSlot);
                this.updateSyncState(eSlot);

                if (bPrevValue != this.isSyncComplete(eSlot)) {
                    this.notifyStateChanged(eSlot);
                }

                return isRem;
            };

            ResourcePoolItem.prototype.isResourceCreated = function () {
                return akra.bf.testBit(this._iResourceFlags, 0 /* CREATED */) && this.isSyncComplete(0 /* CREATED */);
            };

            ResourcePoolItem.prototype.isResourceLoaded = function () {
                return akra.bf.testBit(this._iResourceFlags, 1 /* LOADED */) && this.isSyncComplete(1 /* LOADED */);
            };

            ResourcePoolItem.prototype.isResourceDisabled = function () {
                return akra.bf.testBit(this._iResourceFlags, 2 /* DISABLED */) && this.isSyncComplete(2 /* DISABLED */);
            };

            ResourcePoolItem.prototype.isResourceAltered = function () {
                return akra.bf.testBit(this._iResourceFlags, 3 /* ALTERED */);
            };

            ResourcePoolItem.prototype.setResourceName = function (sName) {
                if (this._pResourcePool != null) {
                    this._pResourcePool.setResourceName(this._iResourceHandle, sName);
                }
            };

            ResourcePoolItem.prototype.findResourceName = function () {
                if (this._pResourcePool != null) {
                    return this._pResourcePool.findResourceName(this._iResourceHandle);
                }

                return null;
            };

            ResourcePoolItem.prototype.release = function () {
                var iRefCount = _super.prototype.release.call(this);

                if (iRefCount == 0) {
                    //Если у нас есть менеджер попросим его удалить нас
                    if (this._pResourcePool != null) {
                        this._pResourcePool.destroyResource(this);
                    }
                }

                return iRefCount;
            };

            ResourcePoolItem.prototype.notifyCreated = function () {
                this.setResourceFlag(0 /* CREATED */, true);
            };

            ResourcePoolItem.prototype.notifyDestroyed = function () {
                this.setResourceFlag(0 /* CREATED */, false);
            };

            ResourcePoolItem.prototype.notifyLoaded = function () {
                this.notifyAltered();
                this.setResourceFlag(1 /* LOADED */, true);
            };

            ResourcePoolItem.prototype.notifyUnloaded = function () {
                this.setResourceFlag(1 /* LOADED */, false);
            };

            ResourcePoolItem.prototype.notifyRestored = function () {
                this.setResourceFlag(2 /* DISABLED */, false);
            };

            ResourcePoolItem.prototype.notifyDisabled = function () {
                this.setResourceFlag(2 /* DISABLED */, true);
            };

            ResourcePoolItem.prototype.notifyAltered = function () {
                this.setResourceFlag(3 /* ALTERED */, true);
            };

            ResourcePoolItem.prototype.notifySaved = function () {
                this.setResourceFlag(3 /* ALTERED */, false);
            };

            /**
            * Назначение кода ресурсу
            * @
            */
            ResourcePoolItem.prototype.setResourceCode = function (pCode) {
                this._pResourceCode.eq(pCode);
                //debug.error("created resource", this.guid, this.findResourceName(), this);
            };

            /**
            * Чтобы ресурс знал какому пулу ресурсов принадлжит
            * @
            */
            ResourcePoolItem.prototype.setResourcePool = function (pPool) {
                this._pResourcePool = pPool;
            };

            /**
            * Назначение хендла ресурсу
            * @
            */
            ResourcePoolItem.prototype.setResourceHandle = function (iHandle) {
                this._iResourceHandle = iHandle;
            };

            ResourcePoolItem.prototype.notifyStateChanged = function (eState) {
                var bState = akra.bf.testBit(this._iResourceFlags, eState);

                if (((this.isSyncComplete(eState) && bState) || (!bState)) || eState == 3 /* ALTERED */) {
                    this.stateChanged.emit(eState, this._iResourceFlags, bState);

                    switch (eState) {
                        case 1 /* LOADED */:
                            return bState ? this.loaded.emit() : this.unloaded.emit();
                        case 0 /* CREATED */:
                            return bState ? this.created.emit() : this.destroyed.emit();
                        case 2 /* DISABLED */:
                            return bState ? this.disabled.emit() : this.restored.emit();
                        case 3 /* ALTERED */:
                            return bState ? this.altered.emit() : this.saved.emit();
                    }
                }
            };

            ResourcePoolItem.prototype.setResourceFlag = function (iFlagBit, isSetting) {
                var iTempFlags = this._iResourceFlags;

                this._iResourceFlags = akra.bf.setBit(this._iResourceFlags, iFlagBit, isSetting);

                //ALTERED - specific signal, every time, when resource will be modified, alter will be emitted.
                if (iTempFlags !== this._iResourceFlags || iFlagBit === 3 /* ALTERED */) {
                    //даже если состояние самого ресурса изменилось,
                    //сигнал об этом не будет отослан пока он не получит статуст синхронизации
                    this.notifyStateChanged(iFlagBit);
                    return true;
                }

                return false;
            };

            ResourcePoolItem.parseEvent = function (pEvent) {
                if (akra.isInt(pEvent)) {
                    return pEvent;
                }

                switch (pEvent.toLowerCase()) {
                    case ResourcePoolItem.LOADED:
                        return 1 /* LOADED */;
                    case ResourcePoolItem.CREATED:
                        return 0 /* CREATED */;
                    case ResourcePoolItem.DISABLED:
                        return 2 /* DISABLED */;
                    case ResourcePoolItem.ALTERED:
                        return 3 /* ALTERED */;
                    default:
                        akra.logger.error('Used unknown event type.');
                }

                return 0;
            };

            ResourcePoolItem.DISABLED = "disabled";
            ResourcePoolItem.ALTERED = "altered";
            ResourcePoolItem.CREATED = "created";
            ResourcePoolItem.LOADED = "loaded";
            return ResourcePoolItem;
        })(akra.util.ReferenceCounter);
        pool.ResourcePoolItem = ResourcePoolItem;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="IUnique.ts" />
/// <reference path="IAFXInstruction.ts" />
/// <reference path="IAFXMaker.ts" />
/// <reference path="IAFXPassInputBlend.ts" />
/// <reference path="ISurfaceMaterial.ts" />
/// <reference path="IBufferMap.ts" />
/// <reference path="IAFXComponent.ts" />
/// <reference path="IAFXComponentBlend.ts" />
/// <reference path="IAFXPassBlend.ts" />
/// <reference path="IAFXInstruction.ts" />
/// <reference path="Color.ts" />
/// <reference path="../math/Vec4.ts" />
var akra;
(function (akra) {
    (function (color) {
        var Vec4 = akra.math.Vec4;

        var iVariousColor = 0;
        var pVariousColors = [
            "BLUE",
            "BLUE_VIOLET",
            "BROWN",
            "CADET_BLUE",
            "CHARTREUSE",
            "CRIMSON",
            "CYAN",
            "DEEP_PINK",
            "DEEP_SKY_BLUE",
            "DODGER_BLUE",
            "FIRE_BRICK",
            "FUCHSIA",
            "GOLD",
            "GREEN",
            "GREEN_YELLOW",
            "HOT_PINK",
            "LAWN_GREEN",
            "LIME",
            "LIME_GREEN",
            "MAGENTA",
            "MEDIUM_BLUE",
            "MEDIUM_ORCHID",
            "MEDIUM_SPRING_GREEN",
            "MEDIUM_VIOLET_RED",
            "ORANGE",
            "ORANGE_RED",
            "PURPLE",
            "RED",
            "SPRING_GREEN",
            "STEEL_BLUE",
            "TOMATO",
            "TURQUOISE",
            "VIOLET",
            "WHEAT",
            "YELLOW",
            "YELLOW_GREEN"
        ];

        function random(bVarious) {
            if (typeof bVarious === "undefined") { bVarious = false; }
            if (!bVarious) {
                return new color.Color(Math.random(), Math.random(), Math.random(), 1.);
            }

            if (iVariousColor === pVariousColors.length) {
                iVariousColor = 0;
            }

            return color[pVariousColors[iVariousColor++]] || color.Color.WHITE;
        }
        color.random = random;

        /**  */ function toVec4(cSrc, vDst) {
            if (typeof vDst === "undefined") { vDst = new Vec4; }
            return vDst.set(cSrc.r, cSrc.g, cSrc.b, cSrc.a);
        }

        color.ZERO = new color.Color(0., 0., 0., 0.);

        color.ALICE_BLUE = new color.Color("#f0f8ff");
        color.ANTIQUE_WHITE = new color.Color("#faebd7");
        color.AQUA = new color.Color("#00ffff");
        color.AQUA_MARINE = new color.Color("#7fffd4");
        color.AZURE = new color.Color("#f0ffff");
        color.BEIGE = new color.Color("#f5f5dc");
        color.BISQUE = new color.Color("#ffe4c4");
        color.BLANCHED_ALMOND = new color.Color("#ffebcd");
        color.BLACK = new color.Color("#000000");
        color.BLUE = new color.Color("#0000ff");
        color.BLUE_VIOLET = new color.Color("#8a2be2");
        color.BROWN = new color.Color("#a52a2a");
        color.BURLY_WOOD = new color.Color("#deb887");
        color.CADET_BLUE = new color.Color("#5f9ea0");
        color.CHARTREUSE = new color.Color("#7fff00");
        color.CHOCOLATE = new color.Color("#d2691e");
        color.CORAL = new color.Color("#ff7f50");
        color.CORNFLOWER_BLUE = new color.Color("#6495ed");
        color.CORNSILK = new color.Color("#fff8dc");
        color.CRIMSON = new color.Color("#dc143c");
        color.CYAN = new color.Color("#00ffff");
        color.DARK_BLUE = new color.Color("#00008b");
        color.DARK_CYAN = new color.Color("#008b8b");
        color.DARK_GOLDEN_ROD = new color.Color("#b8860b");
        color.DARK_GRAY = new color.Color("#a9a9a9");
        color.DARK_GREEN = new color.Color("#006400");
        color.DARK_KHAKI = new color.Color("#bdb76b");
        color.DARK_MAGENTA = new color.Color("#8b008b");
        color.DARK_OLIVE_GREEN = new color.Color("#556b2f");
        color.DARK_ORANGE = new color.Color("#ff8c00");
        color.DARK_ORCHID = new color.Color("#9932cc");
        color.DARK_RED = new color.Color("#8b0000");
        color.DARK_SALMON = new color.Color("#e9967a");
        color.DARK_SEA_GREEN = new color.Color("#8fbc8f");
        color.DARK_SLATE_BLUE = new color.Color("#483d8b");
        color.DARK_SLATE_GRAY = new color.Color("#2f4f4f");
        color.DARK_TURQUOISE = new color.Color("#00ced1");
        color.DARK_VIOLET = new color.Color("#9400d3");
        color.DEEP_PINK = new color.Color("#ff1493");
        color.DEEP_SKY_BLUE = new color.Color("#00bfff");
        color.DIM_GRAY = new color.Color("#696969");
        color.DIM_GREY = new color.Color("#696969");
        color.DODGER_BLUE = new color.Color("#1e90ff");
        color.FIRE_BRICK = new color.Color("#b22222");
        color.FLORAL_WHITE = new color.Color("#fffaf0");
        color.FOREST_GREEN = new color.Color("#228b22");
        color.FUCHSIA = new color.Color("#ff00ff");
        color.GAINSBORO = new color.Color("#dcdcdc");
        color.GHOST_WHITE = new color.Color("#f8f8ff");
        color.GOLD = new color.Color("#ffd700");
        color.GOLDEN_ROD = new color.Color("#daa520");
        color.GRAY = new color.Color("#808080");
        color.GREEN = new color.Color("#008000");
        color.GREEN_YELLOW = new color.Color("#adff2f");
        color.HONEY_DEW = new color.Color("#f0fff0");
        color.HOT_PINK = new color.Color("#ff69b4");
        color.INDIAN_RED = new color.Color("#cd5c5c");
        color.INDIGO = new color.Color("#4b0082");
        color.IVORY = new color.Color("#fffff0");
        color.KHAKI = new color.Color("#f0e68c");
        color.LAVENDER = new color.Color("#e6e6fa");
        color.LAVENDER_BLUSH = new color.Color("#fff0f5");
        color.LAWN_GREEN = new color.Color("#7cfc00");
        color.LEMON_CHIFFON = new color.Color("#fffacd");
        color.LIGHT_BLUE = new color.Color("#add8e6");
        color.LIGHT_CORAL = new color.Color("#f08080");
        color.LIGHT_CYAN = new color.Color("#e0ffff");
        color.LIGHT_GOLDEN_ROD_YELLOW = new color.Color("#fafad2");
        color.LIGHT_GRAY = new color.Color("#d3d3d3");
        color.LIGHT_GREEN = new color.Color("#90ee90");
        color.LIGHT_PINK = new color.Color("#ffb6c1");
        color.LIGHT_SALMON = new color.Color("#ffa07a");
        color.LIGHT_SEA_GREEN = new color.Color("#20b2aa");
        color.LIGHT_SKY_BLUE = new color.Color("#87cefa");
        color.LIGHT_SLATE_GRAY = new color.Color("#778899");
        color.LIGHT_STEEL_BLUE = new color.Color("#b0c4de");
        color.LIGHT_YELLOW = new color.Color("#ffffe0");
        color.LIME = new color.Color("#00ff00");
        color.LIME_GREEN = new color.Color("#32cd32");
        color.LINEN = new color.Color("#faf0e6");
        color.MAGENTA = new color.Color("#ff00ff");
        color.MAROON = new color.Color("#800000");
        color.MEDIUM_AQUA_MARINE = new color.Color("#66cdaa");
        color.MEDIUM_BLUE = new color.Color("#0000cd");
        color.MEDIUM_ORCHID = new color.Color("#ba55d3");
        color.MEDIUM_PURPLE = new color.Color("#9370db");
        color.MEDIUM_SEA_GREEN = new color.Color("#3cb371");
        color.MEDIUM_SLATE_BLUE = new color.Color("#7b68ee");
        color.MEDIUM_SPRING_GREEN = new color.Color("#00fa9a");
        color.MEDIUM_TURQUOISE = new color.Color("#48d1cc");
        color.MEDIUM_VIOLET_RED = new color.Color("#c71585");
        color.MIDNIGHT_BLUE = new color.Color("#191970");
        color.MINT_CREAM = new color.Color("#f5fffa");
        color.MISTY_ROSE = new color.Color("#ffe4e1");
        color.MOCCASIN = new color.Color("#ffe4b5");
        color.NAVAJO_WHITE = new color.Color("#ffdead");
        color.NAVY = new color.Color("#000080");
        color.OLD_LACE = new color.Color("#fdf5e6");
        color.OLIVE = new color.Color("#808000");
        color.OLIVE_DRAB = new color.Color("#6b8e23");
        color.ORANGE = new color.Color("#ffa500");
        color.ORANGE_RED = new color.Color("#ff4500");
        color.ORCHID = new color.Color("#da70d6");
        color.PALE_GOLDEN_ROD = new color.Color("#eee8aa");
        color.PALE_GREEN = new color.Color("#98fb98");
        color.PALE_TURQUOISE = new color.Color("#afeeee");
        color.PALE_VIOLET_RED = new color.Color("#db7093");
        color.PAPAYA_WHIP = new color.Color("#ffefd5");
        color.PEACH_PUFF = new color.Color("#ffdab9");
        color.PERU = new color.Color("#cd853f");
        color.PINK = new color.Color("#ffc0cb");
        color.PLUM = new color.Color("#dda0dd");
        color.POWDER_BLUE = new color.Color("#b0e0e6");
        color.PURPLE = new color.Color("#800080");
        color.RED = new color.Color("#ff0000");
        color.ROSY_BROWN = new color.Color("#bc8f8f");
        color.ROYAL_BLUE = new color.Color("#4169e1");
        color.SADDLE_BROWN = new color.Color("#8b4513");
        color.SALMON = new color.Color("#fa8072");
        color.SANDY_BROWN = new color.Color("#f4a460");
        color.SEA_GREEN = new color.Color("#2e8b57");
        color.SEA_SHELL = new color.Color("#fff5ee");
        color.SIENNA = new color.Color("#a0522d");
        color.SILVER = new color.Color("#c0c0c0");
        color.SKY_BLUE = new color.Color("#87ceeb");
        color.SLATE_BLUE = new color.Color("#6a5acd");
        color.SLATE_GRAY = new color.Color("#708090");
        color.SNOW = new color.Color("#fffafa");
        color.SPRING_GREEN = new color.Color("#00ff7f");
        color.STEEL_BLUE = new color.Color("#4682b4");
        color.TAN = new color.Color("#d2b48c");
        color.TEAL = new color.Color("#008080");
        color.THISTLE = new color.Color("#d8bfd8");
        color.TOMATO = new color.Color("#ff6347");
        color.TURQUOISE = new color.Color("#40e0d0");
        color.VIOLET = new color.Color("#ee82ee");
        color.WHEAT = new color.Color("#f5deb3");
        color.WHITE = new color.Color("#ffffff");
        color.WHITE_SMOKE = new color.Color("#f5f5f5");
        color.YELLOW = new color.Color("#ffff00");
        color.YELLOW_GREEN = new color.Color("#9acd32");
    })(akra.color || (akra.color = {}));
    var color = akra.color;
})(akra || (akra = {}));
/// <reference path="../idl/IRenderer.ts" />
/// <reference path="../idl/ERenderStateValues.ts" />
/// <reference path="../common.ts" />
var akra;
(function (akra) {
    (function (render) {
        function createRenderStateMap() {
            var pMap = {};
            clearRenderStateMap(pMap);

            return pMap;
        }
        render.createRenderStateMap = createRenderStateMap;

        function copyRenderStateMap(pFrom, pTo) {
            if (akra.isNull(pFrom)) {
                return;
            }

            pTo[0 /* BLENDENABLE */] = pFrom[0 /* BLENDENABLE */] || pTo[0 /* BLENDENABLE */];
            pTo[1 /* CULLFACEENABLE */] = pFrom[1 /* CULLFACEENABLE */] || pTo[1 /* CULLFACEENABLE */];
            pTo[2 /* ZENABLE */] = pFrom[2 /* ZENABLE */] || pTo[2 /* ZENABLE */];
            pTo[3 /* ZWRITEENABLE */] = pFrom[3 /* ZWRITEENABLE */] || pTo[3 /* ZWRITEENABLE */];
            pTo[4 /* DITHERENABLE */] = pFrom[4 /* DITHERENABLE */] || pTo[4 /* DITHERENABLE */];
            pTo[5 /* SCISSORTESTENABLE */] = pFrom[5 /* SCISSORTESTENABLE */] || pTo[5 /* SCISSORTESTENABLE */];
            pTo[6 /* STENCILTESTENABLE */] = pFrom[6 /* STENCILTESTENABLE */] || pTo[6 /* STENCILTESTENABLE */];
            pTo[7 /* POLYGONOFFSETFILLENABLE */] = pFrom[7 /* POLYGONOFFSETFILLENABLE */] || pTo[7 /* POLYGONOFFSETFILLENABLE */];
            pTo[8 /* CULLFACE */] = pFrom[8 /* CULLFACE */] || pTo[8 /* CULLFACE */];
            pTo[9 /* FRONTFACE */] = pFrom[9 /* FRONTFACE */] || pTo[9 /* FRONTFACE */];
            pTo[10 /* SRCBLENDCOLOR */] = pFrom[10 /* SRCBLENDCOLOR */] || pTo[10 /* SRCBLENDCOLOR */];
            pTo[11 /* DESTBLENDCOLOR */] = pFrom[11 /* DESTBLENDCOLOR */] || pTo[11 /* DESTBLENDCOLOR */];
            pTo[12 /* SRCBLENDALPHA */] = pFrom[12 /* SRCBLENDALPHA */] || pTo[12 /* SRCBLENDALPHA */];
            pTo[13 /* DESTBLENDALPHA */] = pFrom[13 /* DESTBLENDALPHA */] || pTo[13 /* DESTBLENDALPHA */];
            pTo[14 /* BLENDEQUATIONCOLOR */] = pFrom[14 /* BLENDEQUATIONCOLOR */] || pTo[14 /* BLENDEQUATIONCOLOR */];
            pTo[15 /* BLENDEQUATIONALPHA */] = pFrom[15 /* BLENDEQUATIONALPHA */] || pTo[15 /* BLENDEQUATIONALPHA */];
            pTo[16 /* ZFUNC */] = pFrom[16 /* ZFUNC */] || pTo[16 /* ZFUNC */];
            pTo[17 /* ALPHABLENDENABLE */] = pFrom[17 /* ALPHABLENDENABLE */] || pTo[17 /* ALPHABLENDENABLE */];
            pTo[18 /* ALPHATESTENABLE */] = pFrom[18 /* ALPHATESTENABLE */] || pTo[18 /* ALPHATESTENABLE */];
        }
        render.copyRenderStateMap = copyRenderStateMap;

        function mergeRenderStateMap(pFromA, pFromB, pTo) {
            if (akra.isNull(pFromA) || akra.isNull(pFromB)) {
                return;
            }
            pTo[0 /* BLENDENABLE */] = pFromA[0 /* BLENDENABLE */] || pFromB[0 /* BLENDENABLE */];
            pTo[1 /* CULLFACEENABLE */] = pFromA[1 /* CULLFACEENABLE */] || pFromB[1 /* CULLFACEENABLE */];
            pTo[2 /* ZENABLE */] = pFromA[2 /* ZENABLE */] || pFromB[2 /* ZENABLE */];
            pTo[3 /* ZWRITEENABLE */] = pFromA[3 /* ZWRITEENABLE */] || pFromB[3 /* ZWRITEENABLE */];
            pTo[4 /* DITHERENABLE */] = pFromA[4 /* DITHERENABLE */] || pFromB[4 /* DITHERENABLE */];
            pTo[5 /* SCISSORTESTENABLE */] = pFromA[5 /* SCISSORTESTENABLE */] || pFromB[5 /* SCISSORTESTENABLE */];
            pTo[6 /* STENCILTESTENABLE */] = pFromA[6 /* STENCILTESTENABLE */] || pFromB[6 /* STENCILTESTENABLE */];
            pTo[7 /* POLYGONOFFSETFILLENABLE */] = pFromA[7 /* POLYGONOFFSETFILLENABLE */] || pFromB[7 /* POLYGONOFFSETFILLENABLE */];
            pTo[8 /* CULLFACE */] = pFromA[8 /* CULLFACE */] || pFromB[8 /* CULLFACE */];
            pTo[9 /* FRONTFACE */] = pFromA[9 /* FRONTFACE */] || pFromB[9 /* FRONTFACE */];
            pTo[10 /* SRCBLENDCOLOR */] = pFromA[10 /* SRCBLENDCOLOR */] || pFromB[10 /* SRCBLENDCOLOR */];
            pTo[11 /* DESTBLENDCOLOR */] = pFromA[11 /* DESTBLENDCOLOR */] || pFromB[11 /* DESTBLENDCOLOR */];
            pTo[12 /* SRCBLENDALPHA */] = pFromA[12 /* SRCBLENDALPHA */] || pFromB[12 /* SRCBLENDALPHA */];
            pTo[13 /* DESTBLENDALPHA */] = pFromA[13 /* DESTBLENDALPHA */] || pFromB[13 /* DESTBLENDALPHA */];
            pTo[14 /* BLENDEQUATIONCOLOR */] = pFromA[14 /* BLENDEQUATIONCOLOR */] || pFromB[14 /* BLENDEQUATIONCOLOR */];
            pTo[15 /* BLENDEQUATIONALPHA */] = pFromA[15 /* BLENDEQUATIONALPHA */] || pFromB[15 /* BLENDEQUATIONALPHA */];
            pTo[16 /* ZFUNC */] = pFromA[16 /* ZFUNC */] || pFromB[16 /* ZFUNC */];
            pTo[17 /* ALPHABLENDENABLE */] = pFromA[17 /* ALPHABLENDENABLE */] || pFromB[17 /* ALPHABLENDENABLE */];
            pTo[18 /* ALPHATESTENABLE */] = pFromA[18 /* ALPHATESTENABLE */] || pFromB[18 /* ALPHATESTENABLE */];
        }
        render.mergeRenderStateMap = mergeRenderStateMap;

        function clearRenderStateMap(pMap) {
            pMap[0 /* BLENDENABLE */] = 0 /* UNDEF */;
            pMap[1 /* CULLFACEENABLE */] = 0 /* UNDEF */;
            pMap[2 /* ZENABLE */] = 0 /* UNDEF */;
            pMap[3 /* ZWRITEENABLE */] = 0 /* UNDEF */;
            pMap[4 /* DITHERENABLE */] = 0 /* UNDEF */;
            pMap[5 /* SCISSORTESTENABLE */] = 0 /* UNDEF */;
            pMap[6 /* STENCILTESTENABLE */] = 0 /* UNDEF */;
            pMap[7 /* POLYGONOFFSETFILLENABLE */] = 0 /* UNDEF */;
            pMap[8 /* CULLFACE */] = 0 /* UNDEF */;
            pMap[9 /* FRONTFACE */] = 0 /* UNDEF */;
            pMap[10 /* SRCBLENDCOLOR */] = 0 /* UNDEF */;
            pMap[11 /* DESTBLENDCOLOR */] = 0 /* UNDEF */;
            pMap[12 /* SRCBLENDALPHA */] = 0 /* UNDEF */;
            pMap[13 /* DESTBLENDALPHA */] = 0 /* UNDEF */;
            pMap[14 /* BLENDEQUATIONCOLOR */] = 0 /* UNDEF */;
            pMap[15 /* BLENDEQUATIONALPHA */] = 0 /* UNDEF */;
            pMap[16 /* ZFUNC */] = 0 /* UNDEF */;
            pMap[17 /* ALPHABLENDENABLE */] = 0 /* UNDEF */;
            pMap[18 /* ALPHATESTENABLE */] = 0 /* UNDEF */;
        }
        render.clearRenderStateMap = clearRenderStateMap;

        function createSamplerState() {
            return {
                textureName: "",
                texture: null,
                wrap_s: 0 /* UNDEF */,
                wrap_t: 0 /* UNDEF */,
                mag_filter: 0 /* UNDEF */,
                min_filter: 0 /* UNDEF */
            };
        }
        render.createSamplerState = createSamplerState;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="../idl/IObjectArray.ts" />
/// <reference path="../logger.ts" />
var akra;
(function (akra) {
    (function (util) {
        var ObjectArray = (function () {
            function ObjectArray(pElements) {
                this._pData = [];
                this._bLock = false;
                this._iLength = 0;
                if (arguments.length) {
                    this.fromArray(pElements);
                }
            }
            ObjectArray.prototype.getLength = function () {
                return this._iLength;
            };

            ObjectArray.prototype.lock = function () {
                this._bLock = true;
            };

            ObjectArray.prototype.unlock = function () {
                this._bLock = false;
            };

            ObjectArray.prototype.isLocked = function () {
                return this._bLock;
            };

            ObjectArray.prototype.clear = function (bRemoveLinks) {
                if (typeof bRemoveLinks === "undefined") { bRemoveLinks = false; }
                //"cannot clear. array is locked."
                akra.debug.assert(!this._bLock);

                this._iLength = 0;

                if (bRemoveLinks) {
                    for (var i = 0; i < this._pData.length; ++i) {
                        this._pData[i] = null;
                    }
                }

                return this;
            };

            ObjectArray.prototype.release = function () {
                this.clear(true);
                this._pData.clear();
                return this;
            };

            ObjectArray.prototype.value = function (n) {
                return this._pData[n];
            };

            ObjectArray.prototype.extend = function (n) {
                if (this._pData.length < n) {
                    for (var i = this._pData.length; i < n; ++i) {
                        this._pData[i] = null;
                    }
                }
            };

            ObjectArray.prototype.set = function (n, pData) {
                //"cannot clear. array is locked."
                akra.debug.assert(!this._bLock);

                var N = n + 1;

                this.extend(N);

                if (this._iLength < N) {
                    this._iLength = N;
                }

                this._pData[n] = pData;

                return this;
            };

            ObjectArray.prototype.fromArray = function (pElements, iOffset, iSize) {
                if (typeof iOffset === "undefined") { iOffset = 0; }
                if (typeof iSize === "undefined") { iSize = 0; }
                //cannot clear. array is locked.
                akra.debug.assert(!this._bLock);

                iSize = iSize > 0 ? iSize < pElements.length ? iSize : pElements.length : pElements.length;

                this.extend(iSize);

                for (var i = iOffset, j = 0; i < iSize; ++i, ++j) {
                    this._pData[i] = pElements[j];
                }

                this._iLength = i;

                return this;
            };

            ObjectArray.prototype.push = function (pElement) {
                //"cannot clear. array is locked."
                akra.debug.assert(!this._bLock);

                return this.set(this._iLength, pElement);
            };

            ObjectArray.prototype.pop = function () {
                akra.debug.assert(!this._bLock, "cannot clear. array is locked.");
                return this._iLength > 0 ? this._pData[--this._iLength] : null;
            };

            ObjectArray.prototype.swap = function (i, j) {
                //"cannot clear. array is locked."
                akra.debug.assert(!this._bLock);

                //"invalid swap index."
                akra.debug.assert(i < this._iLength && j < this._iLength);

                this._pData.swap(i, j);

                return this;
            };

            ObjectArray.prototype.takeAt = function (iPos) {
                var pValue = this.value(iPos);

                for (var i = iPos + 1, j = iPos; i < this.getLength(); ++i, ++j) {
                    this._pData[j] = this._pData[i];
                }

                this._iLength--;

                return pValue;
            };

            ObjectArray.prototype.indexOf = function (pObject) {
                for (var i = 0; i < this._iLength; i++) {
                    if (pObject === this._pData[i]) {
                        return i;
                    }
                }

                return -1;
            };
            return ObjectArray;
        })();
        util.ObjectArray = ObjectArray;
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
/// <reference path="../idl/IStringDictionary.ts" />
/// <reference path="../idl/IMap.ts" />
var akra;
(function (akra) {
    (function (stringUtils) {
        var StringDictionary = (function () {
            function StringDictionary() {
                this._pDictionary = null;
                this._pIndexToEntryMap = null;
                this._nEntryCount = 1;
                this._pDictionary = {};
                this._pIndexToEntryMap = {};
            }
            StringDictionary.prototype.add = function (sEntry) {
                if (!akra.isDef(this._pDictionary[sEntry])) {
                    this._pDictionary[sEntry] = this._nEntryCount++;
                    this._pIndexToEntryMap[this._nEntryCount - 1] = sEntry;
                }

                return this._pDictionary[sEntry];
            };

            StringDictionary.prototype.index = function (sEntry) {
                return this._pDictionary[sEntry] || 0;
            };

            StringDictionary.prototype.findEntry = function (iIndex) {
                return this._pIndexToEntryMap[iIndex];
            };
            return StringDictionary;
        })();
        stringUtils.StringDictionary = StringDictionary;
    })(akra.stringUtils || (akra.stringUtils = {}));
    var stringUtils = akra.stringUtils;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EEffectErrors) {
        EEffectErrors[EEffectErrors["REDEFINE_SYSTEM_TYPE"] = 2201] = "REDEFINE_SYSTEM_TYPE";
        EEffectErrors[EEffectErrors["REDEFINE_TYPE"] = 2202] = "REDEFINE_TYPE";
        EEffectErrors[EEffectErrors["REDEFINE_VARIABLE"] = 2234] = "REDEFINE_VARIABLE";
        EEffectErrors[EEffectErrors["REDEFINE_SYSTEM_VARIABLE"] = 2235] = "REDEFINE_SYSTEM_VARIABLE";
        EEffectErrors[EEffectErrors["REDEFINE_FUNCTION"] = 2236] = "REDEFINE_FUNCTION";
        EEffectErrors[EEffectErrors["REDEFINE_SYSTEM_FUNCTION"] = 2237] = "REDEFINE_SYSTEM_FUNCTION";

        EEffectErrors[EEffectErrors["UNSUPPORTED_TYPEDECL"] = 2203] = "UNSUPPORTED_TYPEDECL";
        EEffectErrors[EEffectErrors["UNSUPPORTED_EXPR"] = 2204] = "UNSUPPORTED_EXPR";
        EEffectErrors[EEffectErrors["UNKNOWN_VARNAME"] = 2205] = "UNKNOWN_VARNAME";
        EEffectErrors[EEffectErrors["BAD_ARITHMETIC_OPERATION"] = 2206] = "BAD_ARITHMETIC_OPERATION";
        EEffectErrors[EEffectErrors["BAD_ARITHMETIC_ASSIGNMENT_OPERATION"] = 2207] = "BAD_ARITHMETIC_ASSIGNMENT_OPERATION";
        EEffectErrors[EEffectErrors["BAD_ASSIGNMENT_OPERATION"] = 2208] = "BAD_ASSIGNMENT_OPERATION";
        EEffectErrors[EEffectErrors["BAD_RELATIONAL_OPERATION"] = 2209] = "BAD_RELATIONAL_OPERATION";
        EEffectErrors[EEffectErrors["BAD_LOGICAL_OPERATION"] = 2210] = "BAD_LOGICAL_OPERATION";
        EEffectErrors[EEffectErrors["BAD_CONDITION_TYPE"] = 2211] = "BAD_CONDITION_TYPE";
        EEffectErrors[EEffectErrors["BAD_CONDITION_VALUE_TYPES"] = 2212] = "BAD_CONDITION_VALUE_TYPES";
        EEffectErrors[EEffectErrors["BAD_CAST_TYPE_USAGE"] = 2213] = "BAD_CAST_TYPE_USAGE";
        EEffectErrors[EEffectErrors["BAD_CAST_TYPE_NOT_BASE"] = 2214] = "BAD_CAST_TYPE_NOT_BASE";
        EEffectErrors[EEffectErrors["BAD_CAST_UNKNOWN_TYPE"] = 2215] = "BAD_CAST_UNKNOWN_TYPE";
        EEffectErrors[EEffectErrors["BAD_UNARY_OPERATION"] = 2216] = "BAD_UNARY_OPERATION";
        EEffectErrors[EEffectErrors["BAD_POSTIX_NOT_ARRAY"] = 2217] = "BAD_POSTIX_NOT_ARRAY";
        EEffectErrors[EEffectErrors["BAD_POSTIX_NOT_INT_INDEX"] = 2218] = "BAD_POSTIX_NOT_INT_INDEX";
        EEffectErrors[EEffectErrors["BAD_POSTIX_NOT_FIELD"] = 2219] = "BAD_POSTIX_NOT_FIELD";
        EEffectErrors[EEffectErrors["BAD_POSTIX_NOT_POINTER"] = 2220] = "BAD_POSTIX_NOT_POINTER";
        EEffectErrors[EEffectErrors["BAD_POSTIX_ARITHMETIC"] = 2221] = "BAD_POSTIX_ARITHMETIC";
        EEffectErrors[EEffectErrors["BAD_PRIMARY_NOT_POINT"] = 2222] = "BAD_PRIMARY_NOT_POINT";
        EEffectErrors[EEffectErrors["BAD_COMPLEX_NOT_FUNCTION"] = 2223] = "BAD_COMPLEX_NOT_FUNCTION";
        EEffectErrors[EEffectErrors["BAD_COMPLEX_NOT_TYPE"] = 2224] = "BAD_COMPLEX_NOT_TYPE";
        EEffectErrors[EEffectErrors["BAD_COMPLEX_NOT_CONSTRUCTOR"] = 2225] = "BAD_COMPLEX_NOT_CONSTRUCTOR";
        EEffectErrors[EEffectErrors["BAD_COMPILE_NOT_FUNCTION"] = 2226] = "BAD_COMPILE_NOT_FUNCTION";
        EEffectErrors[EEffectErrors["BAD_REDEFINE_FUNCTION"] = 2227] = "BAD_REDEFINE_FUNCTION";
        EEffectErrors[EEffectErrors["BAD_WHILE_CONDITION"] = 2228] = "BAD_WHILE_CONDITION";
        EEffectErrors[EEffectErrors["BAD_DO_WHILE_CONDITION"] = 2229] = "BAD_DO_WHILE_CONDITION";
        EEffectErrors[EEffectErrors["BAD_IF_CONDITION"] = 2230] = "BAD_IF_CONDITION";
        EEffectErrors[EEffectErrors["BAD_FOR_INIT_EXPR"] = 2231] = "BAD_FOR_INIT_EXPR";
        EEffectErrors[EEffectErrors["BAD_FOR_INIT_EMPTY_ITERATOR"] = 2232] = "BAD_FOR_INIT_EMPTY_ITERATOR";
        EEffectErrors[EEffectErrors["BAD_FOR_COND_EMPTY"] = 2233] = "BAD_FOR_COND_EMPTY";
        EEffectErrors[EEffectErrors["BAD_FOR_COND_RELATION"] = 2238] = "BAD_FOR_COND_RELATION";
        EEffectErrors[EEffectErrors["BAD_FOR_STEP_EMPTY"] = 2239] = "BAD_FOR_STEP_EMPTY";
        EEffectErrors[EEffectErrors["BAD_FOR_STEP_OPERATOR"] = 2240] = "BAD_FOR_STEP_OPERATOR";
        EEffectErrors[EEffectErrors["BAD_FOR_STEP_EXPRESSION"] = 2241] = "BAD_FOR_STEP_EXPRESSION";
        EEffectErrors[EEffectErrors["BAD_NEW_FIELD_FOR_STRUCT_NAME"] = 2242] = "BAD_NEW_FIELD_FOR_STRUCT_NAME";
        EEffectErrors[EEffectErrors["BAD_NEW_FIELD_FOR_STRUCT_SEMANTIC"] = 2243] = "BAD_NEW_FIELD_FOR_STRUCT_SEMANTIC";
        EEffectErrors[EEffectErrors["BAD_NEW_ANNOTATION_VAR"] = 2244] = "BAD_NEW_ANNOTATION_VAR";
        EEffectErrors[EEffectErrors["BAD_FUNCTION_PARAMETER_DEFENITION_NEED_DEFAULT"] = 2245] = "BAD_FUNCTION_PARAMETER_DEFENITION_NEED_DEFAULT";
        EEffectErrors[EEffectErrors["BAD_CANNOT_CHOOSE_FUNCTION"] = 2246] = "BAD_CANNOT_CHOOSE_FUNCTION";
        EEffectErrors[EEffectErrors["BAD_FUNCTION_DEF_RETURN_TYPE"] = 2247] = "BAD_FUNCTION_DEF_RETURN_TYPE";
        EEffectErrors[EEffectErrors["BAD_SYSTEM_FUNCTION_REDEFINE"] = 2248] = "BAD_SYSTEM_FUNCTION_REDEFINE";
        EEffectErrors[EEffectErrors["BAD_SYSTEM_FUNCTION_RETURN_TYPE"] = 2249] = "BAD_SYSTEM_FUNCTION_RETURN_TYPE";
        EEffectErrors[EEffectErrors["BAD_TYPE_NAME_NOT_TYPE"] = 2250] = "BAD_TYPE_NAME_NOT_TYPE";
        EEffectErrors[EEffectErrors["BAD_TYPE_VECTOR_MATRIX"] = 2251] = "BAD_TYPE_VECTOR_MATRIX";
        EEffectErrors[EEffectErrors["BAD_TECHNIQUE_REDEFINE_NAME"] = 2252] = "BAD_TECHNIQUE_REDEFINE_NAME";
        EEffectErrors[EEffectErrors["BAD_MEMOF_ARGUMENT"] = 2253] = "BAD_MEMOF_ARGUMENT";
        EEffectErrors[EEffectErrors["BAD_MEMOF_NO_BUFFER"] = 2254] = "BAD_MEMOF_NO_BUFFER";
        EEffectErrors[EEffectErrors["BAD_FUNCTION_USAGE_RECURSION"] = 2255] = "BAD_FUNCTION_USAGE_RECURSION";
        EEffectErrors[EEffectErrors["BAD_FUNCTION_USAGE_BLACKLIST"] = 2256] = "BAD_FUNCTION_USAGE_BLACKLIST";
        EEffectErrors[EEffectErrors["BAD_FUNCTION_USAGE_VERTEX"] = 2257] = "BAD_FUNCTION_USAGE_VERTEX";
        EEffectErrors[EEffectErrors["BAD_FUNCTION_USAGE_PIXEL"] = 2258] = "BAD_FUNCTION_USAGE_PIXEL";
        EEffectErrors[EEffectErrors["BAD_FUNCTION_VERTEX_DEFENITION"] = 2259] = "BAD_FUNCTION_VERTEX_DEFENITION";
        EEffectErrors[EEffectErrors["BAD_FUNCTION_PIXEL_DEFENITION"] = 2260] = "BAD_FUNCTION_PIXEL_DEFENITION";
        EEffectErrors[EEffectErrors["BAD_RETURN_STMT_VOID"] = 2261] = "BAD_RETURN_STMT_VOID";
        EEffectErrors[EEffectErrors["BAD_RETURN_STMT_EMPTY"] = 2262] = "BAD_RETURN_STMT_EMPTY";
        EEffectErrors[EEffectErrors["BAD_RETURN_STMT_NOT_EQUAL_TYPES"] = 2263] = "BAD_RETURN_STMT_NOT_EQUAL_TYPES";
        EEffectErrors[EEffectErrors["BAD_RETURN_TYPE_FOR_FUNCTION"] = 2264] = "BAD_RETURN_TYPE_FOR_FUNCTION";
        EEffectErrors[EEffectErrors["BAD_FUNCTION_PARAMETER_USAGE"] = 2265] = "BAD_FUNCTION_PARAMETER_USAGE";
        EEffectErrors[EEffectErrors["BAD_OUT_VARIABLE_IN_FUNCTION"] = 2266] = "BAD_OUT_VARIABLE_IN_FUNCTION";
        EEffectErrors[EEffectErrors["BAD_TYPE_FOR_WRITE"] = 2267] = "BAD_TYPE_FOR_WRITE";
        EEffectErrors[EEffectErrors["BAD_TYPE_FOR_READ"] = 2268] = "BAD_TYPE_FOR_READ";
        EEffectErrors[EEffectErrors["BAD_VARIABLE_INITIALIZER"] = 2269] = "BAD_VARIABLE_INITIALIZER";
        EEffectErrors[EEffectErrors["NOT_SUPPORT_STATE_INDEX"] = 2270] = "NOT_SUPPORT_STATE_INDEX";
        EEffectErrors[EEffectErrors["BAD_TEXTURE_FOR_SAMLER"] = 2271] = "BAD_TEXTURE_FOR_SAMLER";
        EEffectErrors[EEffectErrors["CANNOT_CALCULATE_PADDINGS"] = 2272] = "CANNOT_CALCULATE_PADDINGS";
        EEffectErrors[EEffectErrors["UNSUPPORTED_EXTRACT_BASE_TYPE"] = 2273] = "UNSUPPORTED_EXTRACT_BASE_TYPE";
        EEffectErrors[EEffectErrors["BAD_EXTRACTING"] = 2274] = "BAD_EXTRACTING";
        EEffectErrors[EEffectErrors["BAD_TECHNIQUE_IMPORT"] = 2275] = "BAD_TECHNIQUE_IMPORT";
        EEffectErrors[EEffectErrors["BAD_USE_OF_ENGINE_VARIABLE"] = 2276] = "BAD_USE_OF_ENGINE_VARIABLE";
        EEffectErrors[EEffectErrors["BAD_IMPORTED_COMPONENT_NOT_EXIST"] = 2277] = "BAD_IMPORTED_COMPONENT_NOT_EXIST";
        EEffectErrors[EEffectErrors["CANNOT_ADD_SHARED_VARIABLE"] = 2278] = "CANNOT_ADD_SHARED_VARIABLE";
        EEffectErrors[EEffectErrors["BAD_FUNCTION_DONT_HAVE_RETURN_STMT"] = 2279] = "BAD_FUNCTION_DONT_HAVE_RETURN_STMT";
    })(akra.EEffectErrors || (akra.EEffectErrors = {}));
    var EEffectErrors = akra.EEffectErrors;

    (function (EEffectTempErrors) {
        EEffectTempErrors[EEffectTempErrors["BAD_ARRAY_OF_POINTERS"] = 2300] = "BAD_ARRAY_OF_POINTERS";
        EEffectTempErrors[EEffectTempErrors["BAD_LOCAL_OF_SHADER_INPUT"] = 2301] = "BAD_LOCAL_OF_SHADER_INPUT";
        EEffectTempErrors[EEffectTempErrors["BAD_LOCAL_OF_SHADER_OUTPUT"] = 2302] = "BAD_LOCAL_OF_SHADER_OUTPUT";
        EEffectTempErrors[EEffectTempErrors["UNSUPPORTED_PROVIDE_AS"] = 2303] = "UNSUPPORTED_PROVIDE_AS";
    })(akra.EEffectTempErrors || (akra.EEffectTempErrors = {}));
    var EEffectTempErrors = akra.EEffectTempErrors;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EScopeType) {
        EScopeType[EScopeType["k_Default"] = 0] = "k_Default";
        EScopeType[EScopeType["k_Struct"] = 1] = "k_Struct";
        EScopeType[EScopeType["k_Annotation"] = 2] = "k_Annotation";
    })(akra.EScopeType || (akra.EScopeType = {}));
    var EScopeType = akra.EScopeType;

    
})(akra || (akra = {}));
/// <reference path="../idl/EEffectErrors.ts" />
/// <reference path="../logger.ts" />
var akra;
(function (akra) {
    (function (fx) {
        function registerCode(iErr, sDesc) {
            akra.logger.registerCode(iErr, sDesc);
        }

        akra.logger.registerCodeFamily(2200, 2500, "EffectSyntaxErrors");

        registerCode(2201 /* REDEFINE_SYSTEM_TYPE */, "You trying to redefine system type: {typeName}. In line: {line}. In column: {column}");
        registerCode(2202 /* REDEFINE_TYPE */, "You trying to redefine type: {typeName}. In line: {line}. In column: {column}");
        registerCode(2203 /* UNSUPPORTED_TYPEDECL */, "You try to use unssuported type declaration. We implement it soon. In line: {line}.");
        registerCode(2204 /* UNSUPPORTED_EXPR */, "You try to use unssuported expr: {exprName}. We implement it soon. In line: {line}.");
        registerCode(2205 /* UNKNOWN_VARNAME */, "Unknown variable name: {varName}. In line: {line}. In column: {column}");
        registerCode(2206 /* BAD_ARITHMETIC_OPERATION */, "Invalid arithmetic operation!. There no operator '{operator}'" + " for left-type '{leftTypeName}' " + " and right-type '{rightTypeName}'. In line: {line}.");
        registerCode(2207 /* BAD_ARITHMETIC_ASSIGNMENT_OPERATION */, "Invalid arithmetic-assignment operation!. " + " There no operator {operator} for left-type '{leftTypeName}' " + " and right-type '{rightTypeName}'. In line: {line}.");
        registerCode(2208 /* BAD_ASSIGNMENT_OPERATION */, "Invalid assignment operation!. It`s no possible to do assignment " + " between left-type '{leftTypeName}' " + " and right-type '{rightTypeName}'. In line: {line}.");
        registerCode(2209 /* BAD_RELATIONAL_OPERATION */, "Invalid relational operation!. There no operator {operator} " + " for left-type '{leftTypeName}' " + " and right-type '{rightTypeName}'. In line: {line}.");
        registerCode(2210 /* BAD_LOGICAL_OPERATION */, "Invalid logical operation!. In operator: {operator}. " + " Cannot convert type '{typeName}' to 'boolean'. In line: {line}.");
        registerCode(2211 /* BAD_CONDITION_TYPE */, "Invalid conditional expression!. Cannot convert type '{typeName}' to 'boolean'. " + " In line: {line}.");
        registerCode(2212 /* BAD_CONDITION_VALUE_TYPES */, "Invalid conditional expression!. Type '{leftTypeName}' and type '{rightTypeName}'" + " are not equal. In line: {line}.");
        registerCode(2213 /* BAD_CAST_TYPE_USAGE */, "Invalid type cast!. Bad type casting. Only base types without usages are supported. " + " WebGL don`t support so casting. In line: {line}.");
        registerCode(2214 /* BAD_CAST_TYPE_NOT_BASE */, "Invalid type cast!. Bad type for casting '{typeName}'. " + " WebGL support only base-type casting. In line: {line}.");
        registerCode(2216 /* BAD_UNARY_OPERATION */, "Invalid unary expression!. Bad type: '{typeName}' " + " for operator '{opeator}'. In line: {line}.");
        registerCode(2217 /* BAD_POSTIX_NOT_ARRAY */, "Invalid postfix-array expression!. " + " Type of expression is not array: '{typeName}'. In line: {line}.");
        registerCode(2218 /* BAD_POSTIX_NOT_INT_INDEX */, "Invalid postfix-array expression!. Bad type of index: '{typeName}'. " + "Must be 'int'. In line: {line}.");
        registerCode(2219 /* BAD_POSTIX_NOT_FIELD */, "Invalid postfix-point expression!. Type '{typeName}' has no field '{fieldName}'. " + "In line: {line}.");
        registerCode(2220 /* BAD_POSTIX_NOT_POINTER */, "Invalid postfix-point expression!. Type '{typeName}' is not pointer. " + "In line: {line}.");
        registerCode(2221 /* BAD_POSTIX_ARITHMETIC */, "Invalid postfix-arithmetic expression!. Bad type '{typeName}' " + "for operator {operator}. In line: {line}.");
        registerCode(2222 /* BAD_PRIMARY_NOT_POINT */, "Invalid primary expression!. Bad type '{typeName}'." + "It`s not pointer. In line: {line}.");
        registerCode(2223 /* BAD_COMPLEX_NOT_FUNCTION */, "Invalid function call expression!. Could not find function-signature " + "with name {funcName} and so types. In line: {line}.");
        registerCode(2224 /* BAD_COMPLEX_NOT_TYPE */, "Invalid constructor call!. There are not so type. In line: {line}.");
        registerCode(2225 /* BAD_COMPLEX_NOT_CONSTRUCTOR */, "Invalid constructor call!. Could not find constructor-signature " + "with name {typeName} and so types. In line: {line}.");
        registerCode(2226 /* BAD_COMPILE_NOT_FUNCTION */, "Invalid compile expression!. Could not find function-signature " + "with name {funcName} and so types. In line: {line}.");
        registerCode(2227 /* BAD_REDEFINE_FUNCTION */, "You try to redefine function. With name {funcName}. In line: {line}.");
        registerCode(2228 /* BAD_WHILE_CONDITION */, "Bad type of while-condition. Must be 'boolean' but it is '{typeName}'. " + "In line: {line}.");
        registerCode(2229 /* BAD_DO_WHILE_CONDITION */, "Bad type of do-while-condition. Must be 'boolean' but it is '{typeName}'. " + "In line: {line}.");
        registerCode(2230 /* BAD_IF_CONDITION */, "Bad type of if-condition. Must be 'boolean' but it is '{typeName}'. " + "In line: {line}.");
        registerCode(2231 /* BAD_FOR_INIT_EXPR */, "Bad for-init expression. WebGL support only VariableDecl as for-init expression, " + "like \"int i = 0;\" or \"float i = 0.0;\". " + "In line: {line}.");
        registerCode(2232 /* BAD_FOR_INIT_EMPTY_ITERATOR */, "Bad for-init expression. WebGL support only VariableDecl as for-init expression, " + "like \"int i = 0;\" or \"float i = 0.0;\". " + "In line: {line}.");
        registerCode(2233 /* BAD_FOR_COND_EMPTY */, "Bad for-cond expression. WebGL does not support empty conditional expression in for-loop. " + "In line: {line}.");
        registerCode(2238 /* BAD_FOR_COND_RELATION */, "Bad for-cond expression. WebGL support only relational expression for condition in for-loop. " + "In line: {line}.");
        registerCode(2239 /* BAD_FOR_STEP_EMPTY */, "Bad for-step expression. WebGL does not support empty step expression. " + "In line: {line}.");
        registerCode(2240 /* BAD_FOR_STEP_OPERATOR */, "Bad for-step expression. WebGL does not support operator '{operator}' in step expression. " + "In line: {line}.");
        registerCode(2241 /* BAD_FOR_STEP_EXPRESSION */, "Bad for-step expression. WebGL support only unary and assignment expression in for-step. " + "In line: {line}.");
        registerCode(2235 /* REDEFINE_SYSTEM_VARIABLE */, "You trying to redefine system variable: {varName}. In line: {line}. In column: {column}");
        registerCode(2234 /* REDEFINE_VARIABLE */, "You trying to redefine variable: {varName}. In line: {line}. In column: {column}");
        registerCode(2237 /* REDEFINE_SYSTEM_FUNCTION */, "You trying to redefine system function: {funcName}. In line: {line}. In column: {column}");
        registerCode(2236 /* REDEFINE_FUNCTION */, "You trying to redefine function: {funcName}. In line: {line}. In column: {column}");
        registerCode(2242 /* BAD_NEW_FIELD_FOR_STRUCT_NAME */, "You trying to add field to struct with name '{varName}', but it`s already in it. " + "In line: {line}. In column: {column}");
        registerCode(2243 /* BAD_NEW_FIELD_FOR_STRUCT_SEMANTIC */, "You trying to add field to struct with semantic '{semanticName}'," + "but struct already has this semantic." + "In line: {line}. In column: {column}");
        registerCode(2244 /* BAD_NEW_ANNOTATION_VAR */, "Bad variable name '{varName}'. Annotation already has variable with that name." + "In line: {line}. In column: {column}");
        registerCode(2245 /* BAD_FUNCTION_PARAMETER_DEFENITION_NEED_DEFAULT */, "Bad parameter '{varName}' in function '{funcName}'. Need default value." + "In line: {line}. In column: {column}");
        registerCode(2246 /* BAD_CANNOT_CHOOSE_FUNCTION */, "Bad function call. There are two or more call signatures for function '{funcName}'." + "In line: {line}. In column: {column}");
        registerCode(2247 /* BAD_FUNCTION_DEF_RETURN_TYPE */, "Bad function definition. There are two or more different retturn type signatures for function '{funcName}'." + "In line: {line}. In column: {column}");
        registerCode(2248 /* BAD_SYSTEM_FUNCTION_REDEFINE */, "Bad system function '{funcName}'. Already have this function.");
        registerCode(2250 /* BAD_TYPE_NAME_NOT_TYPE */, "Bad type. Could not find type with name '{typeName}'." + "In line: {line}. In column: {column}");
        registerCode(2251 /* BAD_TYPE_VECTOR_MATRIX */, "Bad type. We don`t support vector and matrix typename." + "In line: {line}. In column: {column}");
        registerCode(2252 /* BAD_TECHNIQUE_REDEFINE_NAME */, "Bad technique name '{techName}'. Effect already have technique with that name." + "In line: {line}. In column: {column}");
        registerCode(2253 /* BAD_MEMOF_ARGUMENT */, "Bad 'memof'-operator argument. Literal for its argument is bad idea." + "In line: {line}. In column: {column}");
        registerCode(2254 /* BAD_MEMOF_NO_BUFFER */, "Bad 'memof'-operator argument. No buffer for argument." + "In line: {line}. In column: {column}");
        registerCode(2255 /* BAD_FUNCTION_USAGE_RECURSION */, "Bad function '{funcDef}'. It is recursion.");
        registerCode(2256 /* BAD_FUNCTION_USAGE_BLACKLIST */, "Bad function '{funcDef}'. It use bad-function with recursion.");
        registerCode(2257 /* BAD_FUNCTION_USAGE_VERTEX */, "Bad function '{funcDef}'. Can not use in vertex-shader.");
        registerCode(2258 /* BAD_FUNCTION_USAGE_PIXEL */, "Bad function '{funcDef}'. Can not use in pixel-shader.");
        registerCode(2259 /* BAD_FUNCTION_VERTEX_DEFENITION */, "Bad function with defenition '{funcDef}'. Can not be used as vertex-shader.");
        registerCode(2260 /* BAD_FUNCTION_PIXEL_DEFENITION */, "Bad function with defenition '{funcDef}'. Can not be used as pixel-shader.");
        registerCode(2261 /* BAD_RETURN_STMT_VOID */, "Bad return stmt. You try to return something in void-function." + "In line: {line}. In column: {column}");
        registerCode(2262 /* BAD_RETURN_STMT_EMPTY */, "Bad return stmt. You can not call empty return in non-void-function." + "In line: {line}. In column: {column}");
        registerCode(2263 /* BAD_RETURN_STMT_NOT_EQUAL_TYPES */, "Bad return stmt. Types of return expression and return type of function are not equal." + "In line: {line}. In column: {column}");
        registerCode(2264 /* BAD_RETURN_TYPE_FOR_FUNCTION */, "Bad return type for '{funcName}'. Return type for function can not contain or be sampler/pointer." + "In line: {line}. In column: {column}");
        registerCode(2265 /* BAD_FUNCTION_PARAMETER_USAGE */, "Bad parameter '{varName}' in function '{funcName}'. Bad usage." + "In line: {line}. In column: {column}");
        registerCode(2266 /* BAD_OUT_VARIABLE_IN_FUNCTION */, "Bad variable with name 'Out'. It is sytem for used like return variable in shaders." + "In line: {line}. In column: {column}");
        registerCode(2267 /* BAD_TYPE_FOR_WRITE */, "Variable type is not writable. " + "In line: {line}. In column: {column}");
        registerCode(2268 /* BAD_TYPE_FOR_READ */, "Variable type is not readable. " + "In line: {line}. In column: {column}");
        registerCode(2269 /* BAD_VARIABLE_INITIALIZER */, "Bad init expr for variable '{varName}'. " + "In line: {line}. In column: {column}");
        registerCode(2270 /* NOT_SUPPORT_STATE_INDEX */, "Don`t supported construction '[uint]' in sampler_state. " + "In line: {line}. In column: {column}");
        registerCode(2271 /* BAD_TEXTURE_FOR_SAMLER */, "Incorrect texture setup for sampler. " + "In line: {line}. In column: {column}");
        registerCode(2272 /* CANNOT_CALCULATE_PADDINGS */, "Can not calculate padding for type '{typeName}'.");
        registerCode(2273 /* UNSUPPORTED_EXTRACT_BASE_TYPE */, "Can not extract type '{typeName}'.");
        registerCode(2274 /* BAD_EXTRACTING */, "Bad extract exrpression.");
        registerCode(2275 /* BAD_TECHNIQUE_IMPORT */, "Bad imports in technique '{techniqueName}'.");
        registerCode(2276 /* BAD_USE_OF_ENGINE_VARIABLE */, "You try use 'engine' variable in out of pass." + "In line: {line}. In column: {column}.");
        registerCode(2277 /* BAD_IMPORTED_COMPONENT_NOT_EXIST */, "You try to import not exuisted component '{componentName}'");

        registerCode(2300 /* BAD_ARRAY_OF_POINTERS */, "We don`t support array of pinters now. Only pointe to array.\
							  In line: {line}. In column: {column}");
        registerCode(2301 /* BAD_LOCAL_OF_SHADER_INPUT */, "We don`t support using complex shader input like functions params.\
							 Shader: '{funcName}'");
        registerCode(2302 /* BAD_LOCAL_OF_SHADER_OUTPUT */, "We don`t support using complex shader output like functions params.\
							 Shader: '{funcName}'");
        registerCode(2303 /* UNSUPPORTED_PROVIDE_AS */, "We don`t support 'provide ... as' operator now.");

        registerCode(2279 /* BAD_FUNCTION_DONT_HAVE_RETURN_STMT */, "Function '{funcName}' with non-void return type dont`t have return stmt.");

        function sourceLocationToString(pLocation) {
            var sLocation = "[" + pLocation.file + ":" + pLocation.line.toString() + "]: ";
            return sLocation;
        }

        function syntaxErrorLogRoutine(pLogEntity) {
            var sPosition = sourceLocationToString(pLogEntity.location);
            var sError = "Code: " + pLogEntity.code.toString() + ". ";
            var pParseMessage = pLogEntity.message.split(/\{(\w+)\}/);
            var pInfo = pLogEntity.info;

            for (var i = 0; i < pParseMessage.length; i++) {
                if (akra.isDef(pInfo[pParseMessage[i]])) {
                    pParseMessage[i] = pInfo[pParseMessage[i]];
                }
            }

            var sMessage = sPosition + sError + pParseMessage.join("");

            console["error"].call(console, sMessage);
        }

        akra.logger.setCodeFamilyRoutine("EffectSyntaxErrors", syntaxErrorLogRoutine, 8 /* ERROR */ | 16 /* CRITICAL */);
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/IAFXInstruction.ts" />
/// <reference path="../../idl/parser/IParser.ts" />
/// <reference path="../../common.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            var Instruction = (function () {
                function Instruction() {
                    this._pParentInstruction = null;
                    this._sOperatorName = null;
                    this._pInstructionList = null;
                    this._nInstructions = 0;
                    this._eInstructionType = 0;
                    this._pLastError = null;
                    this._bErrorOccured = false;
                    this._iInstructionID = 0;
                    this._iScope = Instruction.UNDEFINE_SCOPE;
                    this._bVisible = true;
                    this._iInstructionID = Instruction._nInstructionCounter++;
                    this._pParentInstruction = null;
                    this._sOperatorName = null;
                    this._pInstructionList = null;
                    this._nInstructions = 0;
                    this._eInstructionType = 0 /* k_Instruction */;
                    this._pLastError = { code: 0, info: null };
                }
                Instruction.prototype._getParent = function () {
                    return this._pParentInstruction;
                };

                Instruction.prototype._setParent = function (pParentInstruction) {
                    this._pParentInstruction = pParentInstruction;
                };

                Instruction.prototype._getOperator = function () {
                    return this._sOperatorName;
                };

                Instruction.prototype._setOperator = function (sOperator) {
                    this._sOperatorName = sOperator;
                };

                Instruction.prototype._getInstructions = function () {
                    return this._pInstructionList;
                };

                Instruction.prototype._setInstructions = function (pInstructionList) {
                    this._pInstructionList = pInstructionList;
                };

                Instruction.prototype._getInstructionType = function () {
                    return this._eInstructionType;
                };

                Instruction.prototype._getInstructionID = function () {
                    return this._iInstructionID;
                };

                Instruction.prototype._getScope = function () {
                    return this._iScope !== Instruction.UNDEFINE_SCOPE ? this._iScope : !akra.isNull(this._getParent()) ? this._getParent()._getScope() : Instruction.UNDEFINE_SCOPE;
                };

                Instruction.prototype._setScope = function (iScope) {
                    this._iScope = iScope;
                };

                Instruction.prototype._isInGlobalScope = function () {
                    return this._getScope() === 0;
                };

                Instruction.prototype._getLastError = function () {
                    return this._pLastError;
                };

                Instruction.prototype._setError = function (eCode, pInfo) {
                    if (typeof pInfo === "undefined") { pInfo = null; }
                    this._pLastError.code = eCode;
                    this._pLastError.info = pInfo;
                    this._bErrorOccured = true;
                };

                Instruction.prototype._clearError = function () {
                    this._bErrorOccured = false;
                    this._pLastError.code = 0;
                    this._pLastError.info = null;
                };

                Instruction.prototype._isErrorOccured = function () {
                    return this._bErrorOccured;
                };

                Instruction.prototype._setVisible = function (isVisible) {
                    this._bVisible = isVisible;
                };

                Instruction.prototype._isVisible = function () {
                    return this._bVisible;
                };

                Instruction.prototype._initEmptyInstructions = function () {
                    this._pInstructionList = [];
                };

                Instruction.prototype._push = function (pInstruction, isSetParent) {
                    if (typeof isSetParent === "undefined") { isSetParent = false; }
                    if (!akra.isNull(this._pInstructionList)) {
                        this._pInstructionList[this._nInstructions] = pInstruction;
                        this._nInstructions += 1;
                    }
                    if (isSetParent && !akra.isNull(pInstruction)) {
                        pInstruction._setParent(this);
                    }
                };

                Instruction.prototype._addRoutine = function (fnRoutine, iPriority) {
                    //TODO
                };

                Instruction.prototype._prepareFor = function (eUsedType) {
                    if (!akra.isNull(this._pInstructionList) && this._nInstructions > 0) {
                        for (var i = 0; i < this._nInstructions; i++) {
                            this._pInstructionList[i]._prepareFor(eUsedType);
                        }
                    }
                };

                /**
                * Проверка валидности инструкции
                */
                Instruction.prototype._check = function (eStage, pInfo) {
                    if (typeof pInfo === "undefined") { pInfo = null; }
                    if (this._bErrorOccured) {
                        return false;
                    } else {
                        return true;
                    }
                };

                /**
                * Подготовка интсрукции к дальнейшему анализу
                */
                Instruction.prototype.prepare = function () {
                    return true;
                };

                Instruction.prototype.toString = function () {
                    return null;
                };

                Instruction.prototype._toFinalCode = function () {
                    return "";
                };

                Instruction.prototype._clone = function (pRelationMap) {
                    if (typeof pRelationMap === "undefined") { pRelationMap = {}; }
                    if (akra.isDef(pRelationMap[this._getInstructionID()])) {
                        return pRelationMap[this._getInstructionID()];
                    }

                    var pNewInstruction = new this.constructor();
                    var pParent = this._getParent() || null;

                    if (!akra.isNull(pParent) && akra.isDef(pRelationMap[pParent._getInstructionID()])) {
                        pParent = pRelationMap[pParent._getInstructionID()];
                    }

                    pNewInstruction._setParent(pParent);
                    pRelationMap[this._getInstructionID()] = pNewInstruction;

                    if (!akra.isNull(this._pInstructionList) && akra.isNull(pNewInstruction._getInstructions())) {
                        pNewInstruction._initEmptyInstructions();
                    }

                    for (var i = 0; i < this._nInstructions; i++) {
                        pNewInstruction._push(this._pInstructionList[i]._clone(pRelationMap));
                    }

                    pNewInstruction._setOperator(this._getOperator());

                    return pNewInstruction;
                };
                Instruction._nInstructionCounter = 0;

                Instruction.UNDEFINE_LENGTH = 0xffffff;
                Instruction.UNDEFINE_SIZE = 0xffffff;
                Instruction.UNDEFINE_SCOPE = 0xffffff;
                Instruction.UNDEFINE_PADDING = 0xffffff;
                Instruction.UNDEFINE_NAME = "undef";
                return Instruction;
            })();
            instructions.Instruction = Instruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/IAFXInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        /// <reference path="Instruction.ts" />
        (function (instructions) {
            var TypedInstruction = (function (_super) {
                __extends(TypedInstruction, _super);
                function TypedInstruction() {
                    _super.call(this);
                    this._pType = null;
                    this._eInstructionType = 6 /* k_TypedInstruction */;
                }
                TypedInstruction.prototype._getType = function () {
                    return this._pType;
                };

                TypedInstruction.prototype._setType = function (pType) {
                    this._pType = pType;
                };

                TypedInstruction.prototype._clone = function (pRelationMap) {
                    if (typeof pRelationMap === "undefined") { pRelationMap = {}; }
                    var pClonedInstruction = (_super.prototype._clone.call(this, pRelationMap));
                    if (!akra.isNull(this._getType())) {
                        pClonedInstruction._setType(this._getType()._clone(pRelationMap));
                    }
                    return pClonedInstruction;
                };
                return TypedInstruction;
            })(instructions.Instruction);
            instructions.TypedInstruction = TypedInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/IAFXInstruction.ts" />
/// <reference path="../../idl/ITexture.ts" />
/// <reference path="../../idl/IAFXSamplerState.ts" />
var akra;
(function (akra) {
    (function (fx) {
        /// <reference path="TypedInstruction.ts" />
        (function (instructions) {
            var ExprInstruction = (function (_super) {
                __extends(ExprInstruction, _super);
                /**
                * Respresent all kind of instruction
                */
                function ExprInstruction() {
                    _super.call(this);
                    this._pLastEvalResult = null;
                    this._eInstructionType = 21 /* k_ExprInstruction */;
                }
                ExprInstruction.prototype._evaluate = function () {
                    return false;
                };

                ExprInstruction.prototype._simplify = function () {
                    return false;
                };

                ExprInstruction.prototype._getEvalValue = function () {
                    return this._pLastEvalResult;
                };

                ExprInstruction.prototype._isConst = function () {
                    return false;
                };

                ExprInstruction.prototype._getType = function () {
                    return _super.prototype._getType.call(this);
                };

                ExprInstruction.prototype._clone = function (pRelationMap) {
                    return _super.prototype._clone.call(this, pRelationMap);
                };

                ExprInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    var pInstructionList = this._getInstructions();

                    if (akra.isNull(pInstructionList)) {
                        return;
                    }

                    for (var i = 0; i < this._nInstructions; i++) {
                        pInstructionList[i]._addUsedData(pUsedDataCollector, eUsedMode);
                    }
                };
                return ExprInstruction;
            })(instructions.TypedInstruction);
            instructions.ExprInstruction = ExprInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Represent someExpr + / - * % someExpr
            * (+|-|*|/|%) Instruction Instruction
            */
            var ArithmeticExprInstruction = (function (_super) {
                __extends(ArithmeticExprInstruction, _super);
                function ArithmeticExprInstruction() {
                    _super.call(this);
                    this._pInstructionList = [null, null];
                    this._eInstructionType = 23 /* k_ArithmeticExprInstruction */;
                }
                ArithmeticExprInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    _super.prototype._addUsedData.call(this, pUsedDataCollector, 0 /* k_Read */);
                };

                ArithmeticExprInstruction.prototype._evaluate = function () {
                    var pOperands = this._getInstructions();
                    var pValL = pOperands[0]._evaluate() ? pOperands[0]._getEvalValue() : null;
                    var pValR = pOperands[1]._evaluate() ? pOperands[1]._getEvalValue() : null;

                    if (akra.isNull(pValL) || akra.isNull(pValR)) {
                        return false;
                    }

                    try  {
                        switch (this._getOperator()) {
                            case "+":
                                this._pLastEvalResult = pValL + pValR;
                                break;
                            case "-":
                                this._pLastEvalResult = pValL - pValR;
                                break;
                            case "*":
                                this._pLastEvalResult = pValL * pValR;
                                break;
                            case "/":
                                this._pLastEvalResult = pValL / pValR;
                                break;
                            case "%":
                                this._pLastEvalResult = pValL % pValR;
                                break;
                        }
                        return true;
                    } catch (e) {
                        return false;
                    }
                };

                ArithmeticExprInstruction.prototype._toFinalCode = function () {
                    var sCode = "";
                    sCode += this._getInstructions()[0]._toFinalCode();
                    sCode += this._getOperator();
                    sCode += this._getInstructions()[1]._toFinalCode();
                    return sCode;
                };

                ArithmeticExprInstruction.prototype._isConst = function () {
                    var pOperands = this._getInstructions();
                    return pOperands[0]._isConst() && pOperands[1]._isConst();
                };
                return ArithmeticExprInstruction;
            })(instructions.ExprInstruction);
            instructions.ArithmeticExprInstruction = ArithmeticExprInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Represent someExpr = += -= /= *= %= someExpr
            * (=|+=|-=|*=|/=|%=) Instruction Instruction
            */
            var AssignmentExprInstruction = (function (_super) {
                __extends(AssignmentExprInstruction, _super);
                function AssignmentExprInstruction() {
                    _super.call(this);
                    this._pInstructionList = [null, null];
                    this._eInstructionType = 24 /* k_AssignmentExprInstruction */;
                }
                AssignmentExprInstruction.prototype._toFinalCode = function () {
                    var sCode = "";
                    sCode += this._getInstructions()[0]._toFinalCode();
                    sCode += this._getOperator();
                    sCode += this._getInstructions()[1]._toFinalCode();
                    return sCode;
                };

                AssignmentExprInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    var sOperator = this._getOperator();
                    var pSubExprLeft = this._getInstructions()[0];
                    var pSubExprRight = this._getInstructions()[1];

                    if (eUsedMode === 0 /* k_Read */ || sOperator !== "=") {
                        pSubExprLeft._addUsedData(pUsedDataCollector, 2 /* k_ReadWrite */);
                    } else {
                        pSubExprLeft._addUsedData(pUsedDataCollector, 1 /* k_Write */);
                    }

                    pSubExprRight._addUsedData(pUsedDataCollector, 0 /* k_Read */);
                };
                return AssignmentExprInstruction;
            })(instructions.ExprInstruction);
            instructions.AssignmentExprInstruction = AssignmentExprInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
/// <reference path="../Effect.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            var BoolInstruction = (function (_super) {
                __extends(BoolInstruction, _super);
                /**
                * EMPTY_OPERATOR EMPTY_ARGUMENTS
                */
                function BoolInstruction() {
                    _super.call(this);

                    this._bValue = true;
                    this._pType = fx.Effect.getSystemType("bool").getVariableType();
                    this._eInstructionType = 10 /* k_BoolInstruction */;
                }
                BoolInstruction.prototype._setValue = function (bValue) {
                    this._bValue = bValue;
                };

                BoolInstruction.prototype.toString = function () {
                    return this._bValue;
                };

                BoolInstruction.prototype._toFinalCode = function () {
                    if (this._bValue) {
                        return "true";
                    } else {
                        return "false";
                    }
                };

                BoolInstruction.prototype._evaluate = function () {
                    this._pLastEvalResult = this._bValue;
                    return true;
                };

                BoolInstruction.prototype._isConst = function () {
                    return true;
                };

                BoolInstruction.prototype._clone = function (pRelationMap) {
                    var pClonedInstruction = (_super.prototype._clone.call(this, pRelationMap));
                    pClonedInstruction._setValue(this._bValue);
                    return pClonedInstruction;
                };
                BoolInstruction._pBoolType = null;
                return BoolInstruction;
            })(instructions.ExprInstruction);
            instructions.BoolInstruction = BoolInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/IAFXInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        /// <reference path="Instruction.ts" />
        (function (instructions) {
            /**
            * Represent all kind of statements
            */
            var StmtInstruction = (function (_super) {
                __extends(StmtInstruction, _super);
                function StmtInstruction() {
                    _super.call(this);
                    this._eInstructionType = 48 /* k_StmtInstruction */;
                }
                StmtInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    var pInstructionList = this._getInstructions();

                    if (!akra.isNull(pUsedDataCollector)) {
                        for (var i = 0; i < this._nInstructions; i++) {
                            pInstructionList[i]._addUsedData(pUsedDataCollector, eUsedMode);
                        }
                    }
                };
                return StmtInstruction;
            })(instructions.Instruction);
            instructions.StmtInstruction = StmtInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="StmtInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Reprsernt continue; break; discard;
            * (continue || break || discard)
            */
            var BreakStmtInstruction = (function (_super) {
                __extends(BreakStmtInstruction, _super);
                function BreakStmtInstruction() {
                    _super.call(this);
                    this._pInstructionList = null;
                    this._eInstructionType = 51 /* k_BreakStmtInstruction */;
                }
                BreakStmtInstruction.prototype._toFinalCode = function () {
                    return this._getOperator() + ";";
                };
                return BreakStmtInstruction;
            })(instructions.StmtInstruction);
            instructions.BreakStmtInstruction = BreakStmtInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Represent (type) expr
            * EMPTY_OPERATOR VariableTypeInstruction Instruction
            */
            var CastExprInstruction = (function (_super) {
                __extends(CastExprInstruction, _super);
                function CastExprInstruction() {
                    _super.call(this);
                    this._pInstructionList = [null, null];
                    this._eInstructionType = 28 /* k_CastExprInstruction */;
                }
                CastExprInstruction.prototype._toFinalCode = function () {
                    var sCode = "";
                    sCode += this._getInstructions()[0]._toFinalCode();
                    sCode += "(";
                    sCode += this._getInstructions()[1]._toFinalCode();
                    sCode += ")";
                    return sCode;
                };

                CastExprInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    var pSubExpr = this._getInstructions()[1];
                    pSubExpr._addUsedData(pUsedDataCollector, 0 /* k_Read */);
                    // pUsedDataCollector[this._getType()._getInstructionID()] = this._getType();
                };

                CastExprInstruction.prototype._isConst = function () {
                    return this._getInstructions()[1]._isConst();
                };
                return CastExprInstruction;
            })(instructions.ExprInstruction);
            instructions.CastExprInstruction = CastExprInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Represent (expr)
            * EMPTY_OPERATOR ExprInstruction
            */
            var ComplexExprInstruction = (function (_super) {
                __extends(ComplexExprInstruction, _super);
                function ComplexExprInstruction() {
                    _super.call(this);
                    this._pInstructionList = [null];
                    this._eInstructionType = 34 /* k_ComplexExprInstruction */;
                }
                ComplexExprInstruction.prototype._toFinalCode = function () {
                    var sCode = "";

                    sCode += "(" + this._getInstructions()[0]._toFinalCode() + ")";

                    return sCode;
                };

                ComplexExprInstruction.prototype._isConst = function () {
                    return this._getInstructions()[0]._isConst();
                };

                ComplexExprInstruction.prototype._evaluate = function () {
                    if (this._getInstructions()[0]._evaluate()) {
                        this._pLastEvalResult = this._getInstructions()[0]._getEvalValue();
                        return true;
                    } else {
                        return false;
                    }
                };
                return ComplexExprInstruction;
            })(instructions.ExprInstruction);
            instructions.ComplexExprInstruction = ComplexExprInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/IAFXInstruction.ts" />
/// <reference path="../../logger.ts" />
var akra;
(function (akra) {
    (function (fx) {
        /// <reference path="Instruction.ts" />
        /// <reference path="../Effect.ts" />
        (function (instructions) {
            var ComplexTypeInstruction = (function (_super) {
                __extends(ComplexTypeInstruction, _super);
                function ComplexTypeInstruction() {
                    _super.call(this);
                    this._sName = "";
                    this._sRealName = "";
                    this._sHash = "";
                    this._sStrongHash = "";
                    this._iSize = 0;
                    this._pFieldDeclMap = null;
                    this._pFieldDeclList = null;
                    this._pFieldNameList = null;
                    this._pFieldDeclBySemanticMap = null;
                    this._bHasAllUniqueSemantics = true;
                    this._bHasFieldWithoutSemantic = false;
                    this._isContainArray = false;
                    this._isContainSampler = false;
                    this._isContainPointer = false;
                    this._isContainComplexType = false;
                    this._pInstructionList = null;
                    this._eInstructionType = 5 /* k_ComplexTypeInstruction */;
                }
                ComplexTypeInstruction.prototype.toString = function () {
                    return this._getName() || this._getHash();
                };

                ComplexTypeInstruction.prototype._toDeclString = function () {
                    var sCode = "struct " + this._sRealName + "{";

                    for (var i = 0; i < this._pFieldDeclList.length; i++) {
                        sCode += "\t" + this._pFieldDeclList[i]._toFinalCode() + ";\n";
                    }

                    sCode += "}";

                    return sCode;
                };

                ComplexTypeInstruction.prototype._toFinalCode = function () {
                    return this._sRealName;
                };

                ComplexTypeInstruction.prototype._isBuiltIn = function () {
                    return false;
                };

                ComplexTypeInstruction.prototype._setBuiltIn = function (isBuiltIn) {
                };

                //-----------------------------------------------------------------//
                //----------------------------SIMPLE TESTS-------------------------//
                //-----------------------------------------------------------------//
                ComplexTypeInstruction.prototype._isBase = function () {
                    return false;
                };

                ComplexTypeInstruction.prototype._isArray = function () {
                    return false;
                };

                ComplexTypeInstruction.prototype._isNotBaseArray = function () {
                    return false;
                };

                ComplexTypeInstruction.prototype._isComplex = function () {
                    return true;
                };

                ComplexTypeInstruction.prototype._isEqual = function (pType) {
                    return this._getHash() === pType._getHash();
                };

                ComplexTypeInstruction.prototype._isStrongEqual = function (pType) {
                    return this._getStrongHash() === pType._getStrongHash();
                };

                ComplexTypeInstruction.prototype._isConst = function () {
                    return false;
                };

                ComplexTypeInstruction.prototype._isSampler = function () {
                    return false;
                };

                ComplexTypeInstruction.prototype._isSamplerCube = function () {
                    return false;
                };

                ComplexTypeInstruction.prototype._isSampler2D = function () {
                    return false;
                };

                ComplexTypeInstruction.prototype._isWritable = function () {
                    return true;
                };

                ComplexTypeInstruction.prototype._isReadable = function () {
                    return true;
                };

                ComplexTypeInstruction.prototype._containArray = function () {
                    return this._isContainArray;
                };

                ComplexTypeInstruction.prototype._containSampler = function () {
                    return this._isContainSampler;
                };

                ComplexTypeInstruction.prototype._containPointer = function () {
                    return this._isContainPointer;
                };

                ComplexTypeInstruction.prototype._containComplexType = function () {
                    return this._isContainComplexType;
                };

                //-----------------------------------------------------------------//
                //----------------------------SET BASE TYPE INFO-------------------//
                //-----------------------------------------------------------------//
                ComplexTypeInstruction.prototype._setName = function (sName) {
                    this._sName = sName;
                    this._sRealName = sName;
                };

                ComplexTypeInstruction.prototype.setRealName = function (sRealName) {
                    this._sRealName = sRealName;
                };

                ComplexTypeInstruction.prototype.setSize = function (iSize) {
                    this._iSize = iSize;
                };

                ComplexTypeInstruction.prototype._canWrite = function (isWritable) {
                };

                ComplexTypeInstruction.prototype._canRead = function (isWritable) {
                };

                //-----------------------------------------------------------------//
                //----------------------------INIT API-----------------------------//
                //-----------------------------------------------------------------//
                ComplexTypeInstruction.prototype.addField = function (pVariable) {
                    if (akra.isNull(this._pFieldDeclMap)) {
                        this._pFieldDeclMap = {};
                        this._pFieldNameList = [];
                    }

                    if (akra.isNull(this._pFieldDeclList)) {
                        this._pFieldDeclList = [];
                    }

                    var sVarName = pVariable._getName();
                    this._pFieldDeclMap[sVarName] = pVariable;

                    if (this._iSize !== instructions.Instruction.UNDEFINE_SIZE) {
                        var iSize = pVariable._getType()._getSize();
                        if (iSize !== instructions.Instruction.UNDEFINE_SIZE) {
                            this._iSize += iSize;
                        } else {
                            this._iSize = instructions.Instruction.UNDEFINE_SIZE;
                        }
                    }

                    this._pFieldNameList.push(sVarName);

                    if (this._pFieldDeclList.length < this._pFieldNameList.length) {
                        this._pFieldDeclList.push(pVariable);
                    }

                    var pType = pVariable._getType();

                    //pType._markAsField();
                    if (pType._isNotBaseArray() || pType._containArray()) {
                        this._isContainArray = true;
                    }

                    if (fx.Effect.isSamplerType(pType) || pType._containSampler()) {
                        this._isContainSampler = true;
                    }

                    if (pType._isPointer() || pType._containPointer()) {
                        this._isContainPointer = true;
                    }

                    if (pType._isComplex()) {
                        this._isContainComplexType = true;
                    }
                };

                ComplexTypeInstruction.prototype.addFields = function (pFieldCollector, isSetParent) {
                    if (typeof isSetParent === "undefined") { isSetParent = true; }
                    this._pFieldDeclList = (pFieldCollector._getInstructions());

                    for (var i = 0; i < this._pFieldDeclList.length; i++) {
                        this.addField(this._pFieldDeclList[i]);
                        this._pFieldDeclList[i]._setParent(this);
                    }

                    this.calculatePaddings();
                };

                //-----------------------------------------------------------------//
                //----------------------------GET TYPE INFO------------------------//
                //-----------------------------------------------------------------//
                ComplexTypeInstruction.prototype._getName = function () {
                    return this._sName;
                };

                ComplexTypeInstruction.prototype._getRealName = function () {
                    return this._sRealName;
                };

                ComplexTypeInstruction.prototype._getHash = function () {
                    if (this._sHash === "") {
                        this.calcHash();
                    }

                    return this._sHash;
                };

                ComplexTypeInstruction.prototype._getStrongHash = function () {
                    if (this._sStrongHash === "") {
                        this.calcStrongHash();
                    }

                    return this._sStrongHash;
                };

                ComplexTypeInstruction.prototype._hasField = function (sFieldName) {
                    return akra.isDef(this._pFieldDeclMap[sFieldName]);
                };

                ComplexTypeInstruction.prototype._hasFieldWithSematic = function (sSemantic) {
                    if (akra.isNull(this._pFieldDeclBySemanticMap)) {
                        this.analyzeSemantics();
                    }

                    return akra.isDef(this._pFieldDeclBySemanticMap[sSemantic]);
                };

                ComplexTypeInstruction.prototype._hasAllUniqueSemantics = function () {
                    if (akra.isNull(this._pFieldDeclBySemanticMap)) {
                        this.analyzeSemantics();
                    }
                    return this._bHasAllUniqueSemantics;
                };

                ComplexTypeInstruction.prototype._hasFieldWithoutSemantic = function () {
                    if (akra.isNull(this._pFieldDeclBySemanticMap)) {
                        this.analyzeSemantics();
                    }
                    return this._bHasFieldWithoutSemantic;
                };

                ComplexTypeInstruction.prototype._getField = function (sFieldName) {
                    if (!this._hasField(sFieldName)) {
                        return null;
                    }

                    return this._pFieldDeclMap[sFieldName];
                };

                ComplexTypeInstruction.prototype._getFieldBySemantic = function (sSemantic) {
                    if (!this._hasFieldWithSematic(sSemantic)) {
                        return null;
                    }

                    return this._pFieldDeclBySemanticMap[sSemantic];
                };

                ComplexTypeInstruction.prototype._getFieldType = function (sFieldName) {
                    return akra.isDef(this._pFieldDeclMap[sFieldName]) ? this._pFieldDeclMap[sFieldName]._getType() : null;
                };

                ComplexTypeInstruction.prototype._getFieldNameList = function () {
                    return this._pFieldNameList;
                };

                ComplexTypeInstruction.prototype._getSize = function () {
                    if (this._iSize === instructions.Instruction.UNDEFINE_SIZE) {
                        this._iSize = this._calcSize();
                    }
                    return this._iSize;
                };

                ComplexTypeInstruction.prototype._getBaseType = function () {
                    return this;
                };

                ComplexTypeInstruction.prototype._getArrayElementType = function () {
                    return null;
                };

                ComplexTypeInstruction.prototype._getTypeDecl = function () {
                    return this._getParent();
                };

                ComplexTypeInstruction.prototype._getLength = function () {
                    return 0;
                };

                ComplexTypeInstruction.prototype._getFieldDeclList = function () {
                    return this._pFieldDeclList;
                };

                //-----------------------------------------------------------------//
                //----------------------------SYSTEM-------------------------------//
                //-----------------------------------------------------------------//
                ComplexTypeInstruction.prototype._clone = function (pRelationMap) {
                    if (typeof pRelationMap === "undefined") { pRelationMap = {}; }
                    if (this._pParentInstruction === null || !akra.isDef(pRelationMap[this._pParentInstruction._getInstructionID()]) || pRelationMap[this._pParentInstruction._getInstructionID()] === this._pParentInstruction) {
                        //pRelationMap[this._getInstructionID()] = this;
                        return this;
                    }

                    var pClone = _super.prototype._clone.call(this, pRelationMap);

                    pClone._setCloneName(this._sName, this._sRealName);
                    pClone._setCloneHash(this._sHash, this._sStrongHash);
                    pClone._setCloneContain(this._isContainArray, this._isContainSampler);

                    var pFieldDeclList = new Array(this._pFieldDeclList.length);
                    var pFieldNameList = new Array(this._pFieldNameList.length);
                    var pFieldDeclMap = {};

                    for (var i = 0; i < this._pFieldDeclList.length; i++) {
                        var pCloneVar = this._pFieldDeclList[i]._clone(pRelationMap);
                        var sVarName = pCloneVar._getName();

                        pFieldDeclList[i] = pCloneVar;
                        pFieldNameList[i] = sVarName;
                        pFieldDeclMap[sVarName] = pCloneVar;
                    }

                    pClone._setCloneFields(pFieldDeclList, pFieldNameList, pFieldDeclMap);
                    pClone.setSize(this._iSize);

                    return pClone;
                };

                ComplexTypeInstruction.prototype._blend = function (pType, eMode) {
                    if (pType === this) {
                        return this;
                    }

                    if (eMode === 6 /* k_TypeDecl */) {
                        return null;
                    }

                    if (eMode === 1 /* k_Uniform */ || eMode === 2 /* k_Attribute */) {
                        if (this._hasFieldWithoutSemantic() || pType._hasFieldWithoutSemantic()) {
                            return null;
                        }
                    }

                    var pFieldList = this._pFieldDeclList;
                    var pBlendType = new ComplexTypeInstruction();
                    var pRelationMap = {};

                    if (akra.isNull(pFieldList)) {
                        akra.logger.log(this, pType);
                    }

                    for (var i = 0; i < pFieldList.length; i++) {
                        var pField = pFieldList[i];
                        var pBlendField = null;
                        var sFieldName = pField._getName();
                        var sFieldSemantic = pField._getSemantic();

                        if (eMode === 0 /* k_Shared */) {
                            if (pType._hasField(sFieldName)) {
                                pBlendField = pField._blend(pType._getField(sFieldName), eMode);
                            } else {
                                pBlendField = pField._clone(pRelationMap);
                            }
                        } else if (eMode === 2 /* k_Attribute */ || eMode === 1 /* k_Uniform */ || eMode === 7 /* k_VertexOut */) {
                            if (pType._hasFieldWithSematic(sFieldSemantic)) {
                                pBlendField = pField._blend(pType._getFieldBySemantic(sFieldSemantic), eMode);
                            } else {
                                pBlendField = pField._clone(pRelationMap);
                            }

                            if (!akra.isNull(pBlendField)) {
                                pBlendField._getNameId()._setName(sFieldSemantic);
                                pBlendField._getNameId()._setRealName(sFieldSemantic);
                            }
                        }

                        if (akra.isNull(pBlendField)) {
                            return null;
                        }

                        pBlendType.addField(pBlendField);
                    }

                    pFieldList = pType._getFieldDeclList();

                    for (var i = 0; i < pFieldList.length; i++) {
                        var pField = pFieldList[i];
                        var pBlendField = null;
                        var sFieldName = pField._getName();
                        var sFieldSemantic = pField._getSemantic();

                        if (eMode === 0 /* k_Shared */) {
                            if (!this._hasField(sFieldName)) {
                                pBlendField = pField._clone(pRelationMap);
                            }
                        } else if (eMode === 2 /* k_Attribute */ || eMode === 1 /* k_Uniform */ || eMode === 7 /* k_VertexOut */) {
                            if (!this._hasFieldWithSematic(sFieldSemantic)) {
                                pBlendField = pField._clone(pRelationMap);
                                pBlendField._getNameId()._setName(sFieldSemantic);
                                pBlendField._getNameId()._setRealName(sFieldSemantic);
                            }
                        }

                        if (!akra.isNull(pBlendField)) {
                            pBlendType.addField(pBlendField);
                        }
                    }

                    pBlendType._setName(this._getName());
                    pBlendType.setRealName(this._getRealName());

                    return pBlendType;
                };

                ComplexTypeInstruction.prototype._setCloneName = function (sName, sRealName) {
                    this._sName = sName;
                    this._sRealName = sRealName;
                };

                ComplexTypeInstruction.prototype._setCloneHash = function (sHash, sStrongHash) {
                    this._sHash = sHash;
                    this._sStrongHash = sStrongHash;
                };

                ComplexTypeInstruction.prototype._setCloneContain = function (isContainArray, isContainSampler) {
                    this._isContainArray = isContainArray;
                    this._isContainSampler = isContainSampler;
                };

                ComplexTypeInstruction.prototype._setCloneFields = function (pFieldDeclList, pFieldNameList, pFieldDeclMap) {
                    this._pFieldDeclList = pFieldDeclList;
                    this._pFieldNameList = pFieldNameList;
                    this._pFieldDeclMap = pFieldDeclMap;
                };

                ComplexTypeInstruction.prototype._calcSize = function () {
                    var iSize = 0;

                    for (var i = 0; i < this._pFieldDeclList.length; i++) {
                        var iFieldSize = this._pFieldDeclList[i]._getType()._getSize();

                        if (iFieldSize === instructions.Instruction.UNDEFINE_SIZE) {
                            iSize = instructions.Instruction.UNDEFINE_SIZE;
                            break;
                        } else {
                            iSize += iFieldSize;
                        }
                    }

                    return iSize;
                };

                ComplexTypeInstruction.prototype.calcHash = function () {
                    var sHash = "{";

                    for (var i = 0; i < this._pFieldDeclList.length; i++) {
                        sHash += this._pFieldDeclList[i]._getType()._getHash() + ";";
                    }

                    sHash += "}";

                    this._sHash = sHash;
                };

                ComplexTypeInstruction.prototype.calcStrongHash = function () {
                    var sStrongHash = "{";

                    for (var i = 0; i < this._pFieldDeclList.length; i++) {
                        sStrongHash += this._pFieldDeclList[i]._getType()._getStrongHash() + ";";
                    }

                    sStrongHash += "}";

                    this._sStrongHash = sStrongHash;
                };

                ComplexTypeInstruction.prototype.analyzeSemantics = function () {
                    this._pFieldDeclBySemanticMap = {};

                    for (var i = 0; i < this._pFieldDeclList.length; i++) {
                        var pVar = this._pFieldDeclList[i];
                        var sSemantic = pVar._getSemantic();

                        if (sSemantic === "") {
                            this._bHasFieldWithoutSemantic = true;
                        }

                        if (akra.isDef(this._pFieldDeclBySemanticMap[sSemantic])) {
                            this._bHasAllUniqueSemantics = false;
                        }

                        this._pFieldDeclBySemanticMap[sSemantic] = pVar;

                        this._bHasFieldWithoutSemantic = this._bHasFieldWithoutSemantic || pVar._getType()._hasFieldWithoutSemantic();
                        if (this._bHasAllUniqueSemantics && pVar._getType()._isComplex()) {
                            this._bHasAllUniqueSemantics = pVar._getType()._hasAllUniqueSemantics();
                        }
                    }
                };

                ComplexTypeInstruction.prototype.calculatePaddings = function () {
                    var iPadding = 0;

                    for (var i = 0; i < this._pFieldDeclList.length; i++) {
                        var pVarType = this._pFieldDeclList[i]._getType();
                        var iVarSize = pVarType._getSize();

                        if (iVarSize === instructions.Instruction.UNDEFINE_SIZE) {
                            this._setError(2272 /* CANNOT_CALCULATE_PADDINGS */, { typeName: this._getName() });
                            return;
                        }

                        pVarType._setPadding(iPadding);
                        iPadding += iVarSize;
                    }
                };
                return ComplexTypeInstruction;
            })(instructions.Instruction);
            instructions.ComplexTypeInstruction = ComplexTypeInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Represetn compile vs_func(...args)
            * compile IdExprInstruction ExprInstruction ... ExprInstruction
            */
            var CompileExprInstruction = (function (_super) {
                __extends(CompileExprInstruction, _super);
                function CompileExprInstruction() {
                    _super.call(this);
                    this._pInstructionList = [null];
                    this._eInstructionType = 38 /* k_CompileExprInstruction */;
                }
                CompileExprInstruction.prototype.getFunction = function () {
                    return this._pInstructionList[0]._getParent()._getParent();
                };
                return CompileExprInstruction;
            })(instructions.ExprInstruction);
            instructions.CompileExprInstruction = CompileExprInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Represen boolExpr ? someExpr : someExpr
            * EMPTY_OPERATOR Instruction Instruction Instruction
            */
            var ConditionalExprInstruction = (function (_super) {
                __extends(ConditionalExprInstruction, _super);
                function ConditionalExprInstruction() {
                    _super.call(this);
                    this._pInstructionList = [null, null, null];
                    this._eInstructionType = 27 /* k_ConditionalExprInstruction */;
                }
                ConditionalExprInstruction.prototype._toFinalCode = function () {
                    var sCode = "";
                    sCode += this._getInstructions()[0]._toFinalCode();
                    sCode += "?";
                    sCode += this._getInstructions()[1]._toFinalCode();
                    sCode += ":";
                    sCode += this._getInstructions()[2]._toFinalCode();
                    return sCode;
                };

                ConditionalExprInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    _super.prototype._addUsedData.call(this, pUsedDataCollector, 0 /* k_Read */);
                };

                ConditionalExprInstruction.prototype._isConst = function () {
                    return this._getInstructions()[0]._isConst() && this._getInstructions()[1]._isConst();
                };
                return ConditionalExprInstruction;
            })(instructions.ExprInstruction);
            instructions.ConditionalExprInstruction = ConditionalExprInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
/// <reference path="../Effect.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Respresnt ctor(arg1,..., argn)
            * EMPTY_OPERATOR IdInstruction ExprInstruction ... ExprInstruction
            */
            var ConstructorCallInstruction = (function (_super) {
                __extends(ConstructorCallInstruction, _super);
                function ConstructorCallInstruction() {
                    _super.call(this);
                    this._pInstructionList = [null];
                    this._eInstructionType = 37 /* k_ConstructorCallInstruction */;
                }
                // _isConst
                ConstructorCallInstruction.prototype._toFinalCode = function () {
                    var sCode = "";

                    sCode += this._getInstructions()[0]._toFinalCode();
                    sCode += "(";

                    for (var i = 1; i < this._nInstructions; i++) {
                        sCode += this._getInstructions()[i]._toFinalCode();

                        if (i !== this._nInstructions - 1) {
                            sCode += ",";
                        }
                    }

                    sCode += ")";

                    return sCode;
                };

                ConstructorCallInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    var pInstructionList = this._getInstructions();
                    for (var i = 1; i < this._nInstructions; i++) {
                        pInstructionList[i]._addUsedData(pUsedDataCollector, 0 /* k_Read */);
                    }
                };

                ConstructorCallInstruction.prototype._isConst = function () {
                    for (var i = 1; i < this._nInstructions; i++) {
                        if (!this._getInstructions()[i]._isConst()) {
                            return false;
                        }
                    }

                    return true;
                };

                ConstructorCallInstruction.prototype._evaluate = function () {
                    if (!this._isConst()) {
                        return false;
                    }

                    var pRes = null;
                    var pJSTypeCtor = fx.Effect.getExternalType(this._getType());
                    var pArguments = new Array(this._nInstructions - 1);

                    if (akra.isNull(pJSTypeCtor)) {
                        return false;
                    }

                    try  {
                        if (fx.Effect.isScalarType(this._getType())) {
                            var pTestedInstruction = this._getInstructions()[1];
                            if (this._nInstructions > 2 || !pTestedInstruction._evaluate()) {
                                return false;
                            }

                            pRes = pJSTypeCtor(pTestedInstruction._getEvalValue());
                        } else {
                            for (var i = 1; i < this._nInstructions; i++) {
                                var pTestedInstruction = this._getInstructions()[i];

                                if (pTestedInstruction._evaluate()) {
                                    pArguments[i - 1] = pTestedInstruction._getEvalValue();
                                } else {
                                    return false;
                                }
                            }

                            pRes = new pJSTypeCtor;
                            pRes.set.apply(pRes, pArguments);
                        }
                    } catch (e) {
                        return false;
                    }

                    this._pLastEvalResult = pRes;
                    return true;
                };
                return ConstructorCallInstruction;
            })(instructions.ExprInstruction);
            instructions.ConstructorCallInstruction = ConstructorCallInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="StmtInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Represent TypeDecl or VariableDecl or VarStructDecl
            * EMPTY DeclInstruction
            */
            var DeclStmtInstruction = (function (_super) {
                __extends(DeclStmtInstruction, _super);
                function DeclStmtInstruction() {
                    _super.call(this);
                    this._pInstructionList = [null];
                    this._eInstructionType = 55 /* k_DeclStmtInstruction */;
                }
                DeclStmtInstruction.prototype._toFinalCode = function () {
                    var sCode = "";
                    var pVariableList = this._getInstructions();

                    for (var i = 0; i < this._nInstructions; i++) {
                        sCode += pVariableList[i]._toFinalCode() + ";\n";
                    }

                    return sCode;
                };

                DeclStmtInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    if (akra.isNull(this._getInstructions()) || this._nInstructions === 0) {
                        return;
                    }

                    if (this._getInstructions()[0]._getInstructionType() === 14 /* k_TypeDeclInstruction */) {
                        return;
                    }

                    var pVariableList = this._getInstructions();
                    for (var i = 0; i < this._nInstructions; i++) {
                        var pVarType = pVariableList[i]._getType();

                        pUsedDataCollector[pVarType._getInstructionID()] = {
                            type: pVarType,
                            isRead: false,
                            isWrite: true,
                            numRead: 0,
                            numWrite: 1,
                            numUsed: 1
                        };

                        if (pVariableList[i]._hasInitializer()) {
                            pVariableList[i]._getInitializeExpr()._addUsedData(pUsedDataCollector, 0 /* k_Read */);
                        }
                    }
                };
                return DeclStmtInstruction;
            })(instructions.StmtInstruction);
            instructions.DeclStmtInstruction = DeclStmtInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="StmtInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Represent expr;
            * EMPTY_OPERTOR ExprInstruction
            */
            var ExprStmtInstruction = (function (_super) {
                __extends(ExprStmtInstruction, _super);
                function ExprStmtInstruction() {
                    _super.call(this);
                    this._pInstructionList = [null];
                    this._eInstructionType = 50 /* k_ExprStmtInstruction */;
                }
                ExprStmtInstruction.prototype._toFinalCode = function () {
                    return this._getInstructions()[0]._toFinalCode() + ";";
                };
                return ExprStmtInstruction;
            })(instructions.StmtInstruction);
            instructions.ExprStmtInstruction = ExprStmtInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/IAFXInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        /// <reference path="Instruction.ts" />
        (function (instructions) {
            var SimpleInstruction = (function (_super) {
                __extends(SimpleInstruction, _super);
                function SimpleInstruction(sValue) {
                    _super.call(this);
                    this._sValue = "";
                    this._pInstructionList = null;
                    this._eInstructionType = 2 /* k_SimpleInstruction */;

                    this._sValue = sValue;
                }
                SimpleInstruction.prototype._setValue = function (sValue) {
                    this._sValue = sValue;
                };

                SimpleInstruction.prototype._isValue = function (sValue) {
                    return (this._sValue === sValue);
                };

                SimpleInstruction.prototype.toString = function () {
                    return this._sValue;
                };

                SimpleInstruction.prototype._toFinalCode = function () {
                    return this._sValue;
                };

                SimpleInstruction.prototype._clone = function (pRelationMap) {
                    var pClone = _super.prototype._clone.call(this, pRelationMap);
                    pClone._setValue(this._sValue);
                    return pClone;
                };
                return SimpleInstruction;
            })(instructions.Instruction);
            instructions.SimpleInstruction = SimpleInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../idl/IAFXInstruction.ts" />
var akra;
(function (akra) {
    /// <reference path="instructions/SimpleInstruction.ts" />
    (function (fx) {
        var ExprTemplateTranslator = (function () {
            function ExprTemplateTranslator(sExprTemplate) {
                this._pInToOutArgsMap = null;
                this._pExprPart = null;
                this._pInToOutArgsMap = {};
                this._pExprPart = [];

                var pSplitTemplate = sExprTemplate.split(/(\$\d+)/);

                for (var i = 0; i < pSplitTemplate.length; i++) {
                    if (pSplitTemplate[i]) {
                        if (pSplitTemplate[i][0] !== '$') {
                            this._pExprPart.push(new fx.instructions.SimpleInstruction(pSplitTemplate[i]));
                        } else {
                            this._pExprPart.push(null);
                            this._pInToOutArgsMap[this._pExprPart.length - 1] = ((pSplitTemplate[i].substr(1)) * 1 - 1);
                        }
                    }
                }
            }
            ExprTemplateTranslator.prototype.toInstructionList = function (pArguments) {
                var pOutputInstructionList = [];

                for (var i = 0; i < this._pExprPart.length; i++) {
                    if (akra.isNull(this._pExprPart[i])) {
                        pOutputInstructionList.push(pArguments[this._pInToOutArgsMap[i]]);
                    } else {
                        pOutputInstructionList.push(this._pExprPart[i]);
                    }
                }

                return pOutputInstructionList;
            };
            return ExprTemplateTranslator;
        })();
        fx.ExprTemplateTranslator = ExprTemplateTranslator;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
/// <reference path="../Effect.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            var ExtractExprInstruction = (function (_super) {
                __extends(ExtractExprInstruction, _super);
                function ExtractExprInstruction() {
                    _super.call(this);
                    this._eExtractExprType = 0;
                    this._pPointer = null;
                    this._pBuffer = null;
                    this._pOffsetVar = null;
                    this._sPaddingExpr = "";
                    this._sExtractFunction = "";
                    this._bNeedSecondBracket = false;
                    this._pInstructionList = null;
                    this._eInstructionType = 42 /* k_ExtractExprInstruction */;
                }
                ExtractExprInstruction.prototype.getExtractFunction = function () {
                    var pFunction = null;

                    switch (this._eExtractExprType) {
                        case 0 /* k_Header */:
                            pFunction = fx.Effect.findSystemFunction("extractHeader", null);
                            break;

                        case 1 /* k_Float */:
                        case 2 /* k_Int */:
                        case 3 /* k_Bool */:
                            pFunction = fx.Effect.findSystemFunction("extractFloat", null);
                            break;

                        case 4 /* k_Float2 */:
                        case 5 /* k_Int2 */:
                        case 6 /* k_Bool2 */:
                            pFunction = fx.Effect.findSystemFunction("extractFloat2", null);
                            break;

                        case 7 /* k_Float3 */:
                        case 8 /* k_Int3 */:
                        case 9 /* k_Bool3 */:
                            pFunction = fx.Effect.findSystemFunction("extractFloat3", null);
                            break;

                        case 10 /* k_Float4 */:
                        case 11 /* k_Int4 */:
                        case 12 /* k_Bool4 */:
                            pFunction = fx.Effect.findSystemFunction("extractFloat4", null);
                            break;

                        case 13 /* k_Float4x4 */:
                            pFunction = fx.Effect.findSystemFunction("extractFloat4x4", null);
                            break;
                    }

                    return pFunction;
                };

                ExtractExprInstruction.prototype.initExtractExpr = function (pExtractType, pPointer, pBuffer, sPaddingExpr, pOffsetVar) {
                    this._pPointer = pPointer;
                    this._pBuffer = pBuffer;
                    this._sPaddingExpr = sPaddingExpr;
                    this._pOffsetVar = pOffsetVar;
                    this._setType(pExtractType);

                    if (pExtractType._isEqual(fx.Effect.getSystemType("float"))) {
                        this._eExtractExprType = 1 /* k_Float */;
                        this._sExtractFunction += "A_extractFloat(";
                    } else if (pExtractType._isEqual(fx.Effect.getSystemType("ptr"))) {
                        this._eExtractExprType = 1 /* k_Float */;
                        this._sExtractFunction += "A_extractFloat(";
                    } else if (pExtractType._isEqual(fx.Effect.getSystemType("video_buffer_header"))) {
                        this._eExtractExprType = 0 /* k_Header */;
                        this._sExtractFunction += "A_extractTextureHeader(";
                    } else if (pExtractType._isEqual(fx.Effect.getSystemType("bool"))) {
                        this._eExtractExprType = 3 /* k_Bool */;
                        this._sExtractFunction += "boolean(A_extractFloat(";
                        this._bNeedSecondBracket = true;
                    } else if (pExtractType._isEqual(fx.Effect.getSystemType("int"))) {
                        this._eExtractExprType = 2 /* k_Int */;
                        this._sExtractFunction += ("int(A_extractFloat(");
                        this._bNeedSecondBracket = true;
                    } else if (pExtractType._isEqual(fx.Effect.getSystemType("float2"))) {
                        this._eExtractExprType = 4 /* k_Float2 */;
                        this._sExtractFunction += ("A_extractVec2(");
                    } else if (pExtractType._isEqual(fx.Effect.getSystemType("float3"))) {
                        this._eExtractExprType = 7 /* k_Float3 */;
                        this._sExtractFunction += ("A_extractVec3(");
                    } else if (pExtractType._isEqual(fx.Effect.getSystemType("float4"))) {
                        this._eExtractExprType = 10 /* k_Float4 */;
                        this._sExtractFunction += ("A_extractVec4(");
                    } else if (pExtractType._isEqual(fx.Effect.getSystemType("int2"))) {
                        this._eExtractExprType = 5 /* k_Int2 */;
                        this._sExtractFunction += ("ivec2(A_extractVec2(");
                        this._bNeedSecondBracket = true;
                    } else if (pExtractType._isEqual(fx.Effect.getSystemType("int3"))) {
                        this._eExtractExprType = 8 /* k_Int3 */;
                        this._sExtractFunction += ("ivec3(A_extractVec3(");
                        this._bNeedSecondBracket = true;
                    } else if (pExtractType._isEqual(fx.Effect.getSystemType("int4"))) {
                        this._eExtractExprType = 11 /* k_Int4 */;
                        this._sExtractFunction += ("ivec4(A_extractVec4(");
                        this._bNeedSecondBracket = true;
                    } else if (pExtractType._isEqual(fx.Effect.getSystemType("bool2"))) {
                        this._eExtractExprType = 6 /* k_Bool2 */;
                        this._sExtractFunction += ("bvec2(A_extractVec2(");
                        this._bNeedSecondBracket = true;
                    } else if (pExtractType._isEqual(fx.Effect.getSystemType("bool3"))) {
                        this._eExtractExprType = 9 /* k_Bool3 */;
                        this._sExtractFunction += ("bvec3(A_extractVec3(");
                        this._bNeedSecondBracket = true;
                    } else if (pExtractType._isEqual(fx.Effect.getSystemType("bool4"))) {
                        this._eExtractExprType = 12 /* k_Bool4 */;
                        this._sExtractFunction += ("bvec4(A_extractVec4(");
                        this._bNeedSecondBracket = true;
                    } else if (pExtractType._isEqual(fx.Effect.getSystemType("float4x4"))) {
                        this._eExtractExprType = 13 /* k_Float4x4 */;
                        this._sExtractFunction += ("A_extractMat4(");
                    } else {
                        this._setError(2273 /* UNSUPPORTED_EXTRACT_BASE_TYPE */, { typeName: pExtractType._getHash() });
                    }
                };

                ExtractExprInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    var pPointerType = this._pPointer._getType();
                    var pBufferType = this._pBuffer._getType();

                    var pInfo = pUsedDataCollector[pPointerType._getInstructionID()];

                    if (!akra.isDef(pInfo)) {
                        pInfo = {
                            type: pPointerType,
                            isRead: false,
                            isWrite: false,
                            numRead: 0,
                            numWrite: 0,
                            numUsed: 0
                        };

                        pUsedDataCollector[pPointerType._getInstructionID()] = pInfo;
                    }

                    pInfo.isRead = true;
                    pInfo.numRead++;
                    pInfo.numUsed++;

                    pInfo = pUsedDataCollector[pBufferType._getInstructionID()];

                    if (!akra.isDef(pInfo)) {
                        pInfo = {
                            type: pBufferType,
                            isRead: false,
                            isWrite: false,
                            numRead: 0,
                            numWrite: 0,
                            numUsed: 0
                        };

                        pUsedDataCollector[pBufferType._getInstructionID()] = pInfo;
                    }

                    pInfo.isRead = true;
                    pInfo.numRead++;
                    pInfo.numUsed++;
                };

                ExtractExprInstruction.prototype._toFinalCode = function () {
                    var sCode = "";

                    if (this._pBuffer._isDefinedByZero()) {
                        switch (this._eExtractExprType) {
                            case 0 /* k_Header */:
                                sCode = "A_TextureHeader(0.,0.,0.,0.)";
                                break;

                            case 1 /* k_Float */:
                                sCode = "0.";
                                break;
                            case 2 /* k_Int */:
                                sCode = "0";
                                break;
                            case 3 /* k_Bool */:
                                sCode = "false";
                                break;

                            case 4 /* k_Float2 */:
                                sCode = "vec2(0.)";
                                break;
                            case 5 /* k_Int2 */:
                                sCode = "ivec2(0)";
                                break;
                            case 6 /* k_Bool2 */:
                                sCode = "bvec2(false)";
                                break;

                            case 7 /* k_Float3 */:
                                sCode = "vec3(0.)";
                                break;
                            case 8 /* k_Int3 */:
                                sCode = "ivec3(0)";
                                break;
                            case 9 /* k_Bool3 */:
                                sCode = "bvec3(false)";
                                break;

                            case 10 /* k_Float4 */:
                                sCode = "vec4(0.)";
                                break;
                            case 11 /* k_Int4 */:
                                sCode = "ivec4(0)";
                                break;
                            case 12 /* k_Bool4 */:
                                sCode = "bvec4(false)";
                                break;

                            case 13 /* k_Float4x4 */:
                                sCode = "mat4(0.)";
                                break;
                        }
                    } else {
                        sCode = this._sExtractFunction;
                        sCode += this._pBuffer._getVideoBufferSampler()._getNameId()._toFinalCode();
                        sCode += "," + this._pBuffer._getVideoBufferHeader()._getNameId()._toFinalCode();
                        if (this._eExtractExprType !== 0 /* k_Header */) {
                            sCode += "," + this._pPointer._getNameId()._toFinalCode() + this._sPaddingExpr;

                            if (!akra.isNull(this._pOffsetVar)) {
                                sCode += "+" + this._pOffsetVar._getNameId()._toFinalCode();
                            }
                        }
                        sCode += ")";
                        if (this._bNeedSecondBracket) {
                            sCode += ")";
                        }
                    }

                    return sCode;
                };

                ExtractExprInstruction.prototype._clone = function (pRelationMap) {
                    var pClone = _super.prototype._clone.call(this, pRelationMap);
                    pClone._setCloneParams(this._pPointer._clone(pRelationMap), this._pBuffer, this._eExtractExprType, this._sPaddingExpr, this._sExtractFunction, this._bNeedSecondBracket);
                    return pClone;
                };

                ExtractExprInstruction.prototype._setCloneParams = function (pPointer, pBuffer, eExtractExprType, sPaddingExpr, sExtractFunction, bNeedSecondBracket) {
                    this._pPointer = pPointer;
                    this._pBuffer = pBuffer;
                    this._eExtractExprType = eExtractExprType;
                    this._sPaddingExpr = sPaddingExpr;
                    this._sExtractFunction = sExtractFunction;
                    this._bNeedSecondBracket = bNeedSecondBracket;
                };
                return ExtractExprInstruction;
            })(instructions.ExprInstruction);
            instructions.ExtractExprInstruction = ExtractExprInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/IAFXInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        /// <reference path="ExprInstruction.ts" />
        /// <reference path="SimpleInstruction.ts" />
        /// <reference path="ExtractExprInstruction.ts" />
        /// <reference path="Instruction.ts" />
        (function (instructions) {
            var ExtractStmtInstruction = (function (_super) {
                __extends(ExtractStmtInstruction, _super);
                function ExtractStmtInstruction() {
                    _super.call(this);
                    this._pExtractInVar = null;
                    this._pExtractInExpr = null;
                    this._pExtactExpr = null;
                    this._pInstructionList = [];
                    this._eInstructionType = 57 /* k_ExtractStmtInstruction */;
                }
                ExtractStmtInstruction.prototype.generateStmtForBaseType = function (pVarDecl, pPointer, pBuffer, iPadding, pOffset) {
                    if (typeof pOffset === "undefined") { pOffset = null; }
                    var pVarType = pVarDecl._getType();
                    var pVarNameExpr = pVarDecl._getFullNameExpr();
                    if (pVarType._isComplex() || akra.isNull(pVarNameExpr) || pVarType._getSize() === instructions.Instruction.UNDEFINE_SIZE) {
                        this._setError(2274 /* BAD_EXTRACTING */);
                        return;
                    }

                    // var pPointer: IAFXVariableDeclInstruction = isDef(pPointer) ? pPointer : pVarType._getPointer();
                    // var pBuffer: IAFXVariableDeclInstruction = isDef(pBuffer) ?  pBuffer : pVarType._getVideoBuffer();
                    var pBufferSampler = pBuffer._getVideoBufferSampler();
                    var pBufferHeader = pBuffer._getVideoBufferHeader();

                    var isArray = pVarType._isNotBaseArray();
                    var iLength = pVarType._getLength();
                    var sCodeFragment = "";
                    var pExtractType = isArray ? pVarType._getArrayElementType() : pVarType;

                    if (isArray) {
                        if (iLength === instructions.Instruction.UNDEFINE_LENGTH) {
                            this._setError(2274 /* BAD_EXTRACTING */);
                            return;
                        }

                        sCodeFragment = "for(int i=0;i<" + iLength.toString() + ";i++){";
                        this._push(new instructions.SimpleInstruction(sCodeFragment), true);
                    }

                    this._push(pVarNameExpr, false);

                    if (isArray) {
                        sCodeFragment = "[i]=";
                    } else {
                        sCodeFragment = "=";
                    }

                    this._push(new instructions.SimpleInstruction(sCodeFragment), true);

                    var pExtractType = isArray ? pVarType._getArrayElementType() : pVarType;
                    var pExtractExpr = new instructions.ExtractExprInstruction();
                    var sPaddingExpr = "";

                    if (iPadding > 0) {
                        sPaddingExpr = "+" + iPadding.toString() + ".0";
                    } else {
                        sPaddingExpr = "";
                    }

                    if (isArray) {
                        sPaddingExpr += "+float(i*" + pExtractType._getSize().toString() + ")";
                    }

                    pExtractExpr.initExtractExpr(pExtractType, pPointer, pBuffer, sPaddingExpr, pOffset);

                    if (pExtractExpr._isErrorOccured()) {
                        this._setError(pExtractExpr._getLastError().code, pExtractExpr._getLastError().info);
                        return;
                    }

                    this._push(pExtractExpr, true);

                    sCodeFragment = ";";

                    if (isArray) {
                        sCodeFragment += "}";
                    }

                    this._push(new instructions.SimpleInstruction(sCodeFragment), true);

                    this._pExtactExpr = pExtractExpr;
                    this._pExtractInVar = pVarDecl;
                    this._pExtractInExpr = pVarNameExpr;
                };

                ExtractStmtInstruction.prototype._toFinalCode = function () {
                    var sCode = "";

                    for (var i = 0; i < this._nInstructions; i++) {
                        sCode += this._getInstructions()[i]._toFinalCode();
                    }

                    return sCode;
                };

                ExtractStmtInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    this._pExtractInExpr._addUsedData(pUsedDataCollector, 1 /* k_Write */);
                    this._pExtactExpr._addUsedData(pUsedDataCollector, 0 /* k_Read */);
                };

                ExtractStmtInstruction.prototype.getExtractFunction = function () {
                    return this._pExtactExpr.getExtractFunction();
                };
                return ExtractStmtInstruction;
            })(instructions.ExprInstruction);
            instructions.ExtractStmtInstruction = ExtractStmtInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
/// <reference path="../Effect.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            var FloatInstruction = (function (_super) {
                __extends(FloatInstruction, _super);
                /**
                * EMPTY_OPERATOR EMPTY_ARGUMENTS
                */
                function FloatInstruction() {
                    _super.call(this);
                    this._fValue = 0.0;
                    this._pType = fx.Effect.getSystemType("float").getVariableType();
                    this._eInstructionType = 9 /* k_FloatInstruction */;
                }
                FloatInstruction.prototype._setValue = function (fValue) {
                    this._fValue = fValue;
                };

                FloatInstruction.prototype.toString = function () {
                    return this._fValue;
                };

                FloatInstruction.prototype._toFinalCode = function () {
                    var sCode = "";
                    sCode += this._fValue.toString();
                    if (this._fValue % 1 === 0) {
                        sCode += ".";
                    }
                    return sCode;
                };

                FloatInstruction.prototype._evaluate = function () {
                    this._pLastEvalResult = this._fValue;
                    return true;
                };

                FloatInstruction.prototype._isConst = function () {
                    return true;
                };

                FloatInstruction.prototype._clone = function (pRelationMap) {
                    var pClonedInstruction = (_super.prototype._clone.call(this, pRelationMap));
                    pClonedInstruction._setValue(this._fValue);
                    return pClonedInstruction;
                };
                return FloatInstruction;
            })(instructions.ExprInstruction);
            instructions.FloatInstruction = FloatInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/EEffectErrors.ts" />
/// <reference path="StmtInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Represent for(forInit forCond ForStep) stmt
            * for ExprInstruction or VarDeclInstruction ExprInstruction ExprInstruction StmtInstruction
            */
            var ForStmtInstruction = (function (_super) {
                __extends(ForStmtInstruction, _super);
                function ForStmtInstruction() {
                    _super.call(this);
                    this._pInstructionList = [null, null, null, null];
                    this._eInstructionType = 53 /* k_ForStmtInstruction */;
                }
                ForStmtInstruction.prototype._toFinalCode = function () {
                    var sCode = "for(";

                    sCode += this._getInstructions()[0]._toFinalCode() + ";";
                    sCode += this._getInstructions()[1]._toFinalCode() + ";";
                    sCode += this._getInstructions()[2]._toFinalCode() + ")";
                    sCode += this._getInstructions()[3]._toFinalCode();

                    return sCode;
                };

                ForStmtInstruction.prototype._check = function (eStage, pInfo) {
                    if (typeof pInfo === "undefined") { pInfo = null; }
                    var pInstructionList = this._getInstructions();

                    if (this._nInstructions !== 4) {
                        this._setError(2239 /* BAD_FOR_STEP_EMPTY */);
                        return false;
                    }

                    if (akra.isNull(pInstructionList[0])) {
                        this._setError(2232 /* BAD_FOR_INIT_EMPTY_ITERATOR */);
                        return false;
                    }

                    if (pInstructionList[0]._getInstructionType() !== 15 /* k_VariableDeclInstruction */) {
                        this._setError(2231 /* BAD_FOR_INIT_EXPR */);
                        return false;
                    }

                    if (akra.isNull(pInstructionList[1])) {
                        this._setError(2233 /* BAD_FOR_COND_EMPTY */);
                        return false;
                    }

                    if (pInstructionList[1]._getInstructionType() !== 25 /* k_RelationalExprInstruction */) {
                        this._setError(2238 /* BAD_FOR_COND_RELATION */);
                        return false;
                    }

                    if (pInstructionList[2]._getInstructionType() === 29 /* k_UnaryExprInstruction */ || pInstructionList[2]._getInstructionType() === 24 /* k_AssignmentExprInstruction */ || pInstructionList[2]._getInstructionType() === 32 /* k_PostfixArithmeticInstruction */) {
                        var sOperator = pInstructionList[2]._getOperator();
                        if (sOperator !== "++" && sOperator !== "--" && sOperator !== "+=" && sOperator !== "-=") {
                            this._setError(2240 /* BAD_FOR_STEP_OPERATOR */, { operator: sOperator });
                            return false;
                        }
                    } else {
                        this._setError(2241 /* BAD_FOR_STEP_EXPRESSION */);
                        return false;
                    }

                    return true;
                };

                ForStmtInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    var pForInit = this._getInstructions()[0];
                    var pForCondition = this._getInstructions()[1];
                    var pForStep = this._getInstructions()[2];
                    var pForStmt = this._getInstructions()[3];

                    var pIteratorType = pForInit._getType();

                    pUsedDataCollector[pIteratorType._getInstructionID()] = {
                        type: pIteratorType,
                        isRead: false,
                        isWrite: true,
                        numRead: 0,
                        numWrite: 1,
                        numUsed: 1
                    };

                    pForCondition._addUsedData(pUsedDataCollector, eUsedMode);
                    pForStep._addUsedData(pUsedDataCollector, eUsedMode);
                    pForStmt._addUsedData(pUsedDataCollector, eUsedMode);
                };
                return ForStmtInstruction;
            })(instructions.StmtInstruction);
            instructions.ForStmtInstruction = ForStmtInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Respresnt func(arg1,..., argn)
            * EMPTY_OPERATOR IdExprInstruction ExprInstruction ... ExprInstruction
            */
            var FunctionCallInstruction = (function (_super) {
                __extends(FunctionCallInstruction, _super);
                function FunctionCallInstruction() {
                    _super.call(this);
                    this._pInstructionList = [null];
                    this._eInstructionType = 35 /* k_FunctionCallInstruction */;
                }
                FunctionCallInstruction.prototype._toFinalCode = function () {
                    var sCode = "";

                    sCode += this._getInstructions()[0]._toFinalCode();
                    sCode += "(";
                    for (var i = 1; i < this._nInstructions; i++) {
                        sCode += this._getInstructions()[i]._toFinalCode();
                        if (i !== this._nInstructions - 1) {
                            sCode += ",";
                        }
                    }
                    sCode += ")";

                    return sCode;
                };

                FunctionCallInstruction.prototype.getFunction = function () {
                    return this._pInstructionList[0]._getType()._getParent()._getParent();
                };

                FunctionCallInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    var pExprList = this._getInstructions();
                    var pFunction = this.getFunction();
                    var pArguments = pFunction._getArguments();

                    pExprList[0]._addUsedData(pUsedDataCollector, eUsedMode);

                    for (var i = 0; i < pArguments.length; i++) {
                        if (pArguments[i]._getType()._hasUsage("out")) {
                            pExprList[i + 1]._addUsedData(pUsedDataCollector, 1 /* k_Write */);
                        } else if (pArguments[i]._getType()._hasUsage("inout")) {
                            pExprList[i + 1]._addUsedData(pUsedDataCollector, 2 /* k_ReadWrite */);
                        } else {
                            pExprList[i + 1]._addUsedData(pUsedDataCollector, 0 /* k_Read */);
                        }
                    }
                };
                return FunctionCallInstruction;
            })(instructions.ExprInstruction);
            instructions.FunctionCallInstruction = FunctionCallInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/IAFXInstruction.ts" />
/// <reference path="TypedInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            var DeclInstruction = (function (_super) {
                __extends(DeclInstruction, _super);
                function DeclInstruction() {
                    _super.call(this);
                    this._sSemantic = "";
                    this._pAnnotation = null;
                    this._bForPixel = true;
                    this._bForVertex = true;
                    this._bIsBuiltIn = false;
                    this._eInstructionType = 7 /* k_DeclInstruction */;
                }
                DeclInstruction.prototype._setSemantic = function (sSemantic) {
                    this._sSemantic = sSemantic;
                };

                DeclInstruction.prototype._setAnnotation = function (pAnnotation) {
                    this._pAnnotation = pAnnotation;
                };

                DeclInstruction.prototype._getName = function () {
                    return "";
                };

                DeclInstruction.prototype._getRealName = function () {
                    return "";
                };

                DeclInstruction.prototype._getNameId = function () {
                    return null;
                };

                DeclInstruction.prototype._getSemantic = function () {
                    return this._sSemantic;
                };

                DeclInstruction.prototype._isBuiltIn = function () {
                    return this._bIsBuiltIn;
                };

                DeclInstruction.prototype._setBuiltIn = function (isBuiltIn) {
                    this._bIsBuiltIn = isBuiltIn;
                };

                DeclInstruction.prototype._isForAll = function () {
                    return this._bForVertex && this._bForPixel;
                };
                DeclInstruction.prototype._isForPixel = function () {
                    return this._bForPixel;
                };
                DeclInstruction.prototype._isForVertex = function () {
                    return this._bForVertex;
                };

                DeclInstruction.prototype._setForAll = function (canUse) {
                    this._bForVertex = canUse;
                    this._bForPixel = canUse;
                };
                DeclInstruction.prototype._setForPixel = function (canUse) {
                    this._bForPixel = canUse;
                };
                DeclInstruction.prototype._setForVertex = function (canUse) {
                    this._bForVertex = canUse;
                };

                DeclInstruction.prototype._clone = function (pRelationMap) {
                    if (typeof pRelationMap === "undefined") { pRelationMap = {}; }
                    var pClonedInstruction = (_super.prototype._clone.call(this, pRelationMap));
                    pClonedInstruction._setSemantic(this._sSemantic);
                    pClonedInstruction._setAnnotation(this._pAnnotation);
                    return pClonedInstruction;
                };
                return DeclInstruction;
            })(instructions.TypedInstruction);
            instructions.DeclInstruction = DeclInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/EEffectErrors.ts" />
var akra;
(function (akra) {
    (function (fx) {
        /// <reference path="DeclInstruction.ts" />
        /// <reference path="../Effect.ts" />
        (function (instructions) {
            /**
            * Represent type func(...args)[:Semantic]
            * EMPTY_OPERTOR VariableTypeInstruction IdInstruction VarDeclInstruction ... VarDeclInstruction
            */
            var FunctionDefInstruction = (function (_super) {
                __extends(FunctionDefInstruction, _super);
                //private _sHash: string = "";
                function FunctionDefInstruction() {
                    _super.call(this);
                    this._pParameterList = null;
                    this._pParamListForShaderCompile = null;
                    this._pParamListForShaderInput = null;
                    this._bIsComplexShaderInput = false;
                    this._pReturnType = null;
                    this._pFunctionName = null;
                    this._nParamsNeeded = 0;
                    this._sDefinition = "";
                    this._isAnalyzedForVertexUsage = false;
                    this._isAnalyzedForPixelUsage = false;
                    this._bCanUsedAsFunction = true;
                    this._bShaderDef = false;
                    this._pInstructionList = null;
                    this._pParameterList = [];
                    this._eInstructionType = 47 /* k_FunctionDefInstruction */;
                }
                FunctionDefInstruction.prototype._toFinalCode = function () {
                    var sCode = "";

                    if (!this.isShaderDef()) {
                        sCode += this._pReturnType._toFinalCode();
                        sCode += " " + this._pFunctionName._toFinalCode();
                        sCode += "(";

                        for (var i = 0; i < this._pParameterList.length; i++) {
                            sCode += this._pParameterList[i]._toFinalCode();

                            if (i !== this._pParameterList.length - 1) {
                                sCode += ",";
                            }
                        }

                        sCode += ")";
                    } else {
                        sCode = "void " + this._pFunctionName._toFinalCode() + "()";
                    }

                    return sCode;
                };

                FunctionDefInstruction.prototype._setType = function (pType) {
                    this.setReturnType(pType);
                };

                FunctionDefInstruction.prototype._getType = function () {
                    return this.getReturnType();
                };

                FunctionDefInstruction.prototype.setReturnType = function (pReturnType) {
                    this._pReturnType = pReturnType;
                    pReturnType._setParent(this);
                    return true;
                };
                FunctionDefInstruction.prototype.getReturnType = function () {
                    return this._pReturnType;
                };

                FunctionDefInstruction.prototype.setFunctionName = function (pNameId) {
                    this._pFunctionName = pNameId;
                    pNameId._setParent(this);
                    return true;
                };

                FunctionDefInstruction.prototype._getName = function () {
                    return this._pFunctionName._getName();
                };

                FunctionDefInstruction.prototype._getRealName = function () {
                    return this._pFunctionName._getRealName();
                };

                FunctionDefInstruction.prototype._getNameId = function () {
                    return this._pFunctionName;
                };

                FunctionDefInstruction.prototype.getArguments = function () {
                    return this._pParameterList;
                };

                FunctionDefInstruction.prototype.getNumNeededArguments = function () {
                    return this._nParamsNeeded;
                };

                FunctionDefInstruction.prototype.markAsShaderDef = function (isShaderDef) {
                    this._bShaderDef = isShaderDef;
                };

                FunctionDefInstruction.prototype.isShaderDef = function () {
                    return this._bShaderDef;
                };

                FunctionDefInstruction.prototype.addParameter = function (pParameter, isStrictModeOn) {
                    if (this._pParameterList.length > this._nParamsNeeded && !pParameter._hasInitializer()) {
                        this._setError(2245 /* BAD_FUNCTION_PARAMETER_DEFENITION_NEED_DEFAULT */, {
                            funcName: this._pFunctionName._getName(),
                            varName: pParameter._getName()
                        });
                        return false;
                    }

                    var pParameterType = pParameter._getType();

                    if (pParameterType._isPointer() || pParameterType._containPointer()) {
                        if (pParameterType._hasUsage("uniform") || pParameterType._hasUsage("out") || pParameterType._hasUsage("inout")) {
                            this._setError(2265 /* BAD_FUNCTION_PARAMETER_USAGE */, {
                                funcName: this._pFunctionName._getName(),
                                varName: pParameter._getName()
                            });
                            return false;
                        }

                        this._isAnalyzedForVertexUsage = false;
                        this._isAnalyzedForPixelUsage = true;

                        this._setForPixel(false);
                        this._bCanUsedAsFunction = false;
                        pParameterType._setVideoBufferInDepth();
                    } else if (!isStrictModeOn) {
                        if (pParameterType._isComplex() && !pParameterType._hasFieldWithoutSemantic() && pParameterType._hasAllUniqueSemantics()) {
                            if (pParameter._getSemantic() === "" && pParameterType._hasAllUniqueSemantics() && !pParameterType._hasFieldWithoutSemantic()) {
                                pParameterType._addPointIndexInDepth();
                            } else {
                                pParameterType._addPointIndex(false);
                                pParameterType._setVideoBufferInDepth();
                            }
                        } else if (pParameter._getSemantic() !== "") {
                            pParameterType._addPointIndex(false);
                            pParameterType._setVideoBufferInDepth();
                        }
                    }

                    this._pParameterList.push(pParameter);
                    pParameter._setParent(this);

                    if (!pParameter._hasInitializer()) {
                        this._nParamsNeeded++;
                    }

                    return true;
                };

                FunctionDefInstruction.prototype.getParameListForShaderInput = function () {
                    return this._pParamListForShaderInput;
                };

                FunctionDefInstruction.prototype.isComplexShaderInput = function () {
                    return this._bIsComplexShaderInput;
                };

                FunctionDefInstruction.prototype._clone = function (pRelationMap) {
                    if (typeof pRelationMap === "undefined") { pRelationMap = {}; }
                    var pClone = _super.prototype._clone.call(this, pRelationMap);

                    pClone.setFunctionName(this._pFunctionName._clone(pRelationMap));
                    pClone.setReturnType(this.getReturnType()._clone(pRelationMap));

                    for (var i = 0; i < this._pParameterList.length; i++) {
                        pClone.addParameter(this._pParameterList[i]._clone(pRelationMap));
                    }

                    var pShaderParams = [];
                    for (var i = 0; i < this._pParamListForShaderInput.length; i++) {
                        pShaderParams.push(this._pParamListForShaderInput[i]._clone(pRelationMap));
                    }

                    pClone._setShaderParams(pShaderParams, this._bIsComplexShaderInput);
                    pClone._setAnalyzedInfo(this._isAnalyzedForVertexUsage, this._isAnalyzedForPixelUsage, this._bCanUsedAsFunction);

                    return pClone;
                };

                FunctionDefInstruction.prototype._setShaderParams = function (pParamList, isComplexInput) {
                    this._pParamListForShaderInput = pParamList;
                    this._bIsComplexShaderInput = isComplexInput;
                };

                FunctionDefInstruction.prototype._setAnalyzedInfo = function (isAnalyzedForVertexUsage, isAnalyzedForPixelUsage, bCanUsedAsFunction) {
                    this._isAnalyzedForVertexUsage = isAnalyzedForVertexUsage;
                    this._isAnalyzedForPixelUsage = isAnalyzedForPixelUsage;
                    this._bCanUsedAsFunction = bCanUsedAsFunction;
                };

                FunctionDefInstruction.prototype._getStringDef = function () {
                    if (this._sDefinition === "") {
                        this._sDefinition = this._pReturnType._getHash() + " " + this._getName() + "(";

                        for (var i = 0; i < this._pParameterList.length; i++) {
                            this._sDefinition += this._pParameterList[i]._getType()._getHash() + ",";
                        }

                        this._sDefinition += ")";
                    }

                    return this._sDefinition;
                };

                FunctionDefInstruction.prototype._canUsedAsFunction = function () {
                    return this._bCanUsedAsFunction;
                };

                FunctionDefInstruction.prototype._checkForVertexUsage = function () {
                    if (this._isAnalyzedForVertexUsage) {
                        return this._isForVertex();
                    }

                    this._isAnalyzedForVertexUsage = true;

                    var isGood = true;

                    isGood = this.checkReturnTypeForVertexUsage();
                    if (!isGood) {
                        this._setForVertex(false);
                        return false;
                    }

                    isGood = this.checkArgumentsForVertexUsage();
                    if (!isGood) {
                        this._setForVertex(false);
                        return false;
                    }

                    this._setForVertex(true);

                    return true;
                };

                FunctionDefInstruction.prototype._checkForPixelUsage = function () {
                    if (this._isAnalyzedForPixelUsage) {
                        return this._isForPixel();
                    }

                    this._isAnalyzedForPixelUsage = true;

                    var isGood = true;

                    isGood = this.checkReturnTypeForPixelUsage();
                    if (!isGood) {
                        this._setForPixel(false);
                        return false;
                    }

                    isGood = this.checkArgumentsForPixelUsage();
                    if (!isGood) {
                        this._setForPixel(false);
                        return false;
                    }

                    this._setForPixel(true);

                    return true;
                };

                FunctionDefInstruction.prototype.checkReturnTypeForVertexUsage = function () {
                    var pReturnType = this._pReturnType;
                    var isGood = true;

                    if (pReturnType._isEqual(fx.Effect.getSystemType("void"))) {
                        return true;
                    }

                    if (pReturnType._isComplex()) {
                        isGood = !pReturnType._hasFieldWithoutSemantic();
                        if (!isGood) {
                            return false;
                        }

                        isGood = pReturnType._hasAllUniqueSemantics();
                        if (!isGood) {
                            return false;
                        }

                        // isGood = pReturnType._hasFieldWithSematic("POSITION");
                        // if(!isGood){
                        // 	return false;
                        // }
                        isGood = !pReturnType._containSampler();
                        if (!isGood) {
                            return false;
                        }

                        isGood = !pReturnType._containPointer() && !pReturnType._isPointer();
                        if (!isGood) {
                            return false;
                        }

                        isGood = !pReturnType._containComplexType();
                        if (!isGood) {
                            return false;
                        }

                        return true;
                    } else {
                        isGood = pReturnType._isEqual(fx.Effect.getSystemType("float4"));
                        if (!isGood) {
                            return false;
                        }

                        isGood = (this._getSemantic() === "POSITION");
                        if (!isGood) {
                            return false;
                        }

                        return true;
                    }
                };

                FunctionDefInstruction.prototype.checkReturnTypeForPixelUsage = function () {
                    var pReturnType = this._pReturnType;
                    var isGood = true;

                    if (pReturnType._isEqual(fx.Effect.getSystemType("void"))) {
                        return true;
                    }

                    isGood = pReturnType._isBase();
                    if (!isGood) {
                        return false;
                    }

                    isGood = pReturnType._isEqual(fx.Effect.getSystemType("float4"));
                    if (!isGood) {
                        return false;
                    }

                    isGood = this._getSemantic() === "COLOR";
                    if (!isGood) {
                        return false;
                    }

                    return true;
                };

                FunctionDefInstruction.prototype.checkArgumentsForVertexUsage = function () {
                    var pArguments = this._pParameterList;
                    var isAttributeByStruct = false;
                    var isAttributeByParams = false;
                    var isStartAnalyze = false;

                    this._pParamListForShaderInput = [];
                    this._pParamListForShaderCompile = [];

                    for (var i = 0; i < pArguments.length; i++) {
                        var pParam = pArguments[i];

                        if (pParam._isUniform()) {
                            this._pParamListForShaderCompile.push(pParam);
                            continue;
                        }

                        if (!isStartAnalyze) {
                            if (pParam._getSemantic() === "") {
                                if (pParam._getType()._isBase() || pParam._getType()._hasFieldWithoutSemantic() || !pParam._getType()._hasAllUniqueSemantics()) {
                                    return false;
                                }

                                isAttributeByStruct = true;
                            } else if (pParam._getSemantic() !== "") {
                                if (pParam._getType()._isComplex() && (pParam._getType()._hasFieldWithoutSemantic() || !pParam._getType()._hasAllUniqueSemantics())) {
                                    return false;
                                }

                                isAttributeByParams = true;
                            }

                            isStartAnalyze = true;
                        } else if (isAttributeByStruct) {
                            return false;
                        } else if (isAttributeByParams) {
                            if (pParam._getSemantic() === "") {
                                return false;
                            }

                            if (pParam._getType()._isComplex() && (pParam._getType()._hasFieldWithoutSemantic() || !pParam._getType()._hasAllUniqueSemantics())) {
                                return false;
                            }
                        }

                        this._pParamListForShaderInput.push(pParam);
                    }

                    if (isAttributeByStruct) {
                        this._bIsComplexShaderInput = true;
                    }

                    return true;
                };

                FunctionDefInstruction.prototype.checkArgumentsForPixelUsage = function () {
                    var pArguments = this._pParameterList;
                    var isVaryingsByStruct = false;
                    var isVaryingsByParams = false;
                    var isStartAnalyze = false;

                    this._pParamListForShaderInput = [];
                    this._pParamListForShaderCompile = [];

                    for (var i = 0; i < pArguments.length; i++) {
                        var pParam = pArguments[i];

                        if (pParam._isUniform()) {
                            this._pParamListForShaderCompile.push(pParam);
                            continue;
                        }

                        if (!isStartAnalyze) {
                            if (pParam._getSemantic() === "") {
                                if (pParam._getType()._isBase() || pParam._getType()._hasFieldWithoutSemantic() || !pParam._getType()._hasAllUniqueSemantics() || pParam._getType()._containSampler() || pParam._getType()._containPointer() || pParam._getType()._isPointer()) {
                                    return false;
                                }

                                isVaryingsByStruct = true;
                            } else if (pParam._getSemantic() !== "") {
                                if (pParam._getType()._isStrictPointer() || pParam._getType()._containPointer() || pParam._getType()._containSampler() || fx.Effect.isSamplerType(pParam._getType())) {
                                    //LOG(2, pParam._getType()._isPointer(),
                                    //    pParam._getType()._containPointer(),
                                    //    pParam._getType()._containSampler(),
                                    //    Effect.isSamplerType(pParam._getType()));
                                    return false;
                                }

                                if (pParam._getType()._isComplex() && (pParam._getType()._hasFieldWithoutSemantic() || !pParam._getType()._hasAllUniqueSemantics())) {
                                    return false;
                                }

                                isVaryingsByParams = true;
                            }

                            isStartAnalyze = true;
                        } else if (isVaryingsByStruct) {
                            return false;
                        } else if (isVaryingsByParams) {
                            if (pParam._getSemantic() === "") {
                                return false;
                            }

                            if (pParam._getType()._isStrictPointer() || pParam._getType()._containPointer() || pParam._getType()._containSampler() || fx.Effect.isSamplerType(pParam._getType())) {
                                return false;
                            }

                            if (pParam._getType()._isComplex() && (pParam._getType()._hasFieldWithoutSemantic() || !pParam._getType()._hasAllUniqueSemantics())) {
                                return false;
                            }
                        }

                        this._pParamListForShaderInput.push(pParam);
                    }

                    if (isVaryingsByStruct) {
                        this._bIsComplexShaderInput = true;
                    }

                    return true;
                };
                return FunctionDefInstruction;
            })(instructions.DeclInstruction);
            instructions.FunctionDefInstruction = FunctionDefInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/IAFXInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        /// <reference path="Instruction.ts" />
        (function (instructions) {
            var IdInstruction = (function (_super) {
                __extends(IdInstruction, _super);
                /**
                * EMPTY_OPERATOR EMPTY_ARGUMENTS
                */
                function IdInstruction() {
                    _super.call(this);
                    this._isForVarying = false;
                    this._sName = "";
                    this._sRealName = "";
                    this._eInstructionType = 12 /* k_IdInstruction */;
                }
                IdInstruction.prototype._isVisible = function () {
                    return this._getParent()._isVisible();
                };

                IdInstruction.prototype._getName = function () {
                    return this._sName;
                };

                IdInstruction.prototype._getRealName = function () {
                    if (this._isForVarying) {
                        return "V_" + this._sRealName;
                    } else {
                        return this._sRealName;
                    }
                };

                IdInstruction.prototype._setName = function (sName) {
                    this._sName = sName;
                    this._sRealName = sName;
                };

                IdInstruction.prototype._setRealName = function (sRealName) {
                    this._sRealName = sRealName;
                };

                IdInstruction.prototype._markAsVarying = function (bValue) {
                    this._isForVarying = bValue;
                };

                IdInstruction.prototype.toString = function () {
                    return this._sRealName;
                };

                IdInstruction.prototype._toFinalCode = function () {
                    return this._getRealName();
                };

                IdInstruction.prototype._clone = function (pRelationMap) {
                    var pClonedInstruction = (_super.prototype._clone.call(this, pRelationMap));
                    pClonedInstruction._setName(this._sName);
                    pClonedInstruction._setRealName(this._sRealName);
                    return pClonedInstruction;
                };
                return IdInstruction;
            })(instructions.Instruction);
            instructions.IdInstruction = IdInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
/// <reference path="IdInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            var IdExprInstruction = (function (_super) {
                __extends(IdExprInstruction, _super);
                function IdExprInstruction() {
                    _super.call(this);
                    this._pType = null;
                    this._bToFinalCode = true;
                    this._isInPassUnifoms = false;
                    this._isInPassForeigns = false;
                    this._pInstructionList = [null];
                    this._eInstructionType = 22 /* k_IdExprInstruction */;
                }
                IdExprInstruction.prototype._isVisible = function () {
                    return this._pInstructionList[0]._isVisible();
                };

                IdExprInstruction.prototype._getType = function () {
                    if (!akra.isNull(this._pType)) {
                        return this._pType;
                    } else {
                        var pVar = this._pInstructionList[0];
                        this._pType = pVar._getParent()._getType();
                        return this._pType;
                    }
                };

                IdExprInstruction.prototype._isConst = function () {
                    return this._getType()._isConst();
                };

                IdExprInstruction.prototype._evaluate = function () {
                    if (this._getType()._isForeign()) {
                        var pVal = this._getType()._getParentVarDecl()._getValue();
                        if (!akra.isNull(pVal)) {
                            this._pLastEvalResult = pVal;
                            return true;
                        }
                    }

                    return false;
                };

                IdExprInstruction.prototype._prepareFor = function (eUsedMode) {
                    if (!this._isVisible()) {
                        this._bToFinalCode = false;
                    }

                    if (eUsedMode === 3 /* k_PassFunction */) {
                        var pVarDecl = this._getInstructions()[0]._getParent();
                        if (!this._getType()._isUnverifiable() && akra.isNull(pVarDecl._getParent())) {
                            if (pVarDecl._getType()._isForeign()) {
                                this._isInPassForeigns = true;
                            } else {
                                this._isInPassUnifoms = true;
                            }
                        }
                    }
                };

                IdExprInstruction.prototype._toFinalCode = function () {
                    var sCode = "";
                    if (this._bToFinalCode) {
                        if (this._isInPassForeigns || this._isInPassUnifoms) {
                            var pVarDecl = this._getInstructions()[0]._getParent();
                            if (this._isInPassForeigns) {
                                sCode += "foreigns[\"" + pVarDecl._getNameIndex() + "\"]";
                            } else {
                                sCode += "uniforms[\"" + pVarDecl._getNameIndex() + "\"]";
                            }
                        } else {
                            sCode += this._getInstructions()[0]._toFinalCode();
                        }
                    }
                    return sCode;
                };

                IdExprInstruction.prototype._clone = function (pRelationMap) {
                    if (this._getType()._isSampler()) {
                        //TODO: Need fix for shaders used as functions. Need use relation map.
                        return this;
                    }
                    return _super.prototype._clone.call(this, pRelationMap);
                };

                IdExprInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    if (!this._getType()._isFromVariableDecl()) {
                        return;
                    }

                    var pInfo = null;
                    pInfo = pUsedDataCollector[this._getType()._getInstructionID()];

                    if (!akra.isDef(pInfo)) {
                        pInfo = {
                            type: this._getType(),
                            isRead: false,
                            isWrite: false,
                            numRead: 0,
                            numWrite: 0,
                            numUsed: 0
                        };

                        pUsedDataCollector[this._getType()._getInstructionID()] = pInfo;
                    }

                    if (eUsedMode !== 1 /* k_Write */ && eUsedMode !== 3 /* k_Undefined */) {
                        pInfo.isRead = true;
                        pInfo.numRead++;
                    }

                    if (eUsedMode === 1 /* k_Write */ || eUsedMode === 2 /* k_ReadWrite */) {
                        pInfo.isWrite = true;
                        pInfo.numWrite++;
                    }

                    pInfo.numUsed++;
                };
                return IdExprInstruction;
            })(instructions.ExprInstruction);
            instructions.IdExprInstruction = IdExprInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="StmtInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Represent if(expr) stmt or if(expr) stmt else stmt
            * ( if || if_else ) Expr Stmt [Stmt]
            */
            var IfStmtInstruction = (function (_super) {
                __extends(IfStmtInstruction, _super);
                function IfStmtInstruction() {
                    _super.call(this);
                    this._pInstructionList = [null, null, null];
                    this._eInstructionType = 54 /* k_IfStmtInstruction */;
                }
                IfStmtInstruction.prototype._toFinalCode = function () {
                    var sCode = "";
                    if (this._getOperator() === "if") {
                        sCode += "if(";
                        sCode += this._getInstructions()[0]._toFinalCode() + ")";
                        sCode += this._getInstructions()[1]._toFinalCode();
                    } else {
                        sCode += "if(";
                        sCode += this._getInstructions()[0]._toFinalCode() + ") ";
                        sCode += this._getInstructions()[1]._toFinalCode();
                        sCode += "else ";
                        sCode += this._getInstructions()[2]._toFinalCode();
                    }

                    return sCode;
                };
                return IfStmtInstruction;
            })(instructions.StmtInstruction);
            instructions.IfStmtInstruction = IfStmtInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
/// <reference path="../Effect.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            var IntInstruction = (function (_super) {
                __extends(IntInstruction, _super);
                /**
                * EMPTY_OPERATOR EMPTY_ARGUMENTS
                */
                function IntInstruction() {
                    _super.call(this);
                    this._iValue = 0;
                    this._pType = fx.Effect.getSystemType("int").getVariableType();
                    this._eInstructionType = 8 /* k_IntInstruction */;
                }
                IntInstruction.prototype._setValue = function (iValue) {
                    this._iValue = iValue;
                };

                IntInstruction.prototype.toString = function () {
                    return this._iValue;
                };

                IntInstruction.prototype._toFinalCode = function () {
                    var sCode = "";
                    sCode += this._iValue.toString();
                    return sCode;
                };

                IntInstruction.prototype._evaluate = function () {
                    this._pLastEvalResult = this._iValue;
                    return true;
                };

                IntInstruction.prototype._isConst = function () {
                    return true;
                };

                IntInstruction.prototype._clone = function (pRelationMap) {
                    var pClonedInstruction = (_super.prototype._clone.call(this, pRelationMap));
                    pClonedInstruction._setValue(this._iValue);
                    return pClonedInstruction;
                };
                return IntInstruction;
            })(instructions.ExprInstruction);
            instructions.IntInstruction = IntInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="Instruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            var InstructionCollector = (function (_super) {
                __extends(InstructionCollector, _super);
                function InstructionCollector() {
                    _super.call(this);
                    this._pInstructionList = [];
                    this._eInstructionType = 1 /* k_InstructionCollector */;
                }
                InstructionCollector.prototype._toFinalCode = function () {
                    var sCode = "";
                    for (var i = 0; i < this._nInstructions; i++) {
                        sCode += this._getInstructions()[i]._toFinalCode();
                    }

                    return sCode;
                };
                return InstructionCollector;
            })(instructions.Instruction);
            instructions.InstructionCollector = InstructionCollector;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/IAFXInstruction.ts" />
/// <reference path="../../idl/ITexture.ts" />
var akra;
(function (akra) {
    (function (fx) {
        /// <reference path="ExprInstruction.ts" />
        (function (instructions) {
            /**
            * Represetn sampler_state { states }
            */
            var SamplerStateBlockInstruction = (function (_super) {
                __extends(SamplerStateBlockInstruction, _super);
                function SamplerStateBlockInstruction() {
                    _super.call(this);
                    this._pTexture = null;
                    this._pSamplerParams = null;
                    this._pInstructionList = null;
                    this._eInstructionType = 40 /* k_SamplerStateBlockInstruction */;
                }
                SamplerStateBlockInstruction.prototype.addState = function (sStateType, sStateValue) {
                    if (akra.isNull(this._pSamplerParams)) {
                        this._pSamplerParams = {};
                    }

                    this._pSamplerParams[sStateType] = sStateValue;
                    return;
                };

                SamplerStateBlockInstruction.prototype.setTexture = function (pTexture) {
                    this._pTexture = pTexture;
                };

                SamplerStateBlockInstruction.prototype.getTexture = function () {
                    return this._pTexture;
                };

                SamplerStateBlockInstruction.prototype._isConst = function () {
                    return true;
                };

                SamplerStateBlockInstruction.prototype._evaluate = function () {
                    var pSamplerState = {
                        texture: null,
                        textureName: "",
                        wrap_s: 0,
                        wrap_t: 0,
                        mag_filter: 0,
                        min_filter: 0
                    };

                    if (!akra.isNull(this._pTexture)) {
                        pSamplerState.textureName = this._pTexture._getRealName();
                    }

                    if (!akra.isNull(this._pSamplerParams)) {
                        if (akra.isDef(this._pSamplerParams["ADDRESSU"])) {
                            pSamplerState.wrap_s = SamplerStateBlockInstruction.convertWrapMode(this._pSamplerParams["ADDRESSU"]);
                        }

                        if (akra.isDef(this._pSamplerParams["ADDRESSV"])) {
                            pSamplerState.wrap_t = SamplerStateBlockInstruction.convertWrapMode(this._pSamplerParams["ADDRESSV"]);
                        }

                        if (akra.isDef(this._pSamplerParams["MAGFILTER"])) {
                            pSamplerState.mag_filter = SamplerStateBlockInstruction.convertFilters(this._pSamplerParams["MAGFILTER"]);
                        }

                        if (akra.isDef(this._pSamplerParams["MINFILTER"])) {
                            pSamplerState.min_filter = SamplerStateBlockInstruction.convertFilters(this._pSamplerParams["MINFILTER"]);
                        }
                    }

                    this._pLastEvalResult = pSamplerState;

                    return true;
                };

                SamplerStateBlockInstruction.convertWrapMode = function (sState) {
                    switch (sState) {
                        case "WRAP":
                            return 10497 /* REPEAT */;
                        case "CLAMP":
                            return 33071 /* CLAMP_TO_EDGE */;
                        case "MIRROR":
                            return 33648 /* MIRRORED_REPEAT */;

                        default:
                            return 0;
                    }
                };

                SamplerStateBlockInstruction.convertFilters = function (sState) {
                    switch (sState) {
                        case "NEAREST":
                            return 9728 /* NEAREST */;
                        case "LINEAR":
                            return 9729 /* LINEAR */;
                        case "NEAREST_MIPMAP_NEAREST":
                            return 9984 /* NEAREST_MIPMAP_NEAREST */;
                        case "LINEAR_MIPMAP_NEAREST":
                            return 9985 /* LINEAR_MIPMAP_NEAREST */;
                        case "NEAREST_MIPMAP_LINEAR":
                            return 9986 /* NEAREST_MIPMAP_LINEAR */;
                        case "LINEAR_MIPMAP_LINEAR":
                            return 9987 /* LINEAR_MIPMAP_LINEAR */;

                        default:
                            return 0;
                    }
                };
                return SamplerStateBlockInstruction;
            })(instructions.ExprInstruction);
            instructions.SamplerStateBlockInstruction = SamplerStateBlockInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="StmtInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Represent {stmts}
            * EMPTY_OPERATOR StmtInstruction ... StmtInstruction
            */
            var StmtBlockInstruction = (function (_super) {
                __extends(StmtBlockInstruction, _super);
                function StmtBlockInstruction() {
                    _super.call(this);
                    this._pInstructionList = [];
                    this._eInstructionType = 49 /* k_StmtBlockInstruction */;
                }
                StmtBlockInstruction.prototype._toFinalCode = function () {
                    var sCode = "{" + "\n";

                    for (var i = 0; i < this._nInstructions; i++) {
                        sCode += "\t" + this._pInstructionList[i]._toFinalCode() + "\n";
                    }

                    sCode += "}";

                    return sCode;
                };
                return StmtBlockInstruction;
            })(instructions.StmtInstruction);
            instructions.StmtBlockInstruction = StmtBlockInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/IAFXInstruction.ts" />
/// <reference path="../Effect.ts" />
var akra;
(function (akra) {
    (function (fx) {
        /// <reference path="Instruction.ts" />
        /// <reference path="IdInstruction.ts" />
        /// <reference path="VariableInstruction.ts" />
        /// <reference path="IntInstruction.ts" />
        /// <reference path="IdExprInstruction.ts" />
        (function (instructions) {
            var VariableTypeInstruction = (function (_super) {
                __extends(VariableTypeInstruction, _super);
                function VariableTypeInstruction() {
                    _super.call(this);
                    this._pSubType = null;
                    this._pUsageList = null;
                    this._sName = "";
                    this._bIsWritable = null;
                    this._bIsReadable = null;
                    this._bUsedForWrite = false;
                    this._bUsedForRead = false;
                    this._sHash = "";
                    this._sStrongHash = "";
                    this._bIsArray = false;
                    this._bIsPointer = false;
                    this._bIsStrictPointer = false;
                    this._bIsPointIndex = null;
                    this._bIsUniform = null;
                    this._bIsGlobal = null;
                    this._bIsConst = null;
                    this._bIsShared = null;
                    this._bIsForeign = null;
                    this._iLength = instructions.Instruction.UNDEFINE_LENGTH;
                    this._isNeedToUpdateLength = false;
                    this._bIsFromVariableDecl = null;
                    this._bIsFromTypeDecl = null;
                    this._bIsField = false;
                    this._pArrayIndexExpr = null;
                    this._pArrayElementType = null;
                    this._pFieldDeclMap = null;
                    this._pFieldDeclBySemanticMap = null;
                    this._pFieldIdMap = null;
                    this._pUsedFieldMap = null;
                    this._pVideoBuffer = null;
                    this._pMainPointIndex = null;
                    this._pUpPointIndex = null;
                    this._pDownPointIndex = null;
                    this._nPointDim = 0;
                    this._pPointerList = null;
                    this._iPadding = instructions.Instruction.UNDEFINE_PADDING;
                    this._pSubDeclList = null;
                    this._pAttrOffset = null;
                    this._bUnverifiable = false;
                    this._bCollapsed = false;
                    this._pInstructionList = null;
                    this._eInstructionType = 3 /* k_VariableTypeInstruction */;
                }
                VariableTypeInstruction.prototype.toString = function () {
                    return this._getName() || this._getSubType().toString() || this._getHash();
                };

                VariableTypeInstruction.prototype._toFinalCode = function () {
                    var sCode = "";
                    if (!akra.isNull(this._pUsageList)) {
                        if (!this._isShared()) {
                            for (var i = 0; i < this._pUsageList.length; i++) {
                                sCode += this._pUsageList[i] + " ";
                            }
                        }
                    }

                    sCode += this._getSubType()._toFinalCode();

                    return sCode;
                };

                VariableTypeInstruction.prototype._toDeclString = function () {
                    return this._getSubType()._toDeclString();
                };

                VariableTypeInstruction.prototype._isBuiltIn = function () {
                    return false;
                };

                VariableTypeInstruction.prototype._setBuiltIn = function (isBuiltIn) {
                };

                VariableTypeInstruction.prototype._setCollapsed = function (bValue) {
                    this._bCollapsed = bValue;
                };

                VariableTypeInstruction.prototype._isCollapsed = function () {
                    return this._bCollapsed;
                };

                //-----------------------------------------------------------------//
                //----------------------------SIMPLE TESTS-------------------------//
                //-----------------------------------------------------------------//
                VariableTypeInstruction.prototype._isBase = function () {
                    return this._getSubType()._isBase() && this._bIsArray === false;
                };

                VariableTypeInstruction.prototype._isArray = function () {
                    return this._bIsArray || (this._getSubType()._isArray());
                };

                VariableTypeInstruction.prototype._isNotBaseArray = function () {
                    return this._bIsArray || (this._getSubType()._isNotBaseArray());
                };

                VariableTypeInstruction.prototype._isComplex = function () {
                    return this._getSubType()._isComplex();
                };

                VariableTypeInstruction.prototype._isEqual = function (pType) {
                    if (this._isUnverifiable()) {
                        return true;
                    }

                    if (this._isNotBaseArray() && pType._isNotBaseArray() && (this._getLength() !== pType._getLength() || this._getLength() === instructions.Instruction.UNDEFINE_LENGTH || pType._getLength() === instructions.Instruction.UNDEFINE_LENGTH)) {
                        return false;
                    }

                    if (this._getHash() !== pType._getHash()) {
                        return false;
                    }

                    return true;
                };

                VariableTypeInstruction.prototype._isStrongEqual = function (pType) {
                    if (!this._isEqual(pType) || this._getStrongHash() !== pType._getStrongHash()) {
                        return false;
                    }

                    return true;
                };

                VariableTypeInstruction.prototype._isSampler = function () {
                    return this._getSubType()._isSampler();
                };

                VariableTypeInstruction.prototype._isSamplerCube = function () {
                    return this._getSubType()._isSamplerCube();
                };

                VariableTypeInstruction.prototype._isSampler2D = function () {
                    return this._getSubType()._isSampler2D();
                };

                VariableTypeInstruction.prototype._isWritable = function () {
                    if (!akra.isNull(this._bIsWritable)) {
                        return this._bIsWritable;
                    }

                    if ((this._isArray() && !this._isBase()) || this._isForeign() || this._isUniform()) {
                        this._bIsWritable = false;
                    } else {
                        this._bIsWritable = this._getSubType()._isWritable();
                    }

                    return this._bIsWritable;
                };

                VariableTypeInstruction.prototype._isReadable = function () {
                    if (!akra.isNull(this._bIsReadable)) {
                        return this._bIsReadable;
                    }

                    if (this._hasUsage("out")) {
                        this._bIsReadable = false;
                    } else {
                        this._bIsReadable = this._getSubType()._isReadable();
                    }

                    return this._bIsReadable;
                };

                VariableTypeInstruction.prototype._containArray = function () {
                    return this._getSubType()._containArray();
                };

                VariableTypeInstruction.prototype._containSampler = function () {
                    return this._getSubType()._containSampler();
                };

                VariableTypeInstruction.prototype._containPointer = function () {
                    return this._getSubType()._containPointer();
                };

                VariableTypeInstruction.prototype._containComplexType = function () {
                    return this._getSubType()._containComplexType();
                };

                VariableTypeInstruction.prototype._isPointer = function () {
                    return this._bIsPointer || (this._getSubType()._getInstructionType() === 3 /* k_VariableTypeInstruction */ && this._getSubType()._isPointer());
                };

                VariableTypeInstruction.prototype._isStrictPointer = function () {
                    return this._bIsStrictPointer || (this._getSubType()._getInstructionType() === 3 /* k_VariableTypeInstruction */ && this._getSubType()._isStrictPointer());
                };

                VariableTypeInstruction.prototype._isPointIndex = function () {
                    if (akra.isNull(this._bIsPointIndex)) {
                        this._bIsPointIndex = this._isStrongEqual(fx.Effect.getSystemType("ptr"));
                    }

                    return this._bIsPointIndex;
                };

                VariableTypeInstruction.prototype._isFromVariableDecl = function () {
                    if (!akra.isNull(this._bIsFromVariableDecl)) {
                        return this._bIsFromVariableDecl;
                    }

                    if (akra.isNull(this._getParent())) {
                        this._bIsFromVariableDecl = false;
                    } else {
                        var eParentType = this._getParent()._getInstructionType();

                        if (eParentType === 15 /* k_VariableDeclInstruction */) {
                            this._bIsFromVariableDecl = true;
                        } else if (eParentType === 3 /* k_VariableTypeInstruction */) {
                            this._bIsFromVariableDecl = this._getParent()._isFromVariableDecl();
                        } else {
                            this._bIsFromVariableDecl = false;
                        }
                    }

                    return this._bIsFromVariableDecl;
                };

                VariableTypeInstruction.prototype._isFromTypeDecl = function () {
                    if (!akra.isNull(this._bIsFromTypeDecl)) {
                        return this._bIsFromTypeDecl;
                    }

                    if (akra.isNull(this._getParent())) {
                        this._bIsFromTypeDecl = false;
                    } else {
                        var eParentType = this._getParent()._getInstructionType();

                        if (eParentType === 14 /* k_TypeDeclInstruction */) {
                            this._bIsFromTypeDecl = true;
                        } else if (eParentType === 3 /* k_VariableTypeInstruction */) {
                            this._bIsFromTypeDecl = this._getParent()._isFromVariableDecl();
                        } else {
                            this._bIsFromTypeDecl = false;
                        }
                    }

                    return this._bIsFromTypeDecl;
                };

                VariableTypeInstruction.prototype._isUniform = function () {
                    if (akra.isNull(this._bIsUniform)) {
                        this._bIsUniform = this._hasUsage("uniform");
                    }

                    return this._bIsUniform;
                };

                VariableTypeInstruction.prototype._isGlobal = function () {
                    if (akra.isNull(this._bIsGlobal)) {
                        this._bIsGlobal = this._getScope() === 0;
                    }

                    return this._bIsGlobal;
                };

                VariableTypeInstruction.prototype._isConst = function () {
                    if (akra.isNull(this._bIsConst)) {
                        this._bIsConst = this._hasUsage("const");
                    }

                    return this._bIsConst;
                };

                VariableTypeInstruction.prototype._isShared = function () {
                    if (akra.isNull(this._bIsShared)) {
                        this._bIsShared = this._hasUsage("shared");
                    }

                    return this._bIsShared;
                };

                VariableTypeInstruction.prototype._isForeign = function () {
                    if (akra.isNull(this._bIsForeign)) {
                        this._bIsForeign = this._hasUsage("foreign");
                    }

                    return this._bIsForeign;
                };

                VariableTypeInstruction.prototype._isTypeOfField = function () {
                    if (akra.isNull(this._getParent())) {
                        return false;
                    }

                    if (this._getParent()._getInstructionType() === 15 /* k_VariableDeclInstruction */) {
                        var pParentDecl = this._getParent();
                        return pParentDecl._isField();
                    }

                    return false;
                };

                VariableTypeInstruction.prototype._isUnverifiable = function () {
                    return this._bUnverifiable;
                };

                //-----------------------------------------------------------------//
                //----------------------------SET TYPE INFO------------------------//
                //-----------------------------------------------------------------//
                VariableTypeInstruction.prototype._setName = function (sName) {
                    this._sName = sName;
                };

                VariableTypeInstruction.prototype._canWrite = function (isWritable) {
                    this._bIsWritable = isWritable;
                };

                VariableTypeInstruction.prototype._canRead = function (isReadable) {
                    this._bIsReadable = isReadable;
                };

                //-----------------------------------------------------------------//
                //----------------------------INIT API-----------------------------//
                //-----------------------------------------------------------------//
                VariableTypeInstruction.prototype._setPadding = function (iPadding) {
                    this._iPadding = iPadding;
                };

                VariableTypeInstruction.prototype._pushType = function (pType) {
                    var eType = pType._getInstructionType();

                    if (eType === 4 /* k_SystemTypeInstruction */ || eType === 5 /* k_ComplexTypeInstruction */) {
                        this._pSubType = pType;
                    } else {
                        var pVarType = pType;
                        if (!pVarType._isNotBaseArray() && !pVarType._isPointer()) {
                            var pUsageList = pVarType._getUsageList();
                            if (!akra.isNull(pUsageList)) {
                                for (var i = 0; i < pUsageList.length; i++) {
                                    this._addUsage(pUsageList[i]);
                                }
                            }

                            this._pSubType = pVarType._getSubType();
                        } else {
                            this._pSubType = pType;
                        }
                    }
                };

                VariableTypeInstruction.prototype._addUsage = function (sUsage) {
                    if (akra.isNull(this._pUsageList)) {
                        this._pUsageList = [];
                    }

                    if (!this._hasUsage(sUsage)) {
                        this._pUsageList.push(sUsage);
                    }
                };

                VariableTypeInstruction.prototype._addArrayIndex = function (pExpr) {
                    //TODO: add support for v[][10]
                    this._pArrayElementType = new VariableTypeInstruction();
                    this._pArrayElementType._pushType(this._getSubType());
                    if (!akra.isNull(this._pUsageList)) {
                        for (var i = 0; i < this._pUsageList.length; i++) {
                            this._pArrayElementType._addUsage(this._pUsageList[i]);
                        }
                    }
                    this._pArrayElementType._setParent(this);

                    this._pArrayIndexExpr = pExpr;

                    this._iLength = this._pArrayIndexExpr._evaluate() ? this._pArrayIndexExpr._getEvalValue() : instructions.Instruction.UNDEFINE_LENGTH;

                    this._bIsArray = true;

                    if (this._iLength === instructions.Instruction.UNDEFINE_LENGTH) {
                        this._isNeedToUpdateLength = true;
                    }
                };

                VariableTypeInstruction.prototype._addPointIndex = function (isStrict) {
                    if (typeof isStrict === "undefined") { isStrict = true; }
                    this._nPointDim++;
                    this._bIsPointer = true;
                    if (isStrict) {
                        this._bIsStrictPointer = true;
                    }
                };

                VariableTypeInstruction.prototype._setVideoBuffer = function (pBuffer) {
                    if (this._isPointIndex()) {
                        this._getParent()._getParent()._getType()._setVideoBuffer(pBuffer);
                        return;
                    }

                    this._pVideoBuffer = pBuffer;

                    if (!this._isComplex()) {
                        return;
                    }

                    var pFieldNameList = this._getFieldNameList();

                    for (var i = 0; i < pFieldNameList.length; i++) {
                        var pFieldType = this._getFieldType(pFieldNameList[i]);

                        if (pFieldType._isPointer()) {
                            pFieldType._setVideoBuffer(pBuffer);
                        }
                    }
                };

                VariableTypeInstruction.prototype._initializePointers = function () {
                    this._pPointerList = [];
                    var pDownPointer = this._getParentVarDecl();

                    for (var i = 0; i < this._getPointDim(); i++) {
                        var pPointer = new instructions.VariableDeclInstruction();
                        var pPointerType = new VariableTypeInstruction();
                        var pPointerId = new instructions.IdInstruction();

                        pPointer._push(pPointerType, true);
                        pPointer._push(pPointerId, true);

                        pPointerType._pushType(fx.Effect.getSystemType("ptr"));
                        pPointerId._setName(instructions.Instruction.UNDEFINE_NAME);
                        pPointerId._setName(this._getParentVarDecl()._getName() + "_pointer_" + i.toString());

                        if (i > 0) {
                            (this._pPointerList[i - 1]._getType())._setUpDownPointers(pPointer, pDownPointer);
                            pDownPointer = this._pPointerList[i - 1];
                        } else {
                            pPointerType._setUpDownPointers(null, pDownPointer);
                        }

                        pPointer._setParent(this._getParentVarDecl());
                        this._pPointerList.push(pPointer);
                    }

                    this._pPointerList[this._pPointerList.length - 1]._getType()._setUpDownPointers(null, pDownPointer);
                    this._pUpPointIndex = this._pPointerList[0];
                    this._pMainPointIndex = this._pPointerList[this._pPointerList.length - 1];
                };

                VariableTypeInstruction.prototype._setPointerToStrict = function () {
                    this._bIsStrictPointer = true;
                };

                VariableTypeInstruction.prototype._addPointIndexInDepth = function () {
                    if (!this._isComplex()) {
                        return;
                    }

                    var pFieldNameList = this._getFieldNameList();

                    for (var i = 0; i < pFieldNameList.length; i++) {
                        var pFieldType = this._getFieldType(pFieldNameList[i]);
                        if (!pFieldType._isPointer()) {
                            pFieldType._addPointIndex(false);
                            pFieldType._setVideoBufferInDepth();
                        }
                    }
                };

                VariableTypeInstruction.prototype._setVideoBufferInDepth = function () {
                    if (this._isPointer()) {
                        this._setVideoBuffer(fx.Effect.createVideoBufferVariable());
                    } else if (this._isComplex() && this._containPointer()) {
                        var pFieldNameList = this._getFieldNameList();

                        for (var i = 0; i < pFieldNameList.length; i++) {
                            var pFieldType = this._getFieldType(pFieldNameList[i]);

                            pFieldType._setVideoBufferInDepth();
                        }
                    }
                };

                VariableTypeInstruction.prototype._markAsUnverifiable = function (isUnverifiable) {
                    this._bUnverifiable = true;
                };

                VariableTypeInstruction.prototype._addAttrOffset = function (pOffset) {
                    this._pAttrOffset = pOffset;
                };

                //-----------------------------------------------------------------//
                //----------------------------GET TYPE INFO------------------------//
                //-----------------------------------------------------------------//
                VariableTypeInstruction.prototype._getName = function () {
                    return this._sName;
                };

                VariableTypeInstruction.prototype._getRealName = function () {
                    return this._getBaseType()._getRealName();
                };

                VariableTypeInstruction.prototype._getHash = function () {
                    if (this._sHash === "") {
                        this.calcHash();
                    }

                    return this._sHash;
                };

                VariableTypeInstruction.prototype._getStrongHash = function () {
                    if (this._sStrongHash === "") {
                        this.calcStrongHash();
                    }

                    return this._sStrongHash;
                };

                VariableTypeInstruction.prototype._getSize = function () {
                    if (this._isPointer() || this._isPointIndex()) {
                        return 1;
                    }

                    if (this._bIsArray) {
                        var iSize = this._pArrayElementType._getSize();
                        if (this._iLength === instructions.Instruction.UNDEFINE_LENGTH || iSize === instructions.Instruction.UNDEFINE_SIZE) {
                            return instructions.Instruction.UNDEFINE_SIZE;
                        } else {
                            return iSize * this._iLength;
                        }
                    } else {
                        return this._getSubType()._getSize();
                    }
                };

                VariableTypeInstruction.prototype._getBaseType = function () {
                    return this._getSubType()._getBaseType();
                };

                VariableTypeInstruction.prototype._getLength = function () {
                    if (!this._isNotBaseArray()) {
                        this._iLength = 0;
                        return 0;
                    }

                    if (this._isNotBaseArray() && !this._bIsArray) {
                        this._iLength = this._getSubType()._getLength();
                    } else if (this._iLength === instructions.Instruction.UNDEFINE_LENGTH || this._isNeedToUpdateLength) {
                        var isEval = this._pArrayIndexExpr._evaluate();

                        if (isEval) {
                            var iValue = this._pArrayIndexExpr._getEvalValue();
                            this._iLength = akra.isNumber(iValue) ? iValue : instructions.Instruction.UNDEFINE_LENGTH;
                        }
                    }

                    return this._iLength;
                };

                VariableTypeInstruction.prototype._getPadding = function () {
                    return this._isPointIndex() ? this._getDownPointer()._getType()._getPadding() : this._iPadding;
                };

                VariableTypeInstruction.prototype._getArrayElementType = function () {
                    if (this._isUnverifiable()) {
                        return this;
                    }

                    if (!this._isArray()) {
                        return null;
                    }

                    if (akra.isNull(this._pArrayElementType)) {
                        this._pArrayElementType = new VariableTypeInstruction();
                        this._pArrayElementType._pushType(this._getSubType()._getArrayElementType());
                        if (!akra.isNull(this._pUsageList)) {
                            for (var i = 0; i < this._pUsageList.length; i++) {
                                this._pArrayElementType._addUsage(this._pUsageList[i]);
                            }
                        }
                        this._pArrayElementType._setParent(this);
                    }

                    return this._pArrayElementType;
                };

                VariableTypeInstruction.prototype._getTypeDecl = function () {
                    if (!this._isFromTypeDecl()) {
                        return null;
                    }

                    var eParentType = this._getParent()._getInstructionType();

                    if (eParentType === 14 /* k_TypeDeclInstruction */) {
                        return this._getParent();
                    } else {
                        return this._getParent()._getTypeDecl();
                    }
                };

                VariableTypeInstruction.prototype._hasField = function (sFieldName) {
                    return this._isUnverifiable() ? true : this._getSubType()._hasField(sFieldName);
                };

                VariableTypeInstruction.prototype._hasFieldWithSematic = function (sSemantic) {
                    if (!this._isComplex()) {
                        return false;
                    }

                    return this._getSubType()._hasFieldWithSematic(sSemantic);
                };

                VariableTypeInstruction.prototype._hasAllUniqueSemantics = function () {
                    if (!this._isComplex()) {
                        return false;
                    }

                    return this._getSubType()._hasAllUniqueSemantics();
                };

                VariableTypeInstruction.prototype._hasFieldWithoutSemantic = function () {
                    if (!this._isComplex()) {
                        return false;
                    }

                    return this._getSubType()._hasFieldWithoutSemantic();
                };

                VariableTypeInstruction.prototype._getField = function (sFieldName) {
                    if (!this._hasField(sFieldName)) {
                        return null;
                    }

                    if (akra.isNull(this._pFieldDeclMap)) {
                        this._pFieldDeclMap = {};
                    }

                    if (akra.isDef(this._pFieldDeclMap[sFieldName])) {
                        return this._pFieldDeclMap[sFieldName];
                    }

                    var pField = new instructions.VariableDeclInstruction();

                    if (!this._isUnverifiable()) {
                        var pSubField = this._getSubType()._getField(sFieldName);

                        var pFieldType = new VariableTypeInstruction();
                        pFieldType._pushType(pSubField._getType());

                        // if(!this._isBase()){
                        pFieldType._setPadding(pSubField._getType()._getPadding());

                        // }
                        pField._push(pFieldType, true);
                        pField._push(pSubField._getNameId(), false);
                        pField._setSemantic(pSubField._getSemantic());
                    } else {
                        var pFieldName = new instructions.IdInstruction();

                        pFieldName._setName(sFieldName);
                        pFieldName._setRealName(sFieldName);

                        pField._push(this, false);
                        pField._push(pFieldName, true);
                    }

                    pField._setParent(this);

                    this._pFieldDeclMap[sFieldName] = pField;

                    return pField;
                };

                VariableTypeInstruction.prototype._getFieldBySemantic = function (sSemantic) {
                    if (this._hasFieldWithSematic(sSemantic)) {
                        return null;
                    }

                    if (akra.isNull(this._pFieldDeclBySemanticMap)) {
                        this._pFieldDeclBySemanticMap = {};
                    }

                    if (akra.isDef(this._pFieldDeclBySemanticMap[sSemantic])) {
                        return this._pFieldDeclBySemanticMap[sSemantic];
                    }

                    var pField = new instructions.VariableDeclInstruction();
                    var pSubField = this._getSubType()._getFieldBySemantic(sSemantic);

                    var pFieldType = new VariableTypeInstruction();
                    pFieldType._pushType(pSubField._getType());

                    // if(!this._isBase()){
                    pFieldType._setPadding(pSubField._getType()._getPadding());

                    // }
                    pField._push(pFieldType, true);
                    pField._push(pSubField._getNameId(), false);

                    pField._setParent(this);

                    this._pFieldDeclBySemanticMap[sSemantic] = pField;

                    return pField;
                };

                VariableTypeInstruction.prototype._getFieldType = function (sFieldName) {
                    return this._getField(sFieldName)._getType();
                };

                VariableTypeInstruction.prototype._getFieldNameList = function () {
                    return this._getSubType()._getFieldNameList();
                };

                VariableTypeInstruction.prototype._getUsageList = function () {
                    return this._pUsageList;
                };

                VariableTypeInstruction.prototype._getSubType = function () {
                    return this._pSubType;
                };

                VariableTypeInstruction.prototype._hasUsage = function (sUsageName) {
                    if (akra.isNull(this._pUsageList)) {
                        return false;
                    }

                    for (var i = 0; i < this._pUsageList.length; i++) {
                        if (this._pUsageList[i] === sUsageName) {
                            return true;
                        }
                    }

                    if (!akra.isNull(this._getSubType()) && this._getSubType()._getInstructionType() === 3 /* k_VariableTypeInstruction */) {
                        return this._getSubType()._hasUsage(sUsageName);
                    }

                    return false;
                };

                VariableTypeInstruction.prototype._hasVideoBuffer = function () {
                    return !akra.isNull(this._getVideoBuffer());
                };

                VariableTypeInstruction.prototype._getPointDim = function () {
                    return this._nPointDim || ((this._getSubType()._getInstructionType() === 3 /* k_VariableTypeInstruction */) ? this._getSubType()._getPointDim() : 0);
                };

                VariableTypeInstruction.prototype._getPointer = function () {
                    if (!this._isFromVariableDecl() || !(this._isPointer() || this._isPointIndex()) || !this._hasVideoBuffer()) {
                        return null;
                    }

                    if (!akra.isNull(this._pUpPointIndex)) {
                        return this._pUpPointIndex;
                    }

                    if (this._isPointIndex()) {
                        return null;
                    }

                    this._initializePointers();

                    return this._pUpPointIndex;
                };

                VariableTypeInstruction.prototype._getVideoBuffer = function () {
                    if (this._isPointIndex()) {
                        return this._getParent()._getParent()._getType()._getVideoBuffer();
                    }

                    return this._pVideoBuffer;
                };

                VariableTypeInstruction.prototype._getFieldExpr = function (sFieldName) {
                    if (!this._hasField(sFieldName)) {
                        return null;
                    }
                    var pField = this._getField(sFieldName);
                    var pExpr = new instructions.IdExprInstruction();
                    pExpr._push(pField._getNameId(), false);
                    pExpr._setType(pField._getType());

                    return pExpr;
                };

                VariableTypeInstruction.prototype._getFieldIfExist = function (sFieldName) {
                    if (akra.isNull(this._pFieldDeclMap) && akra.isDef(this._pFieldDeclMap[sFieldName])) {
                        return this._pFieldDeclMap[sFieldName];
                    } else {
                        return null;
                    }
                };

                VariableTypeInstruction.prototype._getSubVarDecls = function () {
                    if (!this.canHaveSubDecls()) {
                        return null;
                    }

                    if (akra.isNull(this._pSubDeclList)) {
                        this.generateSubDeclList();
                    }
                    return this._pSubDeclList;
                };

                VariableTypeInstruction.prototype._getFullName = function () {
                    if (!this._isFromVariableDecl()) {
                        return "Not from variable decl";
                    }

                    var eParentType = this._getParent()._getInstructionType();

                    if (eParentType === 15 /* k_VariableDeclInstruction */) {
                        return this._getParent()._getFullName();
                    } else {
                        return this._getParent()._getFullName();
                    }
                };

                VariableTypeInstruction.prototype._getVarDeclName = function () {
                    if (!this._isFromVariableDecl()) {
                        return "";
                    }

                    var eParentType = this._getParent()._getInstructionType();

                    if (eParentType === 15 /* k_VariableDeclInstruction */) {
                        return this._getParent()._getName();
                    } else {
                        return this._getParent()._getVarDeclName();
                    }
                };

                VariableTypeInstruction.prototype._getTypeDeclName = function () {
                    if (!this._isFromVariableDecl()) {
                        return "";
                    }

                    var eParentType = this._getParent()._getInstructionType();

                    if (eParentType === 15 /* k_VariableDeclInstruction */) {
                        return this._getParent()._getName();
                    } else {
                        return this._getParent()._getTypeDeclName();
                    }
                };

                VariableTypeInstruction.prototype._getParentVarDecl = function () {
                    if (!this._isFromVariableDecl()) {
                        return null;
                    }

                    var eParentType = this._getParent()._getInstructionType();

                    if (eParentType === 15 /* k_VariableDeclInstruction */) {
                        return this._getParent();
                    } else {
                        return this._getParent()._getParentVarDecl();
                    }
                };

                VariableTypeInstruction.prototype._getParentContainer = function () {
                    if (!this._isFromVariableDecl() || !this._isTypeOfField()) {
                        return null;
                    }

                    var pContainerType = this._getParentVarDecl()._getParent();
                    if (!pContainerType._isFromVariableDecl()) {
                        return null;
                    }

                    return pContainerType._getParentVarDecl();
                };

                VariableTypeInstruction.prototype._getMainVariable = function () {
                    if (!this._isFromVariableDecl()) {
                        return null;
                    }

                    if (this._isTypeOfField()) {
                        return this._getParent()._getParent()._getMainVariable();
                    } else {
                        return this._getParentVarDecl();
                    }
                };

                VariableTypeInstruction.prototype._getMainPointer = function () {
                    if (akra.isNull(this._pMainPointIndex)) {
                        if (akra.isNull(this._getPointer())) {
                            this._pMainPointIndex = this._getParentVarDecl();
                        } else {
                            this._pMainPointIndex = this._getUpPointer()._getType()._getMainPointer();
                        }
                    }

                    return this._pMainPointIndex;
                };

                VariableTypeInstruction.prototype._getUpPointer = function () {
                    return this._pUpPointIndex;
                };

                VariableTypeInstruction.prototype._getDownPointer = function () {
                    return this._pDownPointIndex;
                };

                VariableTypeInstruction.prototype._getAttrOffset = function () {
                    return this._pAttrOffset;
                };

                //-----------------------------------------------------------------//
                //----------------------------SYSTEM-------------------------------//
                //-----------------------------------------------------------------//
                VariableTypeInstruction.prototype._wrap = function () {
                    var pCloneType = new VariableTypeInstruction();
                    pCloneType._pushType(this);

                    return pCloneType;
                };

                VariableTypeInstruction.prototype._clone = function (pRelationMap) {
                    if (typeof pRelationMap === "undefined") { pRelationMap = {}; }
                    if (akra.isDef(pRelationMap[this._getInstructionID()])) {
                        return pRelationMap[this._getInstructionID()];
                    }

                    if (this._pParentInstruction === null || !akra.isDef(pRelationMap[this._pParentInstruction._getInstructionID()]) || pRelationMap[this._pParentInstruction._getInstructionID()] === this._pParentInstruction) {
                        //pRelationMap[this._getInstructionID()] = this;
                        return this;
                    }

                    var pClone = _super.prototype._clone.call(this, pRelationMap);

                    pClone._pushType(this._pSubType._clone(pRelationMap));
                    if (!akra.isNull(this._pUsageList)) {
                        for (var i = 0; i < this._pUsageList.length; i++) {
                            pClone._addUsage(this._pUsageList[i]);
                        }
                    }

                    pClone._canWrite(this._bIsWritable);
                    pClone._canRead(this._bIsReadable);
                    pClone._setCloneHash(this._sHash, this._sStrongHash);
                    pClone._setPadding(this._getPadding());

                    if (this._bIsArray) {
                        pClone._setCloneArrayIndex(this._pArrayElementType._clone(pRelationMap), this._pArrayIndexExpr._clone(pRelationMap), this._iLength);
                    }

                    if (this._bIsPointer) {
                        var pClonePointerList = null;
                        if (!akra.isNull(this._pPointerList)) {
                            pClonePointerList = new Array(this._pPointerList.length);
                            var pDownPointer = pClone._getParentVarDecl();

                            for (var i = 0; i < this._pPointerList.length; i++) {
                                pClonePointerList[i] = this._pPointerList[i]._clone(pRelationMap);

                                if (i > 0) {
                                    (pClonePointerList[i - 1]._getType())._setUpDownPointers(pClonePointerList[i], pDownPointer);
                                    pDownPointer = pClonePointerList[i - 1];
                                } else {
                                    pClonePointerList[0]._getType()._setUpDownPointers(null, pDownPointer);
                                }
                            }

                            pClonePointerList[pClonePointerList.length - 1]._getType()._setUpDownPointers(null, pDownPointer);
                        }

                        pClone._setClonePointeIndexes(this._getPointDim(), pClonePointerList);
                    }

                    if (!akra.isNull(this._pFieldDeclMap)) {
                        var sFieldName = "";
                        var pCloneFieldMap = {};

                        for (sFieldName in this._pFieldDeclMap) {
                            pCloneFieldMap[sFieldName] = this._pFieldDeclMap[sFieldName]._clone(pRelationMap);
                        }

                        pClone._setCloneFields(pCloneFieldMap);
                    }

                    return pClone;
                };

                VariableTypeInstruction.prototype._blend = function (pType, eMode) {
                    if (this === pType) {
                        return this;
                    }

                    if (eMode === 4 /* k_Global */) {
                        return null;
                    }

                    if (this._isComplex() !== pType._isComplex() || (this._isNotBaseArray() !== pType._isNotBaseArray()) || (this._isStrictPointer() !== pType._isStrictPointer())) {
                        return null;
                    }

                    if (this._isNotBaseArray() || this._getLength() === instructions.Instruction.UNDEFINE_LENGTH || this._getLength() !== pType._getLength()) {
                        return null;
                    }

                    var pBlendBaseType = this._getBaseType()._blend(pType._getBaseType(), eMode);
                    if (akra.isNull(pBlendBaseType)) {
                        return null;
                    }

                    var pBlendType = new VariableTypeInstruction();
                    pBlendType._pushType(pBlendBaseType);

                    if (this._isNotBaseArray()) {
                        var iLength = this._getLength();
                        var pLengthExpr = new instructions.IntInstruction();
                        pLengthExpr._setValue(iLength);
                        pBlendType._addArrayIndex(pLengthExpr);
                    }

                    return pBlendType;
                };

                VariableTypeInstruction.prototype._setCloneHash = function (sHash, sStrongHash) {
                    this._sHash = sHash;
                    this._sStrongHash = sStrongHash;
                };

                VariableTypeInstruction.prototype._setCloneArrayIndex = function (pElementType, pIndexExpr, iLength) {
                    this._bIsArray = true;
                    this._pArrayElementType = pElementType;
                    this._pArrayIndexExpr = pIndexExpr;
                    this._iLength = iLength;
                };

                VariableTypeInstruction.prototype._setClonePointeIndexes = function (nDim, pPointerList) {
                    this._bIsPointer = true;
                    this._nPointDim = nDim;
                    this._pPointerList = pPointerList;
                    if (!akra.isNull(this._pPointerList)) {
                        this._pUpPointIndex = this._pPointerList[0];
                    }
                };

                VariableTypeInstruction.prototype._setCloneFields = function (pFieldMap) {
                    this._pFieldDeclMap = pFieldMap;
                };

                VariableTypeInstruction.prototype._setUpDownPointers = function (pUpPointIndex, pDownPointIndex) {
                    this._pUpPointIndex = pUpPointIndex;
                    this._pDownPointIndex = pDownPointIndex;
                };

                VariableTypeInstruction.prototype.calcHash = function () {
                    var sHash = this._getSubType()._getHash();

                    if (this._bIsArray) {
                        sHash += "[";

                        var iLength = this._getLength();

                        if (iLength === instructions.Instruction.UNDEFINE_LENGTH) {
                            sHash += "undef";
                        } else {
                            sHash += iLength.toString();
                        }

                        sHash += "]";
                    }

                    this._sHash = sHash;
                };

                VariableTypeInstruction.prototype.calcStrongHash = function () {
                    var sStrongHash = this._getSubType()._getStrongHash();

                    if (this._bIsArray) {
                        sStrongHash += "[";

                        var iLength = this._getLength();

                        if (iLength === instructions.Instruction.UNDEFINE_LENGTH) {
                            sStrongHash += "undef";
                        } else {
                            sStrongHash += iLength.toString();
                        }

                        sStrongHash += "]";
                    }
                    if (this._isPointer()) {
                        for (var i = 0; i < this._getPointDim(); i++) {
                            sStrongHash = "@" + sStrongHash;
                        }
                    }

                    this._sStrongHash = sStrongHash;
                };

                VariableTypeInstruction.prototype.generateSubDeclList = function () {
                    if (!this.canHaveSubDecls()) {
                        return;
                    }

                    var pDeclList = [];
                    var i = 0;

                    if (!akra.isNull(this._pAttrOffset)) {
                        pDeclList.push(this._pAttrOffset);
                    }

                    if (this._isPointer()) {
                        if (akra.isNull(this._getUpPointer())) {
                            this._initializePointers();
                        }

                        for (i = 0; i < this._pPointerList.length; i++) {
                            pDeclList.push(this._pPointerList[i]);
                        }
                    }

                    if (this._isComplex()) {
                        var pFieldNameList = this._getFieldNameList();

                        for (i = 0; i < pFieldNameList.length; i++) {
                            var pField = this._getField(pFieldNameList[i]);
                            var pFieldSubDeclList = pField._getSubVarDecls();

                            if (!akra.isNull(pFieldSubDeclList)) {
                                for (var j = 0; j < pFieldSubDeclList.length; j++) {
                                    pDeclList.push(pFieldSubDeclList[j]);
                                }
                            }
                        }
                    }

                    this._pSubDeclList = pDeclList;
                };

                VariableTypeInstruction.prototype.canHaveSubDecls = function () {
                    return this._isComplex() || this._isPointer() || !akra.isNull(this._pAttrOffset);
                };
                return VariableTypeInstruction;
            })(instructions.Instruction);
            instructions.VariableTypeInstruction = VariableTypeInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/IAFXInstruction.ts" />
/// <reference path="../../idl/parser/IParser.ts" />
/// <reference path="../../idl/EEffectErrors.ts" />
var akra;
(function (akra) {
    (function (fx) {
        /// <reference path="../../debug.ts" />
        /// <reference path="DeclInstruction.ts" />
        /// <reference path="ExtractStmtInstruction.ts" />
        /// <reference path="FunctionDefInstruction.ts" />
        /// <reference path="IdInstruction.ts" />
        /// <reference path="Instruction.ts" />
        /// <reference path="InstructionCollector.ts" />
        /// <reference path="SamplerStateBlockInstruction.ts" />
        /// <reference path="StmtBlockInstruction.ts" />
        /// <reference path="VariableTypeInstruction.ts" />
        /// <reference path="VariableInstruction.ts" />
        /// <reference path="../Effect.ts" />
        (function (instructions) {
            /**
            * Represent type func(...args)[:Semantic] [<Annotation> {stmts}]
            * EMPTY_OPERTOR FunctionDefInstruction StmtBlockInstruction
            */
            var FunctionDeclInstruction = (function (_super) {
                __extends(FunctionDeclInstruction, _super);
                function FunctionDeclInstruction() {
                    _super.call(this);
                    this._pFunctionDefenition = null;
                    this._pImplementation = null;
                    this._eFunctionType = 2 /* k_Function */;
                    this._bUsedAsFunction = false;
                    this._bUsedAsVertex = false;
                    this._bUsedAsPixel = false;
                    this._bCanUsedAsFunction = true;
                    this._bUsedInVertex = false;
                    this._bUsedInPixel = false;
                    this._pParseNode = null;
                    this._iImplementationScope = instructions.Instruction.UNDEFINE_SCOPE;
                    this._isInBlackList = false;
                    this._pOutVariable = null;
                    //Info about used data
                    this._pUsedFunctionMap = null;
                    this._pUsedFunctionList = null;
                    this._pAttributeVariableMap = null;
                    this._pVaryingVariableMap = null;
                    this._pUsedVarTypeMap = null;
                    this._pSharedVariableMap = null;
                    this._pGlobalVariableMap = null;
                    this._pUniformVariableMap = null;
                    this._pForeignVariableMap = null;
                    this._pTextureVariableMap = null;
                    // protected _pSharedVariableTypeList: IAFXVariableTypeInstruction[] = null;
                    // protected _pGlobalVariableTypeList: IAFXVariableTypeInstruction[] = null;
                    // protected _pUniformVariableTypeList: IAFXVariableTypeInstruction[] = null;
                    // protected _pForeignVariableTypeList: IAFXVariableTypeInstructionnt[] = null;
                    this._pUsedComplexTypeMap = null;
                    this._pAttributeVariableKeys = null;
                    this._pVaryingVariableKeys = null;
                    this._pSharedVariableKeys = null;
                    this._pUniformVariableKeys = null;
                    this._pForeignVariableKeys = null;
                    this._pGlobalVariableKeys = null;
                    this._pTextureVariableKeys = null;
                    this._pUsedComplexTypeKeys = null;
                    this._pVertexShader = null;
                    this._pPixelShader = null;
                    this._pExtSystemTypeList = null;
                    this._pExtSystemFunctionList = null;
                    this._pExtSystemMacrosList = null;
                    this._pInstructionList = [null, null];
                    this._eInstructionType = 44 /* k_FunctionDeclInstruction */;
                }
                FunctionDeclInstruction.prototype._toFinalCode = function () {
                    var sCode = "";

                    sCode += this._pFunctionDefenition._toFinalCode();
                    sCode += this._pImplementation._toFinalCode();

                    return sCode;
                };

                FunctionDeclInstruction.prototype._toFinalDefCode = function () {
                    return this._pFunctionDefenition._toFinalCode();
                };

                FunctionDeclInstruction.prototype._getType = function () {
                    return this._getReturnType();
                };

                FunctionDeclInstruction.prototype._getName = function () {
                    return this._pFunctionDefenition._getName();
                };

                FunctionDeclInstruction.prototype._getRealName = function () {
                    return this._pFunctionDefenition._getRealName();
                };

                FunctionDeclInstruction.prototype._getNameId = function () {
                    return this._pFunctionDefenition._getNameId();
                };

                FunctionDeclInstruction.prototype._getArguments = function () {
                    return this._pFunctionDefenition.getArguments();
                };

                FunctionDeclInstruction.prototype._getNumNeededArguments = function () {
                    return this._pFunctionDefenition.getNumNeededArguments();
                };

                FunctionDeclInstruction.prototype._hasImplementation = function () {
                    return !akra.isNull(this._pImplementation) || !akra.isNull(this._pParseNode);
                };

                FunctionDeclInstruction.prototype._getReturnType = function () {
                    return this._pFunctionDefenition.getReturnType();
                };

                FunctionDeclInstruction.prototype._getFunctionType = function () {
                    return this._eFunctionType;
                };

                FunctionDeclInstruction.prototype._setFunctionType = function (eFunctionType) {
                    this._eFunctionType = eFunctionType;
                };

                FunctionDeclInstruction.prototype._setImplementationScope = function (iScope) {
                    this._iImplementationScope = iScope;
                };

                FunctionDeclInstruction.prototype._getImplementationScope = function () {
                    return this._iImplementationScope;
                };

                FunctionDeclInstruction.prototype._setParseNode = function (pNode) {
                    this._pParseNode = pNode;
                };

                FunctionDeclInstruction.prototype._getParseNode = function () {
                    return this._pParseNode;
                };

                FunctionDeclInstruction.prototype._setFunctionDef = function (pFunctionDef) {
                    this._pFunctionDefenition = pFunctionDef;
                    this._pInstructionList[0] = pFunctionDef;
                    pFunctionDef._setParent(this);
                    this._nInstructions = this._nInstructions === 0 ? 1 : this._nInstructions;
                };

                FunctionDeclInstruction.prototype._setImplementation = function (pImplementation) {
                    this._pImplementation = pImplementation;
                    this._pInstructionList[1] = pImplementation;
                    pImplementation._setParent(pImplementation);
                    this._nInstructions = 2;

                    this._pParseNode = null;
                };

                FunctionDeclInstruction.prototype._clone = function (pRelationMap) {
                    if (typeof pRelationMap === "undefined") { pRelationMap = {}; }
                    var pClone = _super.prototype._clone.call(this, pRelationMap);

                    if (!akra.isNull(this._pOutVariable)) {
                        pClone._setOutVariable(pRelationMap[this._pOutVariable._getInstructionID()]);
                    }

                    var pUsedVarTypeMap = this.cloneVarTypeUsedMap(this._pUsedVarTypeMap, pRelationMap);
                    var pSharedVariableMap = this.cloneVarDeclMap(this._pSharedVariableMap, pRelationMap);
                    var pGlobalVariableMap = this.cloneVarDeclMap(this._pGlobalVariableMap, pRelationMap);
                    var pUniformVariableMap = this.cloneVarDeclMap(this._pUniformVariableMap, pRelationMap);
                    var pForeignVariableMap = this.cloneVarDeclMap(this._pForeignVariableMap, pRelationMap);
                    var pTextureVariableMap = this.cloneVarDeclMap(this._pTextureVariableMap, pRelationMap);
                    var pUsedComplexTypeMap = this.cloneTypeMap(this._pUsedComplexTypeMap, pRelationMap);

                    pClone._setUsedFunctions(this._pUsedFunctionMap, this._pUsedFunctionList);
                    pClone._setUsedVariableData(pUsedVarTypeMap, pSharedVariableMap, pGlobalVariableMap, pUniformVariableMap, pForeignVariableMap, pTextureVariableMap, pUsedComplexTypeMap);
                    pClone._initAfterClone();

                    return pClone;
                };

                FunctionDeclInstruction.prototype._addOutVariable = function (pVariable) {
                    if (!akra.isNull(this._pOutVariable)) {
                        return false;
                    }

                    if (!pVariable._getType()._isEqual(this._getReturnType())) {
                        return false;
                    }

                    this._pOutVariable = pVariable;
                    return true;
                };

                FunctionDeclInstruction.prototype._getOutVariable = function () {
                    return this._pOutVariable;
                };

                FunctionDeclInstruction.prototype._getVertexShader = function () {
                    return this._pVertexShader;
                };

                FunctionDeclInstruction.prototype._getPixelShader = function () {
                    return this._pPixelShader;
                };

                FunctionDeclInstruction.prototype._markUsedAs = function (eUsedType) {
                    switch (eUsedType) {
                        case 0 /* k_Vertex */:
                            this._bUsedInVertex = true;
                            this._bUsedAsVertex = true;
                            break;
                        case 1 /* k_Pixel */:
                            this._bUsedInPixel = true;
                            this._bUsedAsPixel = true;
                            break;
                        case 2 /* k_Function */:
                            this._bUsedAsFunction = true;
                            break;
                    }
                };

                FunctionDeclInstruction.prototype._isUsedAs = function (eUsedType) {
                    switch (eUsedType) {
                        case 0 /* k_Vertex */:
                            return this._bUsedAsVertex;
                        case 1 /* k_Pixel */:
                            return this._bUsedAsPixel;
                        case 2 /* k_Function */:
                            return this._bUsedAsFunction;
                    }
                };

                FunctionDeclInstruction.prototype._isUsedAsFunction = function () {
                    return this._bUsedAsFunction;
                };

                FunctionDeclInstruction.prototype._isUsedAsVertex = function () {
                    return this._bUsedAsVertex;
                };

                FunctionDeclInstruction.prototype._isUsedAsPixel = function () {
                    return this._bUsedAsPixel;
                };

                FunctionDeclInstruction.prototype._markUsedInVertex = function () {
                    this._bUsedInVertex = true;
                };

                FunctionDeclInstruction.prototype._markUsedInPixel = function () {
                    this._bUsedInPixel = true;
                };

                FunctionDeclInstruction.prototype._isUsedInVertex = function () {
                    return this._bUsedInVertex;
                };

                FunctionDeclInstruction.prototype._isUsedInPixel = function () {
                    return this._bUsedInPixel;
                };

                FunctionDeclInstruction.prototype._isUsed = function () {
                    return this._bUsedAsFunction || this._bUsedAsVertex || this._bUsedAsPixel;
                };

                FunctionDeclInstruction.prototype._checkVertexUsage = function () {
                    return this._isUsedInVertex() ? this._isForVertex() : true;
                };

                FunctionDeclInstruction.prototype._checkPixelUsage = function () {
                    return this._isUsedInPixel() ? this._isForPixel() : true;
                };

                FunctionDeclInstruction.prototype._checkDefenitionForVertexUsage = function () {
                    return this._pFunctionDefenition._checkForVertexUsage();
                };

                FunctionDeclInstruction.prototype._checkDefenitionForPixelUsage = function () {
                    return this._pFunctionDefenition._checkForPixelUsage();
                };

                FunctionDeclInstruction.prototype._canUsedAsFunction = function () {
                    return this._bCanUsedAsFunction && this._pFunctionDefenition._canUsedAsFunction();
                };

                FunctionDeclInstruction.prototype._notCanUsedAsFunction = function () {
                    this._bCanUsedAsFunction = false;
                };

                FunctionDeclInstruction.prototype._addUsedFunction = function (pFunction) {
                    if (pFunction._getInstructionType() === 46 /* k_SystemFunctionInstruction */ && !pFunction._isBuiltIn()) {
                        this.addExtSystemFunction(pFunction);
                        return true;
                    }

                    if (akra.isNull(this._pUsedFunctionMap)) {
                        this._pUsedFunctionMap = {};
                        this._pUsedFunctionList = [];
                    }

                    var iFuncId = pFunction._getInstructionID();

                    if (!akra.isDef(this._pUsedFunctionMap[iFuncId])) {
                        this._pUsedFunctionMap[iFuncId] = pFunction;
                        this._pUsedFunctionList.push(pFunction);
                        return true;
                    }

                    return false;
                };

                FunctionDeclInstruction.prototype._addUsedVariable = function (pVariable) {
                };

                FunctionDeclInstruction.prototype._getUsedFunctionList = function () {
                    return this._pUsedFunctionList;
                };

                FunctionDeclInstruction.prototype._isBlackListFunction = function () {
                    return this._isInBlackList;
                };

                FunctionDeclInstruction.prototype._addToBlackList = function () {
                    this._isInBlackList = true;
                };

                FunctionDeclInstruction.prototype._getStringDef = function () {
                    return this._pFunctionDefenition._getStringDef();
                };

                FunctionDeclInstruction.prototype._convertToVertexShader = function () {
                    var pShader = null;

                    if ((!this._canUsedAsFunction() || !this._isUsedAsFunction()) && (!this._isUsedInPixel())) {
                        pShader = this;
                    } else {
                        pShader = this._clone();
                    }

                    pShader._prepareForVertex();
                    this._pVertexShader = pShader;

                    return pShader;
                };

                FunctionDeclInstruction.prototype._convertToPixelShader = function () {
                    var pShader = null;

                    if ((!this._canUsedAsFunction() || !this._isUsedAsFunction()) && (!this._isUsedInVertex())) {
                        pShader = this;
                    } else {
                        pShader = this._clone();
                    }

                    pShader._prepareForPixel();
                    this._pPixelShader = pShader;

                    return pShader;
                };

                FunctionDeclInstruction.prototype._prepareForVertex = function () {
                    this._setFunctionType(0 /* k_Vertex */);

                    var pShaderInputParamList = this._pFunctionDefenition.getParameListForShaderInput();
                    for (var i = 0; i < pShaderInputParamList.length; i++) {
                        var pParamType = pShaderInputParamList[i]._getType();

                        if (pParamType._isComplex() && akra.isDef(this._pUsedVarTypeMap[pParamType._getInstructionID()]) && this._pUsedVarTypeMap[pParamType._getInstructionID()].isRead) {
                            this._setError(2301 /* BAD_LOCAL_OF_SHADER_INPUT */, { funcName: this._getName() });
                            return;
                        }
                    }

                    var pOutVariable = this._getOutVariable();

                    if (!akra.isNull(pOutVariable)) {
                        if (akra.isDef(this._pUsedVarTypeMap[pOutVariable._getType()._getInstructionID()]) && this._pUsedVarTypeMap[pOutVariable._getType()._getInstructionID()].isRead) {
                            this._setError(2302 /* BAD_LOCAL_OF_SHADER_OUTPUT */, { funcName: this._getName() });
                            return;
                        }

                        pOutVariable._markAsShaderOutput(true);
                    }

                    if (this._pFunctionDefenition.isComplexShaderInput()) {
                        pShaderInputParamList[0]._setVisible(false);
                    }

                    this._pImplementation._prepareFor(0 /* k_Vertex */);
                    this._pFunctionDefenition.markAsShaderDef(true);
                    this.generatesVertexAttrubutes();
                    this.generateVertexVaryings();
                };

                FunctionDeclInstruction.prototype._prepareForPixel = function () {
                    this._setFunctionType(1 /* k_Pixel */);

                    var pShaderInputParamList = this._pFunctionDefenition.getParameListForShaderInput();
                    for (var i = 0; i < pShaderInputParamList.length; i++) {
                        var pParamType = pShaderInputParamList[i]._getType();

                        if (pParamType._isComplex() && akra.isDef(this._pUsedVarTypeMap[pParamType._getInstructionID()]) && this._pUsedVarTypeMap[pParamType._getInstructionID()].isRead) {
                            this._setError(2301 /* BAD_LOCAL_OF_SHADER_INPUT */, { funcName: this._getName() });
                            return;
                        }
                    }

                    if (this._pFunctionDefenition.isComplexShaderInput()) {
                        pShaderInputParamList[0]._setVisible(false);
                    }

                    this._pImplementation._prepareFor(1 /* k_Pixel */);
                    this._pFunctionDefenition.markAsShaderDef(true);

                    this.generatePixelVaryings();
                };

                FunctionDeclInstruction.prototype._setOutVariable = function (pVar) {
                    this._pOutVariable = pVar;
                };

                FunctionDeclInstruction.prototype._setUsedFunctions = function (pUsedFunctionMap, pUsedFunctionList) {
                    this._pUsedFunctionMap = pUsedFunctionMap;
                    this._pUsedFunctionList = pUsedFunctionList;
                };

                FunctionDeclInstruction.prototype._setUsedVariableData = function (pUsedVarTypeMap, pSharedVariableMap, pGlobalVariableMap, pUniformVariableMap, pForeignVariableMap, pTextureVariableMap, pUsedComplexTypeMap) {
                    this._pUsedVarTypeMap = pUsedVarTypeMap;
                    this._pSharedVariableMap = pSharedVariableMap;
                    this._pGlobalVariableMap = pGlobalVariableMap;
                    this._pUniformVariableMap = pUniformVariableMap;
                    this._pForeignVariableMap = pForeignVariableMap;
                    this._pTextureVariableMap = pTextureVariableMap;
                    this._pUsedComplexTypeMap = pUsedComplexTypeMap;
                };

                FunctionDeclInstruction.prototype._initAfterClone = function () {
                    this._pFunctionDefenition = this._pInstructionList[0];
                    this._pImplementation = this._pInstructionList[1];
                };

                FunctionDeclInstruction.prototype._generateInfoAboutUsedData = function () {
                    if (!akra.isNull(this._pUsedVarTypeMap)) {
                        return;
                    }

                    var pUsedData = {};
                    this._pImplementation._addUsedData(pUsedData);

                    this._pUsedVarTypeMap = pUsedData;

                    if (akra.isNull(this._pUsedComplexTypeMap)) {
                        this._pSharedVariableMap = {};
                        this._pGlobalVariableMap = {};
                        this._pUniformVariableMap = {};
                        this._pForeignVariableMap = {};
                        this._pTextureVariableMap = {};
                        this._pUsedComplexTypeMap = {};
                    }

                    for (var i in pUsedData) {
                        var pAnalyzedInfo = pUsedData[i];
                        var pAnalyzedType = pAnalyzedInfo.type;

                        if (pAnalyzedType._isInGlobalScope()) {
                            this.addGlobalVariableType(pAnalyzedType, pAnalyzedInfo.isWrite, pAnalyzedInfo.isRead);
                        } else if (pAnalyzedType._isUniform()) {
                            this.addUniformParameter(pAnalyzedType);
                        } else if (pAnalyzedType._getScope() < this._getImplementationScope()) {
                            if (!this._isUsedAsFunction()) {
                                if (!akra.isNull(this._getOutVariable()) && this._getOutVariable()._getType() !== pAnalyzedType) {
                                    this.addUsedComplexType(pAnalyzedType._getBaseType());
                                }
                            }
                        }
                    }
                    if (!akra.isNull(this._pUsedFunctionList)) {
                        for (var j = 0; j < this._pUsedFunctionList.length; j++) {
                            this.addUsedInfoFromFunction(this._pUsedFunctionList[j]);
                        }
                    }
                };

                FunctionDeclInstruction.prototype._getAttributeVariableMap = function () {
                    return this._pAttributeVariableMap;
                };

                FunctionDeclInstruction.prototype._getVaryingVariableMap = function () {
                    return this._pVaryingVariableMap;
                };

                FunctionDeclInstruction.prototype._getSharedVariableMap = function () {
                    return this._pSharedVariableMap;
                };

                FunctionDeclInstruction.prototype._getGlobalVariableMap = function () {
                    return this._pGlobalVariableMap;
                };

                FunctionDeclInstruction.prototype._getUniformVariableMap = function () {
                    return this._pUniformVariableMap;
                };

                FunctionDeclInstruction.prototype._getForeignVariableMap = function () {
                    return this._pForeignVariableMap;
                };

                FunctionDeclInstruction.prototype._getTextureVariableMap = function () {
                    return this._pTextureVariableMap;
                };

                FunctionDeclInstruction.prototype._getUsedComplexTypeMap = function () {
                    return this._pUsedComplexTypeMap;
                };

                FunctionDeclInstruction.prototype._getAttributeVariableKeys = function () {
                    if (akra.isNull(this._pAttributeVariableKeys) && !akra.isNull(this._pAttributeVariableMap)) {
                        this._pAttributeVariableKeys = Object.keys(this._pAttributeVariableMap);
                    }

                    return this._pAttributeVariableKeys;
                };

                FunctionDeclInstruction.prototype._getVaryingVariableKeys = function () {
                    if (akra.isNull(this._pVaryingVariableKeys) && !akra.isNull(this._pVaryingVariableMap)) {
                        this._pVaryingVariableKeys = Object.keys(this._pVaryingVariableMap);
                    }

                    return this._pVaryingVariableKeys;
                };

                FunctionDeclInstruction.prototype._getSharedVariableKeys = function () {
                    if (akra.isNull(this._pSharedVariableKeys) && !akra.isNull(this._pSharedVariableMap)) {
                        this._pSharedVariableKeys = Object.keys(this._pSharedVariableMap);
                    }

                    return this._pSharedVariableKeys;
                };

                FunctionDeclInstruction.prototype._getUniformVariableKeys = function () {
                    if (akra.isNull(this._pUniformVariableKeys) && !akra.isNull(this._pUniformVariableMap)) {
                        this._pUniformVariableKeys = Object.keys(this._pUniformVariableMap);
                    }

                    return this._pUniformVariableKeys;
                };

                FunctionDeclInstruction.prototype._getForeignVariableKeys = function () {
                    if (akra.isNull(this._pForeignVariableKeys) && !akra.isNull(this._pForeignVariableMap)) {
                        this._pForeignVariableKeys = Object.keys(this._pForeignVariableMap);
                    }

                    return this._pForeignVariableKeys;
                };

                FunctionDeclInstruction.prototype._getGlobalVariableKeys = function () {
                    if (akra.isNull(this._pGlobalVariableKeys) && !akra.isNull(this._pGlobalVariableMap)) {
                        this._pGlobalVariableKeys = Object.keys(this._pGlobalVariableMap);
                    }

                    return this._pGlobalVariableKeys;
                };

                FunctionDeclInstruction.prototype._getTextureVariableKeys = function () {
                    if (akra.isNull(this._pTextureVariableKeys) && !akra.isNull(this._pTextureVariableMap)) {
                        this._pTextureVariableKeys = Object.keys(this._pTextureVariableMap);
                    }

                    return this._pTextureVariableKeys;
                };

                FunctionDeclInstruction.prototype._getUsedComplexTypeKeys = function () {
                    if (akra.isNull(this._pUsedComplexTypeKeys)) {
                        this._pUsedComplexTypeKeys = Object.keys(this._pUsedComplexTypeMap);
                    }

                    return this._pUsedComplexTypeKeys;
                };

                FunctionDeclInstruction.prototype._getExtSystemFunctionList = function () {
                    return this._pExtSystemFunctionList;
                };

                FunctionDeclInstruction.prototype._getExtSystemMacrosList = function () {
                    return this._pExtSystemMacrosList;
                };

                FunctionDeclInstruction.prototype._getExtSystemTypeList = function () {
                    return this._pExtSystemTypeList;
                };

                FunctionDeclInstruction.prototype.generatesVertexAttrubutes = function () {
                    var pShaderInputParamList = this._pFunctionDefenition.getParameListForShaderInput();
                    var isComplexInput = this._pFunctionDefenition.isComplexShaderInput();
                    var isNeedAddTexcoord0Attribute = undefined;
                    var pTexcoordAttr = null;

                    this._pAttributeVariableMap = {};

                    if (isComplexInput) {
                        var pContainerVariable = pShaderInputParamList[0];
                        var pContainerType = pContainerVariable._getType();

                        var pAttributeNames = pContainerType._getFieldNameList();

                        for (var i = 0; i < pAttributeNames.length; i++) {
                            var pAttr = pContainerType._getField(pAttributeNames[i]);

                            if (!this.isVariableTypeUse(pAttr._getType())) {
                                continue;
                            }

                            this._pAttributeVariableMap[pAttr._getInstructionID()] = pAttr;
                            this.generateExtractBlockForAttribute(pAttr);

                            if (pAttr._getSemantic() === akra.data.Usages.TEXCOORD + "0") {
                                isNeedAddTexcoord0Attribute = false;
                            } else if (isNeedAddTexcoord0Attribute === undefined && pAttr._getSemantic().search(akra.data.Usages.TEXCOORD) !== -1) {
                                isNeedAddTexcoord0Attribute = true;
                                pTexcoordAttr = pAttr;
                            }
                        }
                    } else {
                        for (var i = 0; i < pShaderInputParamList.length; i++) {
                            var pAttr = pShaderInputParamList[i];

                            if (!this.isVariableTypeUse(pAttr._getType())) {
                                continue;
                            }

                            this._pAttributeVariableMap[pAttr._getInstructionID()] = pAttr;
                            this.generateExtractBlockForAttribute(pAttr);

                            if (pAttr._getSemantic() === akra.data.Usages.TEXCOORD + "0") {
                                isNeedAddTexcoord0Attribute = false;
                            } else if (isNeedAddTexcoord0Attribute === undefined && pAttr._getSemantic().search(akra.data.Usages.TEXCOORD) !== -1) {
                                isNeedAddTexcoord0Attribute = true;
                                pTexcoordAttr = pAttr;
                            }
                        }
                    }

                    if (isNeedAddTexcoord0Attribute) {
                        var pTexcoord0Attr = pTexcoordAttr._clone();
                        pTexcoord0Attr._setSemantic("TEXCOORD0");
                        pTexcoord0Attr._setRealName("TEXCOORD0");

                        //pTexcoord0Attr._setName("$$_texcoord0_$$");
                        pTexcoord0Attr._getType()._initializePointers();
                        pTexcoord0Attr._getType()._setVideoBufferInDepth();

                        this._pAttributeVariableMap[pTexcoord0Attr._getInstructionID()] = pTexcoord0Attr;
                        this.generateExtractBlockForAttribute(pTexcoord0Attr);
                    }

                    this._pAttributeVariableKeys = this._getAttributeVariableKeys();
                };

                FunctionDeclInstruction.prototype.generateVertexVaryings = function () {
                    if (akra.isNull(this._getOutVariable())) {
                        return;
                    }

                    this._pVaryingVariableMap = {};

                    var pContainerVariable = this._getOutVariable();
                    var pContainerType = pContainerVariable._getType();

                    var pVaryingNames = pContainerType._getFieldNameList();

                    for (var i = 0; i < pVaryingNames.length; i++) {
                        var pVarying = pContainerType._getField(pVaryingNames[i]);

                        if (!this.isVariableTypeUse(pVarying._getType())) {
                            continue;
                        }

                        this._pVaryingVariableMap[pVarying._getInstructionID()] = pVarying;
                    }

                    this._pVaryingVariableKeys = this._getVaryingVariableKeys();
                };

                FunctionDeclInstruction.prototype.generatePixelVaryings = function () {
                    var pShaderInputParamList = this._pFunctionDefenition.getParameListForShaderInput();
                    var isComplexInput = this._pFunctionDefenition.isComplexShaderInput();

                    this._pVaryingVariableMap = {};

                    if (isComplexInput) {
                        var pContainerVariable = pShaderInputParamList[0];
                        var pContainerType = pContainerVariable._getType();

                        var pVaryingNames = pContainerType._getFieldNameList();

                        for (var i = 0; i < pVaryingNames.length; i++) {
                            var pVarying = pContainerType._getField(pVaryingNames[i]);

                            if (!this.isVariableTypeUse(pVarying._getType())) {
                                continue;
                            }

                            this._pVaryingVariableMap[pVarying._getInstructionID()] = pVarying;
                        }
                    } else {
                        for (var i = 0; i < pShaderInputParamList.length; i++) {
                            var pVarying = pShaderInputParamList[i];

                            if (!this.isVariableTypeUse(pVarying._getType())) {
                                continue;
                            }

                            this._pVaryingVariableMap[pVarying._getInstructionID()] = pVarying;
                        }
                    }

                    this._pVaryingVariableKeys = this._getVaryingVariableKeys();
                };

                FunctionDeclInstruction.prototype.cloneVarTypeUsedMap = function (pMap, pRelationMap) {
                    var pCloneMap = {};

                    for (var j in pMap) {
                        var pType = (akra.isDef(pRelationMap[j]) ? pRelationMap[j] : pMap[j].type);
                        var id = pType._getInstructionID();
                        pCloneMap[id] = {
                            type: pType,
                            isRead: pMap[j].isRead,
                            isWrite: pMap[j].isWrite,
                            numRead: pMap[j].numRead,
                            numWrite: pMap[j].numWrite,
                            numUsed: pMap[j].numUsed
                        };
                    }

                    return pCloneMap;
                };

                FunctionDeclInstruction.prototype.cloneVarDeclMap = function (pMap, pRelationMap) {
                    var pCloneMap = {};

                    for (var i in pMap) {
                        var pVar = (akra.isDef(pRelationMap[i]) ? pRelationMap[i] : pMap[i]);

                        if (!akra.isNull(pVar)) {
                            var id = pVar._getInstructionID();
                            pCloneMap[id] = pVar;
                        }
                    }

                    return pCloneMap;
                };

                FunctionDeclInstruction.prototype.cloneTypeMap = function (pMap, pRelationMap) {
                    var pCloneMap = {};

                    for (var i in pMap) {
                        var pVar = (akra.isDef(pRelationMap[i]) ? pRelationMap[i] : pMap[i]);
                        var id = pVar._getInstructionID();
                        pCloneMap[id] = pVar;
                    }

                    return pCloneMap;
                };

                FunctionDeclInstruction.prototype.addGlobalVariableType = function (pVariableType, isWrite, isRead) {
                    if (!pVariableType._isFromVariableDecl()) {
                        return;
                    }

                    var pVariable = pVariableType._getParentVarDecl();
                    var pMainVariable = pVariableType._getMainVariable();
                    var iMainVar = pMainVariable._getInstructionID();
                    var iVar = pVariable._getInstructionID();

                    if (pMainVariable._getType()._isShared()) {
                        // this._pSharedVariableMap[iVar] = pVariable;
                        this._pSharedVariableMap[iMainVar] = pMainVariable;
                    } else if (pMainVariable._getType()._isForeign()) {
                        this._pForeignVariableMap[iMainVar] = pMainVariable;

                        if (pMainVariable._hasConstantInitializer()) {
                            pMainVariable._prepareDefaultValue();
                        }
                    } else if (isWrite || pMainVariable._getType()._isConst()) {
                        this._pGlobalVariableMap[iMainVar] = pMainVariable;
                        if (akra.isDefAndNotNull(this._pUniformVariableMap[iMainVar])) {
                            this._pUniformVariableMap[iMainVar] = null;
                        }
                    } else {
                        if (!akra.isDef(this._pGlobalVariableMap[iMainVar])) {
                            this._pUniformVariableMap[iMainVar] = pMainVariable;

                            if (!pMainVariable._getType()._isComplex() && pMainVariable._hasConstantInitializer()) {
                                pMainVariable._prepareDefaultValue();
                            }
                        }
                    }

                    if (pVariable._isSampler() && pVariable._hasInitializer()) {
                        var pInitExpr = pVariable._getInitializeExpr();
                        var pTexture = null;
                        var pSamplerStates = null;

                        if (pVariableType._isArray()) {
                            var pList = pInitExpr._getInstructions();
                            for (var i = 0; i < pList.length; i++) {
                                pSamplerStates = pList[i]._getInstructions()[0];
                                pTexture = pSamplerStates.getTexture();

                                if (!akra.isNull(pTexture)) {
                                    this._pTextureVariableMap[pTexture._getInstructionID()] = pTexture;
                                }
                            }
                        } else {
                            pSamplerStates = pInitExpr._getInstructions()[0];
                            pTexture = pSamplerStates.getTexture();

                            if (!akra.isNull(pTexture)) {
                                this._pTextureVariableMap[pTexture._getInstructionID()] = pTexture;
                            }
                        }
                    }
                    // this.addUsedComplexType(pMainVariable._getType()._getBaseType());
                };

                FunctionDeclInstruction.prototype.addUniformParameter = function (pType) {
                    var pMainVariable = pType._getMainVariable();
                    var iMainVar = pMainVariable._getInstructionID();

                    if (akra.isDef(this._pGlobalVariableMap[iMainVar])) {
                        akra.debug.error("UNEXPECTED ERROR WITH UNIFORM_PARAMETER");
                    }

                    this._pUniformVariableMap[iMainVar] = pMainVariable;
                    this.addUsedComplexType(pMainVariable._getType()._getBaseType());

                    if (!pMainVariable._getType()._isComplex() && pMainVariable._hasConstantInitializer()) {
                        pMainVariable._prepareDefaultValue();
                    }
                };

                FunctionDeclInstruction.prototype.addUsedComplexType = function (pType) {
                    if (pType._isBase() || akra.isDef(this._pUsedComplexTypeMap[pType._getInstructionID()])) {
                        return;
                    }

                    this._pUsedComplexTypeMap[pType._getInstructionID()] = pType;

                    var pFieldNameList = pType._getFieldNameList();

                    for (var i = 0; i < pFieldNameList.length; i++) {
                        this.addUsedComplexType(pType._getFieldType(pFieldNameList[i])._getBaseType());
                    }
                };

                FunctionDeclInstruction.prototype.addUsedInfoFromFunction = function (pFunction) {
                    pFunction._generateInfoAboutUsedData();

                    var pSharedVarMap = pFunction._getSharedVariableMap();
                    var pGlobalVarMap = pFunction._getGlobalVariableMap();
                    var pUniformVarMap = pFunction._getUniformVariableMap();
                    var pForeignVarMap = pFunction._getForeignVariableMap();
                    var pTextureVarMap = pFunction._getTextureVariableMap();
                    var pUsedComplexTypeMap = pFunction._getUsedComplexTypeMap();

                    for (var j in pSharedVarMap) {
                        this._pSharedVariableMap[pSharedVarMap[j]._getInstructionID()] = pSharedVarMap[j];
                    }

                    for (var j in pForeignVarMap) {
                        this._pForeignVariableMap[pForeignVarMap[j]._getInstructionID()] = pForeignVarMap[j];
                    }

                    for (var j in pTextureVarMap) {
                        this._pTextureVariableMap[pTextureVarMap[j]._getInstructionID()] = pTextureVarMap[j];
                    }

                    for (var j in pGlobalVarMap) {
                        this._pGlobalVariableMap[pGlobalVarMap[j]._getInstructionID()] = pGlobalVarMap[j];

                        if (akra.isDefAndNotNull(this._pUniformVariableMap[pGlobalVarMap[j]._getInstructionID()])) {
                            this._pUniformVariableMap[pGlobalVarMap[j]._getInstructionID()] = null;
                        }
                    }

                    for (var j in pUniformVarMap) {
                        if (!akra.isDef(this._pGlobalVariableMap[pUniformVarMap[j]._getInstructionID()])) {
                            this._pUniformVariableMap[pUniformVarMap[j]._getInstructionID()] = pUniformVarMap[j];
                        }
                    }

                    for (var j in pUsedComplexTypeMap) {
                        this._pUsedComplexTypeMap[pUsedComplexTypeMap[j]._getInstructionID()] = pUsedComplexTypeMap[j];
                    }

                    this.addExtSystemFunction(pFunction);
                };

                FunctionDeclInstruction.prototype.addExtSystemFunction = function (pFunction) {
                    if (akra.isNull(this._pExtSystemFunctionList)) {
                        this._pExtSystemFunctionList = [];
                        this._pExtSystemTypeList = [];
                        this._pExtSystemMacrosList = [];
                    }

                    if (pFunction._getInstructionType() === 46 /* k_SystemFunctionInstruction */) {
                        if (this._pExtSystemFunctionList.indexOf(pFunction) !== -1) {
                            return;
                        }

                        this._pExtSystemFunctionList.push(pFunction);
                    }

                    var pTypes = pFunction._getExtSystemTypeList();
                    var pMacroses = pFunction._getExtSystemMacrosList();
                    var pFunctions = pFunction._getExtSystemFunctionList();

                    if (!akra.isNull(pTypes)) {
                        for (var j = 0; j < pTypes.length; j++) {
                            if (this._pExtSystemTypeList.indexOf(pTypes[j]) === -1) {
                                this._pExtSystemTypeList.push(pTypes[j]);
                            }
                        }
                    }

                    if (!akra.isNull(pMacroses)) {
                        for (var j = 0; j < pMacroses.length; j++) {
                            if (this._pExtSystemMacrosList.indexOf(pMacroses[j]) === -1) {
                                this._pExtSystemMacrosList.push(pMacroses[j]);
                            }
                        }
                    }

                    if (!akra.isNull(pFunctions)) {
                        for (var j = 0; j < pFunctions.length; j++) {
                            if (this._pExtSystemFunctionList.indexOf(pFunctions[j]) === -1) {
                                this._pExtSystemFunctionList.unshift(pFunctions[j]);
                            }
                        }
                    }
                };

                FunctionDeclInstruction.prototype.isVariableTypeUse = function (pVariableType) {
                    var id = pVariableType._getInstructionID();

                    if (!akra.isDef(this._pUsedVarTypeMap[id])) {
                        return false;
                    }

                    if (this._pUsedVarTypeMap[id].numUsed === 0) {
                        return false;
                    }

                    return true;
                };

                FunctionDeclInstruction.prototype.generateExtractBlockForAttribute = function (pAttr) {
                    if (!pAttr._getType()._isPointer()) {
                        return null;
                    }

                    var pExtractCollector = new instructions.InstructionCollector();
                    var pMainPointer = pAttr._getType()._getMainPointer();

                    pAttr._setAttrExtractionBlock(pExtractCollector);

                    this.generateExtractStmtFromPointer(pMainPointer, null, 0, pExtractCollector);

                    pAttr._getType()._getSubVarDecls();

                    return pExtractCollector;
                };

                FunctionDeclInstruction.prototype.generateExtractStmtFromPointer = function (pPointer, pOffset, iDepth, pCollector) {
                    var pPointerType = pPointer._getType();
                    pPointerType._getPointer();
                    var pWhatExtracted = pPointerType._getDownPointer();
                    var pWhatExtractedType = null;

                    while (!akra.isNull(pWhatExtracted)) {
                        pWhatExtractedType = pWhatExtracted._getType();

                        if (!pWhatExtractedType._isPointIndex() && iDepth === 0) {
                            pOffset = this.createOffsetForAttr(pWhatExtracted);
                        }

                        if (!pWhatExtractedType._isComplex()) {
                            var pSingleExtract = new instructions.ExtractStmtInstruction();
                            pSingleExtract.generateStmtForBaseType(pWhatExtracted, pWhatExtractedType._getPointer(), pWhatExtractedType._getVideoBuffer(), 0, pWhatExtractedType._isPointIndex() ? null : pOffset);

                            this._addUsedFunction(pSingleExtract.getExtractFunction());
                            pCollector._push(pSingleExtract, true);
                        } else {
                            iDepth++;
                            this.generateExtractStmtForComplexVar(pWhatExtracted, iDepth <= 1 ? pOffset : null, iDepth, pCollector, pWhatExtractedType._getPointer(), pWhatExtractedType._getVideoBuffer(), 0);
                        }

                        pWhatExtracted = pWhatExtractedType._getDownPointer();
                    }
                };

                FunctionDeclInstruction.prototype.generateExtractStmtForComplexVar = function (pVarDecl, pOffset, iDepth, pCollector, pPointer, pBuffer, iPadding) {
                    var pVarType = pVarDecl._getType();
                    var pFieldNameList = pVarType._getFieldNameList();
                    var pField = null;
                    var pFieldType = null;
                    var pSingleExtract = null;
                    var isNeedPadding = false;

                    for (var i = 0; i < pFieldNameList.length; i++) {
                        pField = pVarType._getField(pFieldNameList[i]);

                        if (akra.isNull(pField)) {
                            continue;
                        }

                        pFieldType = pField._getType();

                        if (iDepth <= 1) {
                            pOffset = this.createOffsetForAttr(pField);
                            isNeedPadding = false;
                        } else {
                            isNeedPadding = true;
                        }

                        if (pFieldType._isPointer()) {
                            var pFieldPointer = pFieldType._getMainPointer();
                            pSingleExtract = new instructions.ExtractStmtInstruction();
                            pSingleExtract.generateStmtForBaseType(pFieldPointer, pPointer, pFieldType._getVideoBuffer(), isNeedPadding ? (iPadding + pFieldType._getPadding()) : 0, pOffset);

                            this._addUsedFunction(pSingleExtract.getExtractFunction());

                            pCollector._push(pSingleExtract, true);
                            this.generateExtractStmtFromPointer(pFieldPointer, pOffset, iDepth, pCollector);
                        } else if (pFieldType._isComplex()) {
                            iDepth++;
                            this.generateExtractStmtForComplexVar(pField, pOffset, iDepth, pCollector, pPointer, pBuffer, isNeedPadding ? (iPadding + pFieldType._getPadding()) : 0);
                        } else {
                            pSingleExtract = new instructions.ExtractStmtInstruction();
                            pSingleExtract.generateStmtForBaseType(pField, pPointer, pBuffer, isNeedPadding ? (iPadding + pFieldType._getPadding()) : 0, pOffset);

                            this._addUsedFunction(pSingleExtract.getExtractFunction());

                            pCollector._push(pSingleExtract, true);
                        }
                    }
                };

                FunctionDeclInstruction.prototype.createOffsetForAttr = function (pAttr) {
                    var pOffset = new instructions.VariableDeclInstruction();
                    var pOffsetType = new instructions.VariableTypeInstruction();
                    var pOffsetId = new instructions.IdInstruction();

                    pOffsetType._pushType(fx.Effect.getSystemType("float"));
                    pOffsetType._addUsage("uniform");

                    pOffsetId._setName("offset");
                    pOffsetId._setRealName(pAttr._getRealName() + "_o");

                    pOffset._push(pOffsetType, true);
                    pOffset._push(pOffsetId, true);

                    pOffset._setParent(pAttr);
                    pOffset._setSemantic(pAttr._getSemantic());

                    pAttr._getType()._addAttrOffset(pOffset);

                    return pOffset;
                };
                return FunctionDeclInstruction;
            })(instructions.DeclInstruction);
            instructions.FunctionDeclInstruction = FunctionDeclInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="Instruction.ts" />
/// <reference path="ExprInstruction.ts" />
/// <reference path="../Effect.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            var InitExprInstruction = (function (_super) {
                __extends(InitExprInstruction, _super);
                function InitExprInstruction() {
                    _super.call(this);
                    this._pConstructorType = null;
                    this._bIsConst = null;
                    this._isArray = false;
                    this._pInstructionList = [];
                    this._eInstructionType = 39 /* k_InitExprInstruction */;
                }
                InitExprInstruction.prototype._toFinalCode = function () {
                    var sCode = "";

                    if (!akra.isNull(this._pConstructorType)) {
                        sCode += this._pConstructorType._toFinalCode();
                    }
                    sCode += "(";

                    for (var i = 0; i < this._nInstructions; i++) {
                        sCode += this._getInstructions()[i]._toFinalCode();

                        if (i !== this._nInstructions - 1) {
                            sCode += ",";
                        }
                    }

                    sCode += ")";

                    return sCode;
                };

                InitExprInstruction.prototype._isConst = function () {
                    if (akra.isNull(this._bIsConst)) {
                        var pInstructionList = this._getInstructions();

                        for (var i = 0; i < pInstructionList.length; i++) {
                            if (!pInstructionList[i]._isConst()) {
                                this._bIsConst = false;
                                break;
                            }
                        }

                        this._bIsConst = akra.isNull(this._bIsConst) ? true : false;
                    }

                    return this._bIsConst;
                };

                InitExprInstruction.prototype._optimizeForVariableType = function (pType) {
                    if ((pType._isNotBaseArray() && pType._getScope() === 0) || (pType._isArray() && this._nInstructions > 1)) {
                        if (pType._getLength() === instructions.Instruction.UNDEFINE_LENGTH || (pType._isNotBaseArray() && this._nInstructions !== pType._getLength()) || (!pType._isNotBaseArray() && this._nInstructions !== pType._getBaseType()._getLength())) {
                            return false;
                        }

                        if (pType._isNotBaseArray()) {
                            this._isArray = true;
                        }

                        var pArrayElementType = pType._getArrayElementType();
                        var pTestedInstruction = null;
                        var isOk = false;

                        for (var i = 0; i < this._nInstructions; i++) {
                            pTestedInstruction = this._getInstructions()[i];

                            if (pTestedInstruction._getInstructionType() === 39 /* k_InitExprInstruction */) {
                                isOk = pTestedInstruction._optimizeForVariableType(pArrayElementType);
                                if (!isOk) {
                                    return false;
                                }
                            } else {
                                if (fx.Effect.isSamplerType(pArrayElementType)) {
                                    if (pTestedInstruction._getInstructionType() !== 40 /* k_SamplerStateBlockInstruction */) {
                                        return false;
                                    }
                                } else {
                                    isOk = pTestedInstruction._getType()._isEqual(pArrayElementType);
                                    if (!isOk) {
                                        return false;
                                    }
                                }
                            }
                        }

                        this._pConstructorType = pType._getBaseType();
                        return true;
                    } else {
                        var pFirstInstruction = this._getInstructions()[0];

                        if (this._nInstructions === 1 && pFirstInstruction._getInstructionType() !== 39 /* k_InitExprInstruction */) {
                            if (fx.Effect.isSamplerType(pType)) {
                                if (pFirstInstruction._getInstructionType() === 40 /* k_SamplerStateBlockInstruction */) {
                                    return true;
                                } else {
                                    return false;
                                }
                            }

                            if (pFirstInstruction._getType()._isEqual(pType)) {
                                return true;
                            } else {
                                return false;
                            }
                        } else if (this._nInstructions === 1) {
                            return false;
                        }

                        var pInstructionList = this._getInstructions();
                        var pFieldNameList = pType._getFieldNameList();

                        for (var i = 0; i < pInstructionList.length; i++) {
                            var pFieldType = pType._getFieldType(pFieldNameList[i]);
                            if (!pInstructionList[i]._optimizeForVariableType(pFieldType)) {
                                return false;
                            }
                        }

                        this._pConstructorType = pType._getBaseType();
                        return true;
                    }
                };

                InitExprInstruction.prototype._evaluate = function () {
                    if (!this._isConst()) {
                        this._pLastEvalResult = null;
                        return false;
                    }

                    var pRes = null;

                    if (this._isArray) {
                        pRes = new Array(this._nInstructions);

                        for (var i = 0; i < this._nInstructions; i++) {
                            var pEvalInstruction = this._getInstructions()[i];

                            if (pEvalInstruction._evaluate()) {
                                pRes[i] = pEvalInstruction._getEvalValue();
                            }
                        }
                    } else if (this._nInstructions === 1) {
                        var pEvalInstruction = this._getInstructions()[0];
                        pEvalInstruction._evaluate();
                        pRes = pEvalInstruction._getEvalValue();
                    } else {
                        var pJSTypeCtor = fx.Effect.getExternalType(this._pConstructorType);
                        var pArguments = new Array(this._nInstructions);

                        if (akra.isNull(pJSTypeCtor)) {
                            return false;
                        }

                        try  {
                            if (fx.Effect.isScalarType(this._pConstructorType)) {
                                var pTestedInstruction = this._getInstructions()[1];
                                if (this._nInstructions > 2 || !pTestedInstruction._evaluate()) {
                                    return false;
                                }

                                pRes = pJSTypeCtor(pTestedInstruction._getEvalValue());
                            } else {
                                for (var i = 0; i < this._nInstructions; i++) {
                                    var pTestedInstruction = this._getInstructions()[i];

                                    if (pTestedInstruction._evaluate()) {
                                        pArguments[i] = pTestedInstruction._getEvalValue();
                                    } else {
                                        return false;
                                    }
                                }

                                pRes = new pJSTypeCtor;
                                pRes.set.apply(pRes, pArguments);
                            }
                        } catch (e) {
                            return false;
                        }
                    }

                    this._pLastEvalResult = pRes;

                    return true;
                };
                return InitExprInstruction;
            })(instructions.ExprInstruction);
            instructions.InitExprInstruction = InitExprInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Represent boolExpr && || boolExpr
            * (&& | ||) Instruction Instruction
            */
            var LogicalExprInstruction = (function (_super) {
                __extends(LogicalExprInstruction, _super);
                function LogicalExprInstruction() {
                    _super.call(this);
                    this._pInstructionList = [null, null];
                    this._eInstructionType = 26 /* k_LogicalExprInstruction */;
                }
                LogicalExprInstruction.prototype._toFinalCode = function () {
                    var sCode = "";
                    sCode += this._getInstructions()[0]._toFinalCode();
                    sCode += this._getOperator();
                    sCode += this._getInstructions()[1]._toFinalCode();
                    return sCode;
                };

                LogicalExprInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    _super.prototype._addUsedData.call(this, pUsedDataCollector, 0 /* k_Read */);
                };

                LogicalExprInstruction.prototype._isConst = function () {
                    return this._getInstructions()[0]._isConst() && this._getInstructions()[1]._isConst() && this._getInstructions()[2]._isConst();
                };
                return LogicalExprInstruction;
            })(instructions.ExprInstruction);
            instructions.LogicalExprInstruction = LogicalExprInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            var MemExprInstruction = (function (_super) {
                __extends(MemExprInstruction, _super);
                function MemExprInstruction() {
                    _super.call(this);
                    this._pBuffer = null;
                    this._pInstructionList = null;
                    this._eInstructionType = 43 /* k_MemExprInstruction */;
                }
                MemExprInstruction.prototype.getBuffer = function () {
                    return this._pBuffer;
                };

                MemExprInstruction.prototype.setBuffer = function (pBuffer) {
                    this._pBuffer = pBuffer;
                    this._setType(pBuffer._getType());
                };

                MemExprInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    var pBufferType = this.getBuffer()._getType();
                    var pInfo = pUsedDataCollector[pBufferType._getInstructionID()];

                    if (!akra.isDef(pInfo)) {
                        pInfo = {
                            type: pBufferType,
                            isRead: false,
                            isWrite: false,
                            numRead: 0,
                            numWrite: 0,
                            numUsed: 0
                        };

                        pUsedDataCollector[pBufferType._getInstructionID()] = pInfo;
                    }
                    if (eUsedMode !== 3 /* k_Undefined */) {
                        pInfo.isRead = true;
                        pInfo.numRead++;
                    }

                    pInfo.numUsed++;
                };
                return MemExprInstruction;
            })(instructions.ExprInstruction);
            instructions.MemExprInstruction = MemExprInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/IMap.ts" />
/// <reference path="../../idl/ERenderStates.ts" />
/// <reference path="../../idl/ERenderStateValues.ts" />
var akra;
(function (akra) {
    (function (fx) {
        /// <reference path="../../render/render.ts" />
        /// <reference path="DeclInstruction.ts" />
        (function (instructions) {
            ;

            var PassInstruction = (function (_super) {
                __extends(PassInstruction, _super);
                function PassInstruction() {
                    _super.call(this);
                    this._pTempNodeList = null;
                    this._pTempFoundedFuncList = null;
                    this._pTempFoundedFuncTypeList = null;
                    this._pParseNode = null;
                    this._sFunctionCode = "";
                    this._pShadersMap = null;
                    this._pPassStateMap = null;
                    this._bIsComlexPass = false;
                    this._fnPassFunction = null;
                    this._pVertexShader = null;
                    this._pPixelShader = null;
                    this._pSharedVariableMapV = null;
                    this._pGlobalVariableMapV = null;
                    this._pUniformVariableMapV = null;
                    this._pForeignVariableMapV = null;
                    this._pTextureVariableMapV = null;
                    this._pUsedComplexTypeMapV = null;
                    this._pSharedVariableMapP = null;
                    this._pGlobalVariableMapP = null;
                    this._pUniformVariableMapP = null;
                    this._pForeignVariableMapP = null;
                    this._pTextureVariableMapP = null;
                    this._pUsedComplexTypeMapP = null;
                    this._pFullUniformVariableMap = null;
                    this._pFullForeignVariableMap = null;
                    this._pFullTextureVariableMap = null;
                    this._pOwnUsedForeignVariableMap = null;
                    this._pComplexPassEvaluateOutput = { "fragment": null, "vertex": null };
                    this._pInstructionList = null;
                    this._eInstructionType = 59 /* k_PassInstruction */;
                }
                PassInstruction.prototype._addFoundFunction = function (pNode, pShader, eType) {
                    if (akra.isNull(this._pTempNodeList)) {
                        this._pTempNodeList = [];
                        this._pTempFoundedFuncList = [];
                        this._pTempFoundedFuncTypeList = [];
                    }

                    this._pTempNodeList.push(pNode);
                    this._pTempFoundedFuncList.push(pShader);
                    this._pTempFoundedFuncTypeList.push(eType);
                };

                PassInstruction.prototype._getFoundedFunction = function (pNode) {
                    if (akra.isNull(this._pTempNodeList)) {
                        return null;
                    }

                    for (var i = 0; i < this._pTempNodeList.length; i++) {
                        if (this._pTempNodeList[i] === pNode) {
                            return this._pTempFoundedFuncList[i];
                        }
                    }

                    return null;
                };

                PassInstruction.prototype._getFoundedFunctionType = function (pNode) {
                    if (akra.isNull(this._pTempNodeList)) {
                        return null;
                    }

                    for (var i = 0; i < this._pTempNodeList.length; i++) {
                        if (this._pTempNodeList[i] === pNode) {
                            return this._pTempFoundedFuncTypeList[i];
                        }
                    }

                    return null;
                };

                PassInstruction.prototype._setParseNode = function (pNode) {
                    this._pParseNode = pNode;
                };

                PassInstruction.prototype._getParseNode = function () {
                    return this._pParseNode;
                };

                PassInstruction.prototype._addCodeFragment = function (sCode) {
                    if (this._isComplexPass()) {
                        this._sFunctionCode += sCode;
                    }
                };

                PassInstruction.prototype._markAsComplex = function (isComplex) {
                    this._bIsComlexPass = isComplex;
                };

                PassInstruction.prototype._getSharedVariableMapV = function () {
                    return this._pSharedVariableMapV;
                };

                PassInstruction.prototype._getGlobalVariableMapV = function () {
                    return this._pGlobalVariableMapV;
                };

                PassInstruction.prototype._getUniformVariableMapV = function () {
                    return this._pUniformVariableMapV;
                };

                PassInstruction.prototype._getForeignVariableMapV = function () {
                    return this._pForeignVariableMapV;
                };

                PassInstruction.prototype._getTextureVariableMapV = function () {
                    return this._pTextureVariableMapV;
                };

                PassInstruction.prototype._getUsedComplexTypeMapV = function () {
                    return this._pUsedComplexTypeMapV;
                };

                PassInstruction.prototype._getSharedVariableMapP = function () {
                    return this._pSharedVariableMapP;
                };

                PassInstruction.prototype._getGlobalVariableMapP = function () {
                    return this._pGlobalVariableMapP;
                };

                PassInstruction.prototype._getUniformVariableMapP = function () {
                    return this._pUniformVariableMapP;
                };

                PassInstruction.prototype._getForeignVariableMapP = function () {
                    return this._pForeignVariableMapP;
                };

                PassInstruction.prototype._getTextureVariableMapP = function () {
                    return this._pTextureVariableMapP;
                };

                PassInstruction.prototype._getUsedComplexTypeMapP = function () {
                    return this._pUsedComplexTypeMapP;
                };

                PassInstruction.prototype._getFullUniformMap = function () {
                    return this._pFullUniformVariableMap;
                };

                PassInstruction.prototype._getFullForeignMap = function () {
                    return this._pFullForeignVariableMap;
                };

                PassInstruction.prototype._getFullTextureMap = function () {
                    return this._pFullTextureVariableMap;
                };

                PassInstruction.prototype._isComplexPass = function () {
                    return this._bIsComlexPass;
                };

                PassInstruction.prototype._getVertexShader = function () {
                    return this._pVertexShader;
                };

                PassInstruction.prototype._getPixelShader = function () {
                    return this._pPixelShader;
                };

                PassInstruction.prototype._addOwnUsedForignVariable = function (pVarDecl) {
                    if (akra.isNull(this._pOwnUsedForeignVariableMap)) {
                        this._pOwnUsedForeignVariableMap = {};
                    }

                    this._pOwnUsedForeignVariableMap[pVarDecl._getInstructionID()] = pVarDecl;
                };

                PassInstruction.prototype._addShader = function (pShader) {
                    var isVertex = pShader._getFunctionType() === 0 /* k_Vertex */;

                    if (this._isComplexPass()) {
                        if (akra.isNull(this._pShadersMap)) {
                            this._pShadersMap = {};
                        }
                        var iShader = pShader._getInstructionID();
                        this._pShadersMap[iShader] = pShader;

                        var sCode = isVertex ? "out.vertex=" : "out.fragment=";
                        sCode += "shaderMap[" + iShader.toString() + "];";
                        this._addCodeFragment(sCode);
                    } else {
                        if (isVertex) {
                            this._pVertexShader = pShader;
                        } else {
                            this._pPixelShader = pShader;
                        }
                    }
                };

                PassInstruction.prototype._setState = function (eType, eValue) {
                    if (akra.isNull(this._pPassStateMap)) {
                        this._pPassStateMap = akra.render.createRenderStateMap();
                    }

                    if (this._isComplexPass()) {
                        this._addCodeFragment("states[" + eType + "]=" + eValue + ";");
                    } else {
                        this._pPassStateMap[eType] = eValue;
                    }
                };

                PassInstruction.prototype._finalizePass = function () {
                    if (this._isComplexPass()) {
                        this._fnPassFunction = (new Function("engine", "foreigns", "uniforms", "states", "shaderMap", "out", this._sFunctionCode));
                    }

                    this.generateInfoAboutUsedVaraibles();

                    this._pTempNodeList = null;
                    this._pTempFoundedFuncList = null;
                    this._pTempFoundedFuncTypeList = null;
                    this._pParseNode = null;
                    this._sFunctionCode = "";
                };

                PassInstruction.prototype._evaluate = function (pEngineStates, pForeigns, pUniforms) {
                    if (this._isComplexPass()) {
                        this._pComplexPassEvaluateOutput.fragment = null;
                        this._pComplexPassEvaluateOutput.vertex = null;
                        this.clearPassStates();

                        this._fnPassFunction(pEngineStates, pForeigns, pUniforms, this._pPassStateMap, this._pShadersMap, this._pComplexPassEvaluateOutput);

                        this._pVertexShader = this._pComplexPassEvaluateOutput.vertex;
                        this._pPixelShader = this._pComplexPassEvaluateOutput.fragment;
                    }

                    return true;
                };

                PassInstruction.prototype._getState = function (eType) {
                    return !akra.isNull(this._pPassStateMap) ? this._pPassStateMap[eType] : 0 /* UNDEF */;
                };

                PassInstruction.prototype._getRenderStates = function () {
                    return this._pPassStateMap;
                };

                PassInstruction.prototype.clearPassStates = function () {
                    if (!akra.isNull(this._pPassStateMap)) {
                        akra.render.clearRenderStateMap(this._pPassStateMap);
                    }
                };

                PassInstruction.prototype.generateInfoAboutUsedVaraibles = function () {
                    if (akra.isNull(this._pSharedVariableMapV)) {
                        this._pSharedVariableMapV = {};
                        this._pGlobalVariableMapV = {};
                        this._pUniformVariableMapV = {};
                        this._pForeignVariableMapV = {};
                        this._pTextureVariableMapV = {};
                        this._pUsedComplexTypeMapV = {};

                        this._pSharedVariableMapP = {};
                        this._pGlobalVariableMapP = {};
                        this._pUniformVariableMapP = {};
                        this._pForeignVariableMapP = {};
                        this._pTextureVariableMapP = {};
                        this._pUsedComplexTypeMapP = {};

                        this._pFullUniformVariableMap = {};
                        this._pFullForeignVariableMap = {};
                        this._pFullTextureVariableMap = {};
                    }

                    if (this._isComplexPass()) {
                        for (var i in this._pShadersMap) {
                            this.addInfoAbouUsedVariablesFromFunction(this._pShadersMap[i]);
                        }
                    } else {
                        if (!akra.isNull(this._pVertexShader)) {
                            this.addInfoAbouUsedVariablesFromFunction(this._pVertexShader);
                        }
                        if (!akra.isNull(this._pPixelShader)) {
                            this.addInfoAbouUsedVariablesFromFunction(this._pPixelShader);
                        }
                    }

                    if (!akra.isNull(this._pOwnUsedForeignVariableMap)) {
                        for (var i in this._pOwnUsedForeignVariableMap) {
                            this._pFullForeignVariableMap[i] = this._pOwnUsedForeignVariableMap[i];
                        }
                    }
                };

                PassInstruction.prototype.addInfoAbouUsedVariablesFromFunction = function (pFunction) {
                    var pSharedVars = pFunction._getSharedVariableMap();
                    var pGlobalVars = pFunction._getGlobalVariableMap();
                    var pUniformVars = pFunction._getUniformVariableMap();
                    var pForeignVars = pFunction._getForeignVariableMap();
                    var pTextureVars = pFunction._getTextureVariableMap();
                    var pTypes = pFunction._getUsedComplexTypeMap();

                    var pSharedVarsTo = null;
                    var pGlobalVarsTo = null;
                    var pUniformVarsTo = null;
                    var pForeignVarsTo = null;
                    var pTextureVarsTo = null;
                    var pTypesTo = null;

                    if (pFunction._getFunctionType() === 0 /* k_Vertex */) {
                        pSharedVarsTo = this._pSharedVariableMapV;
                        pGlobalVarsTo = this._pGlobalVariableMapV;
                        pUniformVarsTo = this._pUniformVariableMapV;
                        pForeignVarsTo = this._pForeignVariableMapV;
                        pTextureVarsTo = this._pTextureVariableMapV;
                        pTypesTo = this._pUsedComplexTypeMapV;
                    } else {
                        pSharedVarsTo = this._pSharedVariableMapP;
                        pGlobalVarsTo = this._pGlobalVariableMapP;
                        pUniformVarsTo = this._pUniformVariableMapP;
                        pForeignVarsTo = this._pForeignVariableMapP;
                        pTextureVarsTo = this._pTextureVariableMapP;
                        pTypesTo = this._pUsedComplexTypeMapP;
                    }

                    for (var i in pSharedVars) {
                        if (!akra.isNull(pSharedVars[i]) && !pSharedVars[i]._isField()) {
                            pSharedVarsTo[i] = pSharedVars[i];
                        }
                    }
                    for (var i in pGlobalVars) {
                        if (!akra.isNull(pGlobalVars[i])) {
                            pGlobalVarsTo[i] = pGlobalVars[i];
                        }
                    }
                    for (var i in pUniformVars) {
                        if (!akra.isNull(pUniformVars[i])) {
                            pUniformVarsTo[i] = pUniformVars[i];
                            this._pFullUniformVariableMap[i] = pUniformVars[i];
                        }
                    }
                    for (var i in pForeignVars) {
                        if (!akra.isNull(pForeignVars[i])) {
                            pForeignVarsTo[i] = pForeignVars[i];
                            this._pFullForeignVariableMap[i] = pForeignVars[i];
                        }
                    }
                    for (var i in pTextureVars) {
                        if (!akra.isNull(pTextureVars[i])) {
                            pTextureVarsTo[i] = pTextureVars[i];
                            this._pFullTextureVariableMap[i] = pTextureVars[i];
                        }
                    }
                    for (var i in pTypes) {
                        if (!akra.isNull(pTypes[i])) {
                            pTypesTo[i] = pTypes[i];
                        }
                    }
                };

                PassInstruction.POST_EFFECT_SEMANTIC = "POST_EFFECT";
                return PassInstruction;
            })(instructions.DeclInstruction);
            instructions.PassInstruction = PassInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Represent someExpr ++
            * (-- | ++) Instruction
            */
            var PostfixArithmeticInstruction = (function (_super) {
                __extends(PostfixArithmeticInstruction, _super);
                function PostfixArithmeticInstruction() {
                    _super.call(this);
                    this._pInstructionList = [null];
                    this._eInstructionType = 32 /* k_PostfixArithmeticInstruction */;
                }
                PostfixArithmeticInstruction.prototype._toFinalCode = function () {
                    var sCode = "";

                    sCode += this._getInstructions()[0]._toFinalCode();
                    sCode += this._getOperator();

                    return sCode;
                };

                PostfixArithmeticInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    var pSubExpr = this._getInstructions()[0];
                    pSubExpr._addUsedData(pUsedDataCollector, 2 /* k_ReadWrite */);
                };

                PostfixArithmeticInstruction.prototype._isConst = function () {
                    return this._getInstructions()[0]._isConst();
                };
                return PostfixArithmeticInstruction;
            })(instructions.ExprInstruction);
            instructions.PostfixArithmeticInstruction = PostfixArithmeticInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Represent someExpr[someIndex]
            * EMPTY_OPERATOR Instruction ExprInstruction
            */
            var PostfixIndexInstruction = (function (_super) {
                __extends(PostfixIndexInstruction, _super);
                function PostfixIndexInstruction() {
                    _super.call(this);
                    this._pSamplerArrayDecl = null;
                    this._pInstructionList = [null, null];
                    this._eInstructionType = 30 /* k_PostfixIndexInstruction */;
                }
                PostfixIndexInstruction.prototype._toFinalCode = function () {
                    var sCode = "";

                    // if((<ExprInstruction>this._getInstructions()[0])._getType()._getLength() === 0){
                    // 	return "";
                    // }
                    if (!akra.isNull(this._pSamplerArrayDecl) && this._pSamplerArrayDecl._isDefinedByZero()) {
                        sCode += this._getInstructions()[0]._toFinalCode();
                    } else {
                        sCode += this._getInstructions()[0]._toFinalCode();

                        if (!this._getInstructions()[0]._getType()._isCollapsed()) {
                            sCode += "[" + this._getInstructions()[1]._toFinalCode() + "]";
                        }
                    }

                    return sCode;
                };

                PostfixIndexInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    var pSubExpr = this._getInstructions()[0];
                    var pIndex = this._getInstructions()[1];

                    pSubExpr._addUsedData(pUsedDataCollector, eUsedMode);
                    pIndex._addUsedData(pUsedDataCollector, 0 /* k_Read */);

                    if (pSubExpr._getType()._isFromVariableDecl() && pSubExpr._getType()._isSampler()) {
                        this._pSamplerArrayDecl = pSubExpr._getType()._getParentVarDecl();
                    }
                };

                PostfixIndexInstruction.prototype._isConst = function () {
                    return this._getInstructions()[0]._isConst() && this._getInstructions()[1]._isConst();
                };
                return PostfixIndexInstruction;
            })(instructions.ExprInstruction);
            instructions.PostfixIndexInstruction = PostfixIndexInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /*
            * Represent someExpr.id
            * EMPTY_OPERATOR Instruction IdInstruction
            */
            var PostfixPointInstruction = (function (_super) {
                __extends(PostfixPointInstruction, _super);
                function PostfixPointInstruction() {
                    _super.call(this);
                    this._bToFinalFirst = true;
                    this._bToFinalSecond = true;
                    this._pInstructionList = [null, null];
                    this._eInstructionType = 31 /* k_PostfixPointInstruction */;
                }
                PostfixPointInstruction.prototype._prepareFor = function (eUsedMode) {
                    if (!this._getInstructions()[0]._isVisible()) {
                        this._bToFinalFirst = false;
                    }

                    if (!this._getInstructions()[1]._isVisible()) {
                        this._bToFinalSecond = false;
                    }

                    this._getInstructions()[0]._prepareFor(eUsedMode);
                    this._getInstructions()[1]._prepareFor(eUsedMode);
                };

                PostfixPointInstruction.prototype._toFinalCode = function () {
                    var sCode = "";

                    sCode += this._bToFinalFirst ? this._getInstructions()[0]._toFinalCode() : "";
                    sCode += this._bToFinalFirst ? "." : "";
                    sCode += this._bToFinalSecond ? this._getInstructions()[1]._toFinalCode() : "";

                    return sCode;
                };

                PostfixPointInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    var pSubExpr = this._getInstructions()[0];
                    var pPoint = this._getInstructions()[1];

                    pSubExpr._addUsedData(pUsedDataCollector, 3 /* k_Undefined */);
                    pPoint._addUsedData(pUsedDataCollector, eUsedMode);
                };

                PostfixPointInstruction.prototype._isConst = function () {
                    return this._getInstructions()[0]._isConst();
                };
                return PostfixPointInstruction;
            })(instructions.ExprInstruction);
            instructions.PostfixPointInstruction = PostfixPointInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Represent @ Expr
            * @ Instruction
            */
            var PrimaryExprInstruction = (function (_super) {
                __extends(PrimaryExprInstruction, _super);
                function PrimaryExprInstruction() {
                    _super.call(this);
                    this._pInstructionList = [null];
                    this._eInstructionType = 33 /* k_PrimaryExprInstruction */;
                }
                PrimaryExprInstruction.prototype._toFinalCode = function () {
                    var sCode = "";

                    sCode += this._getInstructions()[0]._toFinalCode();

                    return sCode;
                };

                PrimaryExprInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    var pPointerType = this._getType();
                    var pInfo = pUsedDataCollector[pPointerType._getInstructionID()];

                    if (!akra.isDef(pInfo)) {
                        pInfo = {
                            type: pPointerType,
                            isRead: false,
                            isWrite: false,
                            numRead: 0,
                            numWrite: 0,
                            numUsed: 0
                        };

                        pUsedDataCollector[pPointerType._getInstructionID()] = pInfo;
                    }

                    if (eUsedMode === 0 /* k_Read */) {
                        pInfo.isRead = true;
                        pInfo.numRead++;
                    } else if (eUsedMode === 1 /* k_Write */) {
                        pInfo.isWrite = true;
                        pInfo.numWrite++;
                    } else if (eUsedMode === 2 /* k_ReadWrite */) {
                        pInfo.isRead = true;
                        pInfo.isWrite = true;
                        pInfo.numRead++;
                        pInfo.numWrite++;
                    }

                    pInfo.numUsed++;
                };
                return PrimaryExprInstruction;
            })(instructions.ExprInstruction);
            instructions.PrimaryExprInstruction = PrimaryExprInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../idl/IScope.ts" />
var akra;
(function (akra) {
    (function (fx) {
        var ProgramScope = (function () {
            function ProgramScope() {
                this._pScopeMap = {};
                this._iCurrentScope = null;
                this._nScope = 0;
            }
            ProgramScope.prototype._isStrictMode = function (iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                var pScope = this._pScopeMap[iScope];

                while (!akra.isNull(pScope)) {
                    if (pScope.isStrictMode) {
                        return true;
                    }

                    pScope = pScope.parent;
                }

                return false;
            };

            ProgramScope.prototype._setStrictModeOn = function (iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                this._pScopeMap[iScope].isStrictMode = true;
            };

            ProgramScope.prototype._newScope = function (eType) {
                var isFirstScope = false;
                var pParentScope;

                if (akra.isNull(this._iCurrentScope)) {
                    pParentScope = null;
                } else {
                    pParentScope = this._pScopeMap[this._iCurrentScope];
                }

                this._iCurrentScope = this._nScope++;

                var pNewScope = {
                    parent: pParentScope,
                    index: this._iCurrentScope,
                    type: eType,
                    isStrictMode: false,
                    variableMap: null,
                    typeMap: null,
                    functionMap: null
                };

                this._pScopeMap[this._iCurrentScope] = pNewScope;
            };

            ProgramScope.prototype._resumeScope = function () {
                if (this._nScope === 0) {
                    return;
                }

                this._iCurrentScope = this._nScope - 1;
            };

            ProgramScope.prototype._setScope = function (iScope) {
                this._iCurrentScope = iScope;
            };

            ProgramScope.prototype._getScope = function () {
                return this._iCurrentScope;
            };

            ProgramScope.prototype._endScope = function () {
                if (akra.isNull(this._iCurrentScope)) {
                    return;
                }

                var pOldScope = this._pScopeMap[this._iCurrentScope];
                var pNewScope = pOldScope.parent;

                if (akra.isNull(pNewScope)) {
                    this._iCurrentScope = null;
                } else {
                    this._iCurrentScope = pNewScope.index;
                }
            };

            ProgramScope.prototype._getScopeType = function () {
                return this._pScopeMap[this._iCurrentScope].type;
            };

            ProgramScope.prototype._getVariable = function (sVariableName, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                if (akra.isNull(iScope)) {
                    return null;
                }

                var pScope = this._pScopeMap[iScope];

                while (!akra.isNull(pScope)) {
                    var pVariableMap = pScope.variableMap;

                    if (!akra.isNull(pVariableMap)) {
                        var pVariable = pVariableMap[sVariableName];

                        if (akra.isDef(pVariable)) {
                            return pVariable;
                        }
                    }

                    pScope = pScope.parent;
                }

                return null;
            };

            ProgramScope.prototype._getType = function (sTypeName, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                var pTypeDecl = this._getTypeDecl(sTypeName, iScope);

                if (!akra.isNull(pTypeDecl)) {
                    return pTypeDecl._getType();
                } else {
                    return null;
                }
            };

            ProgramScope.prototype._getTypeDecl = function (sTypeName, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                if (akra.isNull(iScope)) {
                    return null;
                }

                var pScope = this._pScopeMap[iScope];

                while (!akra.isNull(pScope)) {
                    var pTypeMap = pScope.typeMap;

                    if (!akra.isNull(pTypeMap)) {
                        var pType = pTypeMap[sTypeName];

                        if (akra.isDef(pType)) {
                            return pType;
                        }
                    }

                    pScope = pScope.parent;
                }

                return null;
            };

            /**
            * get function by name and list of types
            * return null - if threre are not function; undefined - if there more then one function; function - if all ok
            */
            ProgramScope.prototype._getFunction = function (sFuncName, pArgumentTypes, iScope) {
                if (typeof iScope === "undefined") { iScope = ProgramScope.GLOBAL_SCOPE; }
                if (akra.isNull(iScope)) {
                    return null;
                }

                var pScope = this._pScopeMap[iScope];
                var pFunction = null;

                while (!akra.isNull(pScope)) {
                    var pFunctionListMap = pScope.functionMap;

                    if (!akra.isNull(pFunctionListMap)) {
                        var pFunctionList = pFunctionListMap[sFuncName];

                        if (akra.isDef(pFunctionList)) {
                            for (var i = 0; i < pFunctionList.length; i++) {
                                var pTestedFunction = pFunctionList[i];
                                var pTestedArguments = pTestedFunction._getArguments();

                                if (akra.isNull(pArgumentTypes)) {
                                    if (pTestedFunction._getNumNeededArguments() === 0) {
                                        if (!akra.isNull(pFunction)) {
                                            return undefined;
                                        }

                                        pFunction = pTestedFunction;
                                    }

                                    continue;
                                }

                                if (pArgumentTypes.length > pTestedArguments.length || pArgumentTypes.length < pTestedFunction._getNumNeededArguments()) {
                                    continue;
                                }

                                var isParamsEqual = true;

                                for (var j = 0; j < pArgumentTypes.length; j++) {
                                    isParamsEqual = false;

                                    if (!pArgumentTypes[j]._getType()._isEqual(pTestedArguments[j]._getType())) {
                                        break;
                                    }

                                    isParamsEqual = true;
                                }

                                if (isParamsEqual) {
                                    if (!akra.isNull(pFunction)) {
                                        return undefined;
                                    }
                                    pFunction = pTestedFunction;
                                }
                            }
                        }
                    }

                    pScope = pScope.parent;
                }

                return pFunction;
            };

            /**
            * get shader function by name and list of types
            * return null - if threre are not function; undefined - if there more then one function; function - if all ok
            */
            ProgramScope.prototype._getShaderFunction = function (sFuncName, pArgumentTypes, iScope) {
                if (typeof iScope === "undefined") { iScope = ProgramScope.GLOBAL_SCOPE; }
                if (akra.isNull(iScope)) {
                    return null;
                }

                var pScope = this._pScopeMap[iScope];
                var pFunction = null;

                while (!akra.isNull(pScope)) {
                    var pFunctionListMap = pScope.functionMap;

                    if (!akra.isNull(pFunctionListMap)) {
                        var pFunctionList = pFunctionListMap[sFuncName];

                        if (akra.isDef(pFunctionList)) {
                            for (var i = 0; i < pFunctionList.length; i++) {
                                var pTestedFunction = pFunctionList[i];
                                var pTestedArguments = pTestedFunction._getArguments();

                                if (pArgumentTypes.length > pTestedArguments.length) {
                                    continue;
                                }

                                var isParamsEqual = true;
                                var iArg = 0;

                                if (pArgumentTypes.length === 0) {
                                    if (!akra.isNull(pFunction)) {
                                        return undefined;
                                    }

                                    pFunction = pTestedFunction;
                                    continue;
                                }

                                for (var j = 0; j < pTestedArguments.length; j++) {
                                    isParamsEqual = false;

                                    if (iArg >= pArgumentTypes.length) {
                                        if (pTestedArguments[j]._isUniform()) {
                                            break;
                                        } else {
                                            isParamsEqual = true;
                                        }
                                    } else if (pTestedArguments[j]._isUniform()) {
                                        if (!pArgumentTypes[iArg]._getType()._isEqual(pTestedArguments[j]._getType())) {
                                            break;
                                        } else {
                                            iArg++;
                                            isParamsEqual = true;
                                        }
                                    }
                                }

                                if (isParamsEqual) {
                                    if (!akra.isNull(pFunction)) {
                                        return undefined;
                                    }
                                    pFunction = pTestedFunction;
                                }
                            }
                        }
                    }

                    pScope = pScope.parent;
                }

                return pFunction;
            };

            ProgramScope.prototype._addVariable = function (pVariable, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                if (akra.isNull(iScope)) {
                    return false;
                }

                var pScope = this._pScopeMap[iScope];
                var pVariableMap = pScope.variableMap;

                if (akra.isNull(pVariableMap)) {
                    pVariableMap = pScope.variableMap = {};
                }

                var sVariableName = pVariable._getName();

                if (!pVariable._getType()._isShared()) {
                    if (this.hasVariableInScope(sVariableName, iScope)) {
                        return false;
                    }

                    pVariableMap[sVariableName] = pVariable;
                    pVariable._setScope(iScope);
                } else {
                    if (!this.hasVariableInScope(sVariableName, iScope)) {
                        pVariableMap[sVariableName] = pVariable;
                        pVariable._setScope(iScope);
                    } else {
                        var pBlendVariable = pVariableMap[sVariableName]._blend(pVariable, 0 /* k_Shared */);
                        if (akra.isNull(pBlendVariable)) {
                            return false;
                        }
                        pVariableMap[sVariableName] = pBlendVariable;
                        pBlendVariable._setScope(iScope);
                    }
                }

                return true;
            };

            ProgramScope.prototype._addType = function (pType, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                if (akra.isNull(iScope)) {
                    return false;
                }

                var pScope = this._pScopeMap[iScope];
                var pTypeMap = pScope.typeMap;

                if (akra.isNull(pTypeMap)) {
                    pTypeMap = pScope.typeMap = {};
                }

                var sTypeName = pType._getName();

                if (this.hasTypeInScope(sTypeName, iScope)) {
                    return false;
                }

                pTypeMap[sTypeName] = pType;
                pType._setScope(iScope);

                return true;
            };

            ProgramScope.prototype._addFunction = function (pFunction, iScope) {
                if (typeof iScope === "undefined") { iScope = ProgramScope.GLOBAL_SCOPE; }
                if (akra.isNull(iScope)) {
                    return false;
                }

                var pScope = this._pScopeMap[iScope];
                var pFunctionMap = pScope.functionMap;

                if (akra.isNull(pFunctionMap)) {
                    pFunctionMap = pScope.functionMap = {};
                }

                var sFuncName = pFunction._getName();

                if (this.hasFunctionInScope(pFunction, iScope)) {
                    return false;
                }

                if (!akra.isDef(pFunctionMap[sFuncName])) {
                    pFunctionMap[sFuncName] = [];
                }

                pFunctionMap[sFuncName].push(pFunction);
                pFunction._setScope(iScope);

                return true;
            };

            ProgramScope.prototype._hasVariable = function (sVariableName, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                if (akra.isNull(iScope)) {
                    return false;
                }

                var pScope = this._pScopeMap[iScope];

                while (!akra.isNull(pScope)) {
                    var pVariableMap = pScope.variableMap;

                    if (!akra.isNull(pVariableMap)) {
                        var pVariable = pVariableMap[sVariableName];

                        if (akra.isDef(pVariable)) {
                            return true;
                        }
                    }

                    pScope = pScope.parent;
                }

                return false;
            };

            ProgramScope.prototype._hasType = function (sTypeName, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                if (akra.isNull(iScope)) {
                    return false;
                }

                var pScope = this._pScopeMap[iScope];

                while (!akra.isNull(pScope)) {
                    var pTypeMap = pScope.typeMap;

                    if (!akra.isNull(pTypeMap)) {
                        var pType = pTypeMap[sTypeName];

                        if (akra.isDef(pType)) {
                            return true;
                        }
                    }

                    pScope = pScope.parent;
                }

                return false;
            };

            ProgramScope.prototype._hasFunction = function (sFuncName, pArgumentTypes, iScope) {
                if (typeof iScope === "undefined") { iScope = ProgramScope.GLOBAL_SCOPE; }
                if (akra.isNull(iScope)) {
                    return false;
                }

                var pScope = this._pScopeMap[iScope];

                while (!akra.isNull(pScope)) {
                    var pFunctionListMap = pScope.functionMap;

                    if (!akra.isNull(pFunctionListMap)) {
                        var pFunctionList = pFunctionListMap[sFuncName];

                        if (akra.isDef(pFunctionList)) {
                            var pFunction = null;

                            for (var i = 0; i < pFunctionList.length; i++) {
                                var pTestedFunction = pFunctionList[i];
                                var pTestedArguments = pTestedFunction._getArguments();

                                if (pArgumentTypes.length > pTestedArguments.length || pArgumentTypes.length < pTestedFunction._getNumNeededArguments()) {
                                    continue;
                                }

                                var isParamsEqual = true;

                                for (var j = 0; j < pArgumentTypes.length; j++) {
                                    isParamsEqual = false;

                                    if (!pArgumentTypes[j]._getType()._isEqual(pTestedArguments[j]._getType())) {
                                        break;
                                    }

                                    isParamsEqual = true;
                                }

                                if (isParamsEqual) {
                                    return true;
                                }
                            }
                        }
                    }

                    pScope = pScope.parent;
                }

                return false;
            };

            ProgramScope.prototype.hasVariableInScope = function (sVariableName, iScope) {
                return akra.isDef(this._pScopeMap[iScope].variableMap[sVariableName]);
            };

            ProgramScope.prototype.hasTypeInScope = function (sTypeName, iScope) {
                return akra.isDef(this._pScopeMap[iScope].typeMap[sTypeName]);
            };

            ProgramScope.prototype.hasFunctionInScope = function (pFunction, iScope) {
                if (akra.isNull(iScope)) {
                    return false;
                }

                var pScope = this._pScopeMap[iScope];
                var pFunctionListMap = pScope.functionMap;
                var pFunctionList = pFunctionListMap[pFunction._getName()];

                if (!akra.isDef(pFunctionList)) {
                    return false;
                }

                var pFunctionArguments = pFunction._getArguments();
                var hasFunction = false;

                for (var i = 0; i < pFunctionList.length; i++) {
                    var pTestedArguments = pFunctionList[i]._getArguments();

                    if (pTestedArguments.length !== pFunctionArguments.length) {
                        continue;
                    }

                    var isParamsEqual = true;

                    for (var j = 0; j < pFunctionArguments.length; j++) {
                        isParamsEqual = false;

                        if (!pTestedArguments[j]._getType()._isEqual(pFunctionArguments[j]._getType())) {
                            break;
                        }

                        isParamsEqual = true;
                    }

                    if (isParamsEqual) {
                        hasFunction = true;
                        break;
                    }
                }

                return hasFunction;
            };

            ProgramScope.GLOBAL_SCOPE = 0;
            return ProgramScope;
        })();
        fx.ProgramScope = ProgramScope;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Represent someExpr == != < > <= >= someExpr
            * (==|!=|<|>|<=|>=) Instruction Instruction
            */
            var RelationalExprInstruction = (function (_super) {
                __extends(RelationalExprInstruction, _super);
                function RelationalExprInstruction() {
                    _super.call(this);
                    this._pInstructionList = [null, null];
                    this._eInstructionType = 25 /* k_RelationalExprInstruction */;
                }
                RelationalExprInstruction.prototype._toFinalCode = function () {
                    var sCode = "";
                    sCode += this._getInstructions()[0]._toFinalCode();
                    sCode += this._getOperator();
                    sCode += this._getInstructions()[1]._toFinalCode();
                    return sCode;
                };

                RelationalExprInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    _super.prototype._addUsedData.call(this, pUsedDataCollector, 0 /* k_Read */);
                };

                RelationalExprInstruction.prototype._isConst = function () {
                    return this._getInstructions()[0]._isConst() && this._getInstructions()[1]._isConst();
                };
                return RelationalExprInstruction;
            })(instructions.ExprInstruction);
            instructions.RelationalExprInstruction = RelationalExprInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="StmtInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Represent return expr;
            * return ExprInstruction
            */
            var ReturnStmtInstruction = (function (_super) {
                __extends(ReturnStmtInstruction, _super);
                function ReturnStmtInstruction() {
                    _super.call(this);
                    this._pPreparedCode = "";
                    this._isPositionReturn = false;
                    this._isColorReturn = false;
                    this._isOnlyReturn = false;
                    this._pInstructionList = [null];
                    this._sOperatorName = "return";
                    this._eInstructionType = 56 /* k_ReturnStmtInstruction */;
                }
                ReturnStmtInstruction.prototype._prepareFor = function (eUsedMode) {
                    var pReturn = this._getInstructions()[0];
                    if (akra.isNull(pReturn)) {
                        return;
                    }

                    if (eUsedMode === 0 /* k_Vertex */) {
                        if (pReturn._getType()._isBase()) {
                            this._isPositionReturn = true;
                        } else {
                            this._isOnlyReturn = true;
                        }
                    } else if (eUsedMode === 1 /* k_Pixel */) {
                        this._isColorReturn = true;
                    }

                    for (var i = 0; i < this._nInstructions; i++) {
                        this._pInstructionList[i]._prepareFor(eUsedMode);
                    }
                };

                ReturnStmtInstruction.prototype._toFinalCode = function () {
                    if (this._isPositionReturn) {
                        return "Out.POSITION=" + this._pInstructionList[0]._toFinalCode() + "; return;";
                    }
                    if (this._isColorReturn) {
                        //return "gl_FragColor=" + this._pInstructionList[0]._toFinalCode() + "; return;";
                        return "resultAFXColor=" + this._pInstructionList[0]._toFinalCode() + "; return;";
                    }
                    if (this._isOnlyReturn) {
                        return "return;";
                    }

                    if (this._nInstructions > 0) {
                        return "return " + this._pInstructionList[0]._toFinalCode() + ";";
                    } else {
                        return "return;";
                    }
                };
                return ReturnStmtInstruction;
            })(instructions.StmtInstruction);
            instructions.ReturnStmtInstruction = ReturnStmtInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="StmtInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Represent empty statement only semicolon ;
            * ;
            */
            var SemicolonStmtInstruction = (function (_super) {
                __extends(SemicolonStmtInstruction, _super);
                function SemicolonStmtInstruction() {
                    _super.call(this);
                    this._pInstructionList = null;
                    this._eInstructionType = 58 /* k_SemicolonStmtInstruction */;
                }
                SemicolonStmtInstruction.prototype._toFinalCode = function () {
                    return ";";
                };
                return SemicolonStmtInstruction;
            })(instructions.StmtInstruction);
            instructions.SemicolonStmtInstruction = SemicolonStmtInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
/// <reference path="../Effect.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            var StringInstruction = (function (_super) {
                __extends(StringInstruction, _super);
                /**
                * EMPTY_OPERATOR EMPTY_ARGUMENTS
                */
                function StringInstruction() {
                    _super.call(this);
                    this._sValue = "";
                    this._pType = fx.Effect.getSystemType("string").getVariableType();
                    this._eInstructionType = 11 /* k_StringInstruction */;
                }
                StringInstruction.prototype._setValue = function (sValue) {
                    this._sValue = sValue;
                };

                StringInstruction.prototype.toString = function () {
                    return this._sValue;
                };

                StringInstruction.prototype._toFinalCode = function () {
                    var sCode = "";
                    sCode += this._sValue;
                    return sCode;
                };

                StringInstruction.prototype._evaluate = function () {
                    this._pLastEvalResult = this._sValue;
                    return true;
                };

                StringInstruction.prototype._isConst = function () {
                    return true;
                };

                StringInstruction.prototype._clone = function (pRelationMap) {
                    var pClonedInstruction = (_super.prototype._clone.call(this, pRelationMap));
                    pClonedInstruction._setValue(this._sValue);
                    return pClonedInstruction;
                };
                StringInstruction._pStringType = null;
                return StringInstruction;
            })(instructions.ExprInstruction);
            instructions.StringInstruction = StringInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/IAFXInstruction.ts" />
/// <reference path="../ExprTemplateTranslator.ts" />
var akra;
(function (akra) {
    (function (fx) {
        /// <reference path="DeclInstruction.ts" />
        /// <reference path="VariableTypeInstruction.ts" />
        /// <reference path="IdInstruction.ts" />
        /// <reference path="TypedInstruction.ts" />
        (function (instructions) {
            var SystemFunctionInstruction = (function (_super) {
                __extends(SystemFunctionInstruction, _super);
                function SystemFunctionInstruction(sName, pReturnType, pExprTranslator, pArgumentTypes) {
                    _super.call(this);
                    this._pExprTranslator = null;
                    this._pName = null;
                    this._pReturnType = null;
                    this._pArguments = null;
                    this._sDefinition = "";
                    this._sImplementation = "";
                    this._pExtSystemTypeList = null;
                    this._pExtSystemFunctionList = null;
                    this._pExtSystemMacrosList = null;

                    this._eInstructionType = 46 /* k_SystemFunctionInstruction */;

                    this._pName = new instructions.IdInstruction();
                    this._pName._setName(sName);
                    this._pName._setParent(this);

                    this._pReturnType = new instructions.VariableTypeInstruction();
                    this._pReturnType._pushType(pReturnType);
                    this._pReturnType._setParent(this);

                    this._pArguments = [];

                    if (!akra.isNull(pArgumentTypes)) {
                        for (var i = 0; i < pArgumentTypes.length; i++) {
                            var pArgument = new instructions.TypedInstruction();
                            pArgument._setType(pArgumentTypes[i]);
                            pArgument._setParent(this);

                            this._pArguments.push(pArgument);
                        }
                    }

                    this._pExprTranslator = pExprTranslator;
                }
                SystemFunctionInstruction.prototype.setDeclCode = function (sDefenition, sImplementation) {
                    this._sDefinition = sDefenition;
                    this._sImplementation = sImplementation;
                };

                /**
                * Generate code
                */
                SystemFunctionInstruction.prototype._toFinalCode = function () {
                    return this._sDefinition + this._sImplementation;
                };

                SystemFunctionInstruction.prototype._toFinalDefCode = function () {
                    return this._sDefinition;
                };

                SystemFunctionInstruction.prototype.setUsedSystemData = function (pTypeList, pFunctionList, pMacrosList) {
                    this._pExtSystemTypeList = pTypeList;
                    this._pExtSystemFunctionList = pFunctionList;
                    this._pExtSystemMacrosList = pMacrosList;
                };

                SystemFunctionInstruction.prototype.closeSystemDataInfo = function () {
                    for (var i = 0; i < this._pExtSystemFunctionList.length; i++) {
                        var pFunction = this._pExtSystemFunctionList[i];

                        var pTypes = pFunction._getExtSystemTypeList();
                        var pMacroses = pFunction._getExtSystemMacrosList();
                        var pFunctions = pFunction._getExtSystemFunctionList();

                        for (var j = 0; j < pTypes.length; j++) {
                            if (this._pExtSystemTypeList.indexOf(pTypes[j]) === -1) {
                                this._pExtSystemTypeList.push(pTypes[j]);
                            }
                        }

                        for (var j = 0; j < pMacroses.length; j++) {
                            if (this._pExtSystemMacrosList.indexOf(pMacroses[j]) === -1) {
                                this._pExtSystemMacrosList.push(pMacroses[j]);
                            }
                        }

                        for (var j = 0; j < pFunctions.length; j++) {
                            if (this._pExtSystemFunctionList.indexOf(pFunctions[j]) === -1) {
                                this._pExtSystemFunctionList.unshift(pFunctions[j]);
                            }
                        }
                    }
                };

                SystemFunctionInstruction.prototype.setExprTranslator = function (pExprTranslator) {
                    this._pExprTranslator = pExprTranslator;
                };

                SystemFunctionInstruction.prototype._getNameId = function () {
                    return this._pName;
                };

                SystemFunctionInstruction.prototype._getArguments = function () {
                    return this._pArguments;
                };

                SystemFunctionInstruction.prototype._getNumNeededArguments = function () {
                    return this._pArguments.length;
                };

                SystemFunctionInstruction.prototype._hasImplementation = function () {
                    return true;
                };

                SystemFunctionInstruction.prototype._getType = function () {
                    return this._getReturnType();
                };

                SystemFunctionInstruction.prototype._getReturnType = function () {
                    return this._pReturnType;
                };

                SystemFunctionInstruction.prototype._getFunctionType = function () {
                    return 2 /* k_Function */;
                };

                SystemFunctionInstruction.prototype._setFunctionType = function (eFunctionType) {
                };

                SystemFunctionInstruction.prototype.closeArguments = function (pArguments) {
                    return this._pExprTranslator.toInstructionList(pArguments);
                };

                SystemFunctionInstruction.prototype._setFunctionDef = function (pFunctionDef) {
                };

                SystemFunctionInstruction.prototype._setImplementation = function (pImplementation) {
                };

                SystemFunctionInstruction.prototype._clone = function (pRelationMap) {
                    return this;
                };

                SystemFunctionInstruction.prototype._addOutVariable = function (pVariable) {
                    return false;
                };

                SystemFunctionInstruction.prototype._getOutVariable = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._getVertexShader = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._getPixelShader = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._markUsedAs = function (eUsedType) {
                };

                SystemFunctionInstruction.prototype._isUsedAs = function (eUsedType) {
                    return true;
                };

                SystemFunctionInstruction.prototype._isUsedAsFunction = function () {
                    return true;
                };

                SystemFunctionInstruction.prototype._isUsedAsVertex = function () {
                    return true;
                };

                SystemFunctionInstruction.prototype._isUsedAsPixel = function () {
                    return true;
                };

                SystemFunctionInstruction.prototype._markUsedInVertex = function () {
                };

                SystemFunctionInstruction.prototype._markUsedInPixel = function () {
                };

                SystemFunctionInstruction.prototype._isUsedInVertex = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._isUsedInPixel = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._isUsed = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._checkVertexUsage = function () {
                    return this._isForVertex();
                };

                SystemFunctionInstruction.prototype._checkPixelUsage = function () {
                    return this._isForPixel();
                };

                SystemFunctionInstruction.prototype._checkDefenitionForVertexUsage = function () {
                    return false;
                };

                SystemFunctionInstruction.prototype._checkDefenitionForPixelUsage = function () {
                    return false;
                };

                SystemFunctionInstruction.prototype._canUsedAsFunction = function () {
                    return true;
                };

                SystemFunctionInstruction.prototype._notCanUsedAsFunction = function () {
                };

                SystemFunctionInstruction.prototype._addUsedFunction = function (pFunction) {
                    return false;
                };

                SystemFunctionInstruction.prototype._addUsedVariable = function (pVariable) {
                };

                SystemFunctionInstruction.prototype._getUsedFunctionList = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._isBlackListFunction = function () {
                    return false;
                };

                SystemFunctionInstruction.prototype._addToBlackList = function () {
                };

                SystemFunctionInstruction.prototype._getStringDef = function () {
                    return "system_func";
                };

                SystemFunctionInstruction.prototype._convertToVertexShader = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._convertToPixelShader = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._prepareForVertex = function () {
                };
                SystemFunctionInstruction.prototype._prepareForPixel = function () {
                };

                SystemFunctionInstruction.prototype.addUsedVariableType = function (pType, eUsedMode) {
                    return false;
                };

                SystemFunctionInstruction.prototype._generateInfoAboutUsedData = function () {
                };

                SystemFunctionInstruction.prototype._getAttributeVariableMap = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._getVaryingVariableMap = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._getSharedVariableMap = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._getGlobalVariableMap = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._getUniformVariableMap = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._getForeignVariableMap = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._getTextureVariableMap = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._getUsedComplexTypeMap = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._getAttributeVariableKeys = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._getVaryingVariableKeys = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._getSharedVariableKeys = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._getUniformVariableKeys = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._getForeignVariableKeys = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._getGlobalVariableKeys = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._getTextureVariableKeys = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._getUsedComplexTypeKeys = function () {
                    return null;
                };

                SystemFunctionInstruction.prototype._getExtSystemFunctionList = function () {
                    return this._pExtSystemFunctionList;
                };

                SystemFunctionInstruction.prototype._getExtSystemMacrosList = function () {
                    return this._pExtSystemMacrosList;
                };

                SystemFunctionInstruction.prototype._getExtSystemTypeList = function () {
                    return this._pExtSystemTypeList;
                };
                return SystemFunctionInstruction;
            })(instructions.DeclInstruction);
            instructions.SystemFunctionInstruction = SystemFunctionInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
/// <reference path="SystemFunctionInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Respresnt system_func(arg1,..., argn)
            * EMPTY_OPERATOR SimpleInstruction ... SimpleInstruction
            */
            var SystemCallInstruction = (function (_super) {
                __extends(SystemCallInstruction, _super);
                function SystemCallInstruction() {
                    _super.call(this);
                    this._pSystemFunction = null;
                    this._pSamplerDecl = null;
                    this._pInstructionList = null;
                    this._eInstructionType = 36 /* k_SystemCallInstruction */;
                }
                SystemCallInstruction.prototype._toFinalCode = function () {
                    if (!akra.isNull(this._pSamplerDecl) && this._pSamplerDecl._isDefinedByZero()) {
                        return "vec4(0.)";
                    }

                    var sCode = "";

                    for (var i = 0; i < this._getInstructions().length; i++) {
                        sCode += this._getInstructions()[i]._toFinalCode();
                    }

                    return sCode;
                };

                SystemCallInstruction.prototype.setSystemCallFunction = function (pFunction) {
                    this._pSystemFunction = pFunction;
                    this._setType(pFunction._getType());
                };

                SystemCallInstruction.prototype._setInstructions = function (pInstructionList) {
                    this._pInstructionList = pInstructionList;
                    this._nInstructions = pInstructionList.length;
                    for (var i = 0; i < pInstructionList.length; i++) {
                        pInstructionList[i]._setParent(this);
                    }
                };

                SystemCallInstruction.prototype.fillByArguments = function (pArguments) {
                    this._setInstructions(this._pSystemFunction.closeArguments(pArguments));
                };

                SystemCallInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    var pInstructionList = this._getInstructions();
                    for (var i = 0; i < this._nInstructions; i++) {
                        if (pInstructionList[i]._getInstructionType() !== 2 /* k_SimpleInstruction */) {
                            pInstructionList[i]._addUsedData(pUsedDataCollector, 0 /* k_Read */);
                            if (pInstructionList[i]._getType()._isSampler()) {
                                this._pSamplerDecl = pInstructionList[i]._getType()._getParentVarDecl();
                            }
                        }
                    }
                };

                SystemCallInstruction.prototype._clone = function (pRelationMap) {
                    var pClone = _super.prototype._clone.call(this, pRelationMap);

                    pClone.setSystemCallFunction(this._pSystemFunction);

                    return pClone;
                };
                return SystemCallInstruction;
            })(instructions.ExprInstruction);
            instructions.SystemCallInstruction = SystemCallInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/IAFXInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        /// <referene path="Instruction.ts" />
        /// <referene path="VariableTypeInstruction.ts" />
        /// <referene path="VariableInstruction.ts" />
        /// <referene path="IdInstruction.ts" />
        (function (instructions) {
            var SystemTypeInstruction = (function (_super) {
                __extends(SystemTypeInstruction, _super);
                function SystemTypeInstruction() {
                    _super.call(this);
                    this._sName = "";
                    this._sRealName = "";
                    this._pElementType = null;
                    this._iLength = 1;
                    this._iSize = null;
                    this._pFieldDeclMap = null;
                    this._bIsArray = false;
                    this._bIsWritable = true;
                    this._bIsReadable = true;
                    this._pFieldNameList = null;
                    this._pWrapVariableType = null;
                    this._bIsBuiltIn = true;
                    this._sDeclString = "";
                    this._eInstructionType = 4 /* k_SystemTypeInstruction */;
                    this._pWrapVariableType = new instructions.VariableTypeInstruction();
                    this._pWrapVariableType._pushType(this);
                }
                SystemTypeInstruction.prototype.toString = function () {
                    return this._getName() || this._getHash();
                };

                SystemTypeInstruction.prototype._toDeclString = function () {
                    return this._sDeclString;
                };

                SystemTypeInstruction.prototype._toFinalCode = function () {
                    return this._sRealName;
                };

                SystemTypeInstruction.prototype._isBuiltIn = function () {
                    return this._bIsBuiltIn;
                };

                SystemTypeInstruction.prototype._setBuiltIn = function (isBuiltIn) {
                    this._bIsBuiltIn = isBuiltIn;
                };

                SystemTypeInstruction.prototype.setDeclString = function (sDecl) {
                    this._sDeclString = sDecl;
                };

                //-----------------------------------------------------------------//
                //----------------------------SIMPLE TESTS-------------------------//
                //-----------------------------------------------------------------//
                SystemTypeInstruction.prototype._isBase = function () {
                    return true;
                };

                SystemTypeInstruction.prototype._isArray = function () {
                    return this._bIsArray;
                };

                SystemTypeInstruction.prototype._isNotBaseArray = function () {
                    return false;
                };

                SystemTypeInstruction.prototype._isComplex = function () {
                    return false;
                };

                SystemTypeInstruction.prototype._isEqual = function (pType) {
                    return this._getHash() === pType._getHash();
                };

                SystemTypeInstruction.prototype._isStrongEqual = function (pType) {
                    return this._getStrongHash() === pType._getStrongHash();
                };

                SystemTypeInstruction.prototype._isConst = function () {
                    return false;
                };

                SystemTypeInstruction.prototype._isSampler = function () {
                    return this._getName() === "sampler" || this._getName() === "sampler2D" || this._getName() === "samplerCUBE";
                };

                SystemTypeInstruction.prototype._isSamplerCube = function () {
                    return this._getName() === "samplerCUBE";
                };

                SystemTypeInstruction.prototype._isSampler2D = function () {
                    return this._getName() === "sampler" || this._getName() === "sampler2D";
                };

                SystemTypeInstruction.prototype._isWritable = function () {
                    return this._bIsWritable;
                };

                SystemTypeInstruction.prototype._isReadable = function () {
                    return this._bIsReadable;
                };

                SystemTypeInstruction.prototype._containArray = function () {
                    return false;
                };

                SystemTypeInstruction.prototype._containSampler = function () {
                    return false;
                };

                SystemTypeInstruction.prototype._containPointer = function () {
                    return false;
                };

                SystemTypeInstruction.prototype._containComplexType = function () {
                    return false;
                };

                //-----------------------------------------------------------------//
                //----------------------------SET BASE TYPE INFO-------------------//
                //-----------------------------------------------------------------//
                SystemTypeInstruction.prototype._setName = function (sName) {
                    this._sName = sName;
                };

                SystemTypeInstruction.prototype.setRealName = function (sRealName) {
                    this._sRealName = sRealName;
                };

                SystemTypeInstruction.prototype.setSize = function (iSize) {
                    this._iSize = iSize;
                };

                SystemTypeInstruction.prototype._canWrite = function (isWritable) {
                    this._bIsWritable = isWritable;
                };

                SystemTypeInstruction.prototype._canRead = function (isReadable) {
                    this._bIsReadable = isReadable;
                };

                //-----------------------------------------------------------------//
                //---------------------------INIT API------------------------------//
                //-----------------------------------------------------------------//
                SystemTypeInstruction.prototype.addIndex = function (pType, iLength) {
                    this._pElementType = pType;
                    this._iLength = iLength;
                    this._iSize = iLength * pType._getSize();
                    this._bIsArray = true;
                };

                SystemTypeInstruction.prototype.addField = function (sFieldName, pType, isWrite, sRealFieldName) {
                    if (typeof isWrite === "undefined") { isWrite = true; }
                    if (typeof sRealFieldName === "undefined") { sRealFieldName = sFieldName; }
                    var pField = new instructions.VariableDeclInstruction();
                    var pFieldType = new instructions.VariableTypeInstruction();
                    var pFieldId = new instructions.IdInstruction();

                    pFieldType._pushType(pType);
                    pFieldType._canWrite(isWrite);

                    pFieldId._setName(sFieldName);
                    pFieldId._setRealName(sRealFieldName);

                    pField._push(pFieldType, true);
                    pField._push(pFieldId, true);

                    if (akra.isNull(this._pFieldDeclMap)) {
                        this._pFieldDeclMap = {};
                    }

                    this._pFieldDeclMap[sFieldName] = pField;

                    if (akra.isNull(this._pFieldNameList)) {
                        this._pFieldNameList = [];
                    }

                    this._pFieldNameList.push(sFieldName);
                };

                //-----------------------------------------------------------------//
                //----------------------------GET TYPE INFO------------------------//
                //-----------------------------------------------------------------//
                SystemTypeInstruction.prototype._getName = function () {
                    return this._sName;
                };

                SystemTypeInstruction.prototype._getRealName = function () {
                    return this._sRealName;
                };

                SystemTypeInstruction.prototype._getHash = function () {
                    return this._sRealName;
                };

                SystemTypeInstruction.prototype._getStrongHash = function () {
                    return this._sName;
                };

                SystemTypeInstruction.prototype._getSize = function () {
                    return this._iSize;
                };

                SystemTypeInstruction.prototype._getBaseType = function () {
                    return this;
                };

                SystemTypeInstruction.prototype.getVariableType = function () {
                    return this._pWrapVariableType;
                };

                SystemTypeInstruction.prototype._getArrayElementType = function () {
                    return this._pElementType;
                };

                SystemTypeInstruction.prototype._getTypeDecl = function () {
                    if (this._isBuiltIn()) {
                        return null;
                    }

                    return this._getParent();
                };

                SystemTypeInstruction.prototype._getLength = function () {
                    return this._iLength;
                };

                SystemTypeInstruction.prototype._hasField = function (sFieldName) {
                    return akra.isDef(this._pFieldDeclMap[sFieldName]);
                };

                SystemTypeInstruction.prototype._hasFieldWithSematic = function (sSemantic) {
                    return false;
                };

                SystemTypeInstruction.prototype._hasAllUniqueSemantics = function () {
                    return false;
                };

                SystemTypeInstruction.prototype._hasFieldWithoutSemantic = function () {
                    return false;
                };

                SystemTypeInstruction.prototype._getField = function (sFieldName) {
                    return akra.isDef(this._pFieldDeclMap[sFieldName]) ? this._pFieldDeclMap[sFieldName] : null;
                };

                SystemTypeInstruction.prototype._getFieldBySemantic = function (sSemantic) {
                    return null;
                };

                SystemTypeInstruction.prototype._getFieldType = function (sFieldName) {
                    return akra.isDef(this._pFieldDeclMap[sFieldName]) ? this._pFieldDeclMap[sFieldName]._getType() : null;
                };

                SystemTypeInstruction.prototype._getFieldNameList = function () {
                    return this._pFieldNameList;
                };

                //-----------------------------------------------------------------//
                //----------------------------SYSTEM-------------------------------//
                //-----------------------------------------------------------------//
                SystemTypeInstruction.prototype._clone = function (pRelationMap) {
                    return this;
                };

                SystemTypeInstruction.prototype._blend = function (pType, eMode) {
                    if (this._isStrongEqual(pType)) {
                        return this;
                    }

                    return null;
                };
                return SystemTypeInstruction;
            })(instructions.Instruction);
            instructions.SystemTypeInstruction = SystemTypeInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/IMap.ts" />
/// <reference path="../../idl/ERenderStates.ts" />
/// <reference path="../../idl/ERenderStateValues.ts" />
var akra;
(function (akra) {
    (function (fx) {
        /// <reference path="../../render/render.ts" />
        /// <reference path="DeclInstruction.ts" />
        /// <reference path="PassInstruction.ts" />
        (function (instructions) {
            var TechniqueInstruction = (function (_super) {
                __extends(TechniqueInstruction, _super);
                function TechniqueInstruction() {
                    _super.call(this);
                    this._sName = "";
                    this._bHasComplexName = false;
                    this._pParseNode = null;
                    this._pSharedVariableListV = null;
                    this._pSharedVariableListP = null;
                    this._pPassList = null;
                    this._bHasImportedTechniqueFromSameEffect = false;
                    this._pImportedTechniqueList = null;
                    this._pFullComponentList = null;
                    this._pFullComponentShiftList = null;
                    this._nTotalPasses = 0;
                    this._bIsPostEffect = false;
                    this._bIsFinalize = false;
                    this._pInstructionList = null;
                    this._eInstructionType = 60 /* k_TechniqueInstruction */;
                }
                TechniqueInstruction.prototype._setName = function (sName, isComplexName) {
                    this._sName = sName;
                    this._bHasComplexName = isComplexName;
                };

                TechniqueInstruction.prototype._getName = function () {
                    return this._sName;
                };

                TechniqueInstruction.prototype._setSemantic = function (sSemantic) {
                    _super.prototype._setSemantic.call(this, sSemantic);

                    if (sSemantic === instructions.PassInstruction.POST_EFFECT_SEMANTIC) {
                        this._bIsPostEffect = true;
                    } else {
                        this._bIsPostEffect = false;
                    }
                };

                TechniqueInstruction.prototype._hasComplexName = function () {
                    return this._bHasComplexName;
                };

                TechniqueInstruction.prototype._isPostEffect = function () {
                    return this._bIsPostEffect;
                };

                TechniqueInstruction.prototype._getSharedVariablesForVertex = function () {
                    return this._pSharedVariableListV;
                };

                TechniqueInstruction.prototype._getSharedVariablesForPixel = function () {
                    return this._pSharedVariableListP;
                };

                TechniqueInstruction.prototype._addPass = function (pPass) {
                    if (akra.isNull(this._pPassList)) {
                        this._pPassList = [];
                    }

                    this._pPassList.push(pPass);
                };

                TechniqueInstruction.prototype._getPassList = function () {
                    return this._pPassList;
                };

                TechniqueInstruction.prototype._getPass = function (iPass) {
                    return iPass < this._pPassList.length ? this._pPassList[iPass] : null;
                };

                TechniqueInstruction.prototype._totalOwnPasses = function () {
                    return this._pPassList.length;
                };

                TechniqueInstruction.prototype._totalPasses = function () {
                    return this._nTotalPasses;
                };

                TechniqueInstruction.prototype._addTechniqueFromSameEffect = function (pTechnique, iShift) {
                    if (akra.isNull(this._pImportedTechniqueList)) {
                        this._pImportedTechniqueList = [];
                    }

                    this._pImportedTechniqueList.push({
                        technique: pTechnique,
                        component: null,
                        shift: iShift
                    });

                    this._bHasImportedTechniqueFromSameEffect = true;
                };

                TechniqueInstruction.prototype._addComponent = function (pComponent, iShift) {
                    if (akra.isNull(this._pImportedTechniqueList)) {
                        this._pImportedTechniqueList = [];
                    }

                    this._pImportedTechniqueList.push({
                        technique: pComponent.getTechnique(),
                        component: pComponent,
                        shift: iShift
                    });
                };

                TechniqueInstruction.prototype._getFullComponentList = function () {
                    return this._pFullComponentList;
                };

                TechniqueInstruction.prototype._getFullComponentShiftList = function () {
                    return this._pFullComponentShiftList;
                };

                TechniqueInstruction.prototype._checkForCorrectImports = function () {
                    return true;
                };

                TechniqueInstruction.prototype._setGlobalParams = function (sProvideNameSpace, pGlobalImportList) {
                    this.generateListOfSharedVariables();

                    if (!this._hasComplexName() && sProvideNameSpace !== "") {
                        this._sName = sProvideNameSpace + "." + this._sName;
                    }

                    if (!akra.isNull(pGlobalImportList)) {
                        if (!akra.isNull(this._pImportedTechniqueList)) {
                            this._pImportedTechniqueList = pGlobalImportList.concat(this._pImportedTechniqueList);
                        } else {
                            this._pImportedTechniqueList = pGlobalImportList.concat();
                        }
                    }

                    if (!this._bHasImportedTechniqueFromSameEffect) {
                        this.generateFullListOfComponent();
                        this._bIsFinalize = true;
                    }
                };

                TechniqueInstruction.prototype._finalize = function (pComposer) {
                    if (this._bIsFinalize) {
                        return;
                    }

                    for (var i = 0; i < this._pImportedTechniqueList.length; i++) {
                        var pInfo = this._pImportedTechniqueList[i];

                        if (akra.isNull(pInfo.component)) {
                            pInfo.component = pComposer.getComponentByName(pInfo.technique._getName());
                        }
                    }

                    this.generateFullListOfComponent();
                    this._bIsFinalize = true;
                };

                TechniqueInstruction.prototype.generateListOfSharedVariables = function () {
                    this._pSharedVariableListV = [];
                    this._pSharedVariableListP = [];

                    for (var i = 0; i < this._pPassList.length; i++) {
                        var pSharedV = this._pPassList[i]._getSharedVariableMapV();
                        var pSharedP = this._pPassList[i]._getSharedVariableMapP();

                        for (var j in pSharedV) {
                            this.addSharedVariable(pSharedV[j], 0 /* k_Vertex */);
                        }

                        for (var j in pSharedP) {
                            this.addSharedVariable(pSharedP[j], 1 /* k_Pixel */);
                        }
                    }
                };

                TechniqueInstruction.prototype.addSharedVariable = function (pVar, eType) {
                    var pAddTo = null;

                    if (eType === 0 /* k_Vertex */) {
                        pAddTo = this._pSharedVariableListV;
                    } else {
                        pAddTo = this._pSharedVariableListP;
                    }

                    for (var i = 0; i < pAddTo.length; i++) {
                        if (pAddTo[i] === pVar) {
                            return;
                        }
                    }

                    pAddTo.push(pVar);
                };

                TechniqueInstruction.prototype.generateFullListOfComponent = function () {
                    this._nTotalPasses = this._totalOwnPasses();

                    if (akra.isNull(this._pImportedTechniqueList)) {
                        return;
                    }

                    this._pFullComponentList = [];
                    this._pFullComponentShiftList = [];

                    for (var i = 0; i < this._pImportedTechniqueList.length; i++) {
                        var pInfo = this._pImportedTechniqueList[i];

                        var pTechnique = pInfo.technique;
                        var iMainShift = pInfo.shift;
                        var pAddComponentList = pTechnique._getFullComponentList();
                        var pAddComponentShiftList = pTechnique._getFullComponentShiftList();

                        if (!akra.isNull(pAddComponentList)) {
                            for (var j = 0; j < pAddComponentList.length; i++) {
                                this._pFullComponentList.push(pAddComponentList[j]);
                                this._pFullComponentShiftList.push(pAddComponentShiftList[j] + iMainShift);
                            }
                        }

                        this._pFullComponentList.push(pInfo.component);
                        this._pFullComponentShiftList.push(iMainShift);

                        if (this._nTotalPasses < iMainShift + pTechnique._totalPasses()) {
                            this._nTotalPasses = iMainShift + pTechnique._totalPasses();
                        }
                    }
                };
                return TechniqueInstruction;
            })(instructions.DeclInstruction);
            instructions.TechniqueInstruction = TechniqueInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/IAFXInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        /// <reference path="DeclInstruction.ts" />
        (function (instructions) {
            var TypeDeclInstruction = (function (_super) {
                __extends(TypeDeclInstruction, _super);
                // EMPTY_OPERATOR VariableTypeInstruction
                function TypeDeclInstruction() {
                    _super.call(this);
                    this._pInstructionList = [null];
                    this._eInstructionType = 14 /* k_TypeDeclInstruction */;
                }
                TypeDeclInstruction.prototype._getType = function () {
                    return this._pInstructionList[0];
                };

                TypeDeclInstruction.prototype._clone = function (pRelationMap) {
                    return _super.prototype._clone.call(this, pRelationMap);
                };

                TypeDeclInstruction.prototype._toFinalCode = function () {
                    return this._getType()._toDeclString() + ";";
                };

                TypeDeclInstruction.prototype._getName = function () {
                    return this._getType()._getName();
                };

                TypeDeclInstruction.prototype._getRealName = function () {
                    return this._getType()._getRealName();
                };

                TypeDeclInstruction.prototype._blend = function (pDecl, eBlendMode) {
                    if (pDecl !== this) {
                        return null;
                    }

                    return this;
                };
                return TypeDeclInstruction;
            })(instructions.DeclInstruction);
            instructions.TypeDeclInstruction = TypeDeclInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ExprInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Represent + - ! ++ -- expr
            * (+|-|!|++|--|) Instruction
            */
            var UnaryExprInstruction = (function (_super) {
                __extends(UnaryExprInstruction, _super);
                function UnaryExprInstruction() {
                    _super.call(this);
                    this._pInstructionList = [null];
                    this._eInstructionType = 29 /* k_UnaryExprInstruction */;
                }
                UnaryExprInstruction.prototype._toFinalCode = function () {
                    var sCode = "";
                    sCode += this._getOperator();
                    sCode += this._getInstructions()[0]._toFinalCode();
                    return sCode;
                };

                UnaryExprInstruction.prototype._addUsedData = function (pUsedDataCollector, eUsedMode) {
                    if (typeof eUsedMode === "undefined") { eUsedMode = 3 /* k_Undefined */; }
                    if (this._getOperator() === "++" || this._getOperator() === "--") {
                        this._getInstructions()[0]._addUsedData(pUsedDataCollector, 2 /* k_ReadWrite */);
                    } else {
                        this._getInstructions()[0]._addUsedData(pUsedDataCollector, 0 /* k_Read */);
                    }
                };

                UnaryExprInstruction.prototype._isConst = function () {
                    return this._getInstructions()[0]._isConst();
                };

                UnaryExprInstruction.prototype._evaluate = function () {
                    var sOperator = this._getOperator();
                    var pExpr = this._getInstructions()[0];

                    if (!pExpr._evaluate()) {
                        return;
                    }

                    var pRes = null;

                    try  {
                        pRes = pExpr._getEvalValue();
                        switch (sOperator) {
                            case "+":
                                pRes = +pRes;
                                break;
                            case "-":
                                pRes = -pRes;
                                break;
                            case "!":
                                pRes = !pRes;
                                break;
                            case "++":
                                pRes = ++pRes;
                                break;
                            case "--":
                                pRes = --pRes;
                                break;
                        }
                    } catch (e) {
                        return false;
                    }

                    this._pLastEvalResult = pRes;
                    return true;
                };
                return UnaryExprInstruction;
            })(instructions.ExprInstruction);
            instructions.UnaryExprInstruction = UnaryExprInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="StmtInstruction.ts" />
var akra;
(function (akra) {
    (function (fx) {
        (function (instructions) {
            /**
            * Represent while(expr) stmt
            * ( while || do_while) ExprInstruction StmtInstruction
            */
            var WhileStmtInstruction = (function (_super) {
                __extends(WhileStmtInstruction, _super);
                function WhileStmtInstruction() {
                    _super.call(this);
                    this._pInstructionList = [null, null];
                    this._eInstructionType = 52 /* k_WhileStmtInstruction */;
                }
                WhileStmtInstruction.prototype._toFinalCode = function () {
                    var sCode = "";
                    if (this._getOperator() === "while") {
                        sCode += "while(";
                        sCode += this._getInstructions()[0]._toFinalCode();
                        sCode += ")";
                        sCode += this._getInstructions()[1]._toFinalCode();
                    } else {
                        sCode += "do";
                        sCode += this._getInstructions()[1]._toFinalCode();
                        sCode += "while(";
                        sCode += this._getInstructions()[0]._toFinalCode();
                        sCode += ");";
                    }
                    return sCode;
                };
                return WhileStmtInstruction;
            })(instructions.StmtInstruction);
            instructions.WhileStmtInstruction = WhileStmtInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../idl/IAFXEffect.ts" />
/// <reference path="../idl/parser/IParser.ts" />
/// <reference path="../idl/IAFXInstruction.ts" />
/// <reference path="../idl/IAFXComposer.ts" />
/// <reference path="../idl/IAFXComponent.ts" />
/// <reference path="../idl/EEffectErrors.ts" />
/// <reference path="../idl/IEffectErrorInfo.ts" />
/// <reference path="../idl/IScope.ts" />
/// <reference path="../idl/IMap.ts" />
var akra;
(function (akra) {
    /// <reference path="../time.ts" />
    /// <reference path="../math/math.ts" />
    /// <reference path="../debug.ts" />
    /// <reference path="errors.ts" />
    /// <reference path="instructions/ArithmeticExprInstruction.ts" />
    /// <reference path="instructions/AssignmentExprInstruction.ts" />
    /// <reference path="instructions/BoolInstruction.ts" />
    /// <reference path="instructions/BreakStmtInstruction.ts" />
    /// <reference path="instructions/CastExprInstruction.ts" />
    /// <reference path="instructions/ComplexExprInstruction.ts" />
    /// <reference path="instructions/ComplexTypeInstruction.ts" />
    /// <reference path="instructions/CompileExprInstruction.ts" />
    /// <reference path="instructions/ConditionalExprInstruction.ts" />
    /// <reference path="instructions/ConstructorCallInstruction.ts" />
    /// <reference path="instructions/DeclStmtInstruction.ts" />
    /// <reference path="instructions/ExprStmtInstruction.ts" />
    /// <reference path="ExprTemplateTranslator.ts" />
    /// <reference path="instructions/ExtractStmtInstruction.ts" />
    /// <reference path="instructions/FloatInstruction.ts" />
    /// <reference path="instructions/ForStmtInstruction.ts" />
    /// <reference path="instructions/FunctionCallInstruction.ts" />
    /// <reference path="instructions/FunctionDefInstruction.ts" />
    /// <reference path="instructions/IdExprInstruction.ts" />
    /// <reference path="instructions/IfStmtInstruction.ts" />
    /// <reference path="instructions/IntInstruction.ts" />
    /// <reference path="instructions/FunctionInstruction.ts" />
    /// <reference path="instructions/IdInstruction.ts" />
    /// <reference path="instructions/InitExprInstruction.ts" />
    /// <reference path="instructions/InstructionCollector.ts" />
    /// <reference path="instructions/LogicalExprInstruction.ts" />
    /// <reference path="instructions/MemExprInstruction.ts" />
    /// <reference path="instructions/PassInstruction.ts" />
    /// <reference path="instructions/PostfixArithmeticInstruction.ts" />
    /// <reference path="instructions/PostfixIndexInstruction.ts" />
    /// <reference path="instructions/PostfixPointInstruction.ts" />
    /// <reference path="instructions/PrimaryExprInstruction.ts" />
    /// <reference path="ProgramScope.ts" />
    /// <reference path="instructions/RelationalExprInstruction.ts" />
    /// <reference path="instructions/ReturnStmtInstruction.ts" />
    /// <reference path="instructions/SamplerStateBlockInstruction.ts" />
    /// <reference path="instructions/SemicolonStmtInstruction.ts" />
    /// <reference path="instructions/SimpleInstruction.ts" />
    /// <reference path="instructions/StmtBlockInstruction.ts" />
    /// <reference path="instructions/StringInstruction.ts" />
    /// <reference path="instructions/SystemCallInstruction.ts" />
    /// <reference path="instructions/SystemFunctionInstruction.ts" />
    /// <reference path="instructions/SystemTypeInstruction.ts" />
    /// <reference path="instructions/TechniqueInstruction.ts" />
    /// <reference path="instructions/TypeInstruction.ts" />
    /// <reference path="instructions/VariableTypeInstruction.ts" />
    /// <reference path="instructions/VariableInstruction.ts" />
    /// <reference path="instructions/UnaryExprInstruction.ts" />
    /// <reference path="instructions/WhileStmtInstruction.ts" />
    (function (fx) {
        var Vec2 = akra.math.Vec2;
        var Vec3 = akra.math.Vec3;
        var Vec4 = akra.math.Vec4;
        var Mat3 = akra.math.Mat3;
        var Mat4 = akra.math.Mat4;

        /** @const */
        var TEMPLATE_TYPE = "template";

        var Effect = (function () {
            function Effect(pComposer) {
                this.guid = akra.guid();
                this._pComposer = null;
                this._pParseTree = null;
                this._pAnalyzedNode = null;
                this._pEffectScope = null;
                this._pCurrentInstruction = null;
                this._pCurrentFunction = null;
                this._pCurrentPass = null;
                this._bHaveCurrentFunctionReturnOccur = false;
                this._pStatistics = null;
                this._sAnalyzedFileName = "";
                this._pSystemMacros = null;
                this._pSystemTypes = null;
                this._pSystemFunctionsMap = null;
                this._pSystemFunctionHashMap = null;
                this._pSystemVariables = null;
                this._pPointerForExtractionList = null;
                this._pFunctionWithImplementationList = null;
                this._pTechniqueList = null;
                this._pTechniqueMap = null;
                this._isAnalyzeInPass = false;
                this._sProvideNameSpace = "";
                this._pImportedGlobalTechniqueList = null;
                this._pAddedTechniqueList = null;
                this._pComposer = pComposer;

                this._pParseTree = null;
                this._pAnalyzedNode = null;

                this._pEffectScope = new fx.ProgramScope();
                this._pCurrentInstruction = null;

                this._pStatistics = null;
                this._sAnalyzedFileName = "";

                this._pPointerForExtractionList = [];

                this._pFunctionWithImplementationList = [];
                this._pTechniqueList = [];
                this._pTechniqueMap = {};

                this.initSystemMacros();
                this.initSystemTypes();
                this.initSystemFunctions();
                this.initSystemVariables();
            }
            Effect.prototype.analyze = function (pTree) {
                var pRootNode = pTree.getRoot();
                var iParseTime = akra.time();

                // LOG(this);
                this._pParseTree = pTree;
                this._pStatistics = { time: 0 };

                try  {
                    this.newScope();

                    // LOG("ok");
                    this.analyzeGlobalUseDecls();

                    // LOG("ok");
                    this.analyzeGlobalProvideDecls();

                    // LOG("ok");
                    this.analyzeGlobalTypeDecls();

                    // LOG("ok");
                    this.analyzeFunctionDefinitions();

                    // LOG("ok");
                    this.analyzeGlobalImports();

                    // LOG("ok");
                    this.analyzeTechniqueImports();

                    // LOG("ok");
                    this.analyzeVariableDecls();

                    // LOG("ok");
                    this.analyzeFunctionDecls();

                    // LOG("ok");
                    this.analyzeTechniques();

                    // LOG("ok");
                    // this.analyzeTypes();
                    // this.preAnalyzeFunctions();
                    // this.preAnalyzeVariables();
                    // this.preAnalyzeTechniques();
                    // this.analyzeDecls();
                    // this.analyzeEffect();
                    // this.postAnalyzeEffect();
                    // this.checkEffect();
                    this.endScope();
                } catch (e) {
                    if (akra.config.DEBUG) {
                        throw e;
                    } else {
                        return false;
                    }
                }

                //Stats
                iParseTime = akra.time() - iParseTime;
                this._pStatistics.time = iParseTime;

                //LOG(this, iParseTime);
                return true;
            };

            Effect.prototype.getStats = function () {
                return this._pStatistics;
            };

            Effect.prototype.setAnalyzedFileName = function (sFileName) {
                this._sAnalyzedFileName = sFileName;
            };

            Effect.prototype.clear = function () {
            };

            Effect.prototype.getTechniqueList = function () {
                return this._pTechniqueList;
            };

            Effect.getBaseVertexOutType = function () {
                return Effect.pSystemVertexOut;
            };
            Effect.getSystemType = function (sTypeName) {
                //boolean, string, float and others
                return akra.isDef(Effect.pSystemTypes[sTypeName]) ? Effect.pSystemTypes[sTypeName] : null;
            };

            Effect.getSystemVariable = function (sName) {
                return akra.isDef(Effect.pSystemVariables[sName]) ? Effect.pSystemVariables[sName] : null;
            };

            Effect.getSystemMacros = function (sName) {
                return akra.isDef(Effect.pSystemMacros[sName]) ? Effect.pSystemMacros[sName] : null;
            };

            Effect.findSystemFunction = function (sFunctionName, pArguments) {
                var pSystemFunctions = Effect.pSystemFunctions[sFunctionName];

                if (!akra.isDef(pSystemFunctions)) {
                    return null;
                }

                if (akra.isNull(pArguments)) {
                    for (var i = 0; i < pSystemFunctions.length; i++) {
                        if (pSystemFunctions[i]._getNumNeededArguments() === 0) {
                            return pSystemFunctions[i];
                        }
                    }
                }

                for (var i = 0; i < pSystemFunctions.length; i++) {
                    if (pArguments.length !== pSystemFunctions[i]._getNumNeededArguments()) {
                        continue;
                    }

                    var pTestedArguments = pSystemFunctions[i]._getArguments();

                    var isOk = true;

                    for (var j = 0; j < pArguments.length; j++) {
                        isOk = false;

                        if (!pArguments[j]._getType()._isEqual(pTestedArguments[j]._getType())) {
                            break;
                        }

                        isOk = true;
                    }

                    if (isOk) {
                        return pSystemFunctions[i];
                    }
                }
            };

            Effect.createVideoBufferVariable = function () {
                var pBuffer = new fx.instructions.VariableDeclInstruction();
                var pBufferType = new fx.instructions.VariableTypeInstruction();
                var pBufferName = new fx.instructions.IdInstruction();

                pBufferType._pushType(Effect.getSystemType("video_buffer"));

                pBuffer._push(pBufferType, true);
                pBuffer._push(pBufferName, true);

                return pBuffer;
            };

            Effect.getExternalType = function (pType) {
                if (pType._isEqual(Effect.getSystemType("int")) || pType._isEqual(Effect.getSystemType("float"))) {
                    return Number;
                } else if (pType._isEqual(Effect.getSystemType("bool"))) {
                    return Boolean;
                } else if (pType._isEqual(Effect.getSystemType("float2")) || pType._isEqual(Effect.getSystemType("bool2")) || pType._isEqual(Effect.getSystemType("int2"))) {
                    return Vec2;
                } else if (pType._isEqual(Effect.getSystemType("float3")) || pType._isEqual(Effect.getSystemType("bool3")) || pType._isEqual(Effect.getSystemType("int3"))) {
                    return Vec3;
                } else if (pType._isEqual(Effect.getSystemType("float4")) || pType._isEqual(Effect.getSystemType("bool4")) || pType._isEqual(Effect.getSystemType("int4"))) {
                    return Vec4;
                } else if (pType._isEqual(Effect.getSystemType("float3x3")) || pType._isEqual(Effect.getSystemType("bool3x3")) || pType._isEqual(Effect.getSystemType("int3x3"))) {
                    return Mat3;
                } else if (pType._isEqual(Effect.getSystemType("float4x4")) || pType._isEqual(Effect.getSystemType("bool4x4")) || pType._isEqual(Effect.getSystemType("int4x4"))) {
                    return Mat4;
                } else {
                    return null;
                }
            };

            Effect.isMatrixType = function (pType) {
                return pType._isEqual(Effect.getSystemType("float2x2")) || pType._isEqual(Effect.getSystemType("float3x3")) || pType._isEqual(Effect.getSystemType("float4x4")) || pType._isEqual(Effect.getSystemType("int2x2")) || pType._isEqual(Effect.getSystemType("int3x3")) || pType._isEqual(Effect.getSystemType("int4x4")) || pType._isEqual(Effect.getSystemType("bool2x2")) || pType._isEqual(Effect.getSystemType("bool3x3")) || pType._isEqual(Effect.getSystemType("bool4x4"));
            };

            Effect.isVectorType = function (pType) {
                return pType._isEqual(Effect.getSystemType("float2")) || pType._isEqual(Effect.getSystemType("float3")) || pType._isEqual(Effect.getSystemType("float4")) || pType._isEqual(Effect.getSystemType("bool2")) || pType._isEqual(Effect.getSystemType("bool3")) || pType._isEqual(Effect.getSystemType("bool4")) || pType._isEqual(Effect.getSystemType("int2")) || pType._isEqual(Effect.getSystemType("int3")) || pType._isEqual(Effect.getSystemType("int4"));
            };

            Effect.isScalarType = function (pType) {
                return pType._isEqual(Effect.getSystemType("bool")) || pType._isEqual(Effect.getSystemType("int")) || pType._isEqual(Effect.getSystemType("ptr")) || pType._isEqual(Effect.getSystemType("float"));
            };

            Effect.isFloatBasedType = function (pType) {
                return pType._isEqual(Effect.getSystemType("float")) || pType._isEqual(Effect.getSystemType("float2")) || pType._isEqual(Effect.getSystemType("float3")) || pType._isEqual(Effect.getSystemType("float4")) || pType._isEqual(Effect.getSystemType("float2x2")) || pType._isEqual(Effect.getSystemType("float3x3")) || pType._isEqual(Effect.getSystemType("float4x4")) || pType._isEqual(Effect.getSystemType("ptr"));
            };

            Effect.isIntBasedType = function (pType) {
                return pType._isEqual(Effect.getSystemType("int")) || pType._isEqual(Effect.getSystemType("int2")) || pType._isEqual(Effect.getSystemType("int3")) || pType._isEqual(Effect.getSystemType("int4")) || pType._isEqual(Effect.getSystemType("int2x2")) || pType._isEqual(Effect.getSystemType("int3x3")) || pType._isEqual(Effect.getSystemType("int4x4"));
            };

            Effect.isBoolBasedType = function (pType) {
                return pType._isEqual(Effect.getSystemType("bool")) || pType._isEqual(Effect.getSystemType("bool2")) || pType._isEqual(Effect.getSystemType("bool3")) || pType._isEqual(Effect.getSystemType("bool4")) || pType._isEqual(Effect.getSystemType("bool2x2")) || pType._isEqual(Effect.getSystemType("bool3x3")) || pType._isEqual(Effect.getSystemType("bool4x4"));
            };

            Effect.isSamplerType = function (pType) {
                return pType._isEqual(Effect.getSystemType("sampler")) || pType._isEqual(Effect.getSystemType("sampler2D")) || pType._isEqual(Effect.getSystemType("samplerCUBE")) || pType._isEqual(Effect.getSystemType("video_buffer"));
            };

            Effect.prototype.generateSuffixLiterals = function (pLiterals, pOutput, iDepth) {
                if (typeof iDepth === "undefined") { iDepth = 0; }
                if (iDepth >= pLiterals.length) {
                    return;
                }

                if (iDepth === 0) {
                    for (var i = 0; i < pLiterals.length; i++) {
                        pOutput[pLiterals[i]] = true;
                    }

                    iDepth = 1;
                }

                var pOutputKeys = Object.keys(pOutput);

                for (var i = 0; i < pLiterals.length; i++) {
                    for (var j = 0; j < pOutputKeys.length; j++) {
                        if (pOutputKeys[j].indexOf(pLiterals[i]) !== -1) {
                            pOutput[pOutputKeys[j] + pLiterals[i]] = false;
                        } else {
                            pOutput[pOutputKeys[j] + pLiterals[i]] = (pOutput[pOutputKeys[j]] === false) ? false : true;
                        }
                    }
                }

                iDepth++;

                this.generateSuffixLiterals(pLiterals, pOutput, iDepth);
            };

            Effect.prototype.initSystemMacros = function () {
                if (akra.isNull(Effect.pSystemMacros)) {
                    this._pSystemMacros = Effect.pSystemMacros = {};
                    this.addSystemMacros();
                }

                this._pSystemMacros = Effect.pSystemMacros;
            };

            Effect.prototype.initSystemTypes = function () {
                if (akra.isNull(Effect.pSystemTypes)) {
                    this._pSystemTypes = Effect.pSystemTypes = {};
                    this.addSystemTypeScalar();
                    this.addSystemTypeVector();
                    this.addSystemTypeMatrix();

                    this.generateBaseVertexOutput();
                }

                this._pSystemTypes = Effect.pSystemTypes;
            };

            Effect.prototype.initSystemFunctions = function () {
                if (akra.isNull(Effect.pSystemFunctions)) {
                    this._pSystemFunctionsMap = Effect.pSystemFunctions = {};
                    this.addSystemFunctions();
                }

                this._pSystemFunctionsMap = Effect.pSystemFunctions;
            };

            Effect.prototype.initSystemVariables = function () {
                if (akra.isNull(Effect.pSystemVariables)) {
                    this._pSystemVariables = Effect.pSystemVariables = {};
                    this.addSystemVariables();
                }

                this._pSystemVariables = Effect.pSystemVariables;
            };

            Effect.prototype.addSystemMacros = function () {
                this.generateSystemMacros("ExtractMacros", "\n#ifdef AKRA_FRAGMENT\n" + "//#define texture2D(sampler, ) texture2D\n" + "#else\n" + "#define texture2D(A, B) texture2DLod(A, B, 0.)\n" + "#endif\n" + "#ifndef A_VB_COMPONENT3\n" + "#define A_VB_COMPONENT4\n" + "#endif\n" + "#ifdef A_VB_COMPONENT4\n" + "#define A_VB_ELEMENT_SIZE 4.\n" + "#endif\n" + "#ifdef A_VB_COMPONENT3\n" + "#define A_VB_ELEMENT_SIZE 3.\n" + "#endif\n" + "#define A_tex2D(S, H, X, Y) texture2D(S, vec2(H.stepX * X , H.stepY * Y))\n" + "#define A_tex2Dv(S, H, V) texture2D(S, V)\n");
            };

            Effect.prototype.addSystemVariables = function () {
                this.generateSystemVariable("fragColor", "gl_FragColor", "float4", false, true, true);
                this.generateSystemVariable("fragCoord", "gl_FragCoord", "float4", false, true, true);
                this.generateSystemVariable("frontFacing", "gl_FrontFacing", "bool", false, true, true);
                this.generateSystemVariable("pointCoord", "gl_PointCoord", "float2", false, true, true);
                this.generateSystemVariable("resultAFXColor", "resultAFXColor", "float4", false, true, true);

                //Engine variable for passes
                this.generatePassEngineVariable();
            };

            Effect.prototype.generateSystemVariable = function (sName, sRealName, sTypeName, isForVertex, isForPixel, isOnlyRead) {
                if (akra.isDef(this._pSystemVariables[sName])) {
                    return;
                }

                var pVariableDecl = new fx.instructions.VariableDeclInstruction();
                var pName = new fx.instructions.IdInstruction();
                var pType = new fx.instructions.VariableTypeInstruction();

                pName._setName(sName);
                pName._setRealName(sRealName);

                pType._pushType(Effect.getSystemType(sTypeName));

                if (isOnlyRead) {
                    pType._canWrite(false);
                }

                pVariableDecl._setForVertex(isForVertex);
                pVariableDecl._setForPixel(isForPixel);

                pVariableDecl._push(pType, true);
                pVariableDecl._push(pName, true);

                this._pSystemVariables[sName] = pVariableDecl;

                pVariableDecl._setBuiltIn(true);
            };

            Effect.prototype.generatePassEngineVariable = function () {
                var pVariableDecl = new fx.instructions.VariableDeclInstruction();
                var pName = new fx.instructions.IdInstruction();
                var pType = new fx.instructions.VariableTypeInstruction();

                pType._canWrite(false);

                pType._markAsUnverifiable(true);
                pName._setName("engine");
                pName._setRealName("engine");

                pVariableDecl._push(pType, true);
                pVariableDecl._push(pName, true);

                this._pSystemVariables["engine"] = pVariableDecl;
            };

            Effect.prototype.generateBaseVertexOutput = function () {
                //TODO: fix defenition of this variables
                var pOutBasetype = new fx.instructions.ComplexTypeInstruction();

                var pPosition = new fx.instructions.VariableDeclInstruction();
                var pPointSize = new fx.instructions.VariableDeclInstruction();
                var pPositionType = new fx.instructions.VariableTypeInstruction();
                var pPointSizeType = new fx.instructions.VariableTypeInstruction();
                var pPositionId = new fx.instructions.IdInstruction();
                var pPointSizeId = new fx.instructions.IdInstruction();

                pPositionType._pushType(Effect.getSystemType("float4"));
                pPointSizeType._pushType(Effect.getSystemType("float"));

                pPositionId._setName("pos");
                pPositionId._setRealName("POSITION");

                pPointSizeId._setName("psize");
                pPointSizeId._setRealName("PSIZE");

                pPosition._push(pPositionType, true);
                pPosition._push(pPositionId, true);

                pPointSize._push(pPointSizeType, true);
                pPointSize._push(pPointSizeId, true);

                pPosition._setSemantic("POSITION");
                pPointSize._setSemantic("PSIZE");

                var pFieldCollector = new fx.instructions.InstructionCollector();
                pFieldCollector._push(pPosition, false);
                pFieldCollector._push(pPointSize, false);

                pOutBasetype.addFields(pFieldCollector, true);

                pOutBasetype._setName("VS_OUT");
                pOutBasetype.setRealName("VS_OUT_S");

                Effect.pSystemVertexOut = pOutBasetype;
            };

            Effect.prototype.addSystemFunctions = function () {
                this._pSystemFunctionHashMap = {};

                this.generateSystemFunction("dot", "dot($1,$2)", "float", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("mul", "$1*$2", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "int", "float2", "float3", "float4"]);
                this.generateSystemFunction("mod", "mod($1,$2)", "float", ["float", "float"], null);
                this.generateSystemFunction("floor", "floor($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("ceil", "ceil($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("fract", "fract($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("abs", "abs($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("sign", "sign($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("normalize", "normalize($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("length", "length($1)", "float", [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("cross", "cross($1, $2)", "float3", ["float3", "float3"], null);
                this.generateSystemFunction("reflect", "reflect($1,$2)", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("max", "max($1,$2)", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("max", "max($1,$2)", TEMPLATE_TYPE, [TEMPLATE_TYPE, "float"], ["float2", "float3", "float4"]);

                this.generateSystemFunction("min", "min($1,$2)", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("min", "min($1,$2)", TEMPLATE_TYPE, [TEMPLATE_TYPE, "float"], ["float2", "float3", "float4"]);

                this.generateSystemFunction("mix", "mix($1,$2,$3)", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("mix", "mix($1,$2,$3)", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, "float"], ["float2", "float3", "float4"]);

                this.generateSystemFunction("clamp", "clamp($1,$2,$3)", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("clamp", "clamp($1,$2,$3)", TEMPLATE_TYPE, [TEMPLATE_TYPE, "float", "float"], ["float2", "float3", "float4"]);

                this.generateSystemFunction("pow", "pow($1,$2)", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("mod", "mod($1,$2)", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float2", "float3", "float4"]);
                this.generateSystemFunction("mod", "mod($1,$2)", TEMPLATE_TYPE, [TEMPLATE_TYPE, "float"], ["float2", "float3", "float4"]);
                this.generateSystemFunction("exp", "exp($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("exp2", "exp2($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("log", "log($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("log2", "log2($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("inversesqrt", "inversesqrt($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("sqrt", "sqrt($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);

                this.generateSystemFunction("all", "all($1)", "bool", [TEMPLATE_TYPE], ["bool2", "bool3", "bool4"]);
                this.generateSystemFunction("any", "any($1)", "bool", [TEMPLATE_TYPE], ["bool2", "bool3", "bool4"]);
                this.generateSystemFunction("not", "not($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["bool2", "bool3", "bool4"]);

                this.generateSystemFunction("distance", "distance($1,$2)", "float", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);

                this.generateSystemFunction("lessThan", "lessThan($1,$2)", "bool2", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float2", "int2"]);
                this.generateSystemFunction("lessThan", "lessThan($1,$2)", "bool3", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float3", "int3"]);
                this.generateSystemFunction("lessThan", "lessThan($1,$2)", "bool4", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float4", "int4"]);

                this.generateSystemFunction("lessThanEqual", "lessThanEqual($1,$2)", "bool2", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float2", "int2"]);
                this.generateSystemFunction("lessThanEqual", "lessThanEqual($1,$2)", "bool3", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float3", "int3"]);
                this.generateSystemFunction("lessThanEqual", "lessThanEqual($1,$2)", "bool4", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float4", "int4"]);

                this.generateSystemFunction("equal", "equal($1,$2)", "bool2", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float2", "int2"]);
                this.generateSystemFunction("equal", "equal($1,$2)", "bool3", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float3", "int3"]);
                this.generateSystemFunction("equal", "equal($1,$2)", "bool4", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float4", "int4"]);
                this.generateSystemFunction("equal", "equal($1,$2)", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["bool2", "bool3", "bool4"]);

                this.generateSystemFunction("notEqual", "notEqual($1,$2)", "bool2", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float2", "int2"]);
                this.generateSystemFunction("notEqual", "notEqual($1,$2)", "bool3", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float3", "int3"]);
                this.generateSystemFunction("notEqual", "notEqual($1,$2)", "bool4", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float4", "int4"]);
                this.generateSystemFunction("notEqual", "notEqual($1,$2)", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["bool2", "bool3", "bool4"]);

                this.generateSystemFunction("greaterThan", "greaterThan($1,$2)", "bool2", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float2", "int2"]);
                this.generateSystemFunction("greaterThan", "greaterThan($1,$2)", "bool3", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float3", "int3"]);
                this.generateSystemFunction("greaterThan", "greaterThan($1,$2)", "bool4", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float4", "int4"]);

                this.generateSystemFunction("greaterThanEqual", "greaterThanEqual($1,$2)", "bool2", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float2", "int2"]);
                this.generateSystemFunction("greaterThanEqual", "greaterThanEqual($1,$2)", "bool3", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float3", "int3"]);
                this.generateSystemFunction("greaterThanEqual", "greaterThanEqual($1,$2)", "bool4", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float4", "int4"]);

                this.generateSystemFunction("radians", "radians($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("degrees", "degrees($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("sin", "sin($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("cos", "cos($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("tan", "tan($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("asin", "asin($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("acos", "acos($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("atan", "atan($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("atan", "atan($1, $2)", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);

                this.generateSystemFunction("tex2D", "texture2D($1,$2)", "float4", ["sampler", "float2"], null);
                this.generateSystemFunction("tex2D", "texture2D($1,$2)", "float4", ["sampler2D", "float2"], null);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2)", "float4", ["sampler", "float3"], null);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2)", "float4", ["sampler2D", "float3"], null);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2)", "float4", ["sampler", "float4"], null);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2)", "float4", ["sampler2D", "float4"], null);
                this.generateSystemFunction("texCUBE", "textureCube($1,$2)", "float4", ["sampler", "float3"], null);
                this.generateSystemFunction("texCUBE", "textureCube($1,$2)", "float4", ["samplerCUBE", "float3"], null);

                this.generateSystemFunction("tex2D", "texture2D($1,$2,$3)", "float4", ["sampler", "float2", "float"], null, false, true);
                this.generateSystemFunction("tex2D", "texture2D($1,$2,$3)", "float4", ["sampler2D", "float2", "float"], null, false, true);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2,$3)", "float4", ["sampler", "float3", "float"], null, false, true);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2,$3)", "float4", ["sampler2D", "float3", "float"], null, false, true);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2,$3)", "float4", ["sampler", "float4", "float"], null, false, true);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2,$3)", "float4", ["sampler2D", "float4", "float"], null, false, true);
                this.generateSystemFunction("texCUBE", "textureCube($1,$2,$3)", "float4", ["sampler", "float3", "float"], null, false, true);
                this.generateSystemFunction("texCUBE", "textureCube($1,$2,$3)", "float4", ["samplerCUBE", "float3", "float"], null, false, true);

                this.generateSystemFunction("tex2DLod", "texture2DLod($1,$2,$3)", "float4", ["sampler", "float2", "float"], null, true, false);
                this.generateSystemFunction("tex2DLod", "texture2DLod($1,$2,$3)", "float4", ["sampler2D", "float2", "float"], null, true, false);
                this.generateSystemFunction("tex2DProjLod", "texture2DProjLod($1,$2,$3)", "float4", ["sampler", "float3", "float"], null, true, false);
                this.generateSystemFunction("tex2DProjLod", "texture2DProjLod($1,$2,$3)", "float4", ["sampler2D", "float3", "float"], null, true, false);
                this.generateSystemFunction("tex2DProjLod", "texture2DProjLod($1,$2,$3)", "float4", ["sampler", "float4", "float"], null, true, false);
                this.generateSystemFunction("tex2DProjLod", "texture2DProjLod($1,$2,$3)", "float4", ["sampler2D", "float4", "float"], null, true, false);
                this.generateSystemFunction("texCUBELod", "textureCubeLod($1,$2,$3)", "float4", ["sampler", "float3", "float"], null, true, false);
                this.generateSystemFunction("texCUBELod", "textureCubeLod($1,$2,$3)", "float4", ["samplerCUBE", "float3", "float"], null, true, false);

                //OES_standard_derivatives
                this.generateSystemFunction("dFdx", "dFdx($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("dFdy", "dFdy($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("width", "width($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("fwidth", "fwidth($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);

                // this.generateSystemFunction("smoothstep", "smoothstep($1, $2, $3)", "float3", ["float3", "float3", "float3"], null);
                this.generateSystemFunction("smoothstep", "smoothstep($1, $2, $3)", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("smoothstep", "smoothstep($1, $2, $3)", TEMPLATE_TYPE, ["float", "float", TEMPLATE_TYPE], ["float2", "float3", "float4"]);

                this.generateSystemFunction("frac", "fract($1)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("lerp", "mix($1,$2,$3)", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
                this.generateSystemFunction("lerp", "mix($1,$2,$3)", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, "float"], ["float2", "float3", "float4"]);

                this.generateSystemFunction("saturate", "max(0., min(1., $1))", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);

                //Extracts
                this.generateNotBuiltInSystemFuction("extractHeader", "void A_extractTextureHeader(sampler2D src, out A_TextureHeader texture)", "{vec4 v = texture2D(src, vec2(0.00001)); " + "texture = A_TextureHeader(v.r, v.g, v.b, v.a);}", "void", ["video_buffer_header"], null, ["ExtractMacros"]);

                this.generateNotBuiltInSystemFuction("extractFloat", "float A_extractFloat(sampler2D sampler, A_TextureHeader header, float offset)", "{float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); " + "float y = floor(pixelNumber / header.width) + .5; " + "float x = mod(pixelNumber, header.width) + .5; " + "int shift = int(mod(offset, A_VB_ELEMENT_SIZE)); " + "\n#ifdef A_VB_COMPONENT4\n" + "if(shift == 0) return A_tex2D(sampler, header, x, y).r; " + "else if(shift == 1) return A_tex2D(sampler, header, x, y).g; " + "else if(shift == 2) return A_tex2D(sampler, header, x, y).b; " + "else if(shift == 3) return A_tex2D(sampler, header, x, y).a; " + "else return 0.; " + "\n#endif\n" + "return 0.;}", "float", ["video_buffer_header"], ["extractHeader"], ["ExtractMacros"]);

                this.generateNotBuiltInSystemFuction("extractFloat2", "vec2 A_extractVec2(sampler2D sampler, A_TextureHeader header, float offset)", "{float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); " + "float y = floor(pixelNumber / header.width) + .5; " + "float x = mod(pixelNumber, header.width) + .5; " + "int shift = int(mod(offset, A_VB_ELEMENT_SIZE)); " + "\n#ifdef A_VB_COMPONENT4\n" + "if(shift == 0) return A_tex2D(sampler, header, x, y).rg; " + "else if(shift == 1) return A_tex2D(sampler, header, x, y).gb; " + "else if(shift == 2) return A_tex2D(sampler, header, x, y).ba; " + "else if(shift == 3) { " + "if(int(x) == int(header.width - 1.)) " + "return vec2(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, 0.5, (y + 1.)).r); " + "else " + "return vec2(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, (x + 1.), y).r); " + "} " + "else { return vec2(0.); } " + "\n#endif\n" + "return vec2(0.);}", "float2", ["video_buffer_header"], ["extractHeader"], ["ExtractMacros"]);

                this.generateNotBuiltInSystemFuction("extractFloat3", "vec3 A_extractVec3(sampler2D sampler, A_TextureHeader header, float offset)", "{float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); " + "float y = floor(pixelNumber / header.width) + .5; " + "float x = mod(pixelNumber, header.width) + .5; " + "int shift = int(mod(offset, A_VB_ELEMENT_SIZE)); " + "\n#ifdef A_VB_COMPONENT4\n" + "if(shift == 0) return A_tex2D(sampler, header, x, y).rgb; " + "else if(shift == 1) return A_tex2D(sampler, header, x, y).gba; " + "else if(shift == 2){ " + "if(int(x) == int(header.width - 1.))  return vec3(A_tex2D(sampler, header, x, y).ba, A_tex2D(sampler, header, 0.5, (y + 1.)).r); " + "else return vec3(A_tex2D(sampler, header, x, y).ba, A_tex2D(sampler, header, (x + 1.), y).r);} " + "else if(shift == 3){ " + "if(int(x) == int(header.width - 1.))  return vec3(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, 0.5, (y + 1.)).rg); " + "else return vec3(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, (x + 1.), y).rg);} " + "else { return vec3(0.); } " + "\n#endif\n" + "\n#ifdef A_VB_COMPONENT3\n" + "if(shift == 0) return A_tex2D(sampler, header,vec2(x,header.stepY*y)).rgb; " + "else if(shift == 1){ " + "if(x == header.width - 1.) return vec3(A_tex2D(sampler, header, x, y).gb, A_tex2D(sampler, header, 0.5, (y + 1.)).r); " + "else return vec3(A_tex2D(sampler, header, x, y).gb, A_tex2D(sampler, header, (x + 1.), y).r);} " + "else if(shift == 3){ " + "if(x == header.width - 1.) return vec3(A_tex2D(sampler, header, x, y).b, A_tex2D(sampler, header, 0.5, (y + 1.)).rg); " + "else return vec3(A_tex2D(sampler, header, x, y).b, A_tex2D(sampler, header, (x + 1)., y).rg);} " + "else { return vec3(0.); } " + "\n#endif\n" + "return vec3(0.);}", "float3", ["video_buffer_header"], ["extractHeader"], ["ExtractMacros"]);

                this.generateNotBuiltInSystemFuction("extractFloat4", "vec4 A_extractVec4(sampler2D sampler, A_TextureHeader header, float offset)", "{float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); " + "float y = floor(pixelNumber / header.width) + .5; " + "float x = mod(pixelNumber, header.width) + .5; " + "int shift = int(mod(offset, A_VB_ELEMENT_SIZE)); " + "\n#ifdef A_VB_COMPONENT4\n" + "if(shift == 0) return A_tex2D(sampler, header, x, y); " + "else if(shift == 1){ " + "if(int(x) == int(header.width - 1.)) " + "return vec4(A_tex2D(sampler, header, x, y).gba, A_tex2D(sampler, header, 0.5, (y + 1.)).r); " + "else " + "return vec4(A_tex2D(sampler, header, x, y).gba, A_tex2D(sampler, header, (x + 1.), y).r);} " + "else if(shift == 2){ " + "if(int(x) == int(header.width - 1.)) " + "return vec4(A_tex2D(sampler, header, x, y).ba, A_tex2D(sampler, header, 0.5, (y + 1.)).rg); " + "else " + "return vec4(A_tex2D(sampler, header, x, y).ba, A_tex2D(sampler, header, (x + 1.), y).rg);} " + "else if(shift == 3){ " + "if(int(x) == int(header.width - 1.)) " + "return vec4(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, 0.5, (y + 1.)).rgb); " + "else return vec4(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, (x + 1.), y).rgb);} " + "else { return vec4(0.); } " + "\n#endif\n" + "\n#ifdef A_VB_COMPONENT3\n" + "\n#endif\n" + "return vec4(0.);}", "float4", ["video_buffer_header"], ["extractHeader"], ["ExtractMacros"]);

                this.generateNotBuiltInSystemFuction("findPixel", "vec2 A_findPixel(A_TextureHeader header, float offset)", "{float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); " + "return vec2(header.stepX * (mod(pixelNumber, header.width) + .5), header.stepY * (floor(pixelNumber / header.width) + .5));}", "float2", ["video_buffer_header"], ["extractHeader"], ["ExtractMacros"]);

                this.generateNotBuiltInSystemFuction("extractFloat4x4", "mat4 A_extractMat4(sampler2D sampler, A_TextureHeader header, float offset)", "{return mat4(A_tex2Dv(sampler, header, A_findPixel(header, offset))," + "A_tex2Dv(sampler, header, A_findPixel(header, offset + 4.))," + "A_tex2Dv(sampler, header, A_findPixel(header, offset + 8.))," + "A_tex2Dv(sampler, header, A_findPixel(header, offset + 12.)));}", "float4x4", ["video_buffer_header"], ["findPixel"], ["ExtractMacros"]);
            };

            Effect.prototype.generateSystemFunction = function (sName, sTranslationExpr, sReturnTypeName, pArgumentsTypes, pTemplateTypes, isForVertex, isForPixel) {
                if (typeof isForVertex === "undefined") { isForVertex = true; }
                if (typeof isForPixel === "undefined") { isForPixel = true; }
                var pExprTranslator = new fx.ExprTemplateTranslator(sTranslationExpr);
                var pSystemFunctions = this._pSystemFunctionsMap;
                var pTypes = null;
                var sFunctionHash = "";
                var pReturnType = null;
                var pFunction = null;

                if (!akra.isNull(pTemplateTypes)) {
                    for (var i = 0; i < pTemplateTypes.length; i++) {
                        pTypes = [];
                        sFunctionHash = sName + "(";
                        pReturnType = (sReturnTypeName === TEMPLATE_TYPE) ? Effect.getSystemType(pTemplateTypes[i]) : Effect.getSystemType(sReturnTypeName);

                        for (var j = 0; j < pArgumentsTypes.length; j++) {
                            if (pArgumentsTypes[j] === TEMPLATE_TYPE) {
                                pTypes.push(Effect.getSystemType(pTemplateTypes[i]));
                                sFunctionHash += pTemplateTypes[i] + ",";
                            } else {
                                pTypes.push(Effect.getSystemType(pArgumentsTypes[j]));
                                sFunctionHash += pArgumentsTypes[j] + ",";
                            }
                        }

                        sFunctionHash += ")";

                        if (this._pSystemFunctionHashMap[sFunctionHash]) {
                            this._error(2248 /* BAD_SYSTEM_FUNCTION_REDEFINE */, { funcName: sFunctionHash });
                        }

                        pFunction = new fx.instructions.SystemFunctionInstruction(sName, pReturnType, pExprTranslator, pTypes);

                        if (!akra.isDef(pSystemFunctions[sName])) {
                            pSystemFunctions[sName] = [];
                        }

                        pFunction._setForVertex(isForVertex);
                        pFunction._setForPixel(isForPixel);

                        pSystemFunctions[sName].push(pFunction);
                        pFunction._setBuiltIn(true);
                    }
                } else {
                    if (sReturnTypeName === TEMPLATE_TYPE) {
                        akra.logger.critical("Bad return type(TEMPLATE_TYPE) for system function '" + sName + "'.");
                    }

                    pReturnType = Effect.getSystemType(sReturnTypeName);
                    pTypes = [];
                    sFunctionHash = sName + "(";

                    for (var i = 0; i < pArgumentsTypes.length; i++) {
                        if (pArgumentsTypes[i] === TEMPLATE_TYPE) {
                            akra.logger.critical("Bad argument type(TEMPLATE_TYPE) for system function '" + sName + "'.");
                        } else {
                            pTypes.push(Effect.getSystemType(pArgumentsTypes[i]));
                            sFunctionHash += pArgumentsTypes[i] + ",";
                        }
                    }

                    sFunctionHash += ")";

                    if (this._pSystemFunctionHashMap[sFunctionHash]) {
                        this._error(2248 /* BAD_SYSTEM_FUNCTION_REDEFINE */, { funcName: sFunctionHash });
                    }

                    pFunction = new fx.instructions.SystemFunctionInstruction(sName, pReturnType, pExprTranslator, pTypes);

                    pFunction._setForVertex(isForVertex);
                    pFunction._setForPixel(isForPixel);

                    if (!akra.isDef(pSystemFunctions[sName])) {
                        pSystemFunctions[sName] = [];
                    }

                    pSystemFunctions[sName].push(pFunction);
                    pFunction._setBuiltIn(true);
                }
            };

            Effect.prototype.generateSystemMacros = function (sMacrosName, sMacrosCode) {
                if (akra.isDef(this._pSystemMacros[sMacrosName])) {
                    return;
                }

                var pMacros = new fx.instructions.SimpleInstruction(sMacrosCode);

                this._pSystemMacros[sMacrosName] = pMacros;
            };

            Effect.prototype.generateNotBuiltInSystemFuction = function (sName, sDefenition, sImplementation, sReturnType, pUsedTypes, pUsedFunctions, pUsedMacros) {
                if (akra.isDef(this._pSystemFunctionsMap[sName])) {
                    return;
                }

                var pReturnType = Effect.getSystemType(sReturnType);
                var pFunction = new fx.instructions.SystemFunctionInstruction(sName, pReturnType, null, null);

                pFunction.setDeclCode(sDefenition, sImplementation);

                var pUsedExtSystemTypes = [];
                var pUsedExtSystemFunctions = [];
                var pUsedExtSystemMacros = [];

                if (!akra.isNull(pUsedTypes)) {
                    for (var i = 0; i < pUsedTypes.length; i++) {
                        var pTypeDecl = Effect.getSystemType(pUsedTypes[i])._getParent();
                        if (!akra.isNull(pTypeDecl)) {
                            pUsedExtSystemTypes.push(pTypeDecl);
                        }
                    }
                }

                if (!akra.isNull(pUsedMacros)) {
                    for (var i = 0; i < pUsedMacros.length; i++) {
                        pUsedExtSystemMacros.push(Effect.getSystemMacros(pUsedMacros[i]));
                    }
                }

                if (!akra.isNull(pUsedFunctions)) {
                    for (var i = 0; i < pUsedFunctions.length; i++) {
                        var pFindFunction = Effect.findSystemFunction(pUsedFunctions[i], null);
                        pUsedExtSystemFunctions.push(pFindFunction);
                    }
                }

                pFunction.setUsedSystemData(pUsedExtSystemTypes, pUsedExtSystemFunctions, pUsedExtSystemMacros);
                pFunction.closeSystemDataInfo();
                pFunction._setBuiltIn(false);

                this._pSystemFunctionsMap[sName] = [pFunction];
            };

            Effect.prototype.generateSystemType = function (sName, sRealName, iSize, isArray, pElementType, iLength) {
                if (typeof iSize === "undefined") { iSize = 1; }
                if (typeof isArray === "undefined") { isArray = false; }
                if (typeof pElementType === "undefined") { pElementType = null; }
                if (typeof iLength === "undefined") { iLength = 1; }
                if (akra.isDef(this._pSystemTypes[sName])) {
                    return null;
                }

                var pSystemType = new fx.instructions.SystemTypeInstruction();

                pSystemType._setName(sName);
                pSystemType.setRealName(sRealName);
                pSystemType.setSize(iSize);
                if (isArray) {
                    pSystemType.addIndex(pElementType, iLength);
                }

                this._pSystemTypes[sName] = pSystemType;
                pSystemType._setBuiltIn(true);

                return pSystemType;
            };

            Effect.prototype.generateNotBuildtInSystemType = function (sName, sRealName, sDeclString, iSize, isArray, pElementType, iLength) {
                if (typeof iSize === "undefined") { iSize = 1; }
                if (typeof isArray === "undefined") { isArray = false; }
                if (typeof pElementType === "undefined") { pElementType = null; }
                if (typeof iLength === "undefined") { iLength = 1; }
                if (akra.isDef(this._pSystemTypes[sName])) {
                    return null;
                }

                var pSystemType = new fx.instructions.SystemTypeInstruction();
                pSystemType._setName(sName);
                pSystemType.setRealName(sRealName);
                pSystemType.setSize(iSize);
                pSystemType.setDeclString(sDeclString);

                if (isArray) {
                    pSystemType.addIndex(pElementType, iLength);
                }

                this._pSystemTypes[sName] = pSystemType;
                pSystemType._setBuiltIn(false);

                var pSystemTypeDecl = new fx.instructions.TypeDeclInstruction();
                pSystemTypeDecl._push(pSystemType, true);
                pSystemTypeDecl._setBuiltIn(false);

                return pSystemType;
            };

            Effect.prototype.addSystemTypeScalar = function () {
                this.generateSystemType("void", "void", 0);
                this.generateSystemType("int", "int", 1);
                this.generateSystemType("bool", "bool", 1);
                this.generateSystemType("float", "float", 1);
                this.generateSystemType("ptr", "float", 1);
                this.generateSystemType("string", "", 0);
                this.generateSystemType("texture", "", 0);
                this.generateSystemType("sampler", "sampler2D", 1);
                this.generateSystemType("sampler2D", "sampler2D", 1);
                this.generateSystemType("samplerCUBE", "samplerCube", 1);
                this.generateSystemType("video_buffer", "sampler2D", 1);

                this.generateNotBuildtInSystemType("video_buffer_header", "A_TextureHeader", "struct A_TextureHeader { float width; float height; float stepX; float stepY; }");
            };

            Effect.prototype.addSystemTypeVector = function () {
                var pXYSuffix = {};
                var pXYZSuffix = {};
                var pXYZWSuffix = {};

                var pRGSuffix = {};
                var pRGBSuffix = {};
                var pRGBASuffix = {};

                var pSTSuffix = {};
                var pSTPSuffix = {};
                var pSTPQSuffix = {};

                this.generateSuffixLiterals(["x", "y"], pXYSuffix);
                this.generateSuffixLiterals(["x", "y", "z"], pXYZSuffix);
                this.generateSuffixLiterals(["x", "y", "z", "w"], pXYZWSuffix);

                this.generateSuffixLiterals(["r", "g"], pRGSuffix);
                this.generateSuffixLiterals(["r", "g", "b"], pRGBSuffix);
                this.generateSuffixLiterals(["r", "g", "b", "a"], pRGBASuffix);

                this.generateSuffixLiterals(["s", "t"], pSTSuffix);
                this.generateSuffixLiterals(["s", "t", "p"], pSTPSuffix);
                this.generateSuffixLiterals(["s", "t", "p", "q"], pSTPQSuffix);

                var pFloat = Effect.getSystemType("float");
                var pInt = Effect.getSystemType("int");
                var pBool = Effect.getSystemType("bool");

                var pFloat2 = this.generateSystemType("float2", "vec2", 0, true, pFloat, 2);
                var pFloat3 = this.generateSystemType("float3", "vec3", 0, true, pFloat, 3);
                var pFloat4 = this.generateSystemType("float4", "vec4", 0, true, pFloat, 4);

                var pInt2 = this.generateSystemType("int2", "ivec2", 0, true, pInt, 2);
                var pInt3 = this.generateSystemType("int3", "ivec3", 0, true, pInt, 3);
                var pInt4 = this.generateSystemType("int4", "ivec4", 0, true, pInt, 4);

                var pBool2 = this.generateSystemType("bool2", "bvec2", 0, true, pBool, 2);
                var pBool3 = this.generateSystemType("bool3", "bvec3", 0, true, pBool, 3);
                var pBool4 = this.generateSystemType("bool4", "bvec4", 0, true, pBool, 4);

                this.addFieldsToVectorFromSuffixObject(pXYSuffix, pFloat2, "float");
                this.addFieldsToVectorFromSuffixObject(pRGSuffix, pFloat2, "float");
                this.addFieldsToVectorFromSuffixObject(pSTSuffix, pFloat2, "float");

                this.addFieldsToVectorFromSuffixObject(pXYZSuffix, pFloat3, "float");
                this.addFieldsToVectorFromSuffixObject(pRGBSuffix, pFloat3, "float");
                this.addFieldsToVectorFromSuffixObject(pSTPSuffix, pFloat3, "float");

                this.addFieldsToVectorFromSuffixObject(pXYZWSuffix, pFloat4, "float");
                this.addFieldsToVectorFromSuffixObject(pRGBASuffix, pFloat4, "float");
                this.addFieldsToVectorFromSuffixObject(pSTPQSuffix, pFloat4, "float");

                this.addFieldsToVectorFromSuffixObject(pXYSuffix, pInt2, "int");
                this.addFieldsToVectorFromSuffixObject(pRGSuffix, pInt2, "int");
                this.addFieldsToVectorFromSuffixObject(pSTSuffix, pInt2, "int");

                this.addFieldsToVectorFromSuffixObject(pXYZSuffix, pInt3, "int");
                this.addFieldsToVectorFromSuffixObject(pRGBSuffix, pInt3, "int");
                this.addFieldsToVectorFromSuffixObject(pSTPSuffix, pInt3, "int");

                this.addFieldsToVectorFromSuffixObject(pXYZWSuffix, pInt4, "int");
                this.addFieldsToVectorFromSuffixObject(pRGBASuffix, pInt4, "int");
                this.addFieldsToVectorFromSuffixObject(pSTPQSuffix, pInt4, "int");

                this.addFieldsToVectorFromSuffixObject(pXYSuffix, pBool2, "bool");
                this.addFieldsToVectorFromSuffixObject(pRGSuffix, pBool2, "bool");
                this.addFieldsToVectorFromSuffixObject(pSTSuffix, pBool2, "bool");

                this.addFieldsToVectorFromSuffixObject(pXYZSuffix, pBool3, "bool");
                this.addFieldsToVectorFromSuffixObject(pRGBSuffix, pBool3, "bool");
                this.addFieldsToVectorFromSuffixObject(pSTPSuffix, pBool3, "bool");

                this.addFieldsToVectorFromSuffixObject(pXYZWSuffix, pBool4, "bool");
                this.addFieldsToVectorFromSuffixObject(pRGBASuffix, pBool4, "bool");
                this.addFieldsToVectorFromSuffixObject(pSTPQSuffix, pBool4, "bool");
            };

            Effect.prototype.addSystemTypeMatrix = function () {
                var pFloat2 = Effect.getSystemType("float2");
                var pFloat3 = Effect.getSystemType("float3");
                var pFloat4 = Effect.getSystemType("float4");

                var pInt2 = Effect.getSystemType("int2");
                var pInt3 = Effect.getSystemType("int3");
                var pInt4 = Effect.getSystemType("int4");

                var pBool2 = Effect.getSystemType("bool2");
                var pBool3 = Effect.getSystemType("bool3");
                var pBool4 = Effect.getSystemType("bool4");

                this.generateSystemType("float2x2", "mat2", 0, true, pFloat2, 2);
                this.generateSystemType("float2x3", "mat2x3", 0, true, pFloat2, 3);
                this.generateSystemType("float2x4", "mat2x4", 0, true, pFloat2, 4);

                this.generateSystemType("float3x2", "mat3x2", 0, true, pFloat3, 2);
                this.generateSystemType("float3x3", "mat3", 0, true, pFloat3, 3);
                this.generateSystemType("float3x4", "mat3x4", 0, true, pFloat3, 4);

                this.generateSystemType("float4x2", "mat4x2", 0, true, pFloat4, 2);
                this.generateSystemType("float4x3", "mat4x3", 0, true, pFloat4, 3);
                this.generateSystemType("float4x4", "mat4", 0, true, pFloat4, 4);

                this.generateSystemType("int2x2", "imat2", 0, true, pInt2, 2);
                this.generateSystemType("int2x3", "imat2x3", 0, true, pInt2, 3);
                this.generateSystemType("int2x4", "imat2x4", 0, true, pInt2, 4);

                this.generateSystemType("int3x2", "imat3x2", 0, true, pInt3, 2);
                this.generateSystemType("int3x3", "imat3", 0, true, pInt3, 3);
                this.generateSystemType("int3x4", "imat3x4", 0, true, pInt3, 4);

                this.generateSystemType("int4x2", "imat4x2", 0, true, pInt4, 2);
                this.generateSystemType("int4x3", "imat4x3", 0, true, pInt4, 3);
                this.generateSystemType("int4x4", "imat4", 0, true, pInt4, 4);

                this.generateSystemType("bool2x2", "bmat2", 0, true, pBool2, 2);
                this.generateSystemType("bool2x3", "bmat2x3", 0, true, pBool2, 3);
                this.generateSystemType("bool2x4", "bmat2x4", 0, true, pBool2, 4);

                this.generateSystemType("bool3x2", "bmat3x2", 0, true, pBool3, 2);
                this.generateSystemType("bool3x3", "bmat3", 0, true, pBool3, 3);
                this.generateSystemType("bool3x4", "bmat3x4", 0, true, pBool3, 4);

                this.generateSystemType("bool4x2", "bmat4x2", 0, true, pBool4, 2);
                this.generateSystemType("bool4x3", "bmat4x3", 0, true, pBool4, 3);
                this.generateSystemType("bool4x4", "bmat4", 0, true, pBool4, 4);
            };

            Effect.prototype.addFieldsToVectorFromSuffixObject = function (pSuffixMap, pType, sBaseType) {
                var sSuffix = null;

                for (sSuffix in pSuffixMap) {
                    var sFieldTypeName = sBaseType + ((sSuffix.length > 1) ? sSuffix.length.toString() : "");
                    var pFieldType = Effect.getSystemType(sFieldTypeName);

                    pType.addField(sSuffix, pFieldType, pSuffixMap[sSuffix]);
                }
            };

            Effect.prototype.getVariable = function (sName) {
                return Effect.getSystemVariable(sName) || this._pEffectScope._getVariable(sName);
            };

            Effect.prototype.hasVariable = function (sName) {
                return this._pEffectScope._hasVariable(sName);
            };

            Effect.prototype.getType = function (sTypeName) {
                return Effect.getSystemType(sTypeName) || this._pEffectScope._getType(sTypeName);
            };

            Effect.prototype.isSystemFunction = function (pFunction) {
                return false;
            };

            Effect.prototype.isSystemVariable = function (pVariable) {
                return false;
            };

            Effect.prototype.isSystemType = function (pType) {
                return false;
            };

            Effect.prototype._errorFromInstruction = function (pError) {
                this._error(pError.code, akra.isNull(pError.info) ? {} : pError.info);
            };

            Effect.prototype._error = function (eCode, pInfo) {
                if (typeof pInfo === "undefined") { pInfo = {}; }
                var sFileName = this._sAnalyzedFileName;

                var pLocation = { file: this._sAnalyzedFileName, line: 0 };
                var pLineColumn = this.getNodeSourceLocation(this.getAnalyzedNode());

                switch (eCode) {
                    default:
                        pInfo.line = pLineColumn.line + 1;
                        pInfo.column = pLineColumn.column + 1;

                        pLocation.line = pLineColumn.line + 1;

                        break;
                }

                var pLogEntity = {
                    code: eCode,
                    info: pInfo,
                    location: pLocation
                };

                akra.logger.critical(pLogEntity);
                //throw new Error(eCode.toString());
            };

            Effect.prototype.setAnalyzedNode = function (pNode) {
                // if(this._pAnalyzedNode !== pNode){
                // 	// debug_print("Analyze node: ", pNode);
                // 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
                // }
                this._pAnalyzedNode = pNode;
            };

            Effect.prototype.getAnalyzedNode = function () {
                return this._pAnalyzedNode;
            };

            Effect.prototype.isStrictMode = function () {
                return this._pEffectScope._isStrictMode();
            };

            Effect.prototype.setStrictModeOn = function () {
                return this._pEffectScope._setStrictModeOn();
            };

            Effect.prototype.newScope = function (eScopeType) {
                if (typeof eScopeType === "undefined") { eScopeType = 0 /* k_Default */; }
                this._pEffectScope._newScope(eScopeType);
            };

            Effect.prototype.resumeScope = function () {
                this._pEffectScope._resumeScope();
            };

            Effect.prototype.getScope = function () {
                return this._pEffectScope._getScope();
            };

            Effect.prototype.setScope = function (iScope) {
                this._pEffectScope._setScope(iScope);
            };

            Effect.prototype.endScope = function () {
                this._pEffectScope._endScope();
            };

            Effect.prototype.getScopeType = function () {
                return this._pEffectScope._getScopeType();
            };

            Effect.prototype.setCurrentAnalyzedFunction = function (pFunction) {
                this._pCurrentFunction = pFunction;
                this._bHaveCurrentFunctionReturnOccur = false;
            };

            Effect.prototype.setCurrentAnalyzedPass = function (pPass) {
                this._pCurrentPass = pPass;
            };

            Effect.prototype.getCurrentAnalyzedFunction = function () {
                return this._pCurrentFunction;
            };

            Effect.prototype.getCurrentAnalyzedPass = function () {
                return this._pCurrentPass;
            };

            Effect.prototype.isAnalzeInPass = function () {
                return this._isAnalyzeInPass;
            };

            Effect.prototype.setAnalyzeInPass = function (isInPass) {
                this._isAnalyzeInPass = isInPass;
            };

            Effect.prototype.setOperator = function (sOperator) {
                if (!akra.isNull(this._pCurrentInstruction)) {
                    this._pCurrentInstruction._setOperator(sOperator);
                }
            };

            Effect.prototype.clearPointersForExtract = function () {
                this._pPointerForExtractionList.length = 0;
            };

            Effect.prototype.addPointerForExtract = function (pPointer) {
                this._pPointerForExtractionList.push(pPointer);
            };

            Effect.prototype.getPointerForExtractList = function () {
                return this._pPointerForExtractionList;
            };

            Effect.prototype.findFunction = function (sFunctionName, pArguments) {
                return Effect.findSystemFunction(sFunctionName, pArguments) || this._pEffectScope._getFunction(sFunctionName, pArguments);
            };

            Effect.prototype.findConstructor = function (pType, pArguments) {
                var pVariableType = new fx.instructions.VariableTypeInstruction();
                pVariableType._pushType(pType);

                return pVariableType;
            };

            Effect.prototype.findShaderFunction = function (sFunctionName, pArguments) {
                return this._pEffectScope._getShaderFunction(sFunctionName, pArguments);
            };

            Effect.prototype.findFunctionByDef = function (pDef) {
                return this.findFunction(pDef._getName(), pDef.getArguments());
            };

            // private addVariable(pVariable: IAFXVariable): void {
            // }
            Effect.prototype.addVariableDecl = function (pVariable) {
                if (this.isSystemVariable(pVariable)) {
                    this._error(2235 /* REDEFINE_SYSTEM_VARIABLE */, { varName: pVariable._getName() });
                }

                var isVarAdded = this._pEffectScope._addVariable(pVariable);

                if (!isVarAdded) {
                    var eScopeType = this.getScopeType();

                    switch (eScopeType) {
                        case 0 /* k_Default */:
                            this._error(2234 /* REDEFINE_VARIABLE */, { varName: pVariable._getName() });
                            break;
                        case 1 /* k_Struct */:
                            this._error(2242 /* BAD_NEW_FIELD_FOR_STRUCT_NAME */, { fieldName: pVariable._getName() });
                            break;
                        case 2 /* k_Annotation */:
                            this._error(2244 /* BAD_NEW_ANNOTATION_VAR */, { varName: pVariable._getName() });
                            break;
                    }
                }

                if (pVariable._getName() === "Out" && !akra.isNull(this.getCurrentAnalyzedFunction())) {
                    var isOk = this.getCurrentAnalyzedFunction()._addOutVariable(pVariable);
                    if (!isOk) {
                        this._error(2266 /* BAD_OUT_VARIABLE_IN_FUNCTION */);
                    }
                }
            };

            Effect.prototype.addTypeDecl = function (pType) {
                if (this.isSystemType(pType)) {
                    this._error(2201 /* REDEFINE_SYSTEM_TYPE */, { typeName: pType._getName() });
                }

                var isTypeAdded = this._pEffectScope._addType(pType);

                if (!isTypeAdded) {
                    this._error(2202 /* REDEFINE_TYPE */, { typeName: pType._getName() });
                }
            };

            Effect.prototype.addFunctionDecl = function (pFunction) {
                if (this.isSystemFunction(pFunction)) {
                    this._error(2237 /* REDEFINE_SYSTEM_FUNCTION */, { funcName: pFunction._getName() });
                }

                var isFunctionAdded = this._pEffectScope._addFunction(pFunction);

                if (!isFunctionAdded) {
                    this._error(2236 /* REDEFINE_FUNCTION */, { funcName: pFunction._getName() });
                }
            };

            Effect.prototype.addTechnique = function (pTechnique) {
                var sName = pTechnique._getName();

                if (akra.isDef(this._pTechniqueMap[sName])) {
                    this._error(2252 /* BAD_TECHNIQUE_REDEFINE_NAME */, { techName: sName });
                    return;
                }

                this._pTechniqueMap[sName] = pTechnique;
                this._pTechniqueList.push(pTechnique);
            };

            Effect.prototype.addExternalSharedVariable = function (pVariable, eShaderType) {
                var isVarAdded = this._pEffectScope._addVariable(pVariable);

                if (!isVarAdded) {
                    this._error(2278 /* CANNOT_ADD_SHARED_VARIABLE */, { varName: pVariable._getName() });
                    return;
                }
            };

            Effect.prototype.analyzeGlobalUseDecls = function () {
                var pChildren = this._pParseTree.getRoot().children;
                var i = 0;

                for (i = pChildren.length - 1; i >= 0; i--) {
                    if (pChildren[i].name === "UseDecl") {
                        this.analyzeUseDecl(pChildren[i]);
                    }
                }
            };

            Effect.prototype.analyzeGlobalProvideDecls = function () {
                var pChildren = this._pParseTree.getRoot().children;
                var i = 0;

                for (i = pChildren.length - 1; i >= 0; i--) {
                    if (pChildren[i].name === "ProvideDecl") {
                        this.analyzeProvideDecl(pChildren[i]);
                    }
                }
            };

            Effect.prototype.analyzeGlobalTypeDecls = function () {
                var pChildren = this._pParseTree.getRoot().children;
                var i = 0;

                for (i = pChildren.length - 1; i >= 0; i--) {
                    if (pChildren[i].name === "TypeDecl") {
                        this.analyzeTypeDecl(pChildren[i]);
                    }
                }
            };

            Effect.prototype.analyzeFunctionDefinitions = function () {
                var pChildren = this._pParseTree.getRoot().children;
                var i = 0;

                for (i = pChildren.length - 1; i >= 0; i--) {
                    if (pChildren[i].name === "FunctionDecl") {
                        this.analyzeFunctionDeclOnlyDefinition(pChildren[i]);
                    }
                }
            };

            Effect.prototype.analyzeGlobalImports = function () {
                var pChildren = this._pParseTree.getRoot().children;
                var i = 0;

                for (i = pChildren.length - 1; i >= 0; i--) {
                    if (pChildren[i].name === "ImportDecl") {
                        this.analyzeImportDecl(pChildren[i], null);
                    }
                }
            };

            Effect.prototype.analyzeTechniqueImports = function () {
                var pChildren = this._pParseTree.getRoot().children;
                var i = 0;

                for (i = pChildren.length - 1; i >= 0; i--) {
                    if (pChildren[i].name === "TechniqueDecl") {
                        this.analyzeTechniqueForImport(pChildren[i]);
                    }
                }
            };

            Effect.prototype.analyzeVariableDecls = function () {
                var pChildren = this._pParseTree.getRoot().children;
                var i = 0;

                for (i = pChildren.length - 1; i >= 0; i--) {
                    if (pChildren[i].name === "VariableDecl") {
                        this.analyzeVariableDecl(pChildren[i]);
                    } else if (pChildren[i].name === "VarStructDecl") {
                        this.analyzeVarStructDecl(pChildren[i]);
                    }
                }
            };

            Effect.prototype.analyzeFunctionDecls = function () {
                for (var i = 0; i < this._pFunctionWithImplementationList.length; i++) {
                    this.resumeFunctionAnalysis(this._pFunctionWithImplementationList[i]);
                }

                this.checkFunctionsForRecursion();
                this.checkFunctionForCorrectUsage();
                this.generateInfoAboutUsedData();
                this.generateShadersFromFunctions();
            };

            Effect.prototype.analyzeTechniques = function () {
                for (var i = 0; i < this._pTechniqueList.length; i++) {
                    this.resumeTechniqueAnalysis(this._pTechniqueList[i]);
                }
            };

            Effect.prototype.checkFunctionsForRecursion = function () {
                var pFunctionList = this._pFunctionWithImplementationList;
                var isNewAdd = true;
                var isNewDelete = true;

                while (isNewAdd || isNewDelete) {
                    isNewAdd = false;
                    isNewDelete = false;

                    mainFor:
                    for (var i = 0; i < pFunctionList.length; i++) {
                        var pTestedFunction = pFunctionList[i];
                        var pUsedFunctionList = pTestedFunction._getUsedFunctionList();

                        if (!pTestedFunction._isUsed()) {
                            continue mainFor;
                        }
                        if (pTestedFunction._isBlackListFunction()) {
                            continue mainFor;
                        }

                        if (akra.isNull(pUsedFunctionList)) {
                            continue mainFor;
                        }

                        for (var j = 0; j < pUsedFunctionList.length; j++) {
                            var pAddedUsedFunctionList = pUsedFunctionList[j]._getUsedFunctionList();

                            if (akra.isNull(pAddedUsedFunctionList)) {
                                continue;
                            }

                            for (var k = 0; k < pAddedUsedFunctionList.length; k++) {
                                var pAddedFunction = pAddedUsedFunctionList[k];

                                if (pTestedFunction === pAddedFunction) {
                                    pTestedFunction._addToBlackList();
                                    isNewDelete = true;
                                    this._error(2255 /* BAD_FUNCTION_USAGE_RECURSION */, { funcDef: pTestedFunction._getStringDef() });
                                    continue mainFor;
                                }

                                if (pAddedFunction._isBlackListFunction() || !pAddedFunction._canUsedAsFunction()) {
                                    pTestedFunction._addToBlackList();
                                    this._error(2256 /* BAD_FUNCTION_USAGE_BLACKLIST */, { funcDef: pTestedFunction._getStringDef() });
                                    isNewDelete = true;
                                    continue mainFor;
                                }

                                if (pTestedFunction._addUsedFunction(pAddedFunction)) {
                                    isNewAdd = true;
                                }
                            }
                        }
                    }
                }
            };

            Effect.prototype.checkFunctionForCorrectUsage = function () {
                var pFunctionList = this._pFunctionWithImplementationList;
                var isNewUsageSet = true;
                var isNewDelete = true;

                while (isNewUsageSet || isNewDelete) {
                    isNewUsageSet = false;
                    isNewDelete = false;

                    mainFor:
                    for (var i = 0; i < pFunctionList.length; i++) {
                        var pTestedFunction = pFunctionList[i];
                        var pUsedFunctionList = pTestedFunction._getUsedFunctionList();

                        if (!pTestedFunction._isUsed()) {
                            continue mainFor;
                        }
                        if (pTestedFunction._isBlackListFunction()) {
                            continue mainFor;
                        }

                        if (!pTestedFunction._checkVertexUsage()) {
                            this._error(2257 /* BAD_FUNCTION_USAGE_VERTEX */, { funcDef: pTestedFunction._getStringDef() });
                            pTestedFunction._addToBlackList();
                            isNewDelete = true;
                            continue mainFor;
                        }

                        if (!pTestedFunction._checkPixelUsage()) {
                            this._error(2258 /* BAD_FUNCTION_USAGE_PIXEL */, { funcDef: pTestedFunction._getStringDef() });
                            pTestedFunction._addToBlackList();
                            isNewDelete = true;
                            continue mainFor;
                        }

                        if (akra.isNull(pUsedFunctionList)) {
                            continue mainFor;
                        }

                        for (var j = 0; j < pUsedFunctionList.length; j++) {
                            var pUsedFunction = pUsedFunctionList[j];

                            if (pTestedFunction._isUsedInVertex()) {
                                if (!pUsedFunction._isForVertex()) {
                                    this._error(2257 /* BAD_FUNCTION_USAGE_VERTEX */, { funcDef: pTestedFunction._getStringDef() });
                                    pTestedFunction._addToBlackList();
                                    isNewDelete = true;
                                    continue mainFor;
                                }

                                if (!pUsedFunction._isUsedInVertex()) {
                                    pUsedFunction._markUsedInVertex();
                                    isNewUsageSet = true;
                                }
                            }

                            if (pTestedFunction._isUsedInPixel()) {
                                if (!pUsedFunction._isForPixel()) {
                                    this._error(2258 /* BAD_FUNCTION_USAGE_PIXEL */, { funcDef: pTestedFunction._getStringDef() });
                                    pTestedFunction._addToBlackList();
                                    isNewDelete = true;
                                    continue mainFor;
                                }

                                if (!pUsedFunction._isUsedInPixel()) {
                                    pUsedFunction._markUsedInPixel();
                                    isNewUsageSet = true;
                                }
                            }
                        }
                    }
                }

                return;
            };

            Effect.prototype.generateInfoAboutUsedData = function () {
                var pFunctionList = this._pFunctionWithImplementationList;

                for (var i = 0; i < pFunctionList.length; i++) {
                    pFunctionList[i]._generateInfoAboutUsedData();
                }
            };

            Effect.prototype.generateShadersFromFunctions = function () {
                var pFunctionList = this._pFunctionWithImplementationList;

                for (var i = 0; i < pFunctionList.length; i++) {
                    var pShader = null;

                    if (pFunctionList[i]._isUsedAsVertex()) {
                        pShader = pFunctionList[i]._convertToVertexShader();
                    }
                    if (pFunctionList[i]._isUsedAsPixel()) {
                        pShader = pFunctionList[i]._convertToPixelShader();
                    }

                    if (pFunctionList[i]._isErrorOccured()) {
                        this._errorFromInstruction(pFunctionList[i]._getLastError());
                        pFunctionList[i]._clearError();
                    }
                }
            };

            Effect.prototype.analyzeVariableDecl = function (pNode, pInstruction) {
                if (typeof pInstruction === "undefined") { pInstruction = null; }
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pGeneralType = null;
                var pVariable = null;
                var i = 0;

                pGeneralType = this.analyzeUsageType(pChildren[pChildren.length - 1]);

                for (i = pChildren.length - 2; i >= 1; i--) {
                    if (pChildren[i].name === "Variable") {
                        pVariable = this.analyzeVariable(pChildren[i], pGeneralType);

                        if (!akra.isNull(pInstruction)) {
                            pInstruction._push(pVariable, true);
                            if (pInstruction._getInstructionType() === 55 /* k_DeclStmtInstruction */) {
                                var pVariableSubDecls = pVariable._getSubVarDecls();
                                if (!akra.isNull(pVariableSubDecls)) {
                                    for (var j = 0; j < pVariableSubDecls.length; j++) {
                                        pInstruction._push(pVariableSubDecls[j], false);
                                    }
                                }
                            }
                        }
                    }
                }
            };

            Effect.prototype.analyzeUsageType = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var i = 0;
                var pType = new fx.instructions.VariableTypeInstruction();

                for (i = pChildren.length - 1; i >= 0; i--) {
                    if (pChildren[i].name === "Type") {
                        var pMainType = this.analyzeType(pChildren[i]);
                        pType._pushType(pMainType);
                    } else if (pChildren[i].name === "Usage") {
                        var sUsage = this.analyzeUsage(pChildren[i]);
                        pType._addUsage(sUsage);
                    }
                }

                this.checkInstruction(pType, 0 /* CODE_TARGET_SUPPORT */);

                return pType;
            };

            Effect.prototype.analyzeType = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pType = null;

                switch (pNode.name) {
                    case "T_TYPE_ID":
                        pType = this.getType(pNode.value);

                        if (akra.isNull(pType)) {
                            this._error(2250 /* BAD_TYPE_NAME_NOT_TYPE */, { typeName: pNode.value });
                        }
                        break;

                    case "Struct":
                        pType = this.analyzeStruct(pNode);
                        break;

                    case "T_KW_VOID":
                        pType = Effect.getSystemType("void");
                        break;

                    case "ScalarType":
                    case "ObjectType":
                        pType = this.getType(pChildren[pChildren.length - 1].value);

                        if (akra.isNull(pType)) {
                            this._error(2250 /* BAD_TYPE_NAME_NOT_TYPE */, { typeName: pChildren[pChildren.length - 1].value });
                        }

                        break;

                    case "VectorType":
                    case "MatrixType":
                        this._error(2251 /* BAD_TYPE_VECTOR_MATRIX */);
                        break;

                    case "BaseType":
                    case "Type":
                        return this.analyzeType(pChildren[0]);
                }

                return pType;
            };

            Effect.prototype.analyzeUsage = function (pNode) {
                this.setAnalyzedNode(pNode);

                pNode = pNode.children[0];
                return pNode.value;
            };

            Effect.prototype.analyzeVariable = function (pNode, pGeneralType) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                var pVarDecl = new fx.instructions.VariableDeclInstruction();
                var pVariableType = new fx.instructions.VariableTypeInstruction();
                var pAnnotation = null;
                var sSemantic = "";
                var pInitExpr = null;

                pVarDecl._push(pVariableType, true);
                pVariableType._pushType(pGeneralType);
                pVarDecl._setScope(this.getScope());

                this.analyzeVariableDim(pChildren[pChildren.length - 1], pVarDecl);

                var i = 0;
                for (i = pChildren.length - 2; i >= 0; i--) {
                    if (pChildren[i].name === "Annotation") {
                        pAnnotation = this.analyzeAnnotation(pChildren[i]);
                        pVarDecl._setAnnotation(pAnnotation);
                    } else if (pChildren[i].name === "Semantic") {
                        sSemantic = this.analyzeSemantic(pChildren[i]);
                        pVarDecl._setSemantic(sSemantic);
                        pVarDecl._getNameId()._setRealName(sSemantic);
                    } else if (pChildren[i].name === "Initializer") {
                        pInitExpr = this.analyzeInitializer(pChildren[i]);
                        if (!pInitExpr._optimizeForVariableType(pVariableType)) {
                            this._error(2269 /* BAD_VARIABLE_INITIALIZER */, { varName: pVarDecl._getName() });
                            return null;
                        }
                        pVarDecl._push(pInitExpr, true);
                    }
                }

                this.checkInstruction(pVarDecl, 0 /* CODE_TARGET_SUPPORT */);

                this.addVariableDecl(pVarDecl);
                pVarDecl._getNameIndex();

                return pVarDecl;
            };

            Effect.prototype.analyzeVariableDim = function (pNode, pVariableDecl) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pVariableType = pVariableDecl._getType();

                if (pChildren.length === 1) {
                    var pName = new fx.instructions.IdInstruction();
                    pName._setName(pChildren[0].value);
                    pVariableDecl._push(pName, true);
                    return;
                }

                this.analyzeVariableDim(pChildren[pChildren.length - 1], pVariableDecl);

                if (pChildren.length === 3) {
                    pVariableType._addPointIndex(true);
                } else if (pChildren.length === 4 && pChildren[0].name === "FromExpr") {
                    var pBuffer = this.analyzeFromExpr(pChildren[0]);
                    pVariableType._addPointIndex(true);
                    pVariableType._setVideoBuffer(pBuffer);
                } else {
                    if (pVariableType._isPointer()) {
                        //TODO: add support for v[][10]
                        this._error(2300 /* BAD_ARRAY_OF_POINTERS */);
                    }

                    var pIndexExpr = this.analyzeExpr(pChildren[pChildren.length - 3]);
                    pVariableType._addArrayIndex(pIndexExpr);
                }
            };

            Effect.prototype.analyzeAnnotation = function (pNode) {
                this.setAnalyzedNode(pNode);

                return null;
            };

            Effect.prototype.analyzeSemantic = function (pNode) {
                this.setAnalyzedNode(pNode);

                var sSemantic = pNode.children[0].value;

                // var pDecl: IAFXDeclInstruction = <IAFXDeclInstruction>this._pCurrentInstruction;
                // pDecl._setSemantic(sSemantic);
                return sSemantic;
            };

            Effect.prototype.analyzeInitializer = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pInitExpr = new fx.instructions.InitExprInstruction();

                if (pChildren.length === 2) {
                    pInitExpr._push(this.analyzeExpr(pChildren[0]), true);
                } else {
                    for (var i = pChildren.length - 3; i >= 1; i--) {
                        if (pChildren[i].name === "InitExpr") {
                            pInitExpr._push(this.analyzeInitExpr(pChildren[i]), true);
                        }
                    }
                }

                return pInitExpr;
            };

            Effect.prototype.analyzeFromExpr = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pBuffer = null;

                if (pChildren[1].name === "T_NON_TYPE_ID") {
                    pBuffer = this.getVariable(pChildren[1].value);
                } else {
                    pBuffer = this.analyzeMemExpr(pChildren[1]).getBuffer();
                }

                return pBuffer;
            };

            Effect.prototype.analyzeInitExpr = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pInitExpr = new fx.instructions.InitExprInstruction();

                if (pChildren.length === 1) {
                    pInitExpr._push(this.analyzeExpr(pChildren[0]), true);
                } else {
                    for (var i = 0; i < pChildren.length; i++) {
                        if (pChildren[i].name === "InitExpr") {
                            pInitExpr._push(this.analyzeInitExpr(pChildren[i]), true);
                        }
                    }
                }

                return pInitExpr;
            };

            Effect.prototype.analyzeExpr = function (pNode) {
                this.setAnalyzedNode(pNode);
                var sName = pNode.name;

                switch (sName) {
                    case "ObjectExpr":
                        return this.analyzeObjectExpr(pNode);
                    case "ComplexExpr":
                        return this.analyzeComplexExpr(pNode);
                    case "PrimaryExpr":
                        return this.analyzePrimaryExpr(pNode);
                    case "PostfixExpr":
                        return this.analyzePostfixExpr(pNode);
                    case "UnaryExpr":
                        return this.analyzeUnaryExpr(pNode);
                    case "CastExpr":
                        return this.analyzeCastExpr(pNode);
                    case "ConditionalExpr":
                        return this.analyzeConditionalExpr(pNode);
                    case "MulExpr":
                    case "AddExpr":
                        return this.analyzeArithmeticExpr(pNode);
                    case "RelationalExpr":
                    case "EqualityExpr":
                        return this.analyzeRelationExpr(pNode);
                    case "AndExpr":
                    case "OrExpr":
                        return this.analyzeLogicalExpr(pNode);
                    case "AssignmentExpr":
                        return this.analyzeAssignmentExpr(pNode);
                    case "T_NON_TYPE_ID":
                        return this.analyzeIdExpr(pNode);
                    case "T_STRING":
                    case "T_UINT":
                    case "T_FLOAT":
                    case "T_KW_TRUE":
                    case "T_KW_FALSE":
                        return this.analyzeSimpleExpr(pNode);
                    case "MemExpr":
                        return this.analyzeMemExpr(pNode);
                    default:
                        this._error(2204 /* UNSUPPORTED_EXPR */, { exprName: sName });
                        break;
                }

                return null;
            };

            Effect.prototype.analyzeObjectExpr = function (pNode) {
                this.setAnalyzedNode(pNode);

                var sName = pNode.children[pNode.children.length - 1].name;

                switch (sName) {
                    case "T_KW_COMPILE":
                        return this.analyzeCompileExpr(pNode);
                    case "T_KW_SAMPLER_STATE":
                        return this.analyzeSamplerStateBlock(pNode);
                }
            };

            Effect.prototype.analyzeCompileExpr = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pExpr = new fx.instructions.CompileExprInstruction();
                var pExprType;
                var pArguments = null;
                var sShaderFuncName = pChildren[pChildren.length - 2].value;
                var pShaderFunc = null;
                var i = 0;

                pArguments = [];

                if (pChildren.length > 4) {
                    var pArgumentExpr;

                    for (i = pChildren.length - 3; i > 0; i--) {
                        if (pChildren[i].value !== ",") {
                            pArgumentExpr = this.analyzeExpr(pChildren[i]);
                            pArguments.push(pArgumentExpr);
                        }
                    }
                }

                pShaderFunc = this.findShaderFunction(sShaderFuncName, pArguments);

                if (akra.isNull(pShaderFunc)) {
                    this._error(2226 /* BAD_COMPILE_NOT_FUNCTION */, { funcName: sShaderFuncName });
                    return null;
                }

                pExprType = pShaderFunc._getType()._wrap();

                pExpr._setType(pExprType);
                pExpr._setOperator("complile");
                pExpr._push(pShaderFunc._getNameId(), false);

                if (!akra.isNull(pArguments)) {
                    for (i = 0; i < pArguments.length; i++) {
                        pExpr._push(pArguments[i], true);
                    }
                }

                this.checkInstruction(pExpr, 0 /* CODE_TARGET_SUPPORT */);

                return pExpr;
            };

            Effect.prototype.analyzeSamplerStateBlock = function (pNode) {
                pNode = pNode.children[0];
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pExpr = new fx.instructions.SamplerStateBlockInstruction();
                var i = 0;

                pExpr._setOperator("sample_state");

                for (i = pChildren.length - 2; i >= 1; i--) {
                    this.analyzeSamplerState(pChildren[i], pExpr);
                }

                this.checkInstruction(pExpr, 0 /* CODE_TARGET_SUPPORT */);

                return pExpr;
            };

            Effect.prototype.analyzeSamplerState = function (pNode, pSamplerStates) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                if (pChildren[pChildren.length - 2].name === "StateIndex") {
                    this._error(2270 /* NOT_SUPPORT_STATE_INDEX */);
                    return;
                }

                var pStateExprNode = pChildren[pChildren.length - 3];
                var pSubStateExprNode = pStateExprNode.children[pStateExprNode.children.length - 1];
                var sStateType = pChildren[pChildren.length - 1].value.toUpperCase();
                var sStateValue = "";
                var isTexture = false;

                if (akra.isNull(pSubStateExprNode.value)) {
                    this._error(2271 /* BAD_TEXTURE_FOR_SAMLER */);
                    return;
                }
                var pTexture = null;

                switch (sStateType) {
                    case "TEXTURE":
                        var pTexture = null;
                        if (pStateExprNode.children.length !== 3 || pSubStateExprNode.value === "{") {
                            this._error(2271 /* BAD_TEXTURE_FOR_SAMLER */);
                            return;
                        }
                        var sTextureName = pStateExprNode.children[1].value;
                        if (akra.isNull(sTextureName) || !this.hasVariable(sTextureName)) {
                            this._error(2271 /* BAD_TEXTURE_FOR_SAMLER */);
                            return;
                        }

                        pTexture = this.getVariable(sTextureName);
                        sStateValue = sTextureName;
                        break;

                    case "ADDRESSU":
                    case "ADDRESSV":
                        sStateValue = pSubStateExprNode.value.toUpperCase();
                        switch (sStateValue) {
                            case "WRAP":
                            case "CLAMP":
                            case "MIRROR":
                                break;
                            default:
                                akra.logger.warn("Webgl don`t support this wrapmode: " + sStateValue);
                                return;
                        }
                        break;

                    case "MAGFILTER":
                    case "MINFILTER":
                        sStateValue = pSubStateExprNode.value.toUpperCase();
                        switch (sStateValue) {
                            case "POINT":
                                sStateValue = "NEAREST";
                                break;
                            case "POINT_MIPMAP_POINT":
                                sStateValue = "NEAREST_MIPMAP_NEAREST";
                                break;
                            case "LINEAR_MIPMAP_POINT":
                                sStateValue = "LINEAR_MIPMAP_NEAREST";
                                break;
                            case "POINT_MIPMAP_LINEAR":
                                sStateValue = "NEAREST_MIPMAP_LINEAR";
                                break;

                            case "NEAREST":
                            case "LINEAR":
                            case "NEAREST_MIPMAP_NEAREST":
                            case "LINEAR_MIPMAP_NEAREST":
                            case "NEAREST_MIPMAP_LINEAR":
                            case "LINEAR_MIPMAP_LINEAR":
                                break;
                            default:
                                akra.logger.warn("Webgl don`t support this texture filter: " + sStateValue);
                                return;
                        }
                        break;

                    default:
                        akra.logger.warn("Don`t support this texture param: " + sStateType);
                        return;
                }

                if (sStateType !== "TEXTURE") {
                    pSamplerStates.addState(sStateType, sStateValue);
                } else {
                    pSamplerStates.setTexture(pTexture);
                }
            };

            Effect.prototype.analyzeComplexExpr = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var sFirstNodeName = pChildren[pChildren.length - 1].name;

                switch (sFirstNodeName) {
                    case "T_NON_TYPE_ID":
                        return this.analyzeFunctionCallExpr(pNode);
                    case "BaseType":
                    case "T_TYPE_ID":
                        return this.analyzeConstructorCallExpr(pNode);
                    default:
                        return this.analyzeSimpleComplexExpr(pNode);
                }
            };

            Effect.prototype.analyzeFunctionCallExpr = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pExpr = null;
                var pExprType = null;
                var pArguments = null;
                var sFuncName = pChildren[pChildren.length - 1].value;
                var pFunction = null;
                var pFunctionId = null;
                var i = 0;
                var pCurrentAnalyzedFunction = this.getCurrentAnalyzedFunction();

                if (pChildren.length > 3) {
                    var pArgumentExpr;

                    pArguments = [];

                    for (i = pChildren.length - 3; i > 0; i--) {
                        if (pChildren[i].value !== ",") {
                            pArgumentExpr = this.analyzeExpr(pChildren[i]);
                            pArguments.push(pArgumentExpr);
                        }
                    }
                }

                pFunction = this.findFunction(sFuncName, pArguments);

                if (akra.isNull(pFunction)) {
                    this._error(2223 /* BAD_COMPLEX_NOT_FUNCTION */, { funcName: sFuncName });
                    return null;
                }

                if (!akra.isDef(pFunction)) {
                    this._error(2246 /* BAD_CANNOT_CHOOSE_FUNCTION */, { funcName: sFuncName });
                    return null;
                }

                if (!akra.isNull(pCurrentAnalyzedFunction)) {
                    if (!pFunction._isForPixel()) {
                        pCurrentAnalyzedFunction._setForPixel(false);
                    }

                    if (!pFunction._isForVertex()) {
                        pCurrentAnalyzedFunction._setForVertex(false);
                    }
                }

                if (pFunction._getInstructionType() === 44 /* k_FunctionDeclInstruction */) {
                    var pFunctionCallExpr = new fx.instructions.FunctionCallInstruction();

                    pFunctionId = new fx.instructions.IdExprInstruction();
                    pFunctionId._push(pFunction._getNameId(), false);

                    pExprType = pFunction._getType()._wrap();

                    pFunctionCallExpr._setType(pExprType);
                    pFunctionCallExpr._push(pFunctionId, true);

                    if (!akra.isNull(pArguments)) {
                        for (i = 0; i < pArguments.length; i++) {
                            pFunctionCallExpr._push(pArguments[i], true);
                        }

                        var pFunctionArguments = pFunction._getArguments();
                        for (i = 0; i < pArguments.length; i++) {
                            if (pFunctionArguments[i]._getType()._hasUsage("out")) {
                                if (!pArguments[i]._getType()._isWritable()) {
                                    this._error(2267 /* BAD_TYPE_FOR_WRITE */);
                                    return null;
                                }

                                if (pArguments[i]._getType()._isStrongEqual(Effect.getSystemType("ptr"))) {
                                    this.addPointerForExtract(pArguments[i]._getType()._getParentVarDecl());
                                }
                            } else if (pFunctionArguments[i]._getType()._hasUsage("inout")) {
                                if (!pArguments[i]._getType()._isWritable()) {
                                    this._error(2267 /* BAD_TYPE_FOR_WRITE */);
                                    return null;
                                }

                                if (!pArguments[i]._getType()._isReadable()) {
                                    this._error(2268 /* BAD_TYPE_FOR_READ */);
                                    return null;
                                }

                                if (pArguments[i]._getType()._isStrongEqual(Effect.getSystemType("ptr"))) {
                                    this.addPointerForExtract(pArguments[i]._getType()._getParentVarDecl());
                                }
                            } else {
                                if (!pArguments[i]._getType()._isReadable()) {
                                    this._error(2268 /* BAD_TYPE_FOR_READ */);
                                    return null;
                                }
                            }
                        }

                        for (i = pArguments.length; i < pFunctionArguments.length; i++) {
                            pFunctionCallExpr._push(pFunctionArguments[i]._getInitializeExpr(), false);
                        }
                    }

                    if (!akra.isNull(pCurrentAnalyzedFunction)) {
                        pCurrentAnalyzedFunction._addUsedFunction(pFunction);
                    }

                    pFunction._markUsedAs(2 /* k_Function */);

                    pExpr = pFunctionCallExpr;
                } else {
                    var pSystemCallExpr = new fx.instructions.SystemCallInstruction();

                    pSystemCallExpr.setSystemCallFunction(pFunction);
                    pSystemCallExpr.fillByArguments(pArguments);

                    if (!akra.isNull(pCurrentAnalyzedFunction)) {
                        for (i = 0; i < pArguments.length; i++) {
                            if (!pArguments[i]._getType()._isReadable()) {
                                this._error(2268 /* BAD_TYPE_FOR_READ */);
                                return null;
                            }
                        }
                    }

                    pExpr = pSystemCallExpr;

                    if (!pFunction._isBuiltIn() && !akra.isNull(pCurrentAnalyzedFunction)) {
                        pCurrentAnalyzedFunction._addUsedFunction(pFunction);
                    }
                }

                this.checkInstruction(pExpr, 0 /* CODE_TARGET_SUPPORT */);

                return pExpr;
            };

            Effect.prototype.analyzeConstructorCallExpr = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pExpr = new fx.instructions.ConstructorCallInstruction();
                var pExprType = null;
                var pArguments = null;
                var pConstructorType = null;
                var i = 0;

                pConstructorType = this.analyzeType(pChildren[pChildren.length - 1]);

                if (akra.isNull(pConstructorType)) {
                    this._error(2224 /* BAD_COMPLEX_NOT_TYPE */);
                    return null;
                }

                if (pChildren.length > 3) {
                    var pArgumentExpr = null;

                    pArguments = [];

                    for (i = pChildren.length - 3; i > 0; i--) {
                        if (pChildren[i].value !== ",") {
                            pArgumentExpr = this.analyzeExpr(pChildren[i]);
                            pArguments.push(pArgumentExpr);
                        }
                    }
                }

                pExprType = this.findConstructor(pConstructorType, pArguments);

                if (akra.isNull(pExprType)) {
                    this._error(2225 /* BAD_COMPLEX_NOT_CONSTRUCTOR */, { typeName: pConstructorType.toString() });
                    return null;
                }

                pExpr._setType(pExprType);
                pExpr._push(pConstructorType, false);

                if (!akra.isNull(pArguments)) {
                    for (i = 0; i < pArguments.length; i++) {
                        if (!pArguments[i]._getType()._isReadable()) {
                            this._error(2268 /* BAD_TYPE_FOR_READ */);
                            return null;
                        }

                        pExpr._push(pArguments[i], true);
                    }
                }

                this.checkInstruction(pExpr, 0 /* CODE_TARGET_SUPPORT */);

                return pExpr;
            };

            Effect.prototype.analyzeSimpleComplexExpr = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pExpr = new fx.instructions.ComplexExprInstruction();
                var pComplexExpr;
                var pExprType;

                pComplexExpr = this.analyzeExpr(pChildren[1]);
                pExprType = pComplexExpr._getType();

                pExpr._setType(pExprType);
                pExpr._push(pComplexExpr, true);

                this.checkInstruction(pExpr, 0 /* CODE_TARGET_SUPPORT */);

                return pExpr;
            };

            Effect.prototype.analyzePrimaryExpr = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pExpr = new fx.instructions.PrimaryExprInstruction();
                var pPrimaryExpr;
                var pPointer = null;
                var pPrimaryExprType;

                pPrimaryExpr = this.analyzeExpr(pChildren[0]);
                pPrimaryExprType = pPrimaryExpr._getType();

                pPointer = pPrimaryExprType._getPointer();

                if (akra.isNull(pPointer)) {
                    this._error(2222 /* BAD_PRIMARY_NOT_POINT */, { typeName: pPrimaryExprType._getHash() });
                    return null;
                }

                var pPointerVarType = pPrimaryExprType._getParent();
                if (!pPrimaryExprType._isStrictPointer()) {
                    this.getCurrentAnalyzedFunction()._setForPixel(false);
                    this.getCurrentAnalyzedFunction()._notCanUsedAsFunction();
                    pPrimaryExprType._setPointerToStrict();
                }

                pExpr._setType(pPointer._getType());
                pExpr._setOperator("@");
                pExpr._push(pPointer._getNameId(), false);

                this.checkInstruction(pExpr, 0 /* CODE_TARGET_SUPPORT */);

                return pExpr;
            };

            Effect.prototype.analyzePostfixExpr = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var sSymbol = pChildren[pChildren.length - 2].value;

                switch (sSymbol) {
                    case "[":
                        return this.analyzePostfixIndex(pNode);
                    case ".":
                        return this.analyzePostfixPoint(pNode);
                    case "++":
                    case "--":
                        return this.analyzePostfixArithmetic(pNode);
                }
            };

            Effect.prototype.analyzePostfixIndex = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pExpr = new fx.instructions.PostfixIndexInstruction();
                var pPostfixExpr = null;
                var pIndexExpr = null;
                var pExprType = null;
                var pPostfixExprType = null;
                var pIndexExprType = null;
                var pIntType = null;

                pPostfixExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pPostfixExprType = pPostfixExpr._getType();

                if (!pPostfixExprType._isArray()) {
                    this._error(2217 /* BAD_POSTIX_NOT_ARRAY */, { typeName: pPostfixExprType.toString() });
                    return null;
                }

                pIndexExpr = this.analyzeExpr(pChildren[pChildren.length - 3]);
                pIndexExprType = pIndexExpr._getType();

                pIntType = Effect.getSystemType("int");

                if (!pIndexExprType._isEqual(pIntType)) {
                    this._error(2218 /* BAD_POSTIX_NOT_INT_INDEX */, { typeName: pIndexExprType.toString() });
                    return null;
                }

                pExprType = (pPostfixExprType._getArrayElementType());

                pExpr._setType(pExprType);
                pExpr._push(pPostfixExpr, true);
                pExpr._push(pIndexExpr, true);

                this.checkInstruction(pExpr, 0 /* CODE_TARGET_SUPPORT */);

                return pExpr;
            };

            Effect.prototype.analyzePostfixPoint = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pExpr = new fx.instructions.PostfixPointInstruction();
                var pPostfixExpr = null;
                var sFieldName = "";
                var pFieldNameExpr = null;
                var pExprType = null;
                var pPostfixExprType = null;

                pPostfixExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pPostfixExprType = pPostfixExpr._getType();

                sFieldName = pChildren[pChildren.length - 3].value;

                pFieldNameExpr = pPostfixExprType._getFieldExpr(sFieldName);

                if (akra.isNull(pFieldNameExpr)) {
                    this._error(2219 /* BAD_POSTIX_NOT_FIELD */, {
                        typeName: pPostfixExprType.toString(),
                        fieldName: sFieldName
                    });
                    return null;
                }

                pExprType = pFieldNameExpr._getType();

                if (pChildren.length === 4) {
                    if (!pExprType._isPointer()) {
                        this._error(2220 /* BAD_POSTIX_NOT_POINTER */, { typeName: pExprType.toString() });
                        return null;
                    }

                    var pBuffer = this.analyzeFromExpr(pChildren[0]);
                    pExprType._setVideoBuffer(pBuffer);
                }

                pExpr._setType(pExprType);
                pExpr._push(pPostfixExpr, true);
                pExpr._push(pFieldNameExpr, true);

                this.checkInstruction(pExpr, 0 /* CODE_TARGET_SUPPORT */);

                return pExpr;
            };

            Effect.prototype.analyzePostfixArithmetic = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var sOperator = pChildren[0].value;
                var pExpr = new fx.instructions.PostfixArithmeticInstruction();
                var pPostfixExpr;
                var pExprType;
                var pPostfixExprType;

                pPostfixExpr = this.analyzeExpr(pChildren[1]);
                pPostfixExprType = pPostfixExpr._getType();

                pExprType = this.checkOneOperandExprType(sOperator, pPostfixExprType);

                if (akra.isNull(pExprType)) {
                    this._error(2221 /* BAD_POSTIX_ARITHMETIC */, {
                        operator: sOperator,
                        typeName: pPostfixExprType.toString()
                    });
                    return null;
                }

                pExpr._setType(pExprType);
                pExpr._setOperator(sOperator);
                pExpr._push(pPostfixExpr, true);

                this.checkInstruction(pExpr, 0 /* CODE_TARGET_SUPPORT */);

                return pExpr;
            };

            Effect.prototype.analyzeUnaryExpr = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var sOperator = pChildren[1].value;
                var pExpr = new fx.instructions.UnaryExprInstruction();
                var pUnaryExpr;
                var pExprType;
                var pUnaryExprType;

                pUnaryExpr = this.analyzeExpr(pChildren[0]);
                pUnaryExprType = pUnaryExpr._getType();

                pExprType = this.checkOneOperandExprType(sOperator, pUnaryExprType);

                if (akra.isNull(pExprType)) {
                    this._error(2216 /* BAD_UNARY_OPERATION */, {
                        operator: sOperator,
                        tyepName: pUnaryExprType.toString()
                    });
                    return null;
                }

                pExpr._setOperator(sOperator);
                pExpr._setType(pExprType);
                pExpr._push(pUnaryExpr, true);

                this.checkInstruction(pExpr, 0 /* CODE_TARGET_SUPPORT */);

                return pExpr;
            };

            Effect.prototype.analyzeCastExpr = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pExpr = new fx.instructions.CastExprInstruction();
                var pExprType;
                var pCastedExpr;

                pExprType = this.analyzeConstTypeDim(pChildren[2]);
                pCastedExpr = this.analyzeExpr(pChildren[0]);

                if (!pCastedExpr._getType()._isReadable()) {
                    this._error(2268 /* BAD_TYPE_FOR_READ */);
                    return null;
                }

                pExpr._setType(pExprType);
                pExpr._push(pExprType, true);
                pExpr._push(pCastedExpr, true);

                this.checkInstruction(pExpr, 0 /* CODE_TARGET_SUPPORT */);

                return pExpr;
            };

            Effect.prototype.analyzeConditionalExpr = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pExpr = new fx.instructions.ConditionalExprInstruction();
                var pConditionExpr;
                var pTrueExpr;
                var pFalseExpr;
                var pConditionType;
                var pTrueExprType;
                var pFalseExprType;
                var pExprType;
                var pBoolType;

                pConditionExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pTrueExpr = this.analyzeExpr(pChildren[pChildren.length - 3]);
                pFalseExpr = this.analyzeExpr(pChildren[0]);

                pConditionType = pConditionExpr._getType();
                pTrueExprType = pTrueExpr._getType();
                pFalseExprType = pFalseExpr._getType();

                pBoolType = Effect.getSystemType("bool");

                if (!pConditionType._isEqual(pBoolType)) {
                    this._error(2211 /* BAD_CONDITION_TYPE */, { typeName: pConditionType.toString() });
                    return null;
                }

                if (!pTrueExprType._isEqual(pFalseExprType)) {
                    this._error(2212 /* BAD_CONDITION_VALUE_TYPES */, {
                        leftTypeName: pTrueExprType.toString(),
                        rightTypeName: pFalseExprType.toString()
                    });
                    return null;
                }

                if (!pConditionType._isReadable()) {
                    this._error(2268 /* BAD_TYPE_FOR_READ */);
                    return null;
                }

                if (!pTrueExprType._isReadable()) {
                    this._error(2268 /* BAD_TYPE_FOR_READ */);
                    return null;
                }

                if (!pFalseExprType._isReadable()) {
                    this._error(2268 /* BAD_TYPE_FOR_READ */);
                    return null;
                }

                pExpr._setType(pTrueExprType);
                pExpr._push(pConditionExpr, true);
                pExpr._push(pTrueExpr, true);
                pExpr._push(pFalseExpr, true);

                this.checkInstruction(pExpr, 0 /* CODE_TARGET_SUPPORT */);

                return pExpr;
            };

            Effect.prototype.analyzeArithmeticExpr = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var sOperator = pNode.children[1].value;
                var pExpr = new fx.instructions.ArithmeticExprInstruction();
                var pLeftExpr = null;
                var pRightExpr = null;
                var pLeftType = null;
                var pRightType = null;
                var pExprType = null;

                pLeftExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pRightExpr = this.analyzeExpr(pChildren[0]);

                pLeftType = pLeftExpr._getType();
                pRightType = pRightExpr._getType();

                pExprType = this.checkTwoOperandExprTypes(sOperator, pLeftType, pRightType);

                if (akra.isNull(pExprType)) {
                    this._error(2206 /* BAD_ARITHMETIC_OPERATION */, {
                        operator: sOperator,
                        leftTypeName: pLeftType.toString(),
                        rightTypeName: pRightType.toString()
                    });
                    return null;
                }

                pExpr._setOperator(sOperator);
                pExpr._setType(pExprType);
                pExpr._push(pLeftExpr, true);
                pExpr._push(pRightExpr, true);

                this.checkInstruction(pExpr, 0 /* CODE_TARGET_SUPPORT */);

                return pExpr;
            };

            Effect.prototype.analyzeRelationExpr = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var sOperator = pNode.children[1].value;
                var pExpr = new fx.instructions.RelationalExprInstruction();
                var pLeftExpr;
                var pRightExpr;
                var pLeftType;
                var pRightType;
                var pExprType;

                pLeftExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pRightExpr = this.analyzeExpr(pChildren[0]);

                pLeftType = pLeftExpr._getType();
                pRightType = pRightExpr._getType();

                pExprType = this.checkTwoOperandExprTypes(sOperator, pLeftType, pRightType);

                if (akra.isNull(pExprType)) {
                    this._error(2209 /* BAD_RELATIONAL_OPERATION */, {
                        operator: sOperator,
                        leftTypeName: pLeftType._getHash(),
                        rightTypeName: pRightType._getHash()
                    });
                    return null;
                }

                pExpr._setOperator(sOperator);
                pExpr._setType(pExprType);
                pExpr._push(pLeftExpr, true);
                pExpr._push(pRightExpr, true);

                this.checkInstruction(pExpr, 0 /* CODE_TARGET_SUPPORT */);

                return pExpr;
            };

            Effect.prototype.analyzeLogicalExpr = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var sOperator = pNode.children[1].value;
                var pExpr = new fx.instructions.LogicalExprInstruction();
                var pLeftExpr;
                var pRightExpr;
                var pLeftType;
                var pRightType;
                var pBoolType;

                pLeftExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pRightExpr = this.analyzeExpr(pChildren[0]);

                pLeftType = pLeftExpr._getType();
                pRightType = pRightExpr._getType();

                pBoolType = Effect.getSystemType("bool");

                if (!pLeftType._isEqual(pBoolType)) {
                    this._error(2210 /* BAD_LOGICAL_OPERATION */, {
                        operator: sOperator,
                        typeName: pLeftType.toString()
                    });
                    return null;
                }
                if (!pRightType._isEqual(pBoolType)) {
                    this._error(2210 /* BAD_LOGICAL_OPERATION */, {
                        operator: sOperator,
                        typeName: pRightType.toString()
                    });
                    return null;
                }

                if (!pLeftType._isReadable()) {
                    this._error(2268 /* BAD_TYPE_FOR_READ */);
                    return null;
                }

                if (!pRightType._isReadable()) {
                    this._error(2268 /* BAD_TYPE_FOR_READ */);
                    return null;
                }

                pExpr._setOperator(sOperator);
                pExpr._setType(pBoolType.getVariableType());
                pExpr._push(pLeftExpr, true);
                pExpr._push(pRightExpr, true);

                this.checkInstruction(pExpr, 0 /* CODE_TARGET_SUPPORT */);

                return pExpr;
            };

            Effect.prototype.analyzeAssignmentExpr = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var sOperator = pChildren[1].value;
                var pExpr = new fx.instructions.AssignmentExprInstruction();
                var pLeftExpr;
                var pRightExpr;
                var pLeftType;
                var pRightType;
                var pExprType;

                pLeftExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pRightExpr = this.analyzeExpr(pChildren[0]);

                pLeftType = pLeftExpr._getType();
                pRightType = pRightExpr._getType();

                if (sOperator !== "=") {
                    pExprType = this.checkTwoOperandExprTypes(sOperator, pLeftType, pRightType);
                    if (akra.isNull(pExprType)) {
                        this._error(2207 /* BAD_ARITHMETIC_ASSIGNMENT_OPERATION */, {
                            operator: sOperator,
                            leftTypeName: pLeftType._getHash(),
                            rightTypeName: pRightType._getHash()
                        });
                    }
                } else {
                    pExprType = pRightType;
                }

                pExprType = this.checkTwoOperandExprTypes("=", pLeftType, pExprType);

                if (akra.isNull(pExprType)) {
                    this._error(2208 /* BAD_ASSIGNMENT_OPERATION */, {
                        leftTypeName: pLeftType._getHash(),
                        rightTypeName: pRightType._getHash()
                    });
                }

                pExpr._setOperator(sOperator);
                pExpr._setType(pExprType);
                pExpr._push(pLeftExpr, true);
                pExpr._push(pRightExpr, true);

                this.checkInstruction(pExpr, 0 /* CODE_TARGET_SUPPORT */);

                return pExpr;
            };

            Effect.prototype.analyzeIdExpr = function (pNode) {
                this.setAnalyzedNode(pNode);

                var sName = pNode.value;
                var pVariable = this.getVariable(sName);

                if (akra.isNull(pVariable)) {
                    this._error(2205 /* UNKNOWN_VARNAME */, { varName: sName });
                    return null;
                }

                if (pVariable._getType()._isUnverifiable() && !this.isAnalzeInPass()) {
                    this._error(2276 /* BAD_USE_OF_ENGINE_VARIABLE */);
                    return null;
                }

                if (!akra.isNull(this.getCurrentAnalyzedFunction())) {
                    if (!pVariable._isForPixel()) {
                        this.getCurrentAnalyzedFunction()._setForPixel(false);
                    }
                    if (!pVariable._isForVertex()) {
                        this.getCurrentAnalyzedFunction()._setForVertex(false);
                    }
                }

                if (!akra.isNull(this.getCurrentAnalyzedPass()) && pVariable._getType()._isForeign()) {
                    this.getCurrentAnalyzedPass()._addOwnUsedForignVariable(pVariable);
                }

                var pVarId = new fx.instructions.IdExprInstruction();
                pVarId._push(pVariable._getNameId(), false);

                this.checkInstruction(pVarId, 0 /* CODE_TARGET_SUPPORT */);

                return pVarId;
            };

            Effect.prototype.analyzeSimpleExpr = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pInstruction = null;
                var sName = pNode.name;
                var sValue = pNode.value;

                switch (sName) {
                    case "T_UINT":
                        pInstruction = new fx.instructions.IntInstruction();
                        pInstruction._setValue(sValue * 1);
                        break;
                    case "T_FLOAT":
                        pInstruction = new fx.instructions.FloatInstruction();
                        pInstruction._setValue(sValue * 1.0);
                        break;
                    case "T_STRING":
                        pInstruction = new fx.instructions.StringInstruction();
                        pInstruction._setValue(sValue);
                        break;
                    case "T_KW_TRUE":
                        pInstruction = new fx.instructions.BoolInstruction();
                        pInstruction._setValue(true);
                        break;
                    case "T_KW_FALSE":
                        pInstruction = new fx.instructions.BoolInstruction();
                        pInstruction._setValue(false);
                        break;
                }

                return pInstruction;
            };

            Effect.prototype.analyzeMemExpr = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pMemExpr = new fx.instructions.MemExprInstruction();

                var pPostfixExpr = this.analyzeExpr(pChildren[0]);
                var pPostfixExprType = pPostfixExpr._getType();

                if (!pPostfixExprType._isFromVariableDecl()) {
                    this._error(2253 /* BAD_MEMOF_ARGUMENT */);
                    return null;
                }

                var pBuffer = pPostfixExprType._getVideoBuffer();

                if (akra.isNull(pBuffer)) {
                    this._error(2254 /* BAD_MEMOF_NO_BUFFER */);
                }

                if (!pPostfixExprType._isStrictPointer() && !akra.isNull(this.getCurrentAnalyzedFunction())) {
                    this.getCurrentAnalyzedFunction()._setForPixel(false);
                    this.getCurrentAnalyzedFunction()._notCanUsedAsFunction();
                    pPostfixExprType._setPointerToStrict();
                }

                pMemExpr.setBuffer(pBuffer);

                return pMemExpr;
            };

            Effect.prototype.analyzeConstTypeDim = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                if (pChildren.length > 1) {
                    this._error(2213 /* BAD_CAST_TYPE_USAGE */);
                    return null;
                }

                var pType;

                pType = (this.analyzeType(pChildren[0]));

                if (!pType._isBase()) {
                    this._error(2214 /* BAD_CAST_TYPE_NOT_BASE */, { typeName: pType.toString() });
                }

                this.checkInstruction(pType, 0 /* CODE_TARGET_SUPPORT */);

                return pType;
            };

            Effect.prototype.analyzeVarStructDecl = function (pNode, pInstruction) {
                if (typeof pInstruction === "undefined") { pInstruction = null; }
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pUsageType = null;
                var pVariable = null;
                var i = 0;

                pUsageType = this.analyzeUsageStructDecl(pChildren[pChildren.length - 1]);

                for (i = pChildren.length - 2; i >= 1; i--) {
                    if (pChildren[i].name === "Variable") {
                        pVariable = this.analyzeVariable(pChildren[i], pUsageType);

                        if (!akra.isNull(pInstruction)) {
                            pInstruction._push(pVariable, true);
                        }
                    }
                }
            };

            Effect.prototype.analyzeUsageStructDecl = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var i = 0;
                var pType = new fx.instructions.VariableTypeInstruction();

                for (i = pChildren.length - 1; i >= 0; i--) {
                    if (pChildren[i].name === "StructDecl") {
                        var pMainType = this.analyzeStructDecl(pChildren[i]);
                        pType._pushType(pMainType);

                        var pTypeDecl = new fx.instructions.TypeDeclInstruction();
                        pTypeDecl._push(pMainType, true);

                        this.addTypeDecl(pTypeDecl);
                    } else if (pChildren[i].name === "Usage") {
                        var sUsage = this.analyzeUsage(pChildren[i]);
                        pType._addUsage(sUsage);
                    }
                }

                this.checkInstruction(pType, 0 /* CODE_TARGET_SUPPORT */);

                return pType;
            };

            Effect.prototype.analyzeTypeDecl = function (pNode, pParentInstruction) {
                if (typeof pParentInstruction === "undefined") { pParentInstruction = null; }
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                var pTypeDeclInstruction = new fx.instructions.TypeDeclInstruction();

                if (pChildren.length === 2) {
                    var pStructInstruction = this.analyzeStructDecl(pChildren[1]);
                    pTypeDeclInstruction._push(pStructInstruction, true);
                } else {
                    this._error(2203 /* UNSUPPORTED_TYPEDECL */);
                }

                this.checkInstruction(pTypeDeclInstruction, 0 /* CODE_TARGET_SUPPORT */);

                this.addTypeDecl(pTypeDeclInstruction);

                pNode.isAnalyzed = true;

                if (!akra.isNull(pParentInstruction)) {
                    pParentInstruction._push(pTypeDeclInstruction, true);
                }

                return pTypeDeclInstruction;
            };

            Effect.prototype.analyzeStructDecl = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                var pStruct = new fx.instructions.ComplexTypeInstruction();
                var pFieldCollector = new fx.instructions.InstructionCollector();

                var sName = pChildren[pChildren.length - 2].value;

                pStruct._setName(sName);

                this.newScope(1 /* k_Struct */);

                var i = 0;
                for (i = pChildren.length - 4; i >= 1; i--) {
                    if (pChildren[i].name === "VariableDecl") {
                        this.analyzeVariableDecl(pChildren[i], pFieldCollector);
                    }
                }

                this.endScope();

                pStruct.addFields(pFieldCollector, true);

                this.checkInstruction(pStruct, 0 /* CODE_TARGET_SUPPORT */);

                return pStruct;
            };

            Effect.prototype.analyzeStruct = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                var pStruct = new fx.instructions.ComplexTypeInstruction();
                var pFieldCollector = new fx.instructions.InstructionCollector();

                this.newScope(1 /* k_Struct */);

                var i = 0;
                for (i = pChildren.length - 4; i >= 1; i--) {
                    if (pChildren[i].name === "VariableDecl") {
                        this.analyzeVariableDecl(pChildren[i], pFieldCollector);
                    }
                }

                this.endScope();

                pStruct.addFields(pFieldCollector, true);

                this.checkInstruction(pStruct, 0 /* CODE_TARGET_SUPPORT */);

                return pStruct;
            };

            Effect.prototype.analyzeFunctionDeclOnlyDefinition = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pFunction = null;
                var pFunctionDef = null;
                var pStmtBlock = null;
                var pAnnotation = null;
                var sLastNodeValue = pChildren[0].value;
                var bNeedAddFunction = false;

                pFunctionDef = this.analyzeFunctionDef(pChildren[pChildren.length - 1]);

                pFunction = this.findFunctionByDef(pFunctionDef);

                if (!akra.isDef(pFunction)) {
                    this._error(2246 /* BAD_CANNOT_CHOOSE_FUNCTION */, { funcName: pFunction._getNameId().toString() });
                    return null;
                }

                if (!akra.isNull(pFunction) && pFunction._hasImplementation()) {
                    this._error(2227 /* BAD_REDEFINE_FUNCTION */, { funcName: pFunction._getNameId().toString() });
                    return null;
                }

                if (akra.isNull(pFunction)) {
                    pFunction = new fx.instructions.FunctionDeclInstruction();
                    bNeedAddFunction = true;
                } else {
                    if (!pFunction._getReturnType()._isEqual(pFunctionDef.getReturnType())) {
                        this._error(2247 /* BAD_FUNCTION_DEF_RETURN_TYPE */, { funcName: pFunction._getNameId().toString() });
                        return null;
                    }

                    bNeedAddFunction = false;
                }

                pFunction._setFunctionDef(pFunctionDef);

                this.resumeScope();

                if (pChildren.length === 3) {
                    pAnnotation = this.analyzeAnnotation(pChildren[1]);
                    pFunction._setAnnotation(pAnnotation);
                }

                if (sLastNodeValue !== ";") {
                    pFunction._setParseNode(pNode);
                    pFunction._setImplementationScope(this.getScope());
                    this._pFunctionWithImplementationList.push(pFunction);
                }

                this.endScope();

                if (bNeedAddFunction) {
                    this.addFunctionDecl(pFunction);
                }
            };

            Effect.prototype.resumeFunctionAnalysis = function (pAnalzedFunction) {
                var pFunction = pAnalzedFunction;
                var pNode = pFunction._getParseNode();

                this.setAnalyzedNode(pNode);
                this.setScope(pFunction._getImplementationScope());

                var pChildren = pNode.children;
                var pStmtBlock = null;

                this.setCurrentAnalyzedFunction(pFunction);

                pStmtBlock = this.analyzeStmtBlock(pChildren[0]);
                pFunction._setImplementation(pStmtBlock);

                if (!pFunction._getReturnType()._isEqual(Effect.getSystemType("void")) && !this._bHaveCurrentFunctionReturnOccur) {
                    this._error(2279 /* BAD_FUNCTION_DONT_HAVE_RETURN_STMT */, { funcName: pFunction._getNameId().toString() });
                }

                this.setCurrentAnalyzedFunction(null);

                this.endScope();

                this.checkInstruction(pFunction, 0 /* CODE_TARGET_SUPPORT */);
            };

            Effect.prototype.analyzeFunctionDef = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pFunctionDef = new fx.instructions.FunctionDefInstruction();
                var pReturnType = null;
                var pFuncName = null;
                var pArguments = null;
                var sFuncName = pChildren[pChildren.length - 2].value;

                pReturnType = this.analyzeUsageType(pChildren[pChildren.length - 1]);

                if (pReturnType._isPointer() || pReturnType._containSampler() || pReturnType._containPointer()) {
                    this._error(2264 /* BAD_RETURN_TYPE_FOR_FUNCTION */, { funcName: sFuncName });
                    return null;
                }

                pFuncName = new fx.instructions.IdInstruction();
                pFuncName._setName(sFuncName);
                pFuncName._setRealName(sFuncName + "_" + this.guid);

                pFunctionDef.setReturnType(pReturnType);
                pFunctionDef.setFunctionName(pFuncName);

                if (pChildren.length === 4) {
                    var sSemantic = this.analyzeSemantic(pChildren[0]);
                    pFunctionDef._setSemantic(sSemantic);
                }

                this.newScope();

                this.analyzeParamList(pChildren[pChildren.length - 3], pFunctionDef);

                this.endScope();

                this.checkInstruction(pFunctionDef, 0 /* CODE_TARGET_SUPPORT */);

                return pFunctionDef;
            };

            Effect.prototype.analyzeParamList = function (pNode, pFunctionDef) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pParameter;

                var i = 0;

                for (i = pChildren.length - 2; i >= 1; i--) {
                    if (pChildren[i].name === "ParameterDecl") {
                        pParameter = this.analyzeParameterDecl(pChildren[i]);
                        pParameter._setScope(this.getScope());
                        pFunctionDef.addParameter(pParameter, this.isStrictMode());
                    }
                }
            };

            Effect.prototype.analyzeParameterDecl = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pType = null;
                var pParameter = null;

                pType = this.analyzeParamUsageType(pChildren[1]);
                pParameter = this.analyzeVariable(pChildren[0], pType);

                return pParameter;
            };

            Effect.prototype.analyzeParamUsageType = function (pNode) {
                var pChildren = pNode.children;
                var i = 0;
                var pType = new fx.instructions.VariableTypeInstruction();

                for (i = pChildren.length - 1; i >= 0; i--) {
                    if (pChildren[i].name === "Type") {
                        var pMainType = this.analyzeType(pChildren[i]);
                        pType._pushType(pMainType);
                    } else if (pChildren[i].name === "ParamUsage") {
                        var sUsage = this.analyzeUsage(pChildren[i]);
                        pType._addUsage(sUsage);
                    }
                }

                this.checkInstruction(pType, 0 /* CODE_TARGET_SUPPORT */);

                return pType;
            };

            Effect.prototype.analyzeStmtBlock = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pStmtBlock = new fx.instructions.StmtBlockInstruction();
                var pStmt;
                var i = 0;

                pStmtBlock._setScope(this.getScope());

                this.newScope();

                for (i = pChildren.length - 2; i > 0; i--) {
                    pStmt = this.analyzeStmt(pChildren[i]);
                    if (!akra.isNull(pStmt)) {
                        pStmtBlock._push(pStmt);
                    }

                    this.addExtactionStmts(pStmtBlock);
                }

                this.endScope();

                this.checkInstruction(pStmtBlock, 0 /* CODE_TARGET_SUPPORT */);

                return pStmtBlock;
            };

            Effect.prototype.analyzeStmt = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var sFirstNodeName = pChildren[pChildren.length - 1].name;

                switch (sFirstNodeName) {
                    case "SimpleStmt":
                        return this.analyzeSimpleStmt(pChildren[0]);
                    case "UseDecl":
                        this.analyzeUseDecl(pChildren[0]);
                        return null;
                    case "T_KW_WHILE":
                        return this.analyzeWhileStmt(pNode);
                    case "T_KW_FOR":
                        return this.analyzeForStmt(pNode);
                    case "T_KW_IF":
                        return this.analyzeIfStmt(pNode);
                }
            };

            Effect.prototype.analyzeSimpleStmt = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var sFirstNodeName = pChildren[pChildren.length - 1].name;

                switch (sFirstNodeName) {
                    case "T_KW_RETURN":
                        return this.analyzeReturnStmt(pNode);

                    case "T_KW_DO":
                        return this.analyzeWhileStmt(pNode);

                    case "StmtBlock":
                        return this.analyzeStmtBlock(pChildren[0]);

                    case "T_KW_DISCARD":
                    case "T_KW_BREAK":
                    case "T_KW_CONTINUE":
                        return this.analyzeBreakStmt(pNode);

                    case "TypeDecl":
                    case "VariableDecl":
                    case "VarStructDecl":
                        return this.analyzeDeclStmt(pChildren[0]);

                    default:
                        if (pChildren.length === 2) {
                            return this.analyzeExprStmt(pNode);
                        } else {
                            return (new fx.instructions.SemicolonStmtInstruction());
                        }
                }
            };

            Effect.prototype.analyzeReturnStmt = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pReturnStmtInstruction = new fx.instructions.ReturnStmtInstruction();

                var pFunctionReturnType = this.getCurrentAnalyzedFunction()._getReturnType();

                this._bHaveCurrentFunctionReturnOccur = true;

                if (pFunctionReturnType._isEqual(Effect.getSystemType("void")) && pChildren.length === 3) {
                    this._error(2261 /* BAD_RETURN_STMT_VOID */);
                    return null;
                } else if (!pFunctionReturnType._isEqual(Effect.getSystemType("void")) && pChildren.length === 2) {
                    this._error(2262 /* BAD_RETURN_STMT_EMPTY */);
                    return null;
                }

                if (pChildren.length === 3) {
                    var pExprInstruction = this.analyzeExpr(pChildren[1]);
                    var pOutVar = this.getCurrentAnalyzedFunction()._getOutVariable();

                    if (!akra.isNull(pOutVar) && pOutVar._getType() !== pExprInstruction._getType()) {
                        this._error(2263 /* BAD_RETURN_STMT_NOT_EQUAL_TYPES */);
                        return null;
                    }

                    if (!pFunctionReturnType._isEqual(pExprInstruction._getType())) {
                        this._error(2263 /* BAD_RETURN_STMT_NOT_EQUAL_TYPES */);
                        return null;
                    }
                    pReturnStmtInstruction._push(pExprInstruction, true);
                }

                this.checkInstruction(pReturnStmtInstruction, 0 /* CODE_TARGET_SUPPORT */);

                return pReturnStmtInstruction;
            };

            Effect.prototype.analyzeBreakStmt = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pBreakStmtInstruction = new fx.instructions.BreakStmtInstruction();
                var sOperatorName = pChildren[1].value;

                pBreakStmtInstruction._setOperator(sOperatorName);

                if (sOperatorName === "discard" && !akra.isNull(this.getCurrentAnalyzedFunction())) {
                    this.getCurrentAnalyzedFunction()._setForVertex(false);
                }

                this.checkInstruction(pBreakStmtInstruction, 0 /* CODE_TARGET_SUPPORT */);

                return pBreakStmtInstruction;
            };

            Effect.prototype.analyzeDeclStmt = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var sNodeName = pNode.name;
                var pDeclStmtInstruction = new fx.instructions.DeclStmtInstruction();

                switch (sNodeName) {
                    case "TypeDecl":
                        this.analyzeTypeDecl(pNode, pDeclStmtInstruction);
                        break;
                    case "VariableDecl":
                        this.analyzeVariableDecl(pNode, pDeclStmtInstruction);
                        break;
                    case "VarStructDecl":
                        this.analyzeVarStructDecl(pNode, pDeclStmtInstruction);
                        break;
                }

                this.checkInstruction(pDeclStmtInstruction, 0 /* CODE_TARGET_SUPPORT */);

                return pDeclStmtInstruction;
            };

            Effect.prototype.analyzeExprStmt = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pExprStmtInstruction = new fx.instructions.ExprStmtInstruction();
                var pExprInstruction = this.analyzeExpr(pChildren[1]);

                pExprStmtInstruction._push(pExprInstruction, true);

                this.checkInstruction(pExprStmtInstruction, 0 /* CODE_TARGET_SUPPORT */);

                return pExprStmtInstruction;
            };

            Effect.prototype.analyzeWhileStmt = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var isDoWhile = (pChildren[pChildren.length - 1].value === "do");
                var isNonIfStmt = (pNode.name === "NonIfStmt") ? true : false;

                var pWhileStmt = new fx.instructions.WhileStmtInstruction();
                var pCondition = null;
                var pConditionType = null;
                var pBoolType = Effect.getSystemType("bool");
                var pStmt = null;

                if (isDoWhile) {
                    pWhileStmt._setOperator("do_while");
                    pCondition = this.analyzeExpr(pChildren[2]);
                    pConditionType = pCondition._getType();

                    if (!pConditionType._isEqual(pBoolType)) {
                        this._error(2229 /* BAD_DO_WHILE_CONDITION */, { typeName: pConditionType.toString() });
                        return null;
                    }

                    pStmt = this.analyzeStmt(pChildren[0]);
                } else {
                    pWhileStmt._setOperator("while");
                    pCondition = this.analyzeExpr(pChildren[2]);
                    pConditionType = pCondition._getType();

                    if (!pConditionType._isEqual(pBoolType)) {
                        this._error(2228 /* BAD_WHILE_CONDITION */, { typeName: pConditionType.toString() });
                        return null;
                    }

                    if (isNonIfStmt) {
                        pStmt = this.analyzeNonIfStmt(pChildren[0]);
                    } else {
                        pStmt = this.analyzeStmt(pChildren[0]);
                    }

                    pWhileStmt._push(pCondition, true);
                    pWhileStmt._push(pStmt, true);
                }

                this.checkInstruction(pWhileStmt, 0 /* CODE_TARGET_SUPPORT */);

                return pWhileStmt;
            };

            Effect.prototype.analyzeIfStmt = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var isIfElse = (pChildren.length === 7);

                var pIfStmtInstruction = new fx.instructions.IfStmtInstruction();
                var pCondition = this.analyzeExpr(pChildren[pChildren.length - 3]);
                var pConditionType = pCondition._getType();
                var pBoolType = Effect.getSystemType("bool");

                var pIfStmt = null;
                var pElseStmt = null;

                if (!pConditionType._isEqual(pBoolType)) {
                    this._error(2230 /* BAD_IF_CONDITION */, { typeName: pConditionType.toString() });
                    return null;
                }

                pIfStmtInstruction._push(pCondition, true);

                if (isIfElse) {
                    pIfStmtInstruction._setOperator("if_else");
                    pIfStmt = this.analyzeNonIfStmt(pChildren[2]);
                    pElseStmt = this.analyzeStmt(pChildren[0]);

                    pIfStmtInstruction._push(pIfStmt, true);
                    pIfStmtInstruction._push(pElseStmt, true);
                } else {
                    pIfStmtInstruction._setOperator("if");
                    pIfStmt = this.analyzeNonIfStmt(pChildren[0]);

                    pIfStmtInstruction._push(pIfStmt, true);
                }

                this.checkInstruction(pIfStmtInstruction, 0 /* CODE_TARGET_SUPPORT */);

                return pIfStmtInstruction;
            };

            Effect.prototype.analyzeNonIfStmt = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var sFirstNodeName = pChildren[pChildren.length - 1].name;

                switch (sFirstNodeName) {
                    case "SimpleStmt":
                        return this.analyzeSimpleStmt(pChildren[0]);
                    case "T_KW_WHILE":
                        return this.analyzeWhileStmt(pNode);
                    case "T_KW_FOR":
                        return this.analyzeForStmt(pNode);
                }
            };

            Effect.prototype.analyzeForStmt = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var isNonIfStmt = (pNode.name === "NonIfStmt");
                var pForStmtInstruction = new fx.instructions.ForStmtInstruction();
                var pStmt = null;

                this.newScope();

                this.analyzeForInit(pChildren[pChildren.length - 3], pForStmtInstruction);
                this.analyzeForCond(pChildren[pChildren.length - 4], pForStmtInstruction);

                if (pChildren.length === 7) {
                    this.analyzeForStep(pChildren[2], pForStmtInstruction);
                } else {
                    pForStmtInstruction._push(null);
                }

                if (isNonIfStmt) {
                    pStmt = this.analyzeNonIfStmt(pChildren[0]);
                } else {
                    pStmt = this.analyzeStmt(pChildren[0]);
                }

                pForStmtInstruction._push(pStmt, true);

                this.endScope();

                this.checkInstruction(pForStmtInstruction, 0 /* CODE_TARGET_SUPPORT */);

                return pForStmtInstruction;
            };

            Effect.prototype.analyzeForInit = function (pNode, pForStmtInstruction) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var sFirstNodeName = pChildren[pChildren.length - 1].name;

                switch (sFirstNodeName) {
                    case "VariableDecl":
                        this.analyzeVariableDecl(pChildren[0], pForStmtInstruction);
                        break;
                    case "Expr":
                        var pExpr = this.analyzeExpr(pChildren[0]);
                        pForStmtInstruction._push(pExpr, true);
                        break;
                    default:
                        // ForInit : ';'
                        pForStmtInstruction._push(null);
                        break;
                }

                return;
            };

            Effect.prototype.analyzeForCond = function (pNode, pForStmtInstruction) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                if (pChildren.length === 1) {
                    pForStmtInstruction._push(null);
                    return;
                }

                var pConditionExpr = this.analyzeExpr(pChildren[1]);

                pForStmtInstruction._push(pConditionExpr, true);
                return;
            };

            Effect.prototype.analyzeForStep = function (pNode, pForStmtInstruction) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pStepExpr = this.analyzeExpr(pChildren[0]);

                pForStmtInstruction._push(pStepExpr, true);

                return;
            };

            Effect.prototype.analyzeUseDecl = function (pNode) {
                this.setAnalyzedNode(pNode);
                this.setStrictModeOn();
            };

            Effect.prototype.analyzeTechniqueForImport = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var pTechnique = new fx.instructions.TechniqueInstruction();
                var sTechniqueName = this.analyzeComplexName(pChildren[pChildren.length - 2]);
                var isComplexName = pChildren[pChildren.length - 2].children.length !== 1;

                pTechnique._setName(sTechniqueName, isComplexName);

                for (var i = pChildren.length - 3; i >= 0; i--) {
                    if (pChildren[i].name === "Annotation") {
                        var pAnnotation = this.analyzeAnnotation(pChildren[i]);
                        pTechnique._setAnnotation(pAnnotation);
                    } else if (pChildren[i].name === "Semantic") {
                        var sSemantic = this.analyzeSemantic(pChildren[i]);
                        pTechnique._setSemantic(sSemantic);
                    } else {
                        this.analyzeTechniqueBodyForImports(pChildren[i], pTechnique);
                    }
                }

                this.addTechnique(pTechnique);
            };

            Effect.prototype.analyzeComplexName = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var sName = "";

                for (var i = pChildren.length - 1; i >= 0; i--) {
                    sName += pChildren[i].value;
                }

                return sName;
            };

            Effect.prototype.analyzeTechniqueBodyForImports = function (pNode, pTechnique) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                for (var i = pChildren.length - 2; i >= 1; i--) {
                    this.analyzePassDeclForImports(pChildren[i], pTechnique);
                }
            };

            Effect.prototype.analyzePassDeclForImports = function (pNode, pTechnique) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                if (pChildren[0].name === "ImportDecl") {
                    this.analyzeImportDecl(pChildren[0], pTechnique);
                } else if (pChildren.length > 1) {
                    var pPass = new fx.instructions.PassInstruction();

                    //TODO: add annotation and id
                    this.analyzePassStateBlockForShaders(pChildren[0], pPass);

                    pPass._setParseNode(pNode);

                    pTechnique._addPass(pPass);
                }
            };

            Effect.prototype.analyzePassStateBlockForShaders = function (pNode, pPass) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                for (var i = pChildren.length - 2; i >= 1; i--) {
                    this.analyzePassStateForShader(pChildren[i], pPass);
                }
            };

            Effect.prototype.analyzePassStateForShader = function (pNode, pPass) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                if (pChildren.length === 1) {
                    pPass._markAsComplex(true);

                    if (pChildren[0].name === "StateIf") {
                        this.analyzePassStateIfForShader(pChildren[0], pPass);
                    } else if (pChildren[0].name === "StateSwitch") {
                        this.analyzePassStateSwitchForShader(pChildren[0], pPass);
                    }

                    return;
                }

                var sType = pChildren[pChildren.length - 1].value.toUpperCase();
                var eShaderType = 0 /* k_Vertex */;

                if (sType === "VERTEXSHADER") {
                    eShaderType = 0 /* k_Vertex */;
                } else if (sType === "PIXELSHADER") {
                    eShaderType = 1 /* k_Pixel */;
                } else {
                    return;
                }

                pNode.isAnalyzed = true;

                var pStateExprNode = pChildren[pChildren.length - 3];
                var pExprNode = pStateExprNode.children[pStateExprNode.children.length - 1];
                var pCompileExpr = this.analyzeExpr(pExprNode);
                var pShaderFunc = pCompileExpr.getFunction();

                if (eShaderType === 0 /* k_Vertex */) {
                    if (!pShaderFunc._checkDefenitionForVertexUsage()) {
                        this._error(2259 /* BAD_FUNCTION_VERTEX_DEFENITION */, { funcDef: pShaderFunc._getStringDef() });
                    }
                } else {
                    if (!pShaderFunc._checkDefenitionForPixelUsage()) {
                        this._error(2260 /* BAD_FUNCTION_PIXEL_DEFENITION */, { funcDef: pShaderFunc._getStringDef() });
                    }
                }

                pShaderFunc._markUsedAs(eShaderType);

                pPass._addFoundFunction(pNode, pShaderFunc, eShaderType);
            };

            Effect.prototype.analyzePassStateIfForShader = function (pNode, pPass) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                if (pChildren.length === 5) {
                    this.analyzePassStateBlockForShaders(pChildren[0], pPass);
                } else if (pChildren.length === 7 && pChildren[0].name === "PassStateBlock") {
                    this.analyzePassStateBlockForShaders(pChildren[2], pPass);
                    this.analyzePassStateBlockForShaders(pChildren[0], pPass);
                } else {
                    this.analyzePassStateBlockForShaders(pChildren[2], pPass);
                    this.analyzePassStateIfForShader(pChildren[0], pPass);
                }
            };

            Effect.prototype.analyzePassStateSwitchForShader = function (pNode, pPass) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                this.analyzePassCaseBlockForShader(pChildren[0], pPass);
            };

            Effect.prototype.analyzePassCaseBlockForShader = function (pNode, pPass) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                for (var i = pChildren.length - 2; i >= 1; i--) {
                    if (pChildren[i].name === "CaseState") {
                        this.analyzePassCaseStateForShader(pChildren[i], pPass);
                    } else if (pChildren[i].name === "DefaultState") {
                        this.analyzePassDefaultStateForShader(pChildren[i], pPass);
                    }
                }
            };

            Effect.prototype.analyzePassCaseStateForShader = function (pNode, pPass) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                for (var i = pChildren.length - 4; i >= 0; i--) {
                    if (pChildren[i].name === "PassState") {
                        this.analyzePassStateForShader(pChildren[i], pPass);
                    }
                }
            };

            Effect.prototype.analyzePassDefaultStateForShader = function (pNode, pPass) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                for (var i = pChildren.length - 3; i >= 0; i--) {
                    if (pChildren[i].name === "PassState") {
                        this.analyzePassStateForShader(pChildren[i], pPass);
                    }
                }
            };

            Effect.prototype.resumeTechniqueAnalysis = function (pTechnique) {
                var pPassList = pTechnique._getPassList();

                for (var i = 0; i < pPassList.length; i++) {
                    this.resumePassAnalysis(pPassList[i]);
                }

                if (!pTechnique._checkForCorrectImports()) {
                    this._error(2275 /* BAD_TECHNIQUE_IMPORT */, { techniqueName: pTechnique._getName() });
                    return;
                }

                pTechnique._setGlobalParams(this._sProvideNameSpace, this._pImportedGlobalTechniqueList);
            };

            Effect.prototype.resumePassAnalysis = function (pPass) {
                var pNode = pPass._getParseNode();

                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                this.setCurrentAnalyzedPass(pPass);
                this.setAnalyzeInPass(true);
                this.analyzePassStateBlock(pChildren[0], pPass);
                this.setAnalyzeInPass(false);
                this.setCurrentAnalyzedPass(null);

                pPass._finalizePass();
            };

            Effect.prototype.analyzePassStateBlock = function (pNode, pPass) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                pPass._addCodeFragment("{");

                for (var i = pChildren.length - 2; i >= 1; i--) {
                    this.analyzePassState(pChildren[i], pPass);
                }

                pPass._addCodeFragment("}");
            };

            Effect.prototype.analyzePassState = function (pNode, pPass) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                if (pChildren.length === 1) {
                    if (pChildren[0].name === "StateIf") {
                        this.analyzePassStateIf(pChildren[0], pPass);
                    } else if (pChildren[0].name === "StateSwitch") {
                        this.analyzePassStateSwitch(pChildren[0], pPass);
                    }

                    return;
                }

                if (pNode.isAnalyzed) {
                    var pFunc = pPass._getFoundedFunction(pNode);
                    var eShaderType = pPass._getFoundedFunctionType(pNode);
                    var pShader = null;

                    if (eShaderType === 0 /* k_Vertex */) {
                        pShader = pFunc._getVertexShader();
                    } else {
                        pShader = pFunc._getPixelShader();
                    }

                    pPass._addShader(pShader);
                } else {
                    var sType = pChildren[pChildren.length - 1].value.toUpperCase();
                    var eType = this.getRenderState(sType);
                    var pStateExprNode = pChildren[pChildren.length - 3];
                    var pExprNode = pStateExprNode.children[pStateExprNode.children.length - 1];

                    if (akra.isNull(pExprNode.value) || akra.isNull(eType)) {
                        akra.logger.warn("So pass state are incorrect");
                        return;
                    }

                    if (pExprNode.value === "{" && pStateExprNode.children.length > 3) {
                        var pValues = new Array(akra.math.ceil((pStateExprNode.children.length - 2) / 2));
                        for (var i = pStateExprNode.children.length - 2, j = 0; i >= 1; i -= 2, j++) {
                            pValues[j] = this.getRenderStateValue(eType, pStateExprNode.children[i].value.toUpperCase());
                        }

                        switch (eType) {
                            case 21 /* BLENDFUNC */:
                                if (pValues.length !== 2) {
                                    akra.logger.warn("So pass state are incorrect");
                                    return;
                                }
                                pPass._setState(10 /* SRCBLENDCOLOR */, pValues[0]);
                                pPass._setState(12 /* SRCBLENDALPHA */, pValues[0]);
                                pPass._setState(11 /* DESTBLENDCOLOR */, pValues[1]);
                                pPass._setState(13 /* DESTBLENDALPHA */, pValues[1]);
                                break;

                            case 22 /* BLENDFUNCSEPARATE */:
                                if (pValues.length !== 4) {
                                    akra.logger.warn("So pass state are incorrect");
                                    return;
                                }
                                pPass._setState(10 /* SRCBLENDCOLOR */, pValues[0]);
                                pPass._setState(12 /* SRCBLENDALPHA */, pValues[2]);
                                pPass._setState(11 /* DESTBLENDCOLOR */, pValues[1]);
                                pPass._setState(13 /* DESTBLENDALPHA */, pValues[3]);
                                break;

                            case 24 /* BLENDEQUATIONSEPARATE */:
                                if (pValues.length !== 2) {
                                    akra.logger.warn("So pass state are incorrect");
                                    return;
                                }
                                pPass._setState(14 /* BLENDEQUATIONCOLOR */, pValues[0]);
                                pPass._setState(15 /* BLENDEQUATIONALPHA */, pValues[1]);
                                break;

                            default:
                                akra.logger.warn("So pass state are incorrect");
                                return;
                        }
                    } else {
                        var sValue = "";
                        if (pExprNode.value === "{") {
                            sValue = pStateExprNode.children[1].value.toUpperCase();
                        } else {
                            sValue = pExprNode.value.toUpperCase();
                        }

                        var eValue = this.getRenderStateValue(eType, sValue);

                        if (eValue !== 0 /* UNDEF */) {
                            switch (eType) {
                                case 19 /* SRCBLEND */:
                                    pPass._setState(10 /* SRCBLENDCOLOR */, eValue);
                                    pPass._setState(12 /* SRCBLENDALPHA */, eValue);
                                    break;
                                case 20 /* DESTBLEND */:
                                    pPass._setState(11 /* DESTBLENDCOLOR */, eValue);
                                    pPass._setState(13 /* DESTBLENDALPHA */, eValue);
                                    break;
                                case 23 /* BLENDEQUATION */:
                                    pPass._setState(14 /* BLENDEQUATIONCOLOR */, eValue);
                                    pPass._setState(15 /* BLENDEQUATIONALPHA */, eValue);
                                    break;
                                default:
                                    pPass._setState(eType, eValue);
                                    break;
                            }
                        }
                    }
                }
            };

            Effect.prototype.getRenderState = function (sState) {
                var eType = null;

                switch (sState) {
                    case "BLENDENABLE":
                        eType = 0 /* BLENDENABLE */;
                        break;
                    case "CULLFACEENABLE":
                        eType = 1 /* CULLFACEENABLE */;
                        break;
                    case "ZENABLE":
                        eType = 2 /* ZENABLE */;
                        break;
                    case "ZWRITEENABLE":
                        eType = 3 /* ZWRITEENABLE */;
                        break;
                    case "DITHERENABLE":
                        eType = 4 /* DITHERENABLE */;
                        break;
                    case "SCISSORTESTENABLE":
                        eType = 5 /* SCISSORTESTENABLE */;
                        break;
                    case "STENCILTESTENABLE":
                        eType = 6 /* STENCILTESTENABLE */;
                        break;
                    case "POLYGONOFFSETFILLENABLE":
                        eType = 7 /* POLYGONOFFSETFILLENABLE */;
                        break;
                    case "CULLFACE":
                        eType = 8 /* CULLFACE */;
                        break;
                    case "FRONTFACE":
                        eType = 9 /* FRONTFACE */;
                        break;

                    case "SRCBLENDCOLOR":
                        eType = 10 /* SRCBLENDCOLOR */;
                        break;
                    case "DESTBLENDCOLOR":
                        eType = 11 /* DESTBLENDCOLOR */;
                        break;
                    case "SRCBLENDALPHA":
                        eType = 12 /* SRCBLENDALPHA */;
                        break;
                    case "DESTBLENDALPHA":
                        eType = 13 /* DESTBLENDALPHA */;
                        break;

                    case "BLENDEQUATIONCOLOR":
                        eType = 14 /* BLENDEQUATIONCOLOR */;
                        break;
                    case "BLENDEQUATIONALPHA":
                        eType = 15 /* BLENDEQUATIONALPHA */;
                        break;

                    case "SRCBLEND":
                        eType = 19 /* SRCBLEND */;
                        break;
                    case "DESTBLEND":
                        eType = 20 /* DESTBLEND */;
                        break;
                    case "BLENDFUNC":
                        eType = 21 /* BLENDFUNC */;
                        break;
                    case "BLENDFUNCSEPARATE":
                        eType = 22 /* BLENDFUNCSEPARATE */;
                        break;

                    case "BLENDEQUATION":
                        eType = 23 /* BLENDEQUATION */;
                        break;
                    case "BLENDEQUATIONSEPARATE":
                        eType = 24 /* BLENDEQUATIONSEPARATE */;
                        break;

                    case "ZFUNC":
                        eType = 16 /* ZFUNC */;
                        break;
                    case "ALPHABLENDENABLE":
                        eType = 17 /* ALPHABLENDENABLE */;
                        break;
                    case "ALPHATESTENABLE":
                        eType = 18 /* ALPHATESTENABLE */;
                        break;

                    default:
                        akra.logger.warn("Unsupported render state type used: " + sState + ". WebGl...");
                        break;
                }

                return eType;
            };

            Effect.prototype.getRenderStateValue = function (eState, sValue) {
                var eValue = 0 /* UNDEF */;

                switch (eState) {
                    case 17 /* ALPHABLENDENABLE */:
                    case 18 /* ALPHATESTENABLE */:
                        akra.logger.warn("ALPHABLENDENABLE/ALPHATESTENABLE not supported in WebGL.");
                        return;

                    case 0 /* BLENDENABLE */:
                    case 1 /* CULLFACEENABLE */:
                    case 2 /* ZENABLE */:
                    case 3 /* ZWRITEENABLE */:
                    case 4 /* DITHERENABLE */:
                    case 5 /* SCISSORTESTENABLE */:
                    case 6 /* STENCILTESTENABLE */:
                    case 7 /* POLYGONOFFSETFILLENABLE */:
                        switch (sValue) {
                            case "TRUE":
                                eValue = 1 /* TRUE */;
                                break;
                            case "FALSE":
                                eValue = 2 /* FALSE */;
                                break;

                            default:
                                akra.logger.warn("Unsupported render state ALPHABLENDENABLE/ZENABLE/ZWRITEENABLE/DITHERENABLE value used: " + sValue + ".");
                                return eValue;
                        }
                        break;

                    case 8 /* CULLFACE */:
                        switch (sValue) {
                            case "FRONT":
                                eValue = 17 /* FRONT */;
                                break;
                            case "BACK":
                                eValue = 18 /* BACK */;
                                break;
                            case "FRONT_AND_BACK":
                                eValue = 19 /* FRONT_AND_BACK */;
                                break;

                            default:
                                akra.logger.warn("Unsupported render state CULLFACE value used: " + sValue + ".");
                                return eValue;
                        }
                        break;

                    case 9 /* FRONTFACE */:
                        switch (sValue) {
                            case "CW":
                                eValue = 15 /* CW */;
                                break;
                            case "CCW":
                                eValue = 16 /* CCW */;
                                break;

                            default:
                                akra.logger.warn("Unsupported render state FRONTFACE value used: " + sValue + ".");
                                return eValue;
                        }
                        break;

                    case 19 /* SRCBLEND */:
                    case 20 /* DESTBLEND */:
                    case 12 /* SRCBLENDALPHA */:
                    case 13 /* DESTBLENDALPHA */:
                    case 10 /* SRCBLENDCOLOR */:
                    case 11 /* DESTBLENDCOLOR */:
                    case 21 /* BLENDFUNC */:
                    case 22 /* BLENDFUNCSEPARATE */:
                        switch (sValue) {
                            case "ZERO":
                                eValue = 3 /* ZERO */;
                                break;
                            case "ONE":
                                eValue = 4 /* ONE */;
                                break;
                            case "SRCCOLOR":
                                eValue = 5 /* SRCCOLOR */;
                                break;
                            case "INVSRCCOLOR":
                                eValue = 6 /* INVSRCCOLOR */;
                                break;
                            case "SRCALPHA":
                                eValue = 7 /* SRCALPHA */;
                                break;
                            case "INVSRCALPHA":
                                eValue = 8 /* INVSRCALPHA */;
                                break;
                            case "DESTALPHA":
                                eValue = 9 /* DESTALPHA */;
                                break;
                            case "INVDESTALPHA":
                                eValue = 10 /* INVDESTALPHA */;
                                break;
                            case "DESTCOLOR":
                                eValue = 11 /* DESTCOLOR */;
                                break;
                            case "INVDESTCOLOR":
                                eValue = 12 /* INVDESTCOLOR */;
                                break;
                            case "SRCALPHASAT":
                                eValue = 13 /* SRCALPHASAT */;
                                break;

                            default:
                                akra.logger.warn("Unsupported render state SRCBLEND/DESTBLEND value used: " + sValue + ".");
                                return eValue;
                        }
                        break;

                    case 23 /* BLENDEQUATION */:
                    case 24 /* BLENDEQUATIONSEPARATE */:
                    case 14 /* BLENDEQUATIONCOLOR */:
                    case 15 /* BLENDEQUATIONALPHA */:
                        switch (sValue) {
                            case "FUNCADD":
                            case "ADD":
                                eValue = 28 /* FUNCADD */;
                                break;
                            case "FUNCSUBTRACT":
                            case "SUBTRACT":
                                eValue = 29 /* FUNCSUBTRACT */;
                                break;
                            case "FUNCREVERSESUBTRACT":
                            case "REVERSESUBTRACT":
                                eValue = 30 /* FUNCREVERSESUBTRACT */;
                                break;
                            default:
                                akra.logger.warn("Unsupported render state BLENDEQUATION/BLENDEQUATIONSEPARATE value used: " + sValue + ".");
                                return eValue;
                        }
                        break;

                    case 16 /* ZFUNC */:
                        switch (sValue) {
                            case "NEVER":
                                eValue = 20 /* NEVER */;
                                break;
                            case "LESS":
                                eValue = 21 /* LESS */;
                                break;
                            case "EQUAL":
                                eValue = 22 /* EQUAL */;
                                break;
                            case "LESSEQUAL":
                                eValue = 23 /* LESSEQUAL */;
                                break;
                            case "GREATER":
                                eValue = 24 /* GREATER */;
                                break;
                            case "NOTEQUAL":
                                eValue = 25 /* NOTEQUAL */;
                                break;
                            case "GREATEREQUAL":
                                eValue = 26 /* GREATEREQUAL */;
                                break;
                            case "ALWAYS":
                                eValue = 27 /* ALWAYS */;
                                break;

                            default:
                                akra.logger.warn("Unsupported render state ZFUNC value used: " + sValue + ".");
                                return eValue;
                        }
                        break;
                }

                return eValue;
            };

            Effect.prototype.analyzePassStateIf = function (pNode, pPass) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                var pIfExpr = this.analyzeExpr(pChildren[pChildren.length - 3]);
                pIfExpr._prepareFor(3 /* k_PassFunction */);

                pPass._addCodeFragment("if(" + pIfExpr._toFinalCode() + ")");

                this.analyzePassStateBlock(pChildren[pChildren.length - 5], pPass);

                if (pChildren.length > 5) {
                    pPass._addCodeFragment("else");

                    if (pChildren[0].name === "PassStateBlock") {
                        this.analyzePassStateBlock(pChildren[0], pPass);
                    } else {
                        pPass._addCodeFragment(" ");
                        this.analyzePassStateIf(pChildren[0], pPass);
                    }
                }
            };

            Effect.prototype.analyzePassStateSwitch = function (pNode, pPass) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                var sCodeFragment = "switch";
                var pSwitchExpr = this.analyzeExpr(pChildren[pChildren.length - 3]);
                pSwitchExpr._prepareFor(3 /* k_PassFunction */);

                pPass._addCodeFragment("(" + pSwitchExpr._toFinalCode() + ")");

                this.analyzePassCaseBlock(pChildren[0], pPass);
            };

            Effect.prototype.analyzePassCaseBlock = function (pNode, pPass) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                pPass._addCodeFragment("{");

                for (var i = pChildren.length - 2; i >= 1; i--) {
                    if (pChildren[i].name === "CaseState") {
                        this.analyzePassCaseState(pChildren[i], pPass);
                    } else if (pChildren[i].name === "DefaultState") {
                        this.analyzePassDefault(pChildren[i], pPass);
                    }
                }

                pPass._addCodeFragment("}");
            };

            Effect.prototype.analyzePassCaseState = function (pNode, pPass) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                var pCaseStateExpr = this.analyzeExpr(pChildren[pChildren.length - 2]);
                pCaseStateExpr._prepareFor(3 /* k_PassFunction */);

                pPass._addCodeFragment("case " + pCaseStateExpr._toFinalCode() + ": ");

                for (var i = pChildren.length - 4; i >= 0; i--) {
                    if (pChildren[i].name === "PassState") {
                        this.analyzePassStateForShader(pChildren[i], pPass);
                    } else {
                        pPass._addCodeFragment(pChildren[i].value);
                    }
                }
            };

            Effect.prototype.analyzePassDefault = function (pNode, pPass) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                pPass._addCodeFragment("default: ");

                for (var i = pChildren.length - 3; i >= 0; i--) {
                    if (pChildren[i].name === "PassState") {
                        this.analyzePassStateForShader(pChildren[i], pPass);
                    } else {
                        pPass._addCodeFragment(pChildren[i].value);
                    }
                }
            };

            Effect.prototype.analyzeImportDecl = function (pNode, pTechnique) {
                if (typeof pTechnique === "undefined") { pTechnique = null; }
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;
                var sComponentName = this.analyzeComplexName(pChildren[pChildren.length - 2]);
                var iShift = 0;

                if (pChildren[0].name === "ExtOpt") {
                    akra.logger.warn("We don`t suppor ext-commands for import");
                }
                if (pChildren.length !== 2) {
                    iShift = this.analyzeShiftOpt(pChildren[0]);
                }

                if (!akra.isNull(pTechnique)) {
                    //We can import techniques from the same file, but on this stage they don`t have component yet.
                    //So we need special mehanism to add them on more belated stage
                    var sShortedComponentName = sComponentName;
                    if (this._sProvideNameSpace !== "") {
                        sShortedComponentName = sComponentName.replace(this._sProvideNameSpace + ".", "");
                    }

                    var pTechniqueFromSameEffect = this._pTechniqueMap[sComponentName] || this._pTechniqueMap[sShortedComponentName];
                    if (akra.isDefAndNotNull(pTechniqueFromSameEffect)) {
                        pTechnique._addTechniqueFromSameEffect(pTechniqueFromSameEffect, iShift);
                        return;
                    }
                }

                var pComponent = this._pComposer.getComponentByName(sComponentName);
                if (!pComponent) {
                    this._error(2277 /* BAD_IMPORTED_COMPONENT_NOT_EXIST */, { componentName: sComponentName });
                    return;
                }

                this.addComponent(pComponent, iShift, pTechnique);
            };

            Effect.prototype.analyzeProvideDecl = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                if (pChildren.length === 2) {
                    this._sProvideNameSpace = this.analyzeComplexName(pChildren[0]);
                } else {
                    this._error(2303 /* UNSUPPORTED_PROVIDE_AS */);
                    return;
                }
            };

            Effect.prototype.analyzeShiftOpt = function (pNode) {
                this.setAnalyzedNode(pNode);

                var pChildren = pNode.children;

                var iShift = (pChildren[0].value);

                if (pChildren.length === 2) {
                    iShift *= 1;
                } else {
                    iShift *= -1;
                }

                return iShift;
            };

            Effect.prototype.addComponent = function (pComponent, iShift, pTechnique) {
                if (!akra.isNull(pTechnique)) {
                    pTechnique._addComponent(pComponent, iShift);
                } else {
                    if (akra.isNull(this._pImportedGlobalTechniqueList)) {
                        this._pImportedGlobalTechniqueList = [];
                    }

                    this._pImportedGlobalTechniqueList.push({
                        technique: pComponent.getTechnique(),
                        component: pComponent,
                        shift: iShift
                    });
                }

                //TODO: add correct add of compnent, not global
                var pComponentTechnique = pComponent.getTechnique();
                if (this.isAddedTechnique(pComponentTechnique)) {
                    return;
                }

                var pSharedListV = pComponentTechnique._getSharedVariablesForVertex();
                var pSharedListP = pComponentTechnique._getSharedVariablesForPixel();

                for (var i = 0; i < pSharedListV.length; i++) {
                    this.addExternalSharedVariable(pSharedListV[i], 0 /* k_Vertex */);
                }

                for (var i = 0; i < pSharedListP.length; i++) {
                    this.addExternalSharedVariable(pSharedListP[i], 1 /* k_Pixel */);
                }

                if (akra.isNull(this._pAddedTechniqueList)) {
                    this._pAddedTechniqueList = [];
                }

                this._pAddedTechniqueList.push(pTechnique);
            };

            Effect.prototype.isAddedTechnique = function (pTechnique) {
                if (akra.isNull(this._pAddedTechniqueList)) {
                    return false;
                }

                for (var i = 0; i < this._pAddedTechniqueList.length; i++) {
                    if (this._pAddedTechniqueList[i] === pTechnique) {
                        return true;
                    }
                }

                return false;
            };

            /**
            * Проверят возможность использования оператора между двумя типами.
            * Возращает тип получаемый в результате приминения опрератора, или, если применить его невозможно - null.
            *
            * @sOperator {string} Один из операторов: + - * / % += -= *= /= %= = < > <= >= == != =
            * @pLeftType {IAFXVariableTypeInstruction} Тип левой части выражения
            * @pRightType {IAFXVariableTypeInstruction} Тип правой части выражения
            */
            Effect.prototype.checkTwoOperandExprTypes = function (sOperator, pLeftType, pRightType) {
                if (pLeftType._isUnverifiable()) {
                    return pLeftType;
                }

                if (pRightType._isUnverifiable()) {
                    return pRightType;
                }

                var isComplex = pLeftType._isComplex() || pRightType._isComplex();
                var isArray = pLeftType._isNotBaseArray() || pRightType._isNotBaseArray();
                var isSampler = Effect.isSamplerType(pLeftType) || Effect.isSamplerType(pRightType);
                var pBoolType = Effect.getSystemType("bool").getVariableType();

                if (isArray || isSampler) {
                    return null;
                }

                if (sOperator === "%" || sOperator === "%=") {
                    return null;
                }

                if (this.isAssignmentOperator(sOperator)) {
                    if (!pLeftType._isWritable()) {
                        this._error(2267 /* BAD_TYPE_FOR_WRITE */);
                        return null;
                    }

                    if (pLeftType._isStrongEqual(Effect.getSystemType("ptr"))) {
                        this.addPointerForExtract(pLeftType._getParentVarDecl());
                    }

                    if (!pRightType._isReadable()) {
                        this._error(2268 /* BAD_TYPE_FOR_READ */);
                        return null;
                    }

                    if (sOperator !== "=" && !pLeftType._isReadable()) {
                        this._error(2268 /* BAD_TYPE_FOR_READ */);
                    }
                } else {
                    if (!pLeftType._isReadable()) {
                        this._error(2268 /* BAD_TYPE_FOR_READ */);
                        return null;
                    }

                    if (!pRightType._isReadable()) {
                        this._error(2268 /* BAD_TYPE_FOR_READ */);
                        return null;
                    }
                }

                if (isComplex) {
                    if (sOperator === "=" && pLeftType._isEqual(pRightType)) {
                        return pLeftType;
                    } else if (this.isEqualOperator(sOperator) && !pLeftType._containArray() && !pLeftType._containSampler()) {
                        return pBoolType;
                    } else {
                        return null;
                    }
                }

                var pReturnType = null;
                var pLeftBaseType = pLeftType._getBaseType().getVariableType();
                var pRightBaseType = pRightType._getBaseType().getVariableType();

                if (pLeftType._isConst() && this.isAssignmentOperator(sOperator)) {
                    return null;
                }

                if (pLeftType._isEqual(pRightType)) {
                    if (this.isArithmeticalOperator(sOperator)) {
                        if (!Effect.isMatrixType(pLeftType) || (sOperator !== "/" && sOperator !== "/=")) {
                            return pLeftBaseType;
                        } else {
                            return null;
                        }
                    } else if (this.isRelationalOperator(sOperator)) {
                        if (Effect.isScalarType(pLeftType)) {
                            return pBoolType;
                        } else {
                            return null;
                        }
                    } else if (this.isEqualOperator(sOperator)) {
                        return pBoolType;
                    } else if (sOperator === "=") {
                        return pLeftBaseType;
                    } else {
                        return null;
                    }
                }

                if (this.isArithmeticalOperator(sOperator)) {
                    if (Effect.isBoolBasedType(pLeftType) || Effect.isBoolBasedType(pRightType) || Effect.isFloatBasedType(pLeftType) !== Effect.isFloatBasedType(pRightType) || Effect.isIntBasedType(pLeftType) !== Effect.isIntBasedType(pRightType)) {
                        return null;
                    }

                    if (Effect.isScalarType(pLeftType)) {
                        return pRightBaseType;
                    }

                    if (Effect.isScalarType(pRightType)) {
                        return pLeftBaseType;
                    }

                    if (sOperator === "*" || sOperator === "*=") {
                        if (Effect.isMatrixType(pLeftType) && Effect.isVectorType(pRightType) && pLeftType._getLength() === pRightType._getLength()) {
                            return pRightBaseType;
                        } else if (Effect.isMatrixType(pRightType) && Effect.isVectorType(pLeftType) && pLeftType._getLength() === pRightType._getLength()) {
                            return pLeftBaseType;
                        } else {
                            return null;
                        }
                    }
                }

                return null;
            };

            /**
            * Проверят возможность использования оператора к типу данных.
            * Возращает тип получаемый в результате приминения опрератора, или, если применить его невозможно - null.
            *
            * @sOperator {string} Один из операторов: + - ! ++ --
            * @pLeftType {IAFXVariableTypeInstruction} Тип операнда
            */
            Effect.prototype.checkOneOperandExprType = function (sOperator, pType) {
                if (pType._isUnverifiable === undefined) {
                    akra.debug.log(pType);
                }
                if (pType._isUnverifiable()) {
                    return pType;
                }

                var isComplex = pType._isComplex();
                var isArray = pType._isNotBaseArray();
                var isSampler = Effect.isSamplerType(pType);

                if (isComplex || isArray || isSampler) {
                    return null;
                }

                if (!pType._isReadable()) {
                    this._error(2268 /* BAD_TYPE_FOR_READ */);
                    return null;
                }

                if (sOperator === "++" || sOperator === "--") {
                    if (!pType._isWritable()) {
                        this._error(2267 /* BAD_TYPE_FOR_WRITE */);
                        return null;
                    }

                    if (pType._isStrongEqual(Effect.getSystemType("ptr"))) {
                        this.addPointerForExtract(pType._getParentVarDecl());
                    }

                    return pType;
                }

                if (sOperator === "!") {
                    var pBoolType = Effect.getSystemType("bool").getVariableType();

                    if (pType._isEqual(pBoolType)) {
                        return pBoolType;
                    } else {
                        return null;
                    }
                } else {
                    if (Effect.isBoolBasedType(pType)) {
                        return null;
                    } else {
                        return pType._getBaseType().getVariableType();
                    }
                }
                //return null;
            };

            Effect.prototype.isAssignmentOperator = function (sOperator) {
                return sOperator === "+=" || sOperator === "-=" || sOperator === "*=" || sOperator === "/=" || sOperator === "%=" || sOperator === "=";
            };

            Effect.prototype.isArithmeticalOperator = function (sOperator) {
                return sOperator === "+" || sOperator === "+=" || sOperator === "-" || sOperator === "-=" || sOperator === "*" || sOperator === "*=" || sOperator === "/" || sOperator === "/=";
            };

            Effect.prototype.isRelationalOperator = function (sOperator) {
                return sOperator === ">" || sOperator === ">=" || sOperator === "<" || sOperator === "<=";
            };

            Effect.prototype.isEqualOperator = function (sOperator) {
                return sOperator === "==" || sOperator === "!=";
            };

            Effect.prototype.addExtactionStmts = function (pStmt) {
                var pPointerList = this.getPointerForExtractList();

                for (var i = 0; i < pPointerList.length; i++) {
                    this.generateExtractStmtFromPointer(pPointerList[i], pStmt);
                }

                this.clearPointersForExtract();
            };

            Effect.prototype.generateExtractStmtFromPointer = function (pPointer, pParentStmt) {
                var pPointerType = pPointer._getType();
                var pWhatExtracted = pPointerType._getDownPointer();
                var pWhatExtractedType = null;

                var pFunction = this.getCurrentAnalyzedFunction();

                while (!akra.isNull(pWhatExtracted)) {
                    pWhatExtractedType = pWhatExtracted._getType();

                    if (!pWhatExtractedType._isComplex()) {
                        var pSingleExtract = new fx.instructions.ExtractStmtInstruction();
                        pSingleExtract.generateStmtForBaseType(pWhatExtracted, pWhatExtractedType._getPointer(), pWhatExtractedType._getVideoBuffer(), 0, null);

                        this.checkInstruction(pSingleExtract, 0 /* CODE_TARGET_SUPPORT */);

                        pParentStmt._push(pSingleExtract, true);

                        if (!akra.isNull(pFunction)) {
                            pFunction._addUsedFunction(pSingleExtract.getExtractFunction());
                        }
                    } else {
                        this.generateExtractStmtForComplexVar(pWhatExtracted, pParentStmt, pWhatExtractedType._getPointer(), pWhatExtractedType._getVideoBuffer(), 0);
                    }

                    pWhatExtracted = pWhatExtractedType._getDownPointer();
                }

                return pParentStmt;
            };

            Effect.prototype.generateExtractStmtForComplexVar = function (pVarDecl, pParentStmt, pPointer, pBuffer, iPadding) {
                var pVarType = pVarDecl._getType();
                var pFieldNameList = pVarType._getFieldNameList();
                var pField = null;
                var pFieldType = null;
                var pSingleExtract = null;

                var pFunction = this.getCurrentAnalyzedFunction();

                for (var i = 0; i < pFieldNameList.length; i++) {
                    pField = pVarType._getField(pFieldNameList[i]);

                    if (akra.isNull(pField)) {
                        continue;
                    }

                    pFieldType = pField._getType();

                    if (pFieldType._isPointer()) {
                        var pFieldPointer = pFieldType._getMainPointer();
                        pSingleExtract = new fx.instructions.ExtractStmtInstruction();
                        pSingleExtract.generateStmtForBaseType(pFieldPointer, pPointer, pFieldType._getVideoBuffer(), iPadding + pFieldType._getPadding(), null);

                        this.checkInstruction(pSingleExtract, 0 /* CODE_TARGET_SUPPORT */);

                        pParentStmt._push(pSingleExtract, true);
                        this.generateExtractStmtFromPointer(pFieldPointer, pParentStmt);

                        if (!akra.isNull(pFunction)) {
                            pFunction._addUsedFunction(pSingleExtract.getExtractFunction());
                        }
                    } else if (pFieldType._isComplex()) {
                        this.generateExtractStmtForComplexVar(pField, pParentStmt, pPointer, pBuffer, iPadding + pFieldType._getPadding());
                    } else {
                        pSingleExtract = new fx.instructions.ExtractStmtInstruction();
                        pSingleExtract.generateStmtForBaseType(pField, pPointer, pBuffer, iPadding + pFieldType._getPadding(), null);

                        this.checkInstruction(pSingleExtract, 0 /* CODE_TARGET_SUPPORT */);

                        pParentStmt._push(pSingleExtract, true);

                        if (!akra.isNull(pFunction)) {
                            pFunction._addUsedFunction(pSingleExtract.getExtractFunction());
                        }
                    }
                }
            };

            Effect.prototype.getNodeSourceLocation = function (pNode) {
                if (akra.isDef(pNode.line)) {
                    return { line: pNode.line, column: pNode.start };
                } else {
                    return this.getNodeSourceLocation(pNode.children[pNode.children.length - 1]);
                }
            };

            Effect.prototype.checkInstruction = function (pInst, eStage) {
                if (!pInst._check(eStage)) {
                    this._errorFromInstruction(pInst._getLastError());
                }
            };
            Effect.pSystemMacros = null;
            Effect.pSystemTypes = null;
            Effect.pSystemFunctions = null;
            Effect.pSystemVariables = null;
            Effect.pSystemVertexOut = null;
            return Effect;
        })();
        fx.Effect = Effect;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/IAFXInstruction.ts" />
/// <reference path="../../webgl/webgl.ts" />
var akra;
(function (akra) {
    (function (fx) {
        /// <reference path="../../stringUtils/StringDictionary.ts" />
        /// <reference path="../Effect.ts" />
        /// <reference path="DeclInstruction.ts" />
        /// <reference path="IdInstruction.ts" />
        /// <reference path="PostfixPointInstruction.ts" />
        /// <reference path="ExtractExprInstruction.ts" />
        /// <reference path="VariableTypeInstruction.ts" />
        (function (instructions) {
            var StringDictionary = akra.stringUtils.StringDictionary;

            var VariableDeclInstruction = (function (_super) {
                __extends(VariableDeclInstruction, _super);
                /**
                * Represent type var_name [= init_expr]
                * EMPTY_OPERATOR VariableTypeInstruction IdInstruction InitExprInstruction
                */
                function VariableDeclInstruction() {
                    _super.call(this);
                    this._bIsVideoBuffer = null;
                    this._pVideoBufferSampler = null;
                    this._pVideoBufferHeader = null;
                    this._pFullNameExpr = null;
                    this._bDefineByZero = false;
                    this._pSubDeclList = null;
                    this._bShaderOutput = false;
                    this._pAttrOffset = null;
                    this._pAttrExtractionBlock = null;
                    this._pValue = null;
                    this._pDefaultValue = null;
                    this._bLockInitializer = false;
                    this._iNameIndex = 0;
                    this._pInstructionList = [null, null, null];
                    this._eInstructionType = 15 /* k_VariableDeclInstruction */;
                }
                VariableDeclInstruction._getIndex = function (sName) {
                    return VariableDeclInstruction.pShaderVarNamesGlobalDictionary.add(sName);
                };

                VariableDeclInstruction.prototype._hasInitializer = function () {
                    return this._nInstructions === 3 && !akra.isNull(this._getInitializeExpr());
                };

                VariableDeclInstruction.prototype._getInitializeExpr = function () {
                    return this._getInstructions()[2];
                };

                VariableDeclInstruction.prototype._hasConstantInitializer = function () {
                    return this._hasInitializer() && this._getInitializeExpr()._isConst();
                };

                VariableDeclInstruction.prototype._lockInitializer = function () {
                    this._bLockInitializer = true;
                };

                VariableDeclInstruction.prototype._unlockInitializer = function () {
                    this._bLockInitializer = false;
                };

                VariableDeclInstruction.prototype._getDefaultValue = function () {
                    return this._pDefaultValue;
                };

                VariableDeclInstruction.prototype._prepareDefaultValue = function () {
                    this._getInitializeExpr()._evaluate();
                    this._pDefaultValue = this._getInitializeExpr()._getEvalValue();
                };

                VariableDeclInstruction.prototype._getValue = function () {
                    return this._pValue;
                };

                VariableDeclInstruction.prototype._setValue = function (pValue) {
                    this._pValue = pValue;

                    if (this._getType()._isForeign()) {
                        this._setRealName(pValue);
                    }
                };

                VariableDeclInstruction.prototype._getType = function () {
                    return this._pInstructionList[0];
                };

                VariableDeclInstruction.prototype._setType = function (pType) {
                    this._pInstructionList[0] = pType;
                    pType._setParent(this);

                    if (this._nInstructions === 0) {
                        this._nInstructions = 1;
                    }
                };

                VariableDeclInstruction.prototype._setName = function (sName) {
                    var pName = new instructions.IdInstruction();
                    pName._setName(sName);
                    pName._setParent(this);

                    this._pInstructionList[1] = pName;

                    if (this._nInstructions < 2) {
                        this._nInstructions = 2;
                    }
                };

                VariableDeclInstruction.prototype._setRealName = function (sRealName) {
                    this._getNameId()._setRealName(sRealName);
                };

                VariableDeclInstruction.prototype._setVideoBufferRealName = function (sSampler, sHeader) {
                    if (!this._isVideoBuffer()) {
                        return;
                    }

                    this._getVideoBufferSampler()._setRealName(sSampler);
                    this._getVideoBufferHeader()._setRealName(sHeader);
                };

                VariableDeclInstruction.prototype._getName = function () {
                    return this._pInstructionList[1]._getName();
                };

                VariableDeclInstruction.prototype._getRealName = function () {
                    return this._pInstructionList[1]._getRealName();
                };

                VariableDeclInstruction.prototype._getNameId = function () {
                    return this._pInstructionList[1];
                };

                VariableDeclInstruction.prototype._isUniform = function () {
                    return this._getType()._hasUsage("uniform");
                };

                VariableDeclInstruction.prototype._isField = function () {
                    if (akra.isNull(this._getParent())) {
                        return false;
                    }

                    var eParentType = this._getParent()._getInstructionType();
                    if (eParentType === 3 /* k_VariableTypeInstruction */ || eParentType === 5 /* k_ComplexTypeInstruction */ || eParentType === 4 /* k_SystemTypeInstruction */) {
                        return true;
                    }

                    return false;
                };

                VariableDeclInstruction.prototype._isPointer = function () {
                    return this._getType()._isPointer();
                };

                VariableDeclInstruction.prototype._isVideoBuffer = function () {
                    if (akra.isNull(this._bIsVideoBuffer)) {
                        this._bIsVideoBuffer = this._getType()._isStrongEqual(fx.Effect.getSystemType("video_buffer"));
                    }

                    return this._bIsVideoBuffer;
                };

                VariableDeclInstruction.prototype._isSampler = function () {
                    return this._getType()._isSampler();
                };

                VariableDeclInstruction.prototype._getSubVarDecls = function () {
                    return this._getType()._getSubVarDecls();
                };

                VariableDeclInstruction.prototype._isDefinedByZero = function () {
                    return this._bDefineByZero;
                };

                VariableDeclInstruction.prototype._defineByZero = function (isDefine) {
                    this._bDefineByZero = isDefine;
                };

                VariableDeclInstruction.prototype._toFinalCode = function () {
                    if (this._isShaderOutput()) {
                        return "";
                    }
                    var sCode = "";

                    if (this._isVideoBuffer()) {
                        this._getVideoBufferHeader()._lockInitializer();

                        sCode = this._getVideoBufferHeader()._toFinalCode();
                        sCode += ";\n";
                        sCode += this._getVideoBufferSampler()._toFinalCode();

                        this._getVideoBufferHeader()._unlockInitializer();
                    } else {
                        sCode = this._getType()._toFinalCode();
                        sCode += " " + this._getNameId()._toFinalCode();

                        if (this._getType()._isNotBaseArray()) {
                            var iLength = this._getType()._getLength();
                            sCode += "[" + iLength + "]";
                        }

                        if (this._hasInitializer() && !this._isSampler() && !this._isUniform() && !this._bLockInitializer) {
                            sCode += "=" + this._getInitializeExpr()._toFinalCode();
                        }
                    }

                    return sCode;
                };

                VariableDeclInstruction.prototype._markAsVarying = function (bValue) {
                    this._getNameId()._markAsVarying(bValue);
                };

                VariableDeclInstruction.prototype._markAsShaderOutput = function (isShaderOutput) {
                    this._bShaderOutput = isShaderOutput;
                };

                VariableDeclInstruction.prototype._isShaderOutput = function () {
                    return this._bShaderOutput;
                };

                VariableDeclInstruction.prototype._setAttrExtractionBlock = function (pCodeBlock) {
                    this._pAttrExtractionBlock = pCodeBlock;
                };

                VariableDeclInstruction.prototype._getAttrExtractionBlock = function () {
                    return this._pAttrExtractionBlock;
                };

                VariableDeclInstruction.prototype._getNameIndex = function () {
                    return this._iNameIndex || (this._iNameIndex = VariableDeclInstruction.pShaderVarNamesGlobalDictionary.add(this._getRealName()));
                };

                VariableDeclInstruction.prototype._getFullNameExpr = function () {
                    if (!akra.isNull(this._pFullNameExpr)) {
                        return this._pFullNameExpr;
                    }

                    if (!this._isField() || !this._getParent()._getParentVarDecl()._isVisible()) {
                        this._pFullNameExpr = new instructions.IdExprInstruction();
                        this._pFullNameExpr._push(this._getNameId(), false);
                    } else {
                        var pMainVar = this._getType()._getParentContainer();

                        if (akra.isNull(pMainVar)) {
                            return null;
                        }

                        var pMainExpr = pMainVar._getFullNameExpr();
                        if (akra.isNull(pMainExpr)) {
                            return null;
                        }
                        var pFieldExpr = new instructions.IdExprInstruction();
                        pFieldExpr._push(this._getNameId(), false);

                        this._pFullNameExpr = new instructions.PostfixPointInstruction();
                        this._pFullNameExpr._push(pMainExpr, false);
                        this._pFullNameExpr._push(pFieldExpr, false);
                        this._pFullNameExpr._setType(this._getType());
                    }

                    return this._pFullNameExpr;
                };

                VariableDeclInstruction.prototype._getFullName = function () {
                    if (this._isField() && this._getParent()._getParentVarDecl()._isVisible()) {
                        var sName = "";
                        var eParentType = this._getParent()._getInstructionType();

                        if (eParentType === 3 /* k_VariableTypeInstruction */) {
                            sName = this._getParent()._getFullName();
                        }

                        sName += "." + this._getName();

                        return sName;
                    } else {
                        return this._getName();
                    }
                };

                VariableDeclInstruction.prototype._getVideoBufferSampler = function () {
                    if (!this._isVideoBuffer()) {
                        return null;
                    }

                    if (akra.isNull(this._pVideoBufferSampler)) {
                        this._pVideoBufferSampler = new VariableDeclInstruction();
                        var pType = new instructions.VariableTypeInstruction();
                        var pId = new instructions.IdInstruction();

                        pType._pushType(fx.Effect.getSystemType("sampler2D"));
                        pType._addUsage("uniform");
                        pId._setName(this._getName() + "_sampler");

                        this._pVideoBufferSampler._push(pType, true);
                        this._pVideoBufferSampler._push(pId, true);
                    }

                    return this._pVideoBufferSampler;
                };

                VariableDeclInstruction.prototype._getVideoBufferHeader = function () {
                    if (!this._isVideoBuffer()) {
                        return null;
                    }

                    if (akra.isNull(this._pVideoBufferHeader)) {
                        this._pVideoBufferHeader = new VariableDeclInstruction();
                        var pType = new instructions.VariableTypeInstruction();
                        var pId = new instructions.IdInstruction();
                        var pExtarctExpr = new instructions.ExtractExprInstruction();

                        pType._pushType(fx.Effect.getSystemType("video_buffer_header"));
                        pId._setName(this._getName() + "_header");

                        this._pVideoBufferHeader._push(pType, true);
                        this._pVideoBufferHeader._push(pId, true);
                        this._pVideoBufferHeader._push(pExtarctExpr, true);

                        pExtarctExpr.initExtractExpr(pType, null, this, "", null);
                    }

                    return this._pVideoBufferHeader;
                };

                VariableDeclInstruction.prototype._getVideoBufferInitExpr = function () {
                    if (!this._isVideoBuffer()) {
                        return null;
                    }

                    return this._getVideoBufferHeader()._getInitializeExpr();
                };

                VariableDeclInstruction.prototype._setCollapsed = function (bValue) {
                    this._getType()._setCollapsed(bValue);
                };

                VariableDeclInstruction.prototype._isCollapsed = function () {
                    return this._getType()._isCollapsed();
                };

                VariableDeclInstruction.prototype._clone = function (pRelationMap) {
                    return _super.prototype._clone.call(this, pRelationMap);
                };

                VariableDeclInstruction.prototype._blend = function (pVariableDecl, eMode) {
                    var pBlendType = this._getType()._blend(pVariableDecl._getType(), eMode);

                    if (akra.isNull(pBlendType)) {
                        return null;
                    }

                    var pBlendVar = new VariableDeclInstruction();
                    var pId = new instructions.IdInstruction();

                    pId._setName(this._getNameId()._getName());
                    pId._setRealName(this._getNameId()._getRealName());

                    pBlendVar._setSemantic(this._getSemantic());
                    pBlendVar._push(pBlendType, true);
                    pBlendVar._push(pId, true);

                    return pBlendVar;
                };
                VariableDeclInstruction.pShaderVarNamesGlobalDictionary = new StringDictionary();
                return VariableDeclInstruction;
            })(instructions.DeclInstruction);
            instructions.VariableDeclInstruction = VariableDeclInstruction;
        })(fx.instructions || (fx.instructions = {}));
        var instructions = fx.instructions;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../idl/IAFXComposer.ts" />
/// <reference path="../idl/IMap.ts" />
var akra;
(function (akra) {
    /// <reference path="../util/ObjectArray.ts" />
    (function (fx) {
        var ObjectArray = akra.util.ObjectArray;

        /** @const */
        var INIT_SLOT_SIZE = 32;

        //TODO: CHECK SAMPLER TYPE
        var SamplerBlender = (function () {
            function SamplerBlender() {
                this._pSlotList = null;
                this._nActiveSlots = 0;
                this._pIdToSlotMap = null;
                this._pIdList = null;
                this._pSlotList = new Array(INIT_SLOT_SIZE);

                for (var i = 0; i < this._pSlotList.length; i++) {
                    this._pSlotList[i] = new ObjectArray();
                }

                this._nActiveSlots = 1;

                this._pIdToSlotMap = { 0: 0 };
                this._pIdList = new Array(INIT_SLOT_SIZE);
            }
            SamplerBlender.prototype.getSlots = function () {
                return this._pSlotList;
            };

            SamplerBlender.prototype.getTotalActiveSlots = function () {
                return this._nActiveSlots;
            };

            SamplerBlender.prototype.getSamplersBySlot = function (iSlot) {
                return this.getSlots()[iSlot];
            };

            SamplerBlender.prototype.clear = function () {
                for (var i = 0; i < this._nActiveSlots; i++) {
                    this._pSlotList[i].clear(false);
                }

                for (var i = 0; i < this._nActiveSlots - 1; i++) {
                    this._pIdToSlotMap[this._pIdList[i]] = -1;
                }

                this._nActiveSlots = 1;
            };

            SamplerBlender.prototype.clearSamplerNames = function () {
                for (var i = 0; i < this._nActiveSlots; i++) {
                    for (var j = 0; j < this._pSlotList[i].getLength(); j++) {
                        var pSampler = this._pSlotList[i].value(j);
                        pSampler._setRealName(pSampler._getSemantic() || pSampler._getName());
                        pSampler._defineByZero(false);
                    }
                }
            };

            SamplerBlender.prototype.addTextureSlot = function (id) {
                if (this._pIdToSlotMap[id] > 0) {
                    return;
                }

                // if(this._pSlotList.length === this._nActiveSlots){
                // 	this._pSlotList.push(new util.ObjectArray());
                // }
                this._pIdToSlotMap[id] = this._nActiveSlots;
                this._pIdList[this._nActiveSlots - 1] = id;
                this._nActiveSlots++;
            };

            SamplerBlender.prototype.addObjectToSlotById = function (pObject, id) {
                this._pSlotList[this._pIdToSlotMap[id]].push(pObject);
            };

            SamplerBlender.prototype.addObjectToSlotIdAuto = function (pObject, id) {
                this.addTextureSlot(id);
                this.addObjectToSlotById(pObject, id);
            };

            SamplerBlender.prototype.getHash = function () {
                var sHash = "";

                for (var i = 0; i < this._nActiveSlots; i++) {
                    var pBlend = this._pSlotList[i];

                    if (pBlend.getLength() > 0) {
                        if (i === 0) {
                            sHash += "Z";
                        }

                        for (var j = 0; j < pBlend.getLength(); j++) {
                            sHash += pBlend.value(j)._getInstructionID().toString() + ".";
                        }

                        sHash += ".";
                    }
                }

                return sHash;
            };

            SamplerBlender.ZERO_SLOT = 0;
            return SamplerBlender;
        })();
        fx.SamplerBlender = SamplerBlender;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../idl/IAFXPassInputBlend.ts" />
/// <reference path="../idl/IAFXVariableContainer.ts" />
/// <reference path="../idl/IMap.ts" />
var akra;
(function (akra) {
    /// <reference path="../math/Vec4.ts" />
    /// <reference path="../render/render.ts" />
    (function (fx) {
        var PassInputBlend = (function () {
            function PassInputBlend(pCreator) {
                this.guid = akra.guid();
                this._pCreator = null;
                // private _bNeedToCalcBlend: boolean = true;
                // private _bNeedToCalcShader: boolean = true;
                this._iLastPassBlendId = 0;
                this._iLastShaderId = 0;
                //private _pMaterialContainer: IMaterialConatiner = null;
                //{
                //	"DIFFUSE": new Vec4(),
                //	"AMBIENT": new Vec4(),
                //	"SPECULAR": new Vec4(),
                //	"EMISSIVE": new Vec4(),
                //	"SHININESS": 1.,
                //	"TRANSPARENCY": 1.
                //};
                //need for accelerate setSurfaceMaterial
                this._nLastSufraceMaterialTextureUpdates = 0;
                this._nLastSamplerUpdates = -1;
                this._pLastSurfaceMaterial = null;
                this._isFirstSetSurfaceNaterial = true;
                this._pMaterialNameIndices = {
                    diffuse: 0,
                    ambient: 0,
                    specular: 0,
                    emissive: 0,
                    normal: 0,
                    material: 0,
                    textures: new Array(16)
                };
                this._pStatesInfo = null;
                this.samplers = null;
                this.samplerArrays = null;
                this.samplerArrayLength = null;
                this.uniforms = null;
                this.foreigns = null;
                this.textures = null;
                this.samplerKeys = null;
                this.samplerArrayKeys = null;
                this.uniformKeys = null;
                this.foreignKeys = null;
                this.textureKeys = null;
                this.renderStates = null;
                this._pCreator = pCreator;

                this._pStatesInfo = {
                    uniformKey: 0,
                    foreignKey: 0,
                    samplerKey: 0,
                    renderStatesKey: 0
                };

                this.init();
            }
            PassInputBlend.prototype.getStatesInfo = function () {
                return this._pStatesInfo;
            };

            PassInputBlend.prototype.hasUniform = function (sName) {
                return this._pCreator.getUniforms().hasVariableWithRealName(sName);
            };

            PassInputBlend.prototype.hasTexture = function (sName) {
                return this._pCreator.getTextures().hasVariableWithRealName(sName);
            };

            PassInputBlend.prototype.hasForeign = function (sName) {
                return this._pCreator.getForeigns().hasVariableWithRealName(sName);
            };

            PassInputBlend.prototype.setUniform = function (sName, pValue) {
                var iIndex = this._pCreator.getUniforms().getIndexByRealName(sName);

                if (iIndex === 0) {
                    return;
                }

                var pInfo = this._pCreator.getUniforms().getVarInfoByIndex(iIndex);

                if (pInfo.type === 18 /* k_Sampler2D */ || pInfo.type === 19 /* k_SamplerCUBE */) {
                    if (pInfo.isArray) {
                        if (akra.isNull(pValue)) {
                            this.samplerArrayLength[iIndex] = 0;
                        } else {
                            for (var i = 0; i < pValue.length; i++) {
                                this.copySamplerState(pValue[i], this.samplerArrays[iIndex][i]);
                            }

                            this.samplerArrayLength[iIndex] = pValue.length;
                        }
                    } else {
                        this.copySamplerState(pValue, this.samplers[iIndex]);
                    }

                    return;
                }

                //Check type
                this._pStatesInfo.uniformKey++;
                this.uniforms[iIndex] = pValue;
            };

            PassInputBlend.prototype.setTexture = function (sName, pValue) {
                var iIndex = this._pCreator.getTextures().getIndexByRealName(sName);

                if (iIndex === 0) {
                    return;
                }

                //Check type
                if (this.textures[iIndex] !== pValue) {
                    this._pStatesInfo.samplerKey++;
                }

                this.textures[iIndex] = pValue;
            };

            PassInputBlend.prototype.setForeign = function (sName, pValue) {
                var iIndex = this._pCreator.getForeigns().getIndexByRealName(sName);

                if (iIndex === 0) {
                    return;
                }

                //Check type
                var pOldValue = this.foreigns[iIndex];

                if (pOldValue !== pValue) {
                    // this._bNeedToCalcBlend = true;
                    // this._bNeedToCalcShader = true;
                    this._pStatesInfo.foreignKey++;
                }

                this.foreigns[iIndex] = pValue;
            };

            PassInputBlend.prototype.setSampler = function (sName, pValue) {
                var iIndex = this._pCreator.getUniforms().getIndexByRealName(sName);

                if (iIndex === 0) {
                    return;
                }

                var eType = this._pCreator.getUniforms().getTypeByIndex(iIndex);

                if (eType !== 18 /* k_Sampler2D */ && eType !== 19 /* k_SamplerCUBE */) {
                    return;
                }

                this.copySamplerState(pValue, this.samplers[iIndex]);
            };

            PassInputBlend.prototype.setSamplerArray = function (sName, pValue) {
                var iIndex = this._pCreator.getUniforms().getIndexByRealName(sName);

                if (iIndex === 0) {
                    return;
                }

                var eType = this._pCreator.getUniforms().getTypeByIndex(iIndex);

                if (eType !== 18 /* k_Sampler2D */ && eType !== 19 /* k_SamplerCUBE */) {
                    return;
                }

                if (!akra.isNull(pValue)) {
                    for (var i = 0; i < pValue.length; i++) {
                        this.copySamplerState(pValue[i], this.samplerArrays[iIndex][i]);
                    }

                    this.samplerArrayLength[iIndex] = pValue.length;
                } else {
                    this.samplerArrayLength[iIndex] = 0;
                }
            };

            PassInputBlend.prototype.setSamplerTexture = function (sName, pTexture) {
                var iIndex = this._pCreator.getUniforms().getIndexByRealName(sName);

                if (iIndex === 0) {
                    return;
                }

                var eType = this._pCreator.getUniforms().getTypeByIndex(iIndex);

                if (eType !== 18 /* k_Sampler2D */ && eType !== 19 /* k_SamplerCUBE */) {
                    return;
                }
                var pState = this.samplers[iIndex];

                if (akra.isString(pTexture)) {
                    if (!akra.isNull(pState.texture) || pState.textureName !== pTexture) {
                        this._pStatesInfo.samplerKey++;
                    }

                    pState.textureName = pTexture;
                    pState.texture = null;
                } else {
                    if (pState.texture !== pTexture) {
                        this._pStatesInfo.samplerKey++;
                    }

                    pState.texture = pTexture;
                }
            };

            PassInputBlend.prototype._setSamplerTextureObject = function (sName, pTexture) {
                var iIndex = this._pCreator.getUniforms().getIndexByRealName(sName);

                if (iIndex === 0) {
                    return;
                }

                var eType = this._pCreator.getUniforms().getTypeByIndex(iIndex);

                if (eType !== 18 /* k_Sampler2D */ && eType !== 19 /* k_SamplerCUBE */) {
                    return;
                }

                var pState = this.samplers[iIndex];

                if (pState.texture !== pTexture) {
                    this._pStatesInfo.samplerKey++;
                }

                pState.texture = pTexture;
            };

            PassInputBlend.prototype.setStruct = function (sName, pValue) {
                this.setUniform(sName, pValue);
            };

            PassInputBlend.prototype.setSurfaceMaterial = function (pSurfaceMaterial) {
                if (akra.isNull(pSurfaceMaterial)) {
                    return;
                }

                if (this._isFirstSetSurfaceNaterial) {
                    for (var i = 0; i < 16; i++) {
                        if (this.hasTexture("TEXTURE" + i.toString())) {
                            this._pMaterialNameIndices.textures[i] = this._pCreator.getTextures().getIndexByRealName("TEXTURE" + i.toString());
                        } else {
                            this._pMaterialNameIndices.textures[i] = 0;
                        }
                    }

                    this._pMaterialNameIndices.material = this.hasUniform("MATERIAL") ? this._pCreator.getUniforms().getIndexByRealName("MATERIAL") : 0;

                    this._pMaterialNameIndices.diffuse = this.hasUniform("S_DIFFUSE") ? this._pCreator.getUniforms().getIndexByRealName("S_DIFFUSE") : 0;
                    this._pMaterialNameIndices.ambient = this.hasUniform("S_AMBIENT") ? this._pCreator.getUniforms().getIndexByRealName("S_AMBIENT") : 0;
                    this._pMaterialNameIndices.specular = this.hasUniform("S_SPECULAR") ? this._pCreator.getUniforms().getIndexByRealName("S_SPECULAR") : 0;
                    this._pMaterialNameIndices.emissive = this.hasUniform("S_EMISSIVE") ? this._pCreator.getUniforms().getIndexByRealName("S_EMISSIVE") : 0;
                    this._pMaterialNameIndices.normal = this.hasUniform("S_NORMAL") ? this._pCreator.getUniforms().getIndexByRealName("S_NORMAL") : 0;
                    this._pMaterialNameIndices.shininess = this.hasUniform("S_SHININESS") ? this._pCreator.getUniforms().getIndexByRealName("S_SHININESS") : 0;

                    this._isFirstSetSurfaceNaterial = false;
                }

                if (this._nLastSamplerUpdates !== this._pStatesInfo.samplerKey || this._pLastSurfaceMaterial !== pSurfaceMaterial || this._nLastSufraceMaterialTextureUpdates !== pSurfaceMaterial.getTotalUpdatesOfTextures()) {
                    var iTotalTextures = pSurfaceMaterial.getTotalTextures();
                    for (var i = 0; i < 16; i++) {
                        if (this._pMaterialNameIndices.textures[i] > 0) {
                            this.textures[this._pMaterialNameIndices.textures[i]] = pSurfaceMaterial.texture(i) || null;
                        }
                    }
                }

                if (this._pMaterialNameIndices.material > 0) {
                    var pMaterial = pSurfaceMaterial.getMaterial();
                    var pMatContainer = pMaterial._getMatContainer();

                    pMatContainer.DIFFUSE.set(pMaterial.diffuse.r, pMaterial.diffuse.g, pMaterial.diffuse.b, pMaterial.diffuse.a);
                    pMatContainer.AMBIENT.set(pMaterial.ambient.r, pMaterial.ambient.g, pMaterial.ambient.b, pMaterial.ambient.a);
                    pMatContainer.SPECULAR.set(pMaterial.specular.r, pMaterial.specular.g, pMaterial.specular.b, pMaterial.specular.a);
                    pMatContainer.EMISSIVE.set(pMaterial.emissive.r, pMaterial.emissive.g, pMaterial.emissive.b, pMaterial.emissive.a);
                    pMatContainer.SHININESS = pMaterial.shininess;
                    pMatContainer.TRANSPARENCY = pMaterial.transparency;

                    this.uniforms[this._pMaterialNameIndices.material] = pMatContainer;
                }

                if (this._nLastSamplerUpdates !== this._pStatesInfo.samplerKey) {
                    this._setSamplerTextureObjectByIndex(this._pMaterialNameIndices.diffuse, pSurfaceMaterial.texture(0 /* DIFFUSE */) || null);
                    this._setSamplerTextureObjectByIndex(this._pMaterialNameIndices.ambient, pSurfaceMaterial.texture(1 /* AMBIENT */) || null);
                    this._setSamplerTextureObjectByIndex(this._pMaterialNameIndices.specular, pSurfaceMaterial.texture(2 /* SPECULAR */) || null);
                    this._setSamplerTextureObjectByIndex(this._pMaterialNameIndices.emissive, pSurfaceMaterial.texture(3 /* EMISSIVE */) || null);
                    this._setSamplerTextureObjectByIndex(this._pMaterialNameIndices.shininess, pSurfaceMaterial.texture(5 /* SHININESS */) || null);
                    this._setSamplerTextureObjectByIndex(this._pMaterialNameIndices.normal, pSurfaceMaterial.texture(4 /* NORMAL */) || null);
                }

                this._pLastSurfaceMaterial = pSurfaceMaterial;
                this._nLastSufraceMaterialTextureUpdates = pSurfaceMaterial.getTotalUpdatesOfTextures();
                this._nLastSamplerUpdates = this._pStatesInfo.samplerKey;
            };

            PassInputBlend.prototype.setRenderState = function (eState, eValue) {
                if (eState === 19 /* SRCBLEND */) {
                    this.setRenderState(10 /* SRCBLENDCOLOR */, eValue);
                    this.setRenderState(12 /* SRCBLENDALPHA */, eValue);
                } else if (eState === 20 /* DESTBLEND */) {
                    this.setRenderState(11 /* DESTBLENDCOLOR */, eValue);
                    this.setRenderState(13 /* DESTBLENDALPHA */, eValue);
                } else {
                    if (this.renderStates[eState] !== eValue) {
                        this._pStatesInfo.renderStatesKey++;
                    }

                    this.renderStates[eState] = eValue;
                }
            };

            PassInputBlend.prototype._getForeignVarNameIndex = function (sName) {
                return this._pCreator.getForeigns().getIndexByRealName(sName);
            };

            PassInputBlend.prototype._getForeignVarNameByIndex = function (iNameIndex) {
                return this._pCreator.getForeigns().getVarInfoByIndex(iNameIndex).realName;
            };

            PassInputBlend.prototype._getUniformVarNameIndex = function (sName) {
                return this._pCreator.getUniforms().getIndexByRealName(sName);
            };

            PassInputBlend.prototype._getUniformVar = function (iNameIndex) {
                return this._pCreator.getUniforms().getVarByIndex(iNameIndex);
            };

            PassInputBlend.prototype._getUniformVarNameByIndex = function (iNameIndex) {
                return this._pCreator.getUniforms().getVarInfoByIndex(iNameIndex).realName;
            };

            PassInputBlend.prototype._getUniformLength = function (iNameIndex) {
                return this._pCreator.getUniforms().getVarByIndex(iNameIndex)._getType()._getLength();
            };

            PassInputBlend.prototype._getUniformType = function (iNameIndex) {
                return this._pCreator.getUniforms().getTypeByIndex(iNameIndex);
            };

            PassInputBlend.prototype._getSamplerState = function (iNameIndex) {
                return this.samplers[iNameIndex];
            };

            PassInputBlend.prototype._getSamplerTexture = function (iNameIndex) {
                return this._getTextureForSamplerState(this._getSamplerState(iNameIndex));
            };

            PassInputBlend.prototype._getTextureForSamplerState = function (pSamplerState) {
                var pTexture = null;

                if (!akra.isNull(pSamplerState.texture)) {
                    pTexture = pSamplerState.texture;
                } else if (pSamplerState.textureName !== "") {
                    if (this.hasTexture(pSamplerState.textureName)) {
                        pTexture = this.textures[this._pCreator.getTextures().getIndexByRealName(pSamplerState.textureName)];
                    }
                }

                return pTexture;
            };

            PassInputBlend.prototype._release = function () {
                for (var i = 0; i < this.uniformKeys.length; i++) {
                    var pInfo = this._pCreator.getUniforms().getVarInfoByIndex(this.uniformKeys[i]);
                    var pDefaultValue = pInfo.variable._getDefaultValue();

                    this.uniforms[this.uniformKeys[i]] = pDefaultValue;
                }

                for (var i = 0; i < this.foreignKeys.length; i++) {
                    var pInfo = this._pCreator.getForeigns().getVarInfoByIndex(this.foreignKeys[i]);
                    var pDefaultValue = pInfo.variable._getDefaultValue();

                    if (!akra.isDefAndNotNull(pDefaultValue)) {
                        pDefaultValue = fx.VariableContainer.getVariableDefaultValue(pInfo.variable);
                    }

                    this.foreigns[this.foreignKeys[i]] = pDefaultValue;
                }

                for (var i = 0; i < this.textureKeys.length; i++) {
                    this.textures[this.textureKeys[i]] = null;
                }

                for (var i = 0; i < this.samplerKeys.length; i++) {
                    var pInfo = this._pCreator.getUniforms().getVarInfoByIndex(this.samplerKeys[i]);
                    var pDefaultState = pInfo.variable._getDefaultValue();
                    var pSamplerState = this.samplers[this.samplerKeys[i]];

                    this.clearSamplerState(pSamplerState);

                    if (!akra.isNull(pDefaultState)) {
                        pSamplerState.textureName = pDefaultState.textureName;
                        pSamplerState.wrap_s = pDefaultState.wrap_s || pSamplerState.wrap_s;
                        pSamplerState.wrap_t = pDefaultState.wrap_t || pSamplerState.wrap_t;
                        pSamplerState.mag_filter = pDefaultState.mag_filter || pSamplerState.mag_filter;
                        pSamplerState.min_filter = pDefaultState.min_filter || pSamplerState.min_filter;
                    }
                }

                for (var i = 0; i < this.samplerArrayKeys.length; i++) {
                    var pInfo = this._pCreator.getUniforms().getVarInfoByIndex(this.samplerArrayKeys[i]);
                    var pDefaultStateList = pInfo.variable._getDefaultValue();
                    var pStateList = this.samplerArrays[this.samplerArrayKeys[i]];

                    for (var j = 0; j < pStateList.length; j++) {
                        this.clearSamplerState(pStateList[j]);

                        if (!akra.isNull(pDefaultStateList) && i < pDefaultStateList.length) {
                            pStateList[j].textureName = pDefaultStateList[j].textureName;
                            pStateList[j].wrap_s = pDefaultStateList[j].wrap_s || pStateList[j].wrap_s;
                            pStateList[j].wrap_t = pDefaultStateList[j].wrap_t || pStateList[j].wrap_t;
                            pStateList[j].mag_filter = pDefaultStateList[j].mag_filter || pStateList[j].mag_filter;
                            pStateList[j].min_filter = pDefaultStateList[j].min_filter || pStateList[j].min_filter;
                        }
                    }

                    this.samplerArrayLength[this.samplerArrayKeys[i]] = !akra.isNull(pDefaultStateList) ? pDefaultStateList.length : 0;
                }

                akra.render.clearRenderStateMap(this.renderStates);

                this._pStatesInfo.uniformKey = 0;
                this._pStatesInfo.foreignKey = 0;
                this._pStatesInfo.samplerKey = 0;
                this._pStatesInfo.renderStatesKey = 0;

                this._nLastSufraceMaterialTextureUpdates = 0;
                this._nLastSamplerUpdates = -1;
                this._pLastSurfaceMaterial = null;

                this._pCreator.releasePassInput(this);
                // this._bNeedToCalcShader = true;
                // this._bNeedToCalcBlend = true;
            };

            PassInputBlend.prototype._isFromSameBlend = function (pInput) {
                return (pInput._getBlend() === this._getBlend());
            };

            PassInputBlend.prototype._getBlend = function () {
                return this._pCreator;
            };

            PassInputBlend.prototype._copyFrom = function (pInput) {
                this._copyUniformsFromInput(pInput);
                this._copyForeignsFromInput(pInput);
                this._copySamplersFromInput(pInput);
                this._copyRenderStatesFromInput(pInput);
            };

            PassInputBlend.prototype._copyUniformsFromInput = function (pInput) {
                for (var i = 0; i < pInput.uniformKeys.length; i++) {
                    var iIndex = pInput.uniformKeys[i];

                    if (akra.isDef(this.uniforms[iIndex])) {
                        this.uniforms[iIndex] = pInput.uniforms[iIndex];
                    }
                }
            };

            PassInputBlend.prototype._copySamplersFromInput = function (pInput) {
                for (var i = 0; i < pInput.textureKeys.length; i++) {
                    var iIndex = pInput.textureKeys[i];

                    if (akra.isDef(this.textures[iIndex])) {
                        this.textures[iIndex] = pInput.textures[iIndex];
                    }
                }

                for (var i = 0; i < pInput.samplerKeys.length; i++) {
                    var iIndex = pInput.samplerKeys[i];

                    if (akra.isDef(this.samplers[iIndex])) {
                        this.copySamplerState(pInput.samplers[iIndex], this.samplers[iIndex]);
                    }
                }

                for (var i = 0; i < pInput.samplerArrayKeys.length; i++) {
                    var iIndex = pInput.samplerArrayKeys[i];

                    if (akra.isDef(this.samplerArrays[iIndex])) {
                        var pFrom = pInput.samplerArrays[iIndex];
                        var pTo = this.samplerArrays[iIndex];
                        var iLength = pInput.samplerArrayLength[iIndex];

                        for (var j = 0; j < iLength; j++) {
                            this.copySamplerState(pFrom[j], pTo[j]);
                        }

                        this.samplerArrayLength[iIndex] = iLength;
                    }
                }
            };

            PassInputBlend.prototype._copyForeignsFromInput = function (pInput) {
                for (var i = 0; i < pInput.foreignKeys.length; i++) {
                    var iIndex = pInput.foreignKeys[i];

                    if (akra.isDef(this.foreigns[iIndex])) {
                        this.foreigns[iIndex] = pInput.foreigns[iIndex];
                    }
                }
            };

            PassInputBlend.prototype._copyRenderStatesFromInput = function (pInput) {
                akra.render.copyRenderStateMap(pInput.renderStates, this.renderStates);
            };

            PassInputBlend.prototype._getLastPassBlendId = function () {
                return this._iLastPassBlendId;
            };

            PassInputBlend.prototype._getLastShaderId = function () {
                return this._iLastShaderId;
            };

            PassInputBlend.prototype._setPassBlendId = function (id) {
                this._iLastPassBlendId = id;
            };

            PassInputBlend.prototype._setShaderId = function (id) {
                this._iLastShaderId = id;
            };

            PassInputBlend.prototype.init = function () {
                this.samplers = {};
                this.samplerArrays = {};
                this.samplerArrayLength = {};

                this.uniforms = {};
                this.foreigns = {};
                this.textures = {};

                this.renderStates = akra.render.createRenderStateMap();

                var pUniformKeys = this._pCreator.getUniforms().getIndices();
                var pForeignKeys = this._pCreator.getForeigns().getIndices();
                var pTextureKeys = this._pCreator.getTextures().getIndices();

                var eType = 0;
                var sName = "";
                var iIndex = 0;

                for (var i = 0; i < pUniformKeys.length; i++) {
                    var iIndex = pUniformKeys[i];
                    var pInfo = this._pCreator.getUniforms().getVarInfoByIndex(iIndex);
                    var pDefaultValue = pInfo.variable._getDefaultValue();

                    if (pInfo.type === 18 /* k_Sampler2D */ || pInfo.type === 19 /* k_SamplerCUBE */) {
                        var hasDefaultValue = !akra.isNull(pDefaultValue);

                        if (pInfo.isArray) {
                            if (hasDefaultValue) {
                                this.samplerArrays[iIndex] = new Array(pDefaultValue.length);
                                this.samplerArrayLength[iIndex] = this.samplerArrays[iIndex].length;
                            } else {
                                this.samplerArrays[iIndex] = new Array(16);
                                this.samplerArrayLength[iIndex] = 0;
                            }

                            for (var j = 0; j < this.samplerArrays[iIndex].length; j++) {
                                var pNewState = akra.render.createSamplerState();

                                if (hasDefaultValue) {
                                    var pDefaultState = pDefaultValue[j];
                                    pNewState.textureName = pDefaultState.textureName;
                                    pNewState.wrap_s = pDefaultState.wrap_s || pNewState.wrap_s;
                                    pNewState.wrap_t = pDefaultState.wrap_t || pNewState.wrap_t;
                                    pNewState.mag_filter = pDefaultState.mag_filter || pNewState.mag_filter;
                                    pNewState.min_filter = pDefaultState.min_filter || pNewState.min_filter;
                                }

                                this.samplerArrays[iIndex][j] = pNewState;
                            }
                        } else {
                            var pNewState = akra.render.createSamplerState();

                            if (hasDefaultValue) {
                                var pDefaultState = pDefaultValue;
                                pNewState.textureName = pDefaultState.textureName;
                                pNewState.wrap_s = pDefaultState.wrap_s || pNewState.wrap_s;
                                pNewState.wrap_t = pDefaultState.wrap_t || pNewState.wrap_t;
                                pNewState.mag_filter = pDefaultState.mag_filter || pNewState.mag_filter;
                                pNewState.min_filter = pDefaultState.min_filter || pNewState.min_filter;
                            }

                            this.samplers[iIndex] = pNewState;
                        }
                    } else {
                        this.uniforms[iIndex] = pDefaultValue;
                    }
                }

                for (var i = 0; i < pForeignKeys.length; i++) {
                    var iIndex = pForeignKeys[i];
                    var pInfo = this._pCreator.getForeigns().getVarInfoByIndex(iIndex);
                    var pDefaultValue = pInfo.variable._getDefaultValue();

                    if (!akra.isDefAndNotNull(pDefaultValue)) {
                        pDefaultValue = fx.VariableContainer.getVariableDefaultValue(pInfo.variable);
                    }

                    this.foreigns[iIndex] = pDefaultValue;
                }

                for (var i = 0; i < pTextureKeys.length; i++) {
                    var iIndex = pTextureKeys[i];
                    this.textures[iIndex] = null;
                }

                this.samplerKeys = Object.keys(this.samplers);
                for (var i = 0; i < this.samplerKeys.length; i++) {
                    this.samplerKeys[i] = +this.samplerKeys[i];
                }

                this.samplerArrayKeys = Object.keys(this.samplerArrays);
                for (var i = 0; i < this.samplerArrayKeys.length; i++) {
                    this.samplerArrayKeys[i] = +this.samplerArrayKeys[i];
                }

                this.uniformKeys = Object.keys(this.uniforms);
                for (var i = 0; i < this.uniformKeys.length; i++) {
                    this.uniformKeys[i] = +this.uniformKeys[i];
                }

                this.foreignKeys = Object.keys(this.foreigns);
                for (var i = 0; i < this.foreignKeys.length; i++) {
                    this.foreignKeys[i] = +this.foreignKeys[i];
                }

                this.textureKeys = Object.keys(this.textures);
                for (var i = 0; i < this.textureKeys.length; i++) {
                    this.textureKeys[i] = +this.textureKeys[i];
                }
            };

            PassInputBlend.prototype.isVarArray = function (pVar) {
                return pVar._getType()._isNotBaseArray();
            };

            PassInputBlend.prototype.clearSamplerState = function (pState) {
                pState.textureName = "";
                pState.texture = null;
                pState.wrap_s = 0 /* UNDEF */;
                pState.wrap_t = 0 /* UNDEF */;
                pState.mag_filter = 0 /* UNDEF */;
                pState.min_filter = 0 /* UNDEF */;
                /*pState.wrap_s = ETextureWrapModes.CLAMP_TO_EDGE;
                pState.wrap_t = ETextureWrapModes.CLAMP_TO_EDGE;
                pState.mag_filter = ETextureFilters.LINEAR;
                pState.min_filter = ETextureFilters.LINEAR;*/
            };

            PassInputBlend.prototype._setSamplerTextureObjectByIndex = function (iNameIndex, pTexture) {
                if (iNameIndex === 0) {
                    return;
                }

                var pState = this.samplers[iNameIndex];
                if (pState.texture !== pTexture) {
                    this._pStatesInfo.samplerKey++;
                }

                pState.texture = pTexture;
            };

            PassInputBlend.prototype.copySamplerState = function (pFrom, pTo) {
                if (pTo.textureName !== pFrom.textureName || pTo.texture !== pFrom.texture) {
                    this._pStatesInfo.samplerKey++;
                }

                pTo.textureName = pFrom.textureName;
                pTo.texture = pFrom.texture;

                pTo.wrap_s = pFrom.wrap_s;
                pTo.wrap_t = pFrom.wrap_t;

                pTo.mag_filter = pFrom.mag_filter;
                pTo.min_filter = pFrom.min_filter;
            };
            return PassInputBlend;
        })();
        fx.PassInputBlend = PassInputBlend;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (sort) {
        function minMax(a, b) {
            return a - b;
        }
        sort.minMax = minMax;
        ;
        function maxMin(a, b) {
            return b - a;
        }
        sort.maxMin = maxMin;
        ;

        /**
        * Search In Sort Array
        */
        function binary(array, value) {
            if (value < array[0] || value > array[array.length - 1]) {
                return -1;
            }

            if (value === array[0]) {
                return 0;
            }

            if (value === array[array.length - 1]) {
                return array.length - 1;
            }

            var p = 0;
            var q = array.length - 1;

            while (p < q) {
                var s = (p + q) >> 1;

                if (value === array[s]) {
                    return s;
                } else if (value > array[s]) {
                    p = s + 1;
                } else {
                    q = s;
                }
            }

            return -1;
        }
        sort.binary = binary;
    })(akra.sort || (akra.sort = {}));
    var sort = akra.sort;
})(akra || (akra = {}));
/// <reference path="../idl/IAFXVariableContainer.ts" />
/// <reference path="../idl/IAFXInstruction.ts" />
/// <reference path="../idl/IMap.ts" />
var akra;
(function (akra) {
    /// <reference path="../sort/sort.ts" />
    /// <reference path="instructions/VariableInstruction.ts" />
    (function (fx) {
        var VariableContainer = (function () {
            function VariableContainer() {
                this._pNameToIndexMap = null;
                this._pRealNameToIndexMap = null;
                this._pIndexList = null;
                this._pVariableInfoMap = null;
                this._bLock = false;
                this._pNameToIndexMap = {};
                this._pRealNameToIndexMap = {};
                this._pVariableInfoMap = {};
            }
            VariableContainer.prototype.getIndices = function () {
                return this._pIndexList;
            };

            VariableContainer.prototype.add = function (pVar) {
                if (this._bLock) {
                    return;
                }

                var iIndex = pVar._getNameIndex();
                var sName = pVar._getName();
                var sRealName = pVar._getRealName();

                this._pNameToIndexMap[sName] = iIndex;
                this._pRealNameToIndexMap[sRealName] = iIndex;
                this._pVariableInfoMap[iIndex] = {
                    variable: pVar,
                    type: VariableContainer.getVariableType(pVar),
                    name: sName,
                    realName: sRealName,
                    isArray: pVar._getType()._isNotBaseArray()
                };
            };

            VariableContainer.prototype.addSystemEntry = function (sName, eType) {
                var iIndex = fx.instructions.VariableDeclInstruction.pShaderVarNamesGlobalDictionary.add(sName);

                this._pNameToIndexMap[sName] = iIndex;
                this._pRealNameToIndexMap[sName] = iIndex;
                this._pVariableInfoMap[iIndex] = {
                    variable: null,
                    type: eType,
                    name: sName,
                    realName: sName,
                    isArray: false
                };
            };

            VariableContainer.prototype.finalize = function () {
                var pTmpKeys = Object.keys(this._pVariableInfoMap);
                this._pIndexList = new Array(pTmpKeys.length);

                for (var i = 0; i < pTmpKeys.length; i++) {
                    this._pIndexList[i] = +pTmpKeys[i];
                }
                this._pIndexList.sort(akra.sort.minMax);
                this._bLock = true;
            };

            VariableContainer.prototype.getVarInfoByIndex = function (iIndex) {
                return this._pVariableInfoMap[iIndex];
            };

            VariableContainer.prototype.getVarByIndex = function (iIndex) {
                return this.getVarInfoByIndex(iIndex).variable;
            };

            VariableContainer.prototype.getTypeByIndex = function (iIndex) {
                return this.getVarInfoByIndex(iIndex).type;
            };

            VariableContainer.prototype.isArrayVariable = function (iIndex) {
                return this.getVarInfoByIndex(iIndex).isArray;
            };

            VariableContainer.prototype.getIndexByName = function (sName) {
                return this._pNameToIndexMap[sName] || (this._pNameToIndexMap[sName] = 0);
            };

            VariableContainer.prototype.getIndexByRealName = function (sName) {
                return this._pRealNameToIndexMap[sName] || (this._pRealNameToIndexMap[sName] = 0);
            };

            VariableContainer.prototype.hasVariableWithName = function (sName) {
                return !!(this.getIndexByName(sName));
            };

            VariableContainer.prototype.hasVariableWithRealName = function (sName) {
                return !!(this.getIndexByRealName(sName));
            };

            VariableContainer.prototype.getVarByName = function (sName) {
                var iIndex = this.getIndexByName(sName);

                if (iIndex === 0) {
                    return null;
                } else {
                    return this.getVarByIndex(iIndex);
                }
            };

            VariableContainer.prototype.getVarByRealName = function (sName) {
                var iIndex = this.getIndexByRealName(sName);

                if (iIndex === 0) {
                    return null;
                } else {
                    return this.getVarByIndex(iIndex);
                }
            };

            VariableContainer.getVariableDefaultValue = function (pVar) {
                var sBaseType = pVar._getType()._getBaseType()._getName();

                switch (sBaseType) {
                    case "texture":
                    case "float":
                    case "int":
                    case "bool":
                    case "float2":
                    case "int2":
                    case "bool2":
                    case "float3":
                    case "int3":
                    case "bool3":
                    case "float4":
                    case "int4":
                    case "bool4":
                    case "float2x2":
                    case "float3x3":
                    case "float4x4":
                    case "sampler":
                    case "sampler2D":
                    case "samplerCUBE":
                        return VariableContainer._pDefaultValuesForTypes[sBaseType];

                    default:
                        return null;
                }
            };

            VariableContainer.getVariableType = function (pVar) {
                var sBaseType = pVar._getType()._getBaseType()._getName();

                switch (sBaseType) {
                    case "texture":
                        return 2 /* k_Texture */;

                    case "float":
                        return 3 /* k_Float */;
                    case "int":
                        return 4 /* k_Int */;
                    case "bool":
                        return 5 /* k_Bool */;

                    case "float2":
                        return 6 /* k_Float2 */;
                    case "int2":
                        return 7 /* k_Int2 */;
                    case "bool2":
                        return 8 /* k_Bool2 */;

                    case "float3":
                        return 9 /* k_Float3 */;
                    case "int3":
                        return 10 /* k_Int3 */;
                    case "bool3":
                        return 11 /* k_Bool3 */;

                    case "float4":
                        return 12 /* k_Float4 */;
                    case "int4":
                        return 13 /* k_Int4 */;
                    case "bool4":
                        return 14 /* k_Bool4 */;

                    case "float2x2":
                        return 15 /* k_Float2x2 */;
                    case "float3x3":
                        return 16 /* k_Float3x3 */;
                    case "float4x4":
                        return 17 /* k_Float4x4 */;

                    case "sampler":
                    case "sampler2D":
                        return 18 /* k_Sampler2D */;
                    case "samplerCUBE":
                        return 19 /* k_SamplerCUBE */;

                    default:
                        if (pVar._getType()._isComplex()) {
                            return 22 /* k_Complex */;
                        } else {
                            return 0 /* k_NotVar */;
                        }
                }
            };
            VariableContainer._pDefaultValuesForTypes = {
                "texture": null,
                "float": 0.,
                "int": 0,
                "bool": false,
                "float2": new akra.math.Vec2(0.),
                "int2": new akra.math.Vec2(0),
                "bool2": new akra.math.Vec2(0),
                "float3": new akra.math.Vec3(0.),
                "int3": new akra.math.Vec3(0),
                "bool3": new akra.math.Vec3(0),
                "float4": new akra.math.Vec4(0.),
                "int4": new akra.math.Vec4(0),
                "bool4": new akra.math.Vec4(0),
                "float2x2": null,
                "float3x3": new akra.math.Mat3(0),
                "float4x4": new akra.math.Mat4(0),
                "sampler": null,
                "samplerCUBE": null
            };
            return VariableContainer;
        })();
        fx.VariableContainer = VariableContainer;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../debug.ts" />
var akra;
(function (akra) {
    /// <reference path="PassInputBlend.ts" />
    /// <reference path="VariableContainer.ts" />
    (function (fx) {
        var ComponentPassInputBlend = (function () {
            function ComponentPassInputBlend() {
                this._pUniformsContainer = null;
                this._pForeignsContainer = null;
                this._pTexturesContainer = null;
                this._pFreePassInputBlendList = null;
                this._pUniformsContainer = new fx.VariableContainer();
                this._pForeignsContainer = new fx.VariableContainer();
                this._pTexturesContainer = new fx.VariableContainer();

                for (var i = 0; i < 16; i++) {
                    this._pTexturesContainer.addSystemEntry("TEXTURE" + i.toString(), 2 /* k_Texture */);
                }
            }
            ComponentPassInputBlend.prototype.getUniforms = function () {
                return this._pUniformsContainer;
            };

            ComponentPassInputBlend.prototype.getTextures = function () {
                return this._pTexturesContainer;
            };

            ComponentPassInputBlend.prototype.getForeigns = function () {
                return this._pForeignsContainer;
            };

            ComponentPassInputBlend.prototype.addDataFromPass = function (pPass) {
                var pUniformMap = pPass._getFullUniformMap();
                var pForeignMap = pPass._getFullForeignMap();
                var pTextureMap = pPass._getFullTextureMap();

                for (var i in pForeignMap) {
                    this._pForeignsContainer.add(pForeignMap[i]);
                }

                for (var i in pTextureMap) {
                    this._pTexturesContainer.add(pTextureMap[i]);
                }

                for (var i in pUniformMap) {
                    this.addUniformVariable(pUniformMap[i], "", "");
                }
            };

            ComponentPassInputBlend.prototype.finalizeInput = function () {
                this._pUniformsContainer.finalize();
                this._pForeignsContainer.finalize();
                this._pTexturesContainer.finalize();

                this._pFreePassInputBlendList = [];

                this.generateNewPassInputs();
            };

            ComponentPassInputBlend.prototype.getPassInput = function () {
                if (this._pFreePassInputBlendList.length === 0) {
                    this.generateNewPassInputs();
                }

                return this._pFreePassInputBlendList.pop();
            };

            ComponentPassInputBlend.prototype.releasePassInput = function (pInput) {
                this._pFreePassInputBlendList.push(pInput);
            };

            ComponentPassInputBlend.prototype.addUniformVariable = function (pVariable, sPrevName, sPrevRealName) {
                var sName = pVariable._getName();
                var sRealName = pVariable._getRealName();

                var pHasVar = this._pUniformsContainer.getVarByRealName(sRealName);

                if (akra.isDefAndNotNull(pHasVar) && !pHasVar._getType()._isEqual(pVariable._getType())) {
                    akra.debug.warn("You used uniforms with the same real-names('" + sRealName + "'). Now we don`t work very well with that.");
                    return;
                }

                this._pUniformsContainer.add(pVariable);
            };

            ComponentPassInputBlend.prototype.generateNewPassInputs = function (nCount) {
                if (typeof nCount === "undefined") { nCount = 5; }
                for (var i = 0; i < nCount; i++) {
                    var pPassInput = new fx.PassInputBlend(this);
                    this._pFreePassInputBlendList.push(pPassInput);
                }
            };
            return ComponentPassInputBlend;
        })();
        fx.ComponentPassInputBlend = ComponentPassInputBlend;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../idl/IAFXComponentBlend.ts" />
/// <reference path="../idl/IAFXComposer.ts" />
/// <reference path="../idl/IAFXInstruction.ts" />
/// <reference path="../idl/IMap.ts" />
var akra;
(function (akra) {
    /// <reference path="../guid.ts" />
    /// <reference path="../debug.ts" />
    /// <reference path="fx.ts" />
    /// <reference path="ComponentPassInputBlend.ts" />
    (function (fx) {
        var ComponentBlend = (function () {
            function ComponentBlend(pComposer) {
                this.guid = akra.guid();
                this._pComposer = null;
                this._isReady = false;
                this._sHash = "";
                this._bNeedToUpdateHash = false;
                this._pComponentHashMap = null;
                this._pAddedComponentInfoList = null;
                this._iShiftMin = 0;
                this._iShiftMax = 0;
                this._nTotalPasses = 0;
                //private _iPostEffectsStart: uint = 0;
                this._pPassTypesList = null;
                this._bHasPostEffectPass = false;
                this._pPassesDList = null;
                this._pComponentInputVarBlend = null;
                this._pComposer = pComposer;

                this._pComponentHashMap = {};

                this._pAddedComponentInfoList = [];
            }
            ComponentBlend.prototype._getMinShift = function () {
                return this._iShiftMin;
            };

            ComponentBlend.prototype._getMaxShift = function () {
                return this._iShiftMax;
            };

            ComponentBlend.prototype.isReadyToUse = function () {
                return this._isReady;
            };

            ComponentBlend.prototype.isEmpty = function () {
                return this._pAddedComponentInfoList.length === 0;
            };

            ComponentBlend.prototype.getComponentCount = function () {
                return this._pAddedComponentInfoList.length;
            };

            ComponentBlend.prototype.getTotalPasses = function () {
                return !akra.isNull(this._pPassesDList) ? this._pPassesDList.length : (this._iShiftMax - this._iShiftMin + 1);
            };

            ComponentBlend.prototype.hasPostEffect = function () {
                return this._bHasPostEffectPass;
            };

            //getPostEffectStartPass(): uint {
            //	return this._iPostEffectsStart;
            //}
            ComponentBlend.prototype.getPassTypes = function () {
                return this._pPassTypesList;
            };

            ComponentBlend.prototype.getHash = function () {
                if (this._bNeedToUpdateHash) {
                    this._sHash = this.calcHash();
                    this._bNeedToUpdateHash = false;
                }

                return this._sHash;
            };

            ComponentBlend.prototype.containComponent = function (pComponent, iShift, iPass) {
                var iCorrectShift = iShift;
                var iCorrectPass = iPass;

                if (iShift === fx.DEFAULT_SHIFT) {
                    if (pComponent.isPostEffect()) {
                        iCorrectShift = fx.ANY_SHIFT;
                    } else {
                        iCorrectShift = 0;
                    }
                }

                if (iPass === fx.ALL_PASSES) {
                    var iPassCount = pComponent.getTotalPasses();
                    for (var i = 0; i < iPassCount; i++) {
                        if (!this.containComponent(pComponent, iCorrectShift === fx.ANY_SHIFT ? fx.ANY_SHIFT : (iCorrectShift + i), i)) {
                            return false;
                        }
                    }

                    return true;
                }

                if (iCorrectShift !== fx.ANY_SHIFT && iCorrectPass !== fx.ANY_PASS) {
                    return this.containComponentHash(pComponent.getHash(iCorrectShift, iCorrectPass));
                } else {
                    for (var i = 0; i < this._pAddedComponentInfoList.length; i++) {
                        var pInfo = this._pAddedComponentInfoList[i];

                        if (pInfo.component === pComponent) {
                            if (iCorrectShift === fx.ANY_SHIFT && iCorrectPass === fx.ANY_PASS) {
                                return true;
                            } else if (iCorrectShift === fx.ANY_SHIFT && pInfo.pass === iCorrectPass) {
                                return true;
                            } else if (iCorrectPass === fx.ANY_PASS && pInfo.shift === iCorrectShift) {
                                return true;
                            }
                        }
                    }

                    return false;
                }
            };

            ComponentBlend.prototype.containComponentHash = function (sComponentHash) {
                return (this._pComponentHashMap[sComponentHash]);
            };

            ComponentBlend.prototype.findAnyAddedComponentInfo = function (pComponent, iShift, iPass) {
                var iCorrectShift = iShift;
                var iCorrectPass = iPass;

                if (iPass === fx.ALL_PASSES) {
                    iCorrectPass = fx.ANY_PASS;
                }

                if (iShift === fx.DEFAULT_SHIFT) {
                    if (pComponent.isPostEffect()) {
                        iCorrectShift = fx.ANY_SHIFT;
                    } else {
                        iCorrectShift = 0;
                    }
                }

                if (iCorrectShift !== fx.ANY_SHIFT && iCorrectPass !== fx.ANY_PASS && !this.containComponentHash(pComponent.getHash(iCorrectShift, iCorrectPass))) {
                    return null;
                } else {
                    for (var i = 0; i < this._pAddedComponentInfoList.length; i++) {
                        var pInfo = this._pAddedComponentInfoList[i];

                        if (pInfo.component === pComponent) {
                            if (iCorrectShift === fx.ANY_SHIFT && iCorrectPass === fx.ANY_PASS) {
                                return pInfo;
                            } else if (iCorrectShift === fx.ANY_SHIFT && pInfo.pass === iCorrectPass) {
                                return pInfo;
                            } else if (iCorrectPass === fx.ANY_PASS && pInfo.shift === iCorrectShift) {
                                return pInfo;
                            } else if (pInfo.pass === iCorrectPass && pInfo.shift === iCorrectShift) {
                                return pInfo;
                            }
                        }
                    }

                    return null;
                }
            };

            ComponentBlend.prototype.addComponent = function (pComponent, iShift, iPass) {
                var iPassCount = pComponent.getTotalPasses();

                if (iPass === fx.ALL_PASSES) {
                    for (var i = 0; i < iPassCount; i++) {
                        this.addComponent(pComponent, iShift + i, i);
                    }

                    return;
                } else if (iPass < 0 || iPass >= iPassCount) {
                    return;
                }

                var sComponentHash = pComponent.getHash(iShift, iPass);
                if (this.containComponentHash(sComponentHash)) {
                    akra.debug.warn("You try to add already used component '" + pComponent.findResourceName() + "' in blend.");
                    return;
                }

                if (iShift < this._iShiftMin) {
                    this._iShiftMin = iShift;
                }

                if (iShift > this._iShiftMax) {
                    this._iShiftMax = iShift;
                }

                var pInfo = {
                    component: pComponent,
                    shift: iShift,
                    pass: iPass,
                    hash: sComponentHash
                };

                this._pComponentHashMap[sComponentHash] = true;
                this._pAddedComponentInfoList.push(pInfo);

                this._isReady = false;

                //this._iPostEffectsStart = 0;
                this._bHasPostEffectPass = false;
                this._bNeedToUpdateHash = true;
            };

            ComponentBlend.prototype.removeComponent = function (pComponent, iShift, iPass) {
                var sComponentHash = pComponent.getHash(iShift, iPass);
                var iPassCount = pComponent.getTotalPasses();

                if (iPass === fx.ALL_PASSES) {
                    for (var i = 0; i < iPassCount; i++) {
                        this.removeComponent(pComponent, iShift + i, i);
                    }

                    return;
                } else if (iPass < 0 || iPass >= iPassCount) {
                    return;
                }

                if (!this.containComponentHash(sComponentHash)) {
                    akra.debug.warn("You try to remove not used component '" + sComponentHash + "' from blend.");
                    return;
                }

                this._pComponentHashMap[sComponentHash] = false;

                for (var i = 0; i < this._pAddedComponentInfoList.length; i++) {
                    var pInfo = this._pAddedComponentInfoList[i];

                    if (pInfo.component === pComponent && pInfo.shift === iShift && pInfo.pass === iPass) {
                        this._pAddedComponentInfoList.splice(i, 1);
                        break;
                    }
                }

                if (this._iShiftMin === iShift || this._iShiftMax === iShift) {
                    this._iShiftMax = 0;
                    this._iShiftMin = 0;

                    for (var i = 0; i < this._pAddedComponentInfoList.length; i++) {
                        var iTestShift = this._pAddedComponentInfoList[i].shift;

                        if (iTestShift < this._iShiftMin) {
                            this._iShiftMin = iTestShift;
                        }

                        if (iTestShift > this._iShiftMax) {
                            this._iShiftMax = iTestShift;
                        }
                    }
                }

                this._isReady = false;

                //this._iPostEffectsStart = 0;
                this._bHasPostEffectPass = false;
                this._bNeedToUpdateHash = true;
            };

            ComponentBlend.prototype.finalizeBlend = function () {
                if (this._isReady) {
                    return true;
                }

                this._pPassesDList = [];
                this._pComponentInputVarBlend = [];
                this._pPassTypesList = new Array(this._iShiftMax - this._iShiftMin + 1);

                for (var i = 0; i < this._pAddedComponentInfoList.length; i++) {
                    var pInfo = this._pAddedComponentInfoList[i];

                    var pComponentTechnique = pInfo.component.getTechnique();
                    var iShift = pInfo.shift - this._iShiftMin;
                    var iPass = pInfo.pass;

                    var pPass = pComponentTechnique._getPass(iPass);

                    if (!akra.isDef(this._pPassesDList[iShift])) {
                        this._pPassesDList[iShift] = [];
                        this._pComponentInputVarBlend[iShift] = new fx.ComponentPassInputBlend();
                    }

                    this._pPassesDList[iShift].push(pPass);
                    this._pComponentInputVarBlend[iShift].addDataFromPass(pPass);
                    this._pPassTypesList[iShift] = pInfo.component.isPostEffect() ? 2 /* POSTEFFECT */ : 1 /* DEFAULT */;

                    if (pInfo.component.isPostEffect()) {
                        this._bHasPostEffectPass = true;
                    }
                    //if (pInfo.component.isPostEffect()) {
                    //	if (this._iPostEffectsStart === 0 || iShift < this._iPostEffectsStart) {
                    //		this._iPostEffectsStart = iShift;
                    //	}
                    //}
                }

                for (var i = 0; i < this._pComponentInputVarBlend.length; i++) {
                    if (akra.isDef(this._pComponentInputVarBlend[i])) {
                        this._pComponentInputVarBlend[i].finalizeInput();
                    } else {
                        this._pComponentInputVarBlend[i] = null;
                        this._pPassesDList[i] = null;
                        this._pPassTypesList[i] = 0 /* UNDEF */;
                    }
                }

                this._isReady = true;

                return true;
            };

            ComponentBlend.prototype.getPassInputForPass = function (iPass) {
                if (!this._isReady) {
                    return null;
                }

                if (iPass < 0 || iPass > this.getTotalPasses() || akra.isNull(this._pComponentInputVarBlend[iPass])) {
                    return null;
                }

                return this._pComponentInputVarBlend[iPass].getPassInput();
            };

            ComponentBlend.prototype.getPassListAtPass = function (iPass) {
                if (!this._isReady) {
                    return null;
                }

                if (iPass < 0 || iPass > this.getTotalPasses()) {
                    return null;
                }

                return this._pPassesDList[iPass];
            };

            ComponentBlend.prototype.clone = function () {
                var pClone = new ComponentBlend(this._pComposer);

                pClone._setDataForClone(this._pAddedComponentInfoList, this._pComponentHashMap, this._iShiftMin, this._iShiftMax);
                return pClone;
            };

            ComponentBlend.prototype._getComponentInfoList = function () {
                return this._pAddedComponentInfoList;
            };

            ComponentBlend.prototype._setDataForClone = function (pComponentInfoList, pComponentHashMap, iShiftMin, iShiftMax) {
                for (var i = 0; i < pComponentInfoList.length; i++) {
                    this._pAddedComponentInfoList.push({
                        component: pComponentInfoList[i].component,
                        shift: pComponentInfoList[i].shift,
                        pass: pComponentInfoList[i].pass,
                        hash: pComponentInfoList[i].hash
                    });

                    this._pComponentHashMap[pComponentInfoList[i].hash] = pComponentHashMap[pComponentInfoList[i].hash];
                }

                this._iShiftMin = iShiftMin;
                this._iShiftMax = iShiftMax;
                this._bNeedToUpdateHash = true;
            };

            ComponentBlend.prototype.calcHash = function () {
                var sHash = "";

                if (this.isEmpty()) {
                    return ComponentBlend.EMPTY_BLEND;
                }

                for (var i = 0; i < this._pAddedComponentInfoList.length; i++) {
                    sHash += this._pAddedComponentInfoList[i].hash + ":";
                }

                return sHash;
            };

            ComponentBlend.EMPTY_BLEND = "EMPTY_BLEND";
            return ComponentBlend;
        })();
        fx.ComponentBlend = ComponentBlend;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../idl/IMap.ts" />
var akra;
(function (akra) {
    (function (stringUtils) {
        var StringMinifier = (function () {
            function StringMinifier() {
                this._pMinMap = {};
                this._nCount = 1;
            }
            StringMinifier.prototype.minify = function (sValue) {
                return this._pMinMap[sValue] || (this._pMinMap[sValue] = this._nCount++);
            };
            return StringMinifier;
        })();
        stringUtils.StringMinifier = StringMinifier;
    })(akra.stringUtils || (akra.stringUtils = {}));
    var stringUtils = akra.stringUtils;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        /**
        * Use for fast and simple find element by ordered parts of complex uint key. Use when you can split you key for independent parts.
        * For example, we can fully described fx.Maker by combination of foreigns, sampler, buffers and material.
        * So if we create unique keys for those parameters we can easly create unique key for maker.
        * And we can not store all this parts of keys in uint variable or in string hash.
        * But if each part can be greater than 256, we can not use single uint variable.
        * And string hash is not very fast. So we can use HashTree<T>, it`s pretty fast ant easy to use.
        * Some code for example:
        * var pMaker: IAFXMaker = this._pFXMakerHashTree.next(iForeignPartHash)
        *                                               .next(iSamplerPartHash)
        *                                               .next(iMaterialPartHash)
        *                                               .next(iBufferPartHash)
        *                                               .getContent();
        */
        var HashTree = (function () {
            function HashTree() {
                /** Root entry */
                this._pRoot = null;
                /** Current entry */
                this._pCurrent = null;
                /** Sort function */
                this._fnSort = null;
                this._pRoot = this._pCurrent = {
                    parent: null,
                    //children: [],
                    children: {},
                    value: 0,
                    content: null
                };

                this._fnSort = function (a, b) {
                    return a.value - b.value;
                };
            }
            HashTree.prototype.has = function (iValue) {
                var pEntry = this._pCurrent.children[iValue];

                if (akra.isDef(pEntry)) {
                    this._pCurrent = pEntry;
                    return true;
                } else {
                    pEntry = {
                        parent: this._pCurrent,
                        //children: [],
                        children: {},
                        value: iValue,
                        content: null
                    };

                    this._pCurrent.children[iValue] = pEntry;
                    this._pCurrent = pEntry;

                    return false;
                }
                //var iIndex: uint = HashTree.binarySearchInSortArray<T>(this._pCurrent.children, iValue);
                //if (iIndex !== -1) {
                //	this._pCurrent = this._pCurrent.children[iIndex];
                //	return true;
                //}
                //var pNewEntry: IHashTreeEntry<T> = <IHashTreeEntry<T>>{
                //	parent: this._pCurrent,
                //	children: [],
                //	//children: <any>{},
                //	value: iValue,
                //	content: null
                //};
                //this._pCurrent.children.push(pNewEntry);
                //this._pCurrent.children.sort(<any>this._fnSort);
                //this._pCurrent = pNewEntry;
                //return false;
            };

            HashTree.prototype.next = function (iValue) {
                this.has(iValue);
                return this;
            };

            HashTree.prototype.release = function () {
                this._pCurrent = this._pRoot;
            };

            HashTree.prototype.addContent = function (pContent) {
                this._pCurrent.content = pContent;
            };

            HashTree.prototype.getContent = function () {
                return this._pCurrent.content;
            };

            HashTree.binarySearchInSortArray = function (pArray, iValue) {
                if (pArray.length === 0) {
                    return -1;
                }

                if (iValue < pArray[0].value || iValue > pArray[pArray.length - 1].value) {
                    return -1;
                }

                if (iValue === pArray[0].value) {
                    return 0;
                }

                if (iValue === pArray[pArray.length - 1].value) {
                    return pArray.length - 1;
                }

                var p = 0;
                var q = pArray.length - 1;

                while (p < q) {
                    var s = (p + q) >> 1;

                    if (iValue === pArray[s].value) {
                        return s;
                    } else if (iValue > pArray[s].value) {
                        p = s + 1;
                    } else {
                        q = s;
                    }
                }

                return -1;
            };
            return HashTree;
        })();
        fx.HashTree = HashTree;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="ICodec.ts" />
/// <reference path="EPixelFormats.ts" />
/// <reference path="../idl/ICodec.ts" />
/// <reference path="../idl/IMap.ts" />
/// <reference path="../logger.ts" />
var akra;
(function (akra) {
    (function (pixelUtil) {
        var Codec = (function () {
            function Codec() {
            }
            Codec.registerCodec = function (pCodec) {
                if (!akra.isDef(Codec._pMapCodecs[pCodec.getType()])) {
                    Codec._pMapCodecs[pCodec.getType()] = pCodec;
                } else {
                    akra.logger.critical(pCodec.getType() + " already has a registered codec. ");
                }
            };

            Codec.isCodecRegistered = function (pCodec) {
                return akra.isDef(Codec._pMapCodecs[pCodec.getType()]);
            };

            Codec.unRegisterCodec = function (pCodec) {
                delete Codec._pMapCodecs[pCodec.getType()];
            };

            Codec.getExtension = function () {
                var pExt = Array();
                var sExt = "";
                for (sExt in Codec._pMapCodecs) {
                    pExt.push(sExt);
                }
                return pExt;
            };

            Codec.getCodec = function (pMagicNumber) {
                var sExt = "";
                if (akra.isString(pMagicNumber)) {
                    if (akra.isDef(Codec._pMapCodecs[pMagicNumber])) {
                        return Codec._pMapCodecs[pMagicNumber];
                    } else {
                        akra.logger.critical("Can not find codec for " + pMagicNumber);
                        return null;
                    }
                } else {
                    for (sExt in Codec._pMapCodecs) {
                        var sExt1 = Codec._pMapCodecs[sExt].magicNumberToFileExt(pMagicNumber);
                        if (sExt1) {
                            if (sExt1 == Codec._pMapCodecs[sExt].getType()) {
                                return Codec._pMapCodecs[sExt];
                            } else {
                                return Codec.getCodec(sExt1);
                            }
                        }
                    }
                }
                return null;
            };

            Codec.prototype.magicNumberMatch = function (pMagicNumber) {
                return !(this.magicNumberToFileExt(pMagicNumber).length == 0);
            };

            Codec.prototype.magicNumberToFileExt = function (pMagicNumber) {
                akra.debug.critical("Codec.magicNumberToFileExt is virtual");
                return null;
            };

            Codec.prototype.getType = function () {
                akra.debug.critical("Codec.getType is virtual");
                return null;
            };

            Codec.prototype.getDataType = function () {
                akra.debug.critical("Codec.getDataType is virtual");
                return null;
            };

            Codec.prototype.code = function (pInput, pData) {
                akra.debug.critical("Codec.code is virtual");
                return null;
            };
            Codec.prototype.decode = function (pData, pCodecData) {
                akra.debug.critical("Codec.decode is virtual");
                return null;
            };
            Codec._pMapCodecs = {};
            return Codec;
        })();
        pixelUtil.Codec = Codec;
    })(akra.pixelUtil || (akra.pixelUtil = {}));
    var pixelUtil = akra.pixelUtil;
})(akra || (akra = {}));
/// <reference path="../idl/IImgCodec.ts" />
/// <reference path="../idl/EPixelFormats.ts" />
/// <reference path="Codec.ts" />
var akra;
(function (akra) {
    (function (pixelUtil) {
        var ImgCodec = (function (_super) {
            __extends(ImgCodec, _super);
            function ImgCodec() {
                _super.apply(this, arguments);
            }
            ImgCodec.prototype.getDataType = function () {
                return "ImgData";
            };
            return ImgCodec;
        })(pixelUtil.Codec);
        pixelUtil.ImgCodec = ImgCodec;
    })(akra.pixelUtil || (akra.pixelUtil = {}));
    var pixelUtil = akra.pixelUtil;
})(akra || (akra = {}));
var akra;
(function (akra) {
    /// <reference path="../logger.ts" />
    /// <reference path="../idl/ICodec.ts" />
    (function (pixelUtil) {
        var CodecData = (function () {
            function CodecData() {
            }
            CodecData.prototype.getDataType = function () {
                akra.logger.critical("CodecData.dataType is virtual");
                return "CodecData";
            };
            return CodecData;
        })();
        pixelUtil.CodecData = CodecData;
    })(akra.pixelUtil || (akra.pixelUtil = {}));
    var pixelUtil = akra.pixelUtil;
})(akra || (akra = {}));
/// <reference path="../idl/IImgCodec.ts" />
/// <reference path="../idl/EPixelFormats.ts" />
var akra;
(function (akra) {
    /// <reference path="CodecData.ts" />
    /// <reference path="../pool/resources/Img.ts" />
    (function (pixelUtil) {
        var ImgData = (function (_super) {
            __extends(ImgData, _super);
            function ImgData() {
                _super.apply(this, arguments);
                this._iHeight = 0;
                this._iWidth = 0;
                this._iDepth = 1;
                this._iSize = 0;
                this._nMipMaps = 0;
                this._iFlags = 0;
                this._eFormat = 0 /* UNKNOWN */;
            }
            ImgData.prototype.getWidth = function () {
                return this._iWidth;
            };

            ImgData.prototype.setWidth = function (iWidth) {
                this._iWidth = iWidth;
            };

            ImgData.prototype.getHeight = function () {
                return this._iHeight;
            };

            ImgData.prototype.setHeight = function (iHeight) {
                this._iHeight = iHeight;
            };

            ImgData.prototype.getDepth = function () {
                return this._iDepth;
            };

            ImgData.prototype.setDepth = function (iDepth) {
                this._iDepth = iDepth;
            };

            ImgData.prototype.getNumMipMaps = function () {
                return this._nMipMaps;
            };

            ImgData.prototype.setNumMipMaps = function (nNumMipMaps) {
                this._nMipMaps = nNumMipMaps;
            };

            ImgData.prototype.getFormat = function () {
                return this._eFormat;
            };

            ImgData.prototype.setFormat = function (ePixelFormat) {
                this._eFormat = ePixelFormat;
            };

            ImgData.prototype.getFlags = function () {
                return this._iFlags;
            };

            ImgData.prototype.setFlags = function (iFlags) {
                this._iFlags = iFlags;
            };

            ImgData.prototype.getCubeFlags = function () {
                return this._iCubeFlags;
            };

            ImgData.prototype.setCubeFlags = function (iFlags) {
                this._iCubeFlags = iFlags;
            };

            ImgData.prototype.getSize = function () {
                return akra.pool.resources.Img.calculateSize(this.getNumMipMaps(), this.getNumFace(), this.getWidth(), this.getHeight(), this.getDepth(), this.getFormat());
            };

            ImgData.prototype.getNumFace = function () {
                if (this._iFlags & 2 /* CUBEMAP */) {
                    var nFace = 0;
                    for (var i = 0; i < 32; i++) {
                        nFace++;
                    }
                    return nFace;
                } else {
                    return 1;
                }
            };

            ImgData.prototype.getDataType = function () {
                return "ImgData";
            };
            return ImgData;
        })(pixelUtil.CodecData);
        pixelUtil.ImgData = ImgData;
    })(akra.pixelUtil || (akra.pixelUtil = {}));
    var pixelUtil = akra.pixelUtil;
})(akra || (akra = {}));
/// <reference path="../../idl/IImg.ts" />
/// <reference path="../../idl/EPixelFormats.ts" />
var akra;
(function (akra) {
    (function (pool) {
        /// <reference path="../../io/io.ts" />
        /// <reference path="../../pixelUtil/ImgCodec.ts" />
        /// <reference path="../../pixelUtil/ImgData.ts" />
        /// <reference path="../../path/path.ts" />
        /// <reference path="../ResourcePoolItem.ts" />
        (function (resources) {
            var Codec = akra.pixelUtil.Codec;

            var ImgData = akra.pixelUtil.ImgData;

            var Img = (function (_super) {
                __extends(Img, _super);
                function Img() {
                    _super.call(this);
                    this._iWidth = 0;
                    this._iHeight = 0;
                    this._iDepth = 0;
                    this._nMipMaps = 0;
                    this._iFlags = 0;
                    this._iCubeFlags = 0;
                    this._eFormat = 0 /* UNKNOWN */;
                    this._pBuffer = null;
                }
                Img.prototype.getByteLength = function () {
                    return this._pBuffer.buffer.byteLength;
                };

                Img.prototype.getWidth = function () {
                    return this._iWidth;
                };

                Img.prototype.getHeight = function () {
                    return this._iHeight;
                };

                Img.prototype.getDepth = function () {
                    return this._iDepth;
                };

                Img.prototype.getNumFaces = function () {
                    if (this._iFlags & 2 /* CUBEMAP */) {
                        var nFace = 0;
                        for (var i = 0; i < 6; i++) {
                            if (this._iCubeFlags & (1 << i)) {
                                nFace++;
                            }
                        }
                        return nFace;
                    } else {
                        return 1;
                    }
                };

                Img.prototype.getNumMipMaps = function () {
                    return this._nMipMaps;
                };

                Img.prototype.getFormat = function () {
                    return this._eFormat;
                };

                Img.prototype.getFlags = function () {
                    return this._iFlags;
                };

                Img.prototype.getCubeFlags = function () {
                    return this._iCubeFlags;
                };

                Img.prototype.createResource = function () {
                    // innitialize the resource (called once)
                    akra.debug.assert(!this.isResourceCreated(), "The resource has already been created.");

                    // signal that the resource is now created,
                    // but has not been enabled
                    this.notifyCreated();
                    this.notifyDisabled();

                    return true;
                };

                Img.prototype.destroyResource = function () {
                    // destroy the resource
                    //
                    // we permit redundant calls to destroy, so there are no asserts here
                    //
                    if (this.isResourceCreated()) {
                        // disable the resource
                        this.disableResource();

                        this.freeMemory();

                        this.notifyUnloaded();
                        this.notifyDestroyed();

                        return (true);
                    }

                    return (false);
                };

                Img.prototype.restoreResource = function () {
                    akra.debug.assert(this.isResourceCreated(), "The resource has not been created.");

                    this.notifyRestored();
                    return true;
                };

                Img.prototype.disableResource = function () {
                    akra.debug.assert(this.isResourceCreated(), "The resource has not been created.");

                    this.notifyDisabled();
                    return true;
                };

                Img.prototype.loadResource = function (sFilename) {
                    return !akra.isNull(this.load(sFilename));
                };

                Img.prototype.saveResource = function (sFilename) {
                    return false;
                };

                Img.prototype.create = function (iWidth, iHeight, iDepth, eFormat, nFaces, nMipMaps) {
                    if (typeof iDepth === "undefined") { iDepth = 1; }
                    if (typeof eFormat === "undefined") { eFormat = 28 /* BYTE_RGBA */; }
                    if (typeof nFaces === "undefined") { nFaces = 1; }
                    if (typeof nMipMaps === "undefined") { nMipMaps = 0; }
                    var iSize = Img.calculateSize(nMipMaps, nFaces, iWidth, iHeight, iDepth, eFormat);
                    var pBuffer = new Uint8Array(iSize);
                    return this.loadDynamicImage(pBuffer, iWidth, iHeight, iDepth, eFormat, nFaces, nMipMaps);
                };

                Img.prototype.freeMemory = function () {
                    this._iWidth = 0;
                    this._iHeight = 0;
                    this._iDepth = 0;
                    this._pBuffer = null;
                };

                Img.prototype.set = function (pSrc) {
                    this.freeMemory();

                    this._iWidth = pSrc.getWidth();
                    this._iHeight = pSrc.getHeight();
                    this._iDepth = pSrc.getDepth();
                    this._eFormat = pSrc.getFormat();

                    this._iFlags = pSrc.getFlags();

                    this._nMipMaps = pSrc.getNumMipMaps();

                    this._pBuffer = new Uint8Array(pSrc.getData());

                    return this;
                };

                Img.prototype.loadImageWithInternalFormatFromURL = function (sPath, sExt, cb) {
                    var _this = this;
                    Img.decodeImageWithInternalFormatFromURL(sPath, sExt, function (e, pData, iWidth, iHeight, iDepth, eFormat) {
                        if (e) {
                            cb && cb(new Error("Could not decode image with internal format."));
                            return;
                        }

                        _this.loadDynamicImage(pData, iWidth, iHeight, 1, eFormat);

                        cb && cb(null);
                    });
                };

                Img.prototype.load = function () {
                    var _this = this;
                    var cb = null;
                    var sFilename;
                    var sExt;
                    var pCanvas;
                    var pData;

                    //load from HTMLCanvasElement
                    if (arguments[0] instanceof HTMLCanvasElement) {
                        pCanvas = arguments[0];
                        cb = arguments[1];

                        var pTempContext = pCanvas.getContext('2d');

                        if (!pTempContext) {
                            if (akra.isDefAndNotNull(cb)) {
                                cb(new Error("Could not create canvas rendering context 2D."));
                            }

                            return this;
                        }

                        var pImageData = pTempContext.getImageData(0, 0, pCanvas.width, pCanvas.height);

                        this.loadDynamicImage(new Uint8Array(pImageData.data.buffer.slice(0, pImageData.data.buffer.byteLength)), pCanvas.width, pCanvas.height);

                        if (akra.isDefAndNotNull(cb)) {
                            cb(null);
                        }

                        return this;
                    } else if (akra.isString(arguments[0])) {
                        sFilename = arguments[0];
                        cb = arguments[1];
                        sExt = akra.path.parse(sFilename).getExt();

                        if (!sExt) {
                            //FIXME: move determImageExtension to Image codec
                            //could not determ extension fron path
                            akra.info.determImageExtension(sFilename, function (e, pData, sExt) {
                                if (e)
                                    return cb(e);
                                _this.load(pData, sExt, cb);
                            });
                        } else {
                            if (Img.isInternalImageFormat(sExt)) {
                                this.loadImageWithInternalFormatFromURL(sFilename, sExt, cb);
                            } else {
                                akra.io.fopen(sFilename, "rb").read(function (e, pData) {
                                    if (e)
                                        return cb(e);
                                    _this.load(new Uint8Array(pData), sExt, cb);
                                });
                            }
                        }

                        return this;
                    }

                    //load from data
                    pData = arguments[0];
                    sExt = arguments[1];
                    cb = arguments[2];

                    var pCodec = null;

                    if (Img.isInternalImageFormat(sExt)) {
                        var sURL = akra.conv.toURL(pData, 'image\/' + sExt);
                        this.loadImageWithInternalFormatFromURL(sURL, sExt, cb);
                        return this;
                    }

                    //check codec, if can
                    if (sExt) {
                        pCodec = Codec.getCodec(sExt);
                    }

                    //determ code from data
                    if (!pCodec) {
                        var iMagicLen = Math.min(32, pData.byteLength);
                        pCodec = Codec.getCodec(pData.subarray(pData.byteOffset, iMagicLen));
                    }

                    if (!pCodec) {
                        var e = new Error("Unable to load image: Image format is unknown. Unable to identify codec. Check it or specify format explicitly.\n" + "Img.load");

                        akra.debug.critical(e);

                        if (cb) {
                            cb(e);
                        }

                        return this;
                    }

                    var pImgData = new ImgData();

                    this._pBuffer = pCodec.decode(pData, pImgData);

                    this._iWidth = pImgData.getWidth();
                    this._iHeight = pImgData.getHeight();
                    this._iDepth = pImgData.getDepth();
                    this._nMipMaps = pImgData.getNumMipMaps();
                    this._iFlags = pImgData.getFlags();
                    this._iCubeFlags = pImgData.getCubeFlags();

                    this._eFormat = pImgData.getFormat();

                    this.notifyLoaded();

                    if (cb) {
                        cb(null);
                    }

                    return this;
                };

                Img.prototype.loadRawData = function (pData, iWidth, iHeight, iDepth, eFormat, nFaces, nMipMaps) {
                    if (typeof iDepth === "undefined") { iDepth = 1; }
                    if (typeof eFormat === "undefined") { eFormat = 10 /* BYTE_RGB */; }
                    if (typeof nFaces === "undefined") { nFaces = 1; }
                    if (typeof nMipMaps === "undefined") { nMipMaps = 0; }
                    var iSize = Img.calculateSize(nMipMaps, nFaces, iWidth, iHeight, iDepth, eFormat);

                    if (iSize != pData.buffer.byteLength) {
                        akra.logger.critical("Stream size does not match calculated image size\n" + "Img.loadRawData");
                    }

                    var pBuffer = new Uint8Array(iSize);

                    pBuffer.set(pData);

                    return this.loadDynamicImage(pBuffer, iWidth, iHeight, iDepth, eFormat, nFaces, nMipMaps);
                };

                Img.prototype.loadDynamicImage = function (pData, iWidth, iHeight, iDepth, eFormat, nFaces, nMipMaps) {
                    if (typeof iDepth === "undefined") { iDepth = 1; }
                    if (typeof eFormat === "undefined") { eFormat = 10 /* BYTE_RGB */; }
                    if (typeof nFaces === "undefined") { nFaces = 1; }
                    if (typeof nMipMaps === "undefined") { nMipMaps = 0; }
                    //size
                    this._iWidth = iWidth;
                    this._iHeight = iHeight;
                    this._iDepth = iDepth;

                    this._eFormat = eFormat;
                    this._nMipMaps = nMipMaps;
                    this._iFlags = 0;

                    if (akra.pixelUtil.isCompressed(this._eFormat)) {
                        this._iFlags |= 1 /* COMPRESSED */;
                    }
                    if (this._iDepth != 1) {
                        this._iFlags |= 4 /* TEXTURE_3D */;
                    }

                    if (nFaces == 6) {
                        this._iFlags |= 2 /* CUBEMAP */;
                    }

                    if (nFaces != 6 && nFaces != 1) {
                        akra.logger.critical("Number of faces currently must be 6 or 1.\n" + "Img.loadDynamicImage");
                    }

                    this._pBuffer = pData;
                    this.notifyLoaded();
                    return this;
                };

                Img.prototype.convert = function (eFormat) {
                    return this.getFormat() == eFormat;
                };

                //Gets the physical width in bytes of each row of pixels.
                Img.prototype.getRawSpan = function () {
                    return this._iWidth * this.getPixelSize();
                };

                Img.prototype.getBPP = function () {
                    return this.getPixelSize() * 8;
                };

                Img.prototype.getPixelSize = function () {
                    return akra.pixelUtil.getNumElemBytes(this._eFormat);
                };

                Img.prototype.getData = function () {
                    return this._pBuffer;
                };

                Img.prototype.hasFlag = function (eFlag) {
                    if (this._iFlags & eFlag) {
                        return true;
                    } else {
                        return false;
                    }
                };

                Img.prototype.hasAlpha = function () {
                    return akra.pixelUtil.hasAlpha(this._eFormat);
                };

                Img.prototype.isCompressed = function () {
                    return akra.pixelUtil.isCompressed(this._eFormat);
                };

                Img.prototype.isLuminance = function () {
                    return akra.pixelUtil.isLuminance(this._eFormat);
                };

                Img.prototype.getColorAt = function (pColor, x, y, z) {
                    if (typeof z === "undefined") { z = 0; }
                    var iStart = this.getPixelSize() * (z * this._iWidth * this._iHeight + this._iWidth * y + x);
                    akra.pixelUtil.unpackColour(pColor, this._eFormat, this._pBuffer.subarray(iStart, iStart + this.getPixelSize()));
                    return pColor;
                };

                Img.prototype.setColorAt = function (pColor, x, y, z) {
                    if (typeof z === "undefined") { z = 0; }
                    var iStart = this.getPixelSize() * (z * this._iWidth * this._iHeight + this._iWidth * y + x);
                    akra.pixelUtil.packColour(pColor, this._eFormat, this._pBuffer.subarray(iStart, iStart + this.getPixelSize()));
                };

                Img.prototype.getPixels = function (iFace, iMipMap) {
                    // Image data is arranged as:
                    // face 0, top level (mip 0)
                    // face 0, mip 1
                    // face 0, mip 2
                    // face 1, top level (mip 0)
                    // face 1, mip 1
                    // face 1, mip 2
                    // etc
                    if (iMipMap > this.getNumMipMaps()) {
                        akra.logger.warn("Mipmap index out of range", iMipMap, this.getNumMipMaps());
                        return null;
                    }

                    if (iFace >= this.getNumFaces()) {
                        akra.logger.warn("Face index out of range", iFace, this.getNumFaces());
                        return null;
                    }

                    // Calculate mipmap offset and size
                    var pData = this.getData();

                    // Base offset is number of full faces
                    var iWidth = this._iWidth;
                    var iHeight = this._iHeight;
                    var iDepth = this._iDepth;

                    // Figure out the offsets
                    var iFullFaceSize = 0;
                    var iFinalFaceSize = 0;
                    var iFinalWidth = 0;
                    var iFinalHeight = 0;
                    var iFinalDepth = 0;
                    var iMipSize = 0;
                    var iOffset = 0;

                    for (var iMip = 0; iMip <= this.getNumMipMaps(); ++iMip) {
                        if (iMip == iMipMap) {
                            iFinalFaceSize = iFullFaceSize;
                            iFinalWidth = iWidth;
                            iFinalHeight = iHeight;
                            iFinalDepth = iDepth;
                            iMipSize = akra.pixelUtil.getMemorySize(iWidth, iHeight, iDepth, this.getFormat());
                        }

                        iFullFaceSize += akra.pixelUtil.getMemorySize(iWidth, iHeight, iDepth, this.getFormat());

                        /// Half size in each dimension
                        if (iWidth != 1)
                            iWidth /= 2;
                        if (iHeight != 1)
                            iHeight /= 2;
                        if (iDepth != 1)
                            iDepth /= 2;
                    }

                    // Advance pointer by number of full faces, plus mip offset into
                    iOffset += iFace * iFullFaceSize;
                    iOffset += iFinalFaceSize;

                    // Return subface as pixelbox
                    var pSrc = new akra.pixelUtil.PixelBox(iFinalWidth, iFinalHeight, iFinalDepth, this.getFormat(), pData.subarray(iOffset, iOffset + iMipSize));

                    return pSrc;
                };

                Img.prototype.scale = function (pDest, eFilter) {
                    return null;
                };

                Img.prototype.resize = function (iWidth, iHeight, eFilter) {
                    return null;
                };

                Img.prototype.generatePerlinNoise = function (fScale, iOctaves, fFalloff) {
                };

                Img.prototype.randomChannelNoise = function (iChannel, iMinRange, iMaxRange) {
                };

                Img.calculateSize = function (nMipMaps, nFaces, iWidth, iHeight, iDepth, eFormat) {
                    var iSize = 0;
                    var iMip = 0;

                    for (iMip = 0; iMip <= nMipMaps; iMip++) {
                        iSize += akra.pixelUtil.getMemorySize(iWidth, iHeight, iDepth, eFormat) * nFaces;
                        if (iWidth != 1)
                            iWidth = Math.floor(iWidth / 2);
                        if (iHeight != 1)
                            iHeight = Math.floor(iHeight / 2);
                        if (iDepth != 1)
                            iDepth = Math.floor(iDepth / 2);
                    }
                    return iSize;
                };

                Img.isInternalImageFormat = function (sExt) {
                    if (akra.isString(sExt)) {
                        sExt = sExt.toUpperCase();
                        return sExt === "PNG" || sExt === "JPG" || sExt === "JPEG" || sExt === "GIF" || sExt === "BMP";
                    }

                    return false;
                };

                Img.decodeImageWithInternalFormatFromURL = function (sPath, sExt, cb) {
                    var pImg = new Image();

                    if (akra.isDefAndNotNull(sExt)) {
                        sExt = sExt.toUpperCase();
                    }

                    pImg.onload = function () {
                        var pTempCanvas = document.createElement("canvas");
                        pTempCanvas.width = pImg.width;
                        pTempCanvas.height = pImg.height;

                        var pTempContext = (pTempCanvas.getContext("2d"));
                        pTempContext.drawImage(pImg, 0, 0);

                        var pImageData = pTempContext.getImageData(0, 0, pImg.width, pImg.height);
                        var pRGBAData = new Uint8Array(pImageData.data.buffer.slice(0, pImageData.data.buffer.byteLength));

                        var pData = null;
                        var eFormat = 0 /* UNKNOWN */;
                        var bNoAlpha = true;

                        if (sExt === "PNG" || sExt === "GIF") {
                            for (var i = 0; i < pRGBAData.length; i += 4) {
                                if (pRGBAData[i + 3] !== 0xff) {
                                    bNoAlpha = false;
                                    break;
                                }
                            }
                        }

                        if (sExt === "JPG" || sExt === "JPEG" || bNoAlpha) {
                            var pRGBData = new Uint8Array(pRGBAData.length / 4 * 3);
                            for (var i = 0, j = 0; i < pRGBAData.length; i += 4, j += 3) {
                                pRGBData[j] = pRGBAData[i];
                                pRGBData[j + 1] = pRGBAData[i + 1];
                                pRGBData[j + 2] = pRGBAData[i + 2];
                            }

                            pData = pRGBData;
                            eFormat = 10 /* BYTE_RGB */;
                        } else {
                            pData = pRGBAData;
                            eFormat = 28 /* BYTE_RGBA */;
                        }

                        cb(null, pData, pImg.width, pImg.height, 1, eFormat);
                    };

                    pImg.onerror = function () {
                        cb(new Error("HTML Image element loading error."), null, 0, 0, 0, 0 /* UNKNOWN */);
                    };

                    pImg.onabort = function () {
                        cb(new Error("HTML Image element loading aborted."), null, 0, 0, 0, 0 /* UNKNOWN */);
                    };

                    pImg.src = sPath;
                };

                Img.getMaxMipmaps = function (iWidth, iHeight, iDepth, eFormat) {
                    var iCount = 0;
                    if ((iWidth > 0) && (iHeight > 0)) {
                        do {
                            if (iWidth > 1) {
                                iWidth = iWidth >>> 1;
                            }
                            if (iHeight > 1) {
                                iHeight = iHeight >>> 1;
                            }
                            if (iDepth > 1) {
                                iDepth = iDepth >>> 1;
                            }

                            /*
                            NOT needed, compressed formats will have mipmaps up to 1x1
                            if(PixelUtil::isValidExtent(width, height, depth, format))
                            count ++;
                            else
                            break;
                            */
                            iCount++;
                        } while(!(iWidth === 1 && iHeight === 1 && iDepth === 1));
                    }
                    return iCount;
                };
                return Img;
            })(pool.ResourcePoolItem);
            resources.Img = Img;
        })(pool.resources || (pool.resources = {}));
        var resources = pool.resources;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="../../idl/ITexture.ts"	 />
/// <reference path="../../idl/IImg.ts"	 />
/// <reference path="../../idl/EPixelFormats.ts" />
/// <reference path="../../idl/IColor.ts" />
/// <reference path="../../idl/IMap.ts" />
var akra;
(function (akra) {
    (function (pool) {
        /// <reference path="../../pixelUtil/pixelUtil.ts" />
        /// <reference path="../ResourcePoolItem.ts" />
        /// <reference path="Img.ts" />
        /// <reference path="../../debug.ts" />
        /// <reference path="../../logger.ts" />
        (function (resources) {
            (function (ETextureForcedFormatFlags) {
                ETextureForcedFormatFlags[ETextureForcedFormatFlags["FORCEMIPLEVELS"] = 0] = "FORCEMIPLEVELS";
                ETextureForcedFormatFlags[ETextureForcedFormatFlags["FORCEFORMAT"] = 1] = "FORCEFORMAT";
                ETextureForcedFormatFlags[ETextureForcedFormatFlags["FORCESIZE"] = 2] = "FORCESIZE";
            })(resources.ETextureForcedFormatFlags || (resources.ETextureForcedFormatFlags = {}));
            var ETextureForcedFormatFlags = resources.ETextureForcedFormatFlags;

            var Texture = (function (_super) {
                __extends(Texture, _super);
                function Texture() {
                    _super.call(this);
                    this._iFlags = akra.ETextureFlags.DEFAULT;
                    this._iWidth = 512;
                    this._iHeight = 512;
                    this._iDepth = 1;
                    this._eFormat = 0 /* UNKNOWN */;
                    this._nMipLevels = 0;
                    this._nRequestedMipLevels = 0;
                    this._eTextureType = 3553 /* TEXTURE_2D */;
                    this._pParams = {};
                    this._isInternalResourceCreated = false;
                    this._isMipmapsHardwareGenerated = false;

                    this._pParams[10241 /* MIN_FILTER */] = 9728 /* NEAREST */;
                    this._pParams[10240 /* MAG_FILTER */] = 9728 /* NEAREST */;
                    this._pParams[10242 /* WRAP_S */] = 33071 /* CLAMP_TO_EDGE */;
                    this._pParams[10243 /* WRAP_T */] = 33071 /* CLAMP_TO_EDGE */;
                }
                Texture.prototype.getWidth = function () {
                    return this._iWidth;
                };

                Texture.prototype.getHeight = function () {
                    return this._iHeight;
                };

                Texture.prototype.getDepth = function () {
                    return this._iDepth;
                };

                Texture.prototype.getFormat = function () {
                    return this._eFormat;
                };

                Texture.prototype.getTextureType = function () {
                    return this._eTextureType;
                };

                Texture.prototype.getMipLevels = function () {
                    return this._nMipLevels;
                };

                Texture.prototype.getByteLength = function () {
                    return this.getSize();
                };

                Texture.prototype.getFlags = function () {
                    return this._iFlags;
                };

                Texture.prototype.setFlags = function (iFlags) {
                    this._iFlags = iFlags;
                };

                Texture.prototype.isTexture2D = function () {
                    return this._eTextureType === 3553 /* TEXTURE_2D */;
                };

                Texture.prototype.isTextureCube = function () {
                    return this._eTextureType === 34067 /* TEXTURE_CUBE_MAP */;
                };

                Texture.prototype.isCompressed = function () {
                    return (this._eFormat >= 17 /* DXT1 */ && this._eFormat <= 21 /* DXT5 */) || (this._eFormat >= 38 /* PVRTC_RGB2 */ && this._eFormat <= 41 /* PVRTC_RGBA4 */);
                };

                Texture.prototype.isValid = function () {
                    return this._isInternalResourceCreated;
                };

                Texture.prototype.getNumFaces = function () {
                    return this._eTextureType === 34067 /* TEXTURE_CUBE_MAP */ ? 6 : 1;
                };

                Texture.prototype.getSize = function () {
                    //FIXME: necessary consider the number of texture MIP levels
                    return this.getNumFaces() * akra.pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
                };

                Texture.prototype.unwrapCubeTexture = function (pCubeTex) {
                    if (this.getTextureType() != 3553 /* TEXTURE_2D */) {
                        return false;
                    }
                    return this.getBuffer().unwrapFromCubeTexture(pCubeTex);
                };

                Texture.prototype.reset = function (iWidth, iHeight) {
                    if (typeof iWidth === "undefined") { iWidth = this._iWidth; }
                    if (typeof iHeight === "undefined") { iHeight = iWidth; }
                    this._iWidth = iWidth;
                    this._iHeight = iHeight;
                };

                Texture.prototype.getBuffer = function (iFace, iMipmap) {
                    return null;
                };

                Texture.prototype.create = function (iWidth, iHeight, iDepth, pPixels, eFlags, nMipLevels, nFaces, eTextureType, eFormat) {
                    if (typeof iDepth === "undefined") { iDepth = 1; }
                    if (typeof pPixels === "undefined") { pPixels = null; }
                    if (typeof eFlags === "undefined") { eFlags = akra.ETextureFlags.DEFAULT; }
                    if (typeof nMipLevels === "undefined") { nMipLevels = 0; }
                    if (typeof nFaces === "undefined") { nFaces = 0; }
                    if (typeof eTextureType === "undefined") { eTextureType = 3553 /* TEXTURE_2D */; }
                    if (typeof eFormat === "undefined") { eFormat = 11 /* B8G8R8 */; }
                    if (eTextureType != 3553 /* TEXTURE_2D */ && eTextureType != 34067 /* TEXTURE_CUBE_MAP */) {
                        akra.logger.critical("Given texture type unsupported");
                        return false;
                    }

                    this._eTextureType = eTextureType;

                    this._iWidth = iWidth;
                    this._iHeight = iHeight;
                    this._iDepth = iDepth;

                    this._iFlags = eFlags;
                    this._nMipLevels = nMipLevels;

                    this._eFormat = eFormat;

                    if (akra.isArray(pPixels)) {
                        pPixels = new Uint8Array(pPixels);
                        return this.loadRawData(pPixels, iWidth, iHeight, iDepth, eFormat, nFaces, nMipLevels);
                    } else if (akra.isTypedArray(pPixels)) {
                        return this.loadRawData(pPixels, iWidth, iHeight, iDepth, eFormat, nFaces, nMipLevels);
                    } else {
                        return this.createInternalTexture(pPixels);
                    }
                };

                Texture.prototype.loadResource = function (sFilename) {
                    if (arguments.length == 0) {
                        return;
                    }

                    var pImage = this.getManager().loadImage(sFilename);

                    if (pImage.isResourceLoaded()) {
                        return this.loadImage(pImage);
                    }

                    pImage.loaded.connect(this, this._onImageLoad);

                    return true;
                };

                Texture.prototype._onImageLoad = function (pImage) {
                    pImage.loaded.disconnect(this, this._onImageLoad);
                    this.loadImage(pImage);
                };

                Texture.prototype.destroyResource = function () {
                    this.freeInternalTexture();
                    this.notifyDestroyed();
                    return true;
                };

                Texture.prototype.setFilter = function (eParam, eValue) {
                    if (this._pParams[eParam] === eValue) {
                        return true;
                    }

                    this._pParams[eParam] = eValue;
                    return this._setFilterInternalTexture(eParam, eValue);
                };

                Texture.prototype.setWrapMode = function (eParam, eValue) {
                    if (this._pParams[eParam] === eValue) {
                        return true;
                    }

                    this._pParams[eParam] = eValue;
                    return this._setWrapModeInternalTexture(eParam, eValue);
                };

                Texture.prototype.getFilter = function (eParam) {
                    // if(!isDefAndNotNull(this._pParams[eParam])) {
                    //     this._pParams[eParam] = this._getFilterInternalTexture(eParam);
                    // }
                    return this._pParams[eParam];
                };

                Texture.prototype.getWrapMode = function (eParam) {
                    // if(!isDefAndNotNull(this._pParams[eParam])) {
                    //     this._pParams[eParam] = this._getWrapModeInternalTexture(eParam);
                    // }
                    return this._pParams[eParam];
                };

                Texture.prototype._setFilterInternalTexture = function (eParam, eValue) {
                    akra.logger.critical("virual");
                    return false;
                };
                Texture.prototype._setWrapModeInternalTexture = function (eParam, eValue) {
                    akra.logger.critical("virual");
                    return false;
                };

                Texture.prototype._getFilterInternalTexture = function (eParam) {
                    akra.logger.critical("virual");
                    return 0;
                };
                Texture.prototype._getWrapModeInternalTexture = function (eParam) {
                    akra.logger.critical("virual");
                    return 0;
                };

                Texture.prototype.loadRawData = function (pData, iWidth, iHeight, iDepth, eFormat, nFaces, nMipMaps) {
                    if (typeof iDepth === "undefined") { iDepth = 1; }
                    if (typeof eFormat === "undefined") { eFormat = 10 /* BYTE_RGB */; }
                    if (typeof nFaces === "undefined") { nFaces = 1; }
                    if (typeof nMipMaps === "undefined") { nMipMaps = 0; }
                    var pTempImg = this.getManager().getImagePool().findResource(".texture.temp_image");

                    if (akra.isNull(pTempImg)) {
                        pTempImg = this.getManager().getImagePool().createResource(".texture.temp_image");
                    }

                    pTempImg.loadRawData(pData, iWidth, iHeight, iDepth, eFormat, nFaces, nMipMaps);
                    var isLoaded = this.loadImage(pTempImg);
                    this.getManager().getImagePool().destroyResource(pTempImg);

                    return isLoaded;
                };

                Texture.prototype.loadImage = function (pImage) {
                    var isLoaded = this._loadImages(pImage);

                    if (isLoaded) {
                        this.notifyLoaded();
                        return true;
                    } else {
                        return false;
                    }
                };

                Texture.prototype.loadImages = function (pImages) {
                    var isLoaded = this._loadImages(pImages);

                    if (isLoaded) {
                        this.notifyLoaded();
                        return true;
                    } else {
                        return false;
                    }
                };

                Texture.prototype._loadImages = function (pImage) {
                    var _this = this;
                    if (this.isResourceLoaded()) {
                        akra.logger.warn("Yoy try to load texture when it already have been loaded. All texture data was destoyed.");
                        this.freeInternalTexture();
                    }

                    var pMainImage = null;
                    var pImageList = null;

                    if (!akra.isArray(pImage)) {
                        pMainImage = pImage;
                        pImageList = new Array(0);
                        pImageList[0] = pMainImage;
                    } else {
                        if (akra.isString(arguments[0][0])) {
                            var pPathList = arguments[0];
                            pImageList = new Array(pPathList.length);

                            pPathList.forEach(function (sPath, i) {
                                pImageList[i] = _this.getManager().loadImage(sPath);
                            });
                        } else {
                            pImageList = arguments[0];
                        }

                        if (pImageList.length === 0) {
                            akra.logger.critical("Cannot load empty list of images");
                            return false;
                        }

                        pMainImage = pImageList[0];
                    }

                    this._iWidth = pMainImage.getWidth();
                    this._iHeight = pMainImage.getHeight();
                    this._iDepth = pMainImage.getDepth();

                    // Get source image format and adjust if required
                    if (akra.webgl.isWebGLFormatSupport(pMainImage.getFormat())) {
                        this._eFormat = pMainImage.getFormat();
                    } else {
                        akra.logger.info("Format not support(" + akra.pixelUtil.getFormatName(pMainImage.getFormat()) + ")");

                        //FIXME: skip this and go to bulk pixel conversion.
                        if (pMainImage.convert(14 /* B8G8R8A8 */)) {
                            this._eFormat = pMainImage.getFormat();
                        } else {
                            akra.logger.critical("Could not convert from " + pMainImage.getFormat() + " to R8G8B8A8");
                        }
                    }

                    for (i = 1; i < pImageList.length; i++) {
                        if (!pImageList[i].convert(pMainImage.getFormat())) {
                            akra.logger.critical("Format not support and not convert");
                        }
                    }

                    // The custom mipmaps in the image have priority over everything
                    var iImageMips = pMainImage.getNumMipMaps();

                    if (iImageMips === resources.Img.getMaxMipmaps(this._iWidth, this._iHeight, this._iDepth, this._eFormat)) {
                        this._nMipLevels = iImageMips;

                        // Disable flag for auto mip generation
                        this._iFlags = akra.bf.clearAll(this._iFlags, 256 /* AUTOMIPMAP */);
                    } else {
                        this._nMipLevels = 0;
                    }

                    // Check if we're loading one image with multiple faces
                    // or a vector of images representing the faces
                    var iFaces = 0;
                    var isMultiImage = false;

                    if (pImageList.length == 6) {
                        iFaces = 6;
                        isMultiImage = true;
                        this._eTextureType = 34067 /* TEXTURE_CUBE_MAP */;
                    } else if (pMainImage.getNumFaces() == 6) {
                        iFaces = 6;
                        isMultiImage = false;
                        this._eTextureType = 34067 /* TEXTURE_CUBE_MAP */;
                    } else {
                        iFaces = 1;
                        isMultiImage = false;
                        this._eTextureType = 3553 /* TEXTURE_2D */;
                    }

                    // Check wether number of faces in images exceeds number of faces
                    // in this texture. If so, clamp it.
                    if (iFaces > this.getNumFaces()) {
                        iFaces = this.getNumFaces();
                    }

                    // Create the texture
                    this.createInternalTexture(null);

                    // Main loading loop
                    // imageMips == 0 if the image has no custom mipmaps, otherwise contains the number of custom mips
                    var mip = 0;
                    var i = 0;
                    for (mip = 0; mip <= this._nMipLevels; ++mip) {
                        for (i = 0; i < iFaces; ++i) {
                            var pSrc;

                            if (isMultiImage) {
                                // Load from multiple images
                                pSrc = pImageList[i].getPixels(0, mip);
                            } else {
                                // Load from faces of images[0] or main Image
                                pSrc = pMainImage.getPixels(i, mip);
                            }

                            // Destination: entire texture. blitFromMemory does the scaling to
                            // a power of two for us when needed
                            this.getBuffer(i, mip).blitFromMemory(pSrc);
                        }
                    }

                    return true;
                };

                Texture.prototype.convertToImage = function (pDestImage, bIncludeMipMaps) {
                    // logger.critical("!!!нехуй")
                    var iNumMips = bIncludeMipMaps ? this._nMipLevels + 1 : 1;
                    var iDataSize = akra.pixelUtil.calculateSizeForImage(iNumMips, this.getNumFaces(), this._iWidth, this._iHeight, this._iDepth, this._eFormat);

                    var pPixData = new Uint8Array(iDataSize);

                    // if there are multiple faces and mipmaps we must pack them into the data
                    // faces, then mips
                    var pCurrentPixData = pPixData;

                    var iFace = 0;
                    var mip = 0;

                    for (iFace = 0; iFace < this.getNumFaces(); ++iFace) {
                        for (mip = 0; mip < iNumMips; ++mip) {
                            var iMipDataSize = akra.pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);

                            var pPixBox = new akra.pixelUtil.PixelBox(this._iWidth, this._iHeight, this._iDepth, this._eFormat, pCurrentPixData);
                            this.getBuffer(iFace, mip).blitToMemory(pPixBox);

                            pCurrentPixData = pCurrentPixData.subarray(iMipDataSize);
                        }
                    }

                    // load, and tell Image to delete the memory when it's done.
                    pDestImage.loadDynamicImage(pPixData, this._iWidth, this._iHeight, this._iDepth, this._eFormat, this.getNumFaces(), iNumMips - 1);
                };

                Texture.prototype.copyToTexture = function (pTarget) {
                    if (pTarget.getNumFaces() !== this.getNumFaces()) {
                        akra.logger.critical("Texture types must match");
                    }

                    var nMipLevels = Math.min(this._nMipLevels, pTarget.getMipLevels());
                    if (akra.bf.testAny(this._iFlags, 256 /* AUTOMIPMAP */) || akra.bf.testAny(this.getFlags(), 256 /* AUTOMIPMAP */)) {
                        nMipLevels = 0;
                    }

                    var iFace = 0, mip = 0;

                    for (iFace = 0; iFace < this.getNumFaces(); iFace++) {
                        for (mip = 0; mip <= nMipLevels; mip++) {
                            pTarget.getBuffer(iFace, mip).blit(this.getBuffer(iFace, mip));
                        }
                    }
                };

                Texture.prototype.createInternalTexture = function (cFillColor) {
                    if (typeof cFillColor === "undefined") { cFillColor = null; }
                    if (!this._isInternalResourceCreated) {
                        this._createInternalTextureImpl(cFillColor);
                        this._isInternalResourceCreated = true;
                        this.notifyCreated();
                        return true;
                    }

                    return false;
                };

                Texture.prototype.freeInternalTexture = function () {
                    if (this._isInternalResourceCreated) {
                        this.freeInternalTextureImpl();
                        this._isInternalResourceCreated = false;
                        this.notifyDestroyed();
                        return true;
                    }

                    return false;
                };

                Texture.prototype._createInternalTextureImpl = function (cFillColor) {
                    if (typeof cFillColor === "undefined") { cFillColor = null; }
                    return false;
                };

                Texture.prototype.freeInternalTextureImpl = function () {
                    return false;
                };

                Texture.prototype.setPixelRGBA = function (i1, i2, iTextureWidth, iTextureHeight, pBuffer) {
                    return;
                };
                return Texture;
            })(pool.ResourcePoolItem);
            resources.Texture = Texture;
        })(pool.resources || (pool.resources = {}));
        var resources = pool.resources;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="../../idl/ISurfaceMaterial.ts" />
var akra;
(function (akra) {
    (function (pool) {
        /// <reference path="../ResourcePoolItem.ts" />
        /// <reference path="../../material/Material.ts" />
        /// <reference path="../../debug.ts" />
        /// <reference path="Texture.ts" />
        (function (resources) {
            var Material = akra.material.Material;
            var Mat4 = akra.math.Mat4;

            var SurfaceMaterial = (function (_super) {
                __extends(SurfaceMaterial, _super);
                function SurfaceMaterial() {
                    _super.call(this);
                    this._pMaterial = new Material;
                    this._nTotalTextures = 0;
                    this._iTextureFlags = 0;
                    this._iTextureMatrixFlags = 0;
                    this._pTextures = new Array(SurfaceMaterial.MAX_TEXTURES_PER_SURFACE);
                    this._pTexcoords = new Array(SurfaceMaterial.MAX_TEXTURES_PER_SURFACE);
                    this._pTextureMatrices = new Array(SurfaceMaterial.MAX_TEXTURES_PER_SURFACE);
                    //For acceleration of PassInpuBlend.setSurfaceMaterial and PassBlend.generateFXMaker
                    this._nTextureUpdates = 0;
                    this._nTexcoordUpdates = 0;

                    for (var i = 0; i < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE; ++i) {
                        this._pTexcoords[i] = i;
                    }
                }
                SurfaceMaterial.prototype.notifyAltered = function () {
                    _super.prototype.notifyAltered.call(this);
                    this._nTextureUpdates++;
                    this._nTexcoordUpdates++;
                };

                SurfaceMaterial.prototype.getTotalUpdatesOfTextures = function () {
                    return this._nTextureUpdates;
                };

                SurfaceMaterial.prototype.getTotalUpdatesOfTexcoords = function () {
                    return this._nTexcoordUpdates;
                };

                SurfaceMaterial.prototype.getTotalTextures = function () {
                    return this._nTotalTextures;
                };

                SurfaceMaterial.prototype.getTextureFlags = function () {
                    return this._iTextureFlags;
                };

                SurfaceMaterial.prototype.getTextureMatrixFlags = function () {
                    return this._iTextureMatrixFlags;
                };

                SurfaceMaterial.prototype.getMaterial = function () {
                    return this._pMaterial;
                };

                SurfaceMaterial.prototype.setMaterial = function (pMaterial) {
                    this._pMaterial = pMaterial;
                };

                SurfaceMaterial.prototype.createResource = function () {
                    this.notifyLoaded();
                    this.notifyCreated();
                    return true;
                };

                SurfaceMaterial.prototype.setTexture = function (iIndex, texture, iTexcoord) {
                    if (typeof iTexcoord === "undefined") { iTexcoord = 0; }
                    akra.debug.assert(iIndex < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE, "invalid texture slot");

                    var pRmgr = this.getManager();
                    var pTexture = null;

                    this._pTexcoords[iIndex] = iTexcoord;

                    if (iIndex !== iTexcoord) {
                        this._nTexcoordUpdates = 0;
                    }

                    this._nTextureUpdates++;

                    if (akra.isString(texture)) {
                        pTexture = this._pTextures[iIndex];

                        if (pTexture) {
                            //realise first
                            if (pTexture.release() == 0) {
                                this._pTextures[iIndex] = null;
                                //pTexture.destroyResource();
                            } else {
                                akra.debug.warn("cannot destroy resource...");
                            }

                            this._iTextureFlags = akra.bf.clearBit(this._iTextureFlags, iIndex);
                            this._nTotalTextures--;
                        }

                        this._pTextures[iIndex] = pRmgr.getTexturePool().loadResource(texture);

                        if (this._pTextures[iIndex]) {
                            this._iTextureFlags = akra.bf.setBit(this._iTextureFlags, iIndex);

                            ++this._nTotalTextures;

                            this.sync(this._pTextures[iIndex], 1 /* LOADED */);
                        }

                        return true;
                    } else if (texture instanceof resources.Texture) {
                        if (!this._pTextures[iIndex] || pTexture != this._pTextures[iIndex]) {
                            pTexture = texture;
                            if (this._pTextures[iIndex]) {
                                // realise first
                                // DisplayManager.texturePool().releaseResource(this._pTextures[iIndex]);
                                if (this._pTextures[iIndex].release() == 0) {
                                    // this._pTextureMatrices[iIndex].destroyResource();
                                    this._pTextures[iIndex] = null;
                                } else {
                                    akra.debug.warn("cannot destroy resource...");
                                }

                                this._iTextureFlags = akra.bf.clearBit(this._iTextureFlags, iIndex);
                                --this._nTotalTextures;
                            }

                            this._pTextures[iIndex] = pTexture;

                            this._pTextures[iIndex].addRef();
                            this._iTextureFlags = akra.bf.setBit(this._iTextureFlags, iIndex);

                            this._nTotalTextures++;

                            this.sync(this._pTextures[iIndex], 1 /* LOADED */);
                        }

                        return true;
                    } else if (akra.isNumber(texture)) {
                        if (!this._pTextures[iIndex] || this._pTextures[iIndex].getResourceHandle() != texture) {
                            if (this._pTextures[iIndex]) {
                                //TheGameHost.displayManager().texturePool().releaseResource(m_pTextures[index]);
                                if (this._pTextures[iIndex].release() === 0) {
                                    // this._pTextures[iIndex].destroyResource();
                                    this._pTextures[iIndex] = null;
                                } else {
                                    akra.debug.warn("cannot destroy resource...");
                                }

                                this._iTextureFlags = akra.bf.clearBit(this._iTextureFlags, iIndex);
                                --this._nTotalTextures;
                            }

                            this._pTextures[iIndex] = pRmgr.getTexturePool().getResource(texture);

                            if (this._pTextures[iIndex]) {
                                this._iTextureFlags = akra.bf.setBit(this._iTextureFlags, iIndex);
                                ++this._nTotalTextures;
                                this.sync(this._pTextures[iIndex], 1 /* LOADED */);
                            }
                        }

                        return true;
                    }

                    this._pTexcoords[iIndex] = iIndex;

                    return false;
                };

                SurfaceMaterial.prototype.setTextureMatrix = function (iIndex, m4fValue) {
                    akra.debug.assert(iIndex < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE, "invalid texture slot");

                    if (!m4fValue) {
                        this._pTextureMatrices[iIndex] = new Mat4();
                    } else {
                        this._pTextureMatrices[iIndex] = new Mat4(m4fValue);
                    }

                    this._iTextureFlags = akra.bf.setBit(this._iTextureMatrixFlags, iIndex);
                    return true;
                };

                SurfaceMaterial.prototype.isEqual = function (pSurfaceMaterial) {
                    if (this._nTotalTextures === pSurfaceMaterial.getTotalTextures() && this._iTextureFlags === pSurfaceMaterial.getTextureFlags() && this._iTextureMatrixFlags === pSurfaceMaterial.getTextureMatrixFlags()) {
                        if ((this._pMaterial && this._pMaterial.isEqual(pSurfaceMaterial.getMaterial())) || (pSurfaceMaterial.getMaterial() === null)) {
                            for (var i = 0; i < this._pTextures.length; i++) {
                                if (this._pTextures[i] !== pSurfaceMaterial.texture[i]) {
                                    return false;
                                }
                            }
                            ;

                            for (var i = 0; i < this._pTextureMatrices.length; ++i) {
                                for (var j = 0; j < this._pTextureMatrices[i].data.length; j++) {
                                    if (this._pTextureMatrices[i].data[j] !== pSurfaceMaterial.textureMatrix[i].data[j]) {
                                        return false;
                                    }
                                }
                            }

                            return true;
                        }
                    }

                    return false;
                };

                SurfaceMaterial.prototype.texture = function (iSlot) {
                    akra.debug.assert((iSlot >= 0 && iSlot < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE), "invalid texture slot");
                    return this._pTextures[iSlot] || null;
                };

                SurfaceMaterial.prototype.texcoord = function (iSlot) {
                    akra.debug.assert((iSlot >= 0 && iSlot < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE), "invalid texture slot");
                    return this._pTexcoords[iSlot];
                };

                SurfaceMaterial.prototype.textureMatrix = function (iSlot) {
                    akra.debug.assert((iSlot >= 0 && iSlot < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE), "invalid texture slot");
                    return this._pTextureMatrices[iSlot];
                };

                SurfaceMaterial.MAX_TEXTURES_PER_SURFACE = 16;
                return SurfaceMaterial;
            })(pool.ResourcePoolItem);
            resources.SurfaceMaterial = SurfaceMaterial;
        })(pool.resources || (pool.resources = {}));
        var resources = pool.resources;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="../idl/IAFXAttributeBlendContainer.ts" />
/// <reference path="../pool/resources/SurfaceMaterial.ts" />
var akra;
(function (akra) {
    (function (fx) {
        var SurfaceMaterial = akra.pool.resources.SurfaceMaterial;

        var TexcoordSwapper = (function () {
            function TexcoordSwapper() {
                this._pTmpToTex = null;
                this._pTexToTmp = null;
                this._pTexcoords = null;
                this._sTmpToTexCode = "";
                this._sTexToTmpCode = "";
                this._iMaxTexcoords = 0;
                this._iMaxTexcoords = SurfaceMaterial.MAX_TEXTURES_PER_SURFACE;
                this._pTmpToTex = new Array(this._iMaxTexcoords);
                this._pTexToTmp = new Array(this._iMaxTexcoords);
                this._pTexcoords = new Array(this._iMaxTexcoords);
            }
            TexcoordSwapper.prototype.getTmpDeclCode = function () {
                return this._sTexToTmpCode;
            };

            TexcoordSwapper.prototype.getTecoordSwapCode = function () {
                return this._sTmpToTexCode;
            };

            TexcoordSwapper.prototype.clear = function () {
                for (var i = 0; i < this._iMaxTexcoords; i++) {
                    this._pTmpToTex[i] = "";
                    this._pTexToTmp[i] = "";
                    this._pTexcoords[i] = 0;
                }

                this._sTmpToTexCode = "";
                this._sTexToTmpCode = "";
            };

            TexcoordSwapper.prototype.generateSwapCode = function (pMaterial, pAttrConatiner) {
                this.clear();

                if (akra.isNull(pMaterial)) {
                    return;
                }

                //TODO: do it faster in one for
                var pTexcoords = this._pTexcoords;

                for (var i = 0; i < this._iMaxTexcoords; i++) {
                    var iTexcoord = pMaterial.texcoord(i);

                    if (iTexcoord !== i && pAttrConatiner.hasTexcoord(i)) {
                        var pAttr = pAttrConatiner.getTexcoordVar(i);

                        this._pTexToTmp[i] = pAttr._getType()._getBaseType()._getRealName() + " " + "T" + i.toString() + "=" + pAttr._getRealName() + ";";

                        this._sTexToTmpCode += this._pTexToTmp[i] + "\n";
                    }

                    if (!pAttrConatiner.hasTexcoord(iTexcoord)) {
                        pTexcoords[iTexcoord] = 0;
                    } else {
                        pTexcoords[iTexcoord] = iTexcoord;
                    }
                }

                for (var i = 0; i < this._iMaxTexcoords; i++) {
                    if (pTexcoords[i] !== i && pAttrConatiner.hasTexcoord(i)) {
                        var pAttr = pAttrConatiner.getTexcoordVar(i);

                        if (this._pTexToTmp[pTexcoords[i]] !== "") {
                            this._pTmpToTex[i] = pAttr._getRealName() + "=" + this._pTexToTmp[pTexcoords[i]] + ";";
                        } else {
                            this._pTmpToTex[i] = pAttr._getRealName() + "=" + pAttrConatiner.getTexcoordVar(pTexcoords[i])._getRealName() + ";";
                        }

                        this._sTmpToTexCode += this._pTmpToTex[i] + "\n";
                    }
                }
            };
            return TexcoordSwapper;
        })();
        fx.TexcoordSwapper = TexcoordSwapper;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../idl/IAFXInstruction.ts" />
/// <reference path="../idl/IMap.ts" />
/// <reference path="../logger.ts" />
/// <reference path="../webgl/webgl.ts" />
var akra;
(function (akra) {
    (function (fx) {
        var VariableBlendContainer = (function () {
            function VariableBlendContainer() {
                this._pVarBlendInfoList = null;
                this._pNameToIndexMap = null;
                this._pNameIndexToIndexMap = null;
                this._pVarBlendInfoList = [];
                this._pNameToIndexMap = {};
                this._pNameIndexToIndexMap = {};
            }
            VariableBlendContainer.prototype.getVarsInfo = function () {
                return this._pVarBlendInfoList;
            };

            VariableBlendContainer.prototype.getVarBlenInfo = function (iIndex) {
                return this._pVarBlendInfoList[iIndex];
            };

            VariableBlendContainer.prototype.getVarList = function (iIndex) {
                return this._pVarBlendInfoList[iIndex].varList;
            };

            VariableBlendContainer.prototype.getBlendType = function (iIndex) {
                return this._pVarBlendInfoList[iIndex].blendType;
            };

            VariableBlendContainer.prototype.getKeyIndexByName = function (sName) {
                return akra.isDef(this._pNameToIndexMap[sName]) ? this._pNameToIndexMap[sName] : (this._pNameToIndexMap[sName] = -1);
            };

            VariableBlendContainer.prototype.getKeyIndexByNameIndex = function (iNameIndex) {
                return akra.isDef(this._pNameIndexToIndexMap[iNameIndex]) ? this._pNameIndexToIndexMap[iNameIndex] : (this._pNameIndexToIndexMap[iNameIndex] = -1);
            };

            VariableBlendContainer.prototype.hasVariableWithName = function (sName) {
                return this.getKeyIndexByName(sName) === -1 ? false : true;
            };

            VariableBlendContainer.prototype.hasVariableWithNameIndex = function (iNameIndex) {
                return this.getKeyIndexByNameIndex(iNameIndex) === -1 ? false : true;
            };

            VariableBlendContainer.prototype.hasVariable = function (pVar) {
                return this.hasVariableWithNameIndex(pVar._getNameIndex());
            };

            VariableBlendContainer.prototype.getVariable = function (iIndex) {
                return this._pVarBlendInfoList[iIndex].varList[0];
            };

            VariableBlendContainer.prototype.getVariableByName = function (sName) {
                var iIndex = this.getKeyIndexByName(sName);
                return iIndex === -1 ? null : this.getVariable(iIndex);
            };

            VariableBlendContainer.prototype.getVariableByNameIndex = function (iNameIndex) {
                var iIndex = this.getKeyIndexByNameIndex(iNameIndex);
                return iIndex === -1 ? null : this.getVariable(iIndex);
            };

            VariableBlendContainer.prototype.addVariable = function (pVariable, eBlendMode) {
                var sName = pVariable._getRealName();
                var iNameIndex = pVariable._getNameIndex();
                var iIndex = this.getKeyIndexByNameIndex(iNameIndex);

                if (iIndex === -1) {
                    this._pVarBlendInfoList.push({
                        varList: [pVariable],
                        blendType: pVariable._getType(),
                        name: sName,
                        nameIndex: iNameIndex
                    });

                    iIndex = this._pVarBlendInfoList.length - 1;

                    this._pNameToIndexMap[sName] = iIndex;
                    this._pNameIndexToIndexMap[iNameIndex] = iIndex;

                    return true;
                }

                var pBlendType = this._pVarBlendInfoList[iIndex].blendType._blend(pVariable._getType(), eBlendMode);

                if (pBlendType === this._pVarBlendInfoList[iIndex].blendType) {
                    return true;
                }

                if (akra.isNull(pBlendType)) {
                    akra.logger.error("Could not blend type for variable '" + sName + "'");
                    return false;
                }

                this._pVarBlendInfoList[iIndex].varList.push(pVariable);
                this._pVarBlendInfoList[iIndex].blendType = pBlendType;

                return true;
            };

            VariableBlendContainer.prototype.removeVaribale = function (sName) {
                var iIndex = this.getKeyIndexByName(sName);

                if (iIndex === -1) {
                    return false;
                }

                var iNameIndex = this._pVarBlendInfoList[iIndex].nameIndex;
                this._pNameToIndexMap[sName] = -1;
                this._pNameIndexToIndexMap[iNameIndex] = -1;

                this._pVarBlendInfoList.splice(iIndex, 1);

                this.recalcMaps();
                return true;
            };

            VariableBlendContainer.prototype.getDeclCodeForVar = function (iIndex, bWithInitializer) {
                var pInfo = this._pVarBlendInfoList[iIndex];
                var pType = pInfo.blendType;
                var pVar = this.getVariable(iIndex);

                var sCode = pType._toFinalCode() + " ";
                sCode += pVar._getRealName();

                if (pVar._getType()._isNotBaseArray()) {
                    var iLength = pVar._getType()._getLength();
                    if (iLength === 0) {
                        sCode += "[1]";
                    } else {
                        sCode += "[" + iLength + "]";
                    }
                }

                if (bWithInitializer && pVar._hasInitializer()) {
                    sCode += "=" + pVar._getInitializeExpr()._toFinalCode();
                }

                return sCode;
            };

            VariableBlendContainer.prototype.forEach = function (iIndex, fnModifier) {
                if (iIndex === -1) {
                    return;
                }

                var pVarList = this.getVarList(iIndex);

                for (var i = 0; i < pVarList.length; i++) {
                    fnModifier.call(null, pVarList[i]);
                }
            };

            VariableBlendContainer.prototype.setNameForEach = function (iIndex, sNewRealName) {
                if (iIndex === -1) {
                    return;
                }

                var pVarList = this.getVarList(iIndex);

                for (var i = 0; i < pVarList.length; i++) {
                    pVarList[i]._setRealName(sNewRealName);
                }
            };

            VariableBlendContainer.prototype.recalcMaps = function () {
                for (var i = 0; i < this._pVarBlendInfoList.length; i++) {
                    this._pNameToIndexMap[this._pVarBlendInfoList[i].name] = i;
                    this._pNameIndexToIndexMap[this._pVarBlendInfoList[i].nameIndex] = i;
                }
            };
            return VariableBlendContainer;
        })();
        fx.VariableBlendContainer = VariableBlendContainer;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (data) {
        data.Usages = {
            "POSITION": "POSITION",
            "POSITION1": "POSITION1",
            "POSITION2": "POSITION2",
            "POSITION3": "POSITION3",
            "BLENDWEIGHT": "BLENDWEIGHT",
            "BLENDINDICES": "BLENDINDICES",
            "BLENDMETA": "BLENDMETA",
            "NORMAL": "NORMAL",
            "NORMAL1": "NORMAL1",
            "NORMAL2": "NORMAL2",
            "NORMAL3": "NORMAL3",
            "PSIZE": "PSIZE",
            "TEXCOORD": "TEXCOORD",
            "TEXCOORD1": "TEXCOORD1",
            "TEXCOORD2": "TEXCOORD2",
            "TEXCOORD3": "TEXCOORD3",
            "TEXCOORD4": "TEXCOORD4",
            "TEXCOORD5": "TEXCOORD5",
            "TANGENT": "TANGENT",
            "BINORMAL": "BINORMAL",
            "TESSFACTOR": "TESSFACTOR",
            "COLOR": "COLOR",
            "FOG": "FOG",
            "DEPTH": "DEPTH",
            "SAMPLE": "SAMPLE",
            "INDEX": "INDEX",
            "INDEX0": "INDEX0",
            "INDEX1": "INDEX1",
            "INDEX2": "INDEX2",
            "INDEX3": "INDEX3",
            //system indices starts from 10
            "INDEX10": "INDEX10",
            "INDEX11": "INDEX11",
            "INDEX12": "INDEX12",
            "INDEX13": "INDEX13",
            "MATERIAL": "MATERIAL",
            "MATERIAL1": "MATERIAL1",
            "MATERIAL2": "MATERIAL2",
            "DIFFUSE": "DIFFUSE",
            "AMBIENT": "AMBIENT",
            "SPECULAR": "SPECULAR",
            "EMISSIVE": "EMISSIVE",
            "SHININESS": "SHININESS",
            //special semantic for video buffer
            "TEXTURE_HEADER": "TEXTURE_HEADER",
            "UNKNOWN": "UNKNOWN",
            "END": "\a\n\r"
        };
    })(akra.data || (akra.data = {}));
    var data = akra.data;
})(akra || (akra = {}));
/// <reference path="../idl/IAFXInstruction.ts" />
/// <reference path="../idl/IMap.ts" />
/// <reference path="../idl/IRenderer.ts" />
var akra;
(function (akra) {
    /// <reference path="../config/config.ts" />
    /// <reference path="../webgl/webgl.ts" />
    /// <reference path="../logger.ts" />
    /// <reference path="Effect.ts" />
    /// <reference path="VariableBlendContainer.ts" />
    /// <reference path="../data/Usage.ts" />
    (function (fx) {
        var AttributeBlendContainer = (function (_super) {
            __extends(AttributeBlendContainer, _super);
            function AttributeBlendContainer() {
                _super.call(this);
                this._pSlotBySemanticIndex = null;
                this._pTypeInfoBySemanticIndex = null;
                this._pFlowBySlots = null;
                this._pSlotByFlows = null;
                this._pIsPointerBySlot = null;
                this._pVBByBufferSlots = null;
                this._pBufferSlotBySlots = null;
                this._pHashPartList = null;
                this._pOffsetVarsBySemanticMap = null;
                this._pOffsetDefaultMap = null;
                this._nSemantics = 0;
                this._nSlots = 0;
                this._nBufferSlots = 0;
                this._sHash = "";

                this._pSlotBySemanticIndex = null;

                //this._pFlowBySemanticIndex = null;
                var iMaxSlots = 16;
                var iMaxVertexSamplers = 4;

                if (akra.config.WEBGL) {
                    iMaxSlots = akra.webgl.maxVertexAttributes;
                    iMaxVertexSamplers = akra.webgl.maxVertexTextureImageUnits;
                }

                this._pFlowBySlots = new Array(iMaxSlots);
                this._pSlotByFlows = new Array(iMaxSlots);
                this._pIsPointerBySlot = new Array(iMaxSlots);
                this._pVBByBufferSlots = new Array(iMaxVertexSamplers);
                this._pBufferSlotBySlots = new Array(iMaxSlots);
                this._pHashPartList = null;
            }
            AttributeBlendContainer.prototype.getAttrsInfo = function () {
                return this.getVarsInfo();
            };

            AttributeBlendContainer.prototype.getTotalSlots = function () {
                return this._nSlots;
            };

            AttributeBlendContainer.prototype.getTotalBufferSlots = function () {
                return this._nBufferSlots;
            };

            AttributeBlendContainer.prototype.getOffsetVarsBySemantic = function (sName) {
                return this._pOffsetVarsBySemanticMap[sName];
            };

            AttributeBlendContainer.prototype.getOffsetDefault = function (sName) {
                return this._pOffsetDefaultMap[sName];
            };

            AttributeBlendContainer.prototype.getSlotBySemanticIndex = function (iIndex) {
                return this._pSlotBySemanticIndex[iIndex];
            };

            AttributeBlendContainer.prototype.getBufferSlotBySemanticIndex = function (iIndex) {
                return this._pBufferSlotBySlots[this.getSlotBySemanticIndex(iIndex)];
            };

            AttributeBlendContainer.prototype.getAttributeListBySemanticIndex = function (iIndex) {
                return this.getVarList(iIndex);
            };

            AttributeBlendContainer.prototype.getTypeForShaderAttributeBySemanticIndex = function (iIndex) {
                return this._pIsPointerBySlot[this.getSlotBySemanticIndex(iIndex)] ? fx.Effect.getSystemType("ptr") : this.getTypeBySemanticIndex(iIndex)._getBaseType();
            };

            AttributeBlendContainer.prototype.getTypeBySemanticIndex = function (iIndex) {
                return this.getBlendType(iIndex);
            };

            AttributeBlendContainer.prototype.addAttribute = function (pVariable) {
                return this.addVariable(pVariable, 2 /* k_Attribute */);
            };

            AttributeBlendContainer.prototype.hasAttrWithSemantic = function (sSemantic) {
                return this.hasVariableWithName(sSemantic);
            };

            AttributeBlendContainer.prototype.getAttributeBySemanticIndex = function (iIndex) {
                return this.getVariable(iIndex);
            };

            AttributeBlendContainer.prototype.getAttributeBySemantic = function (sSemantic) {
                return this.getVariableByName(sSemantic);
            };

            AttributeBlendContainer.prototype.hasTexcoord = function (iSlot) {
                return this.hasAttrWithSemantic(akra.data.Usages.TEXCOORD + iSlot.toString());
            };

            AttributeBlendContainer.prototype.getTexcoordVar = function (iSlot) {
                return this.getVariableByName(akra.data.Usages.TEXCOORD + iSlot.toString());
            };

            AttributeBlendContainer.prototype.finalize = function () {
                this._nSemantics = this.getAttrsInfo().length;

                this._pSlotBySemanticIndex = new Array(this._nSemantics);
                this._pTypeInfoBySemanticIndex = new Array(this._nSemantics);

                for (var i = 0; i < this._nSemantics; i++) {
                    this._pSlotBySemanticIndex[i] = -1;
                    this._pTypeInfoBySemanticIndex[i] = this.createTypeInfo(i);
                }

                for (var i = 0; i < this._pFlowBySlots.length; i++) {
                    this._pFlowBySlots[i] = -1;
                    this._pSlotByFlows[i] = -1;
                    this._pIsPointerBySlot[i] = false;
                    this._pBufferSlotBySlots[i] = -1;
                }

                for (var i = 0; i < this._pVBByBufferSlots.length; i++) {
                    this._pVBByBufferSlots[i] = 0;
                }
            };

            AttributeBlendContainer.prototype.clear = function () {
                this._nSlots = 0;
                this._nBufferSlots = 0;

                this._sHash = "";
            };

            AttributeBlendContainer.prototype.generateOffsetMap = function () {
                this._pOffsetVarsBySemanticMap = {};
                this._pOffsetDefaultMap = {};

                var pAttrs = this.getAttrsInfo();

                for (var i = 0; i < pAttrs.length; i++) {
                    var pAttrInfo = pAttrs[i];
                    var sSemantic = pAttrInfo.name;
                    var pAttr = this.getAttributeBySemanticIndex(i);

                    if (pAttr._isPointer()) {
                        this._pOffsetVarsBySemanticMap[sSemantic] = [];
                        if (pAttr._getType()._isComplex()) {
                            var pAttrSubDecls = pAttr._getSubVarDecls();

                            for (var j = 0; j < pAttrSubDecls.length; j++) {
                                var pSubDecl = pAttrSubDecls[j];

                                if (pSubDecl._getName() === "offset") {
                                    var sOffsetName = pSubDecl._getRealName();

                                    this._pOffsetVarsBySemanticMap[sSemantic].push(pSubDecl);
                                    this._pOffsetDefaultMap[sOffsetName] = pSubDecl._getParent()._getType()._getPadding();
                                }
                            }
                        } else {
                            var pOffsetVar = pAttr._getType()._getAttrOffset();
                            var sOffsetName = pOffsetVar._getRealName();

                            this._pOffsetVarsBySemanticMap[sSemantic].push(pOffsetVar);
                            this._pOffsetDefaultMap[sOffsetName] = 0;
                        }
                    } else {
                        this._pOffsetVarsBySemanticMap[sSemantic] = null;
                    }
                }
            };

            AttributeBlendContainer.prototype.initFromBufferMap = function (pMap) {
                this.clear();

                if (akra.isNull(pMap)) {
                    akra.logger.critical("Yoy don`t set any buffermap for render");
                    return;
                }

                var pAttrs = this.getAttrsInfo();
                var iHash = 0;

                for (var i = 0; i < pAttrs.length; i++) {
                    var pAttrInfo = pAttrs[i];
                    var sSemantic = pAttrInfo.name;
                    var pTypeInfo = this._pTypeInfoBySemanticIndex[i];

                    var pFindFlow = null;

                    if (pTypeInfo.isComplex) {
                        // pFindFlow = pMap.findFlow(sSemantic) || pMap.getFlow(sSemantic, true);
                        pFindFlow = pMap.findFlow(sSemantic) || pMap.getFlowBySemantic(sSemantic);
                    } else {
                        // pFindFlow = pMap.getFlow(sSemantic, true);
                        pFindFlow = pMap.getFlowBySemantic(sSemantic);
                    }

                    if (!akra.isNull(pFindFlow)) {
                        var iBufferSlot = -1;
                        var iFlow = pFindFlow.flow;
                        var iSlot = this._pSlotByFlows[iFlow];

                        if (pFindFlow.type === 1 /* MAPPABLE */ && iSlot >= 0 && iSlot < this._nSlots && this._pFlowBySlots[iSlot] === iFlow) {
                            this._pSlotBySemanticIndex[i] = iSlot;
                            iHash += ((iSlot + 1) << 5 + (this._pBufferSlotBySlots[iSlot] + 1)) << iSlot;
                            // continue;
                        } else {
                            iSlot = this._nSlots;

                            if (pFindFlow.type === 1 /* MAPPABLE */) {
                                if (!pTypeInfo.isPointer) {
                                    akra.logger.critical("You try to put pointer data into non-pointer attribute with semantic '" + sSemantic + "'");
                                }

                                // iSlot = this._pSlotByFlows[iFlow];
                                // if(iSlot >= 0 && this._pFlowBySlots[iSlot] === iFlow){
                                // 	this._pSlotBySemanticIndex[i] = iSlot;
                                // 	iHash += ((iSlot + 1) << 5 + (this._pBufferSlotBySlots[iSlot] + 1)) << iSlot;
                                // 	continue;
                                // }
                                // iSlot = this._nSlots;
                                var iBuffer = pFindFlow.data.getBuffer().guid;

                                for (var j = 0; j < this._nBufferSlots; j++) {
                                    if (this._pVBByBufferSlots[j] === iBuffer) {
                                        iBufferSlot = j;
                                        break;
                                    }
                                }

                                if (iBufferSlot === -1) {
                                    iBufferSlot = this._nBufferSlots;
                                    this._pVBByBufferSlots[iBufferSlot] = iBuffer;
                                    this._nBufferSlots++;
                                }

                                this._pIsPointerBySlot[iSlot] = true;
                            } else {
                                if (pTypeInfo.isStrictPointer) {
                                    akra.logger.critical("You try to put non-pointer data into pointer attribute with semantic '" + sSemantic + "'");
                                }

                                this._pIsPointerBySlot[iSlot] = false;
                            }

                            //new slot
                            this._pSlotBySemanticIndex[i] = iSlot;
                            this._pFlowBySlots[iSlot] = iFlow;
                            this._pSlotByFlows[iFlow] = iSlot;
                            this._pBufferSlotBySlots[iSlot] = iBufferSlot;

                            iHash += ((iSlot + 1) << 5 + (iBufferSlot + 1)) << iSlot;
                            this._nSlots++;
                        }
                    } else {
                        this._pSlotBySemanticIndex[i] = -1;
                    }
                }

                this._sHash = iHash.toString();
            };

            AttributeBlendContainer.prototype.getHash = function () {
                return this._sHash;
            };

            AttributeBlendContainer.prototype.createTypeInfo = function (iIndex) {
                return {
                    isComplex: this.getTypeBySemanticIndex(iIndex)._isComplex(),
                    isPointer: this.getTypeBySemanticIndex(iIndex)._isPointer(),
                    isStrictPointer: this.getTypeBySemanticIndex(iIndex)._isStrictPointer()
                };
            };
            return AttributeBlendContainer;
        })(fx.VariableBlendContainer);
        fx.AttributeBlendContainer = AttributeBlendContainer;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../idl/IAFXInstruction.ts" />
/// <reference path="../logger.ts" />
var akra;
(function (akra) {
    /// <reference path="VariableBlendContainer.ts" />
    /// <reference path="instructions/ComplexTypeInstruction.ts" />
    (function (fx) {
        var ComplexTypeBlendContainer = (function () {
            function ComplexTypeBlendContainer() {
                this._pTypeListMap = null;
                this._pTypeKeys = null;
                this._pTypeListMap = {};
                this._pTypeKeys = [];
            }
            ComplexTypeBlendContainer.prototype.getKeys = function () {
                return this._pTypeKeys;
            };

            ComplexTypeBlendContainer.prototype.getTypes = function () {
                return this._pTypeListMap;
            };

            ComplexTypeBlendContainer.prototype.addComplexType = function (pComplexType) {
                var pFieldList = pComplexType._getFieldDeclList();
                for (var i = 0; i < pFieldList.length; i++) {
                    if (pFieldList[i]._getType()._isComplex()) {
                        if (!this.addComplexType(pFieldList[i]._getType()._getBaseType())) {
                            return false;
                        }
                    }
                }

                var sName = pComplexType._getRealName();

                if (!akra.isDef(this._pTypeListMap[sName])) {
                    this._pTypeListMap[sName] = pComplexType;
                    this._pTypeKeys.push(sName);

                    return true;
                }

                var pBlendType = this._pTypeListMap[sName]._blend(pComplexType, 6 /* k_TypeDecl */);
                if (akra.isNull(pBlendType)) {
                    akra.logger.error("Could not blend type declaration '" + sName + "'");
                    return false;
                }

                this._pTypeListMap[sName] = pBlendType;

                return true;
            };

            ComplexTypeBlendContainer.prototype.addFromVarConatiner = function (pContainer) {
                if (akra.isNull(pContainer)) {
                    return true;
                }

                var pVarInfoList = pContainer.getVarsInfo();

                for (var i = 0; i < pVarInfoList.length; i++) {
                    var pType = pContainer.getBlendType(i)._getBaseType();

                    if (pType._isComplex()) {
                        if (!this.addComplexType(pType)) {
                            return false;
                        }
                    }
                }

                return true;
            };
            return ComplexTypeBlendContainer;
        })();
        fx.ComplexTypeBlendContainer = ComplexTypeBlendContainer;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../idl/IAFXInstruction.ts" />
/// <reference path="../idl/IMap.ts" />
var akra;
(function (akra) {
    (function (fx) {
        var ExtSystemDataContainer = (function () {
            function ExtSystemDataContainer() {
                this._pExtSystemMacrosList = null;
                this._pExtSystemTypeList = null;
                this._pExtSystemFunctionList = null;
                this._pExtSystemMacrosList = [];
                this._pExtSystemTypeList = [];
                this._pExtSystemFunctionList = [];
            }
            ExtSystemDataContainer.prototype.getMacroses = function () {
                return this._pExtSystemMacrosList;
            };

            ExtSystemDataContainer.prototype.getTypes = function () {
                return this._pExtSystemTypeList;
            };

            ExtSystemDataContainer.prototype.getFunctions = function () {
                return this._pExtSystemFunctionList;
            };

            ExtSystemDataContainer.prototype.addFromFunction = function (pFunction) {
                var pTypes = pFunction._getExtSystemTypeList();
                var pMacroses = pFunction._getExtSystemMacrosList();
                var pFunctions = pFunction._getExtSystemFunctionList();

                if (!akra.isNull(pTypes)) {
                    for (var j = 0; j < pTypes.length; j++) {
                        if (this._pExtSystemTypeList.indexOf(pTypes[j]) === -1) {
                            this._pExtSystemTypeList.push(pTypes[j]);
                        }
                    }
                }

                if (!akra.isNull(pMacroses)) {
                    for (var j = 0; j < pMacroses.length; j++) {
                        if (this._pExtSystemMacrosList.indexOf(pMacroses[j]) === -1) {
                            this._pExtSystemMacrosList.push(pMacroses[j]);
                        }
                    }
                }

                if (!akra.isNull(pFunctions)) {
                    for (var j = 0; j < pFunctions.length; j++) {
                        if (this._pExtSystemFunctionList.indexOf(pFunctions[j]) === -1) {
                            this._pExtSystemFunctionList.push(pFunctions[j]);
                        }
                    }
                }
            };
            return ExtSystemDataContainer;
        })();
        fx.ExtSystemDataContainer = ExtSystemDataContainer;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../idl/IAFXMaker.ts" />
/// <reference path="../idl/IAFXComposer.ts" />
/// <reference path="../idl/IResourcePoolManager.ts" />
/// <reference path="../idl/IShaderInput.ts" />
/// <reference path="../idl/IShaderProgram.ts" />
var akra;
(function (akra) {
    /// <reference path="../config/config.ts" />
    /// <reference path="../webgl/webgl.ts" />
    /// <reference path="../logger.ts" />
    /// <reference path="../render/render.ts" />
    /// <reference path="../debug.ts" />
    /// <reference path="../math/math.ts" />
    /// <reference path="instructions/Instruction.ts" />
    /// <reference path="VariableContainer.ts" />
    /// <reference path="SamplerBlender.ts" />
    /// <reference path="../util/ObjectArray.ts" />
    (function (fx) {
        var Vec2 = akra.math.Vec2;
        var Vec3 = akra.math.Vec3;
        var Vec4 = akra.math.Vec4;
        var Mat3 = akra.math.Mat3;
        var Mat4 = akra.math.Mat4;

        var ObjectArray = akra.util.ObjectArray;

        

        function createShaderUniformInfo(sName, iLocation, pWebGLLocation) {
            if (typeof pWebGLLocation === "undefined") { pWebGLLocation = null; }
            return {
                name: sName,
                location: iLocation,
                webGLLocation: pWebGLLocation,
                type: 0 /* k_NotVar */,
                length: 0,
                applyFunction: null,
                //applyFunctionName: "",
                defaultValue: null,
                lastValue: null
            };
        }

        function createShaderAttrInfo(sName, iLocation) {
            return {
                name: sName,
                location: iLocation,
                semantic: "",
                isMappable: false,
                isComplex: false,
                vertexTextureInfo: null,
                offsets: null
            };
        }

        function createShaderAttrOffsetInfo(sSemantic, pShaderUniformInfo, fDefault) {
            return {
                semantic: sSemantic,
                shaderVarInfo: pShaderUniformInfo,
                defaultValue: fDefault
            };
        }

        function createInputUniformInfo(sName, iNameIndex, pShaderUniformInfo, isComplex) {
            return {
                name: sName,
                nameIndex: iNameIndex,
                isComplex: isComplex,
                isCollapsedArray: false,
                shaderVarInfo: pShaderUniformInfo,
                structVarInfo: null
            };
        }

        // function createUniformStructFieldInfo(sName: string, sShaderName: string,
        // 							  eType: EAFXShaderVariableType, iLength: uint): AIUniformStructInfo {
        // 	return <AIUniformStructInfo>{
        // 		name: sName,
        // 		shaderName: sShaderName,
        // 		type: eType,
        // 		length: iLength
        // 	};
        // }
        function createUniformStructFieldInfo(sName, isComplex, isArray) {
            return {
                name: sName,
                isComplex: isComplex,
                isArray: isArray,
                index: -1,
                fields: null,
                shaderVarInfo: null
            };
        }

        var Maker = (function () {
            function Maker(pComposer, pPassBlend) {
                this.guid = akra.guid();
                this._pComposer = null;
                this._pPassBlend = null;
                this._pShaderProgram = null;
                this._pRealUniformNameList = null;
                this._pRealAttrNameList = null;
                // is really exists uniform & attr?
                this._pUniformExistMap = {};
                this._pAttrExistMap = {};
                this._isUsedZero2D = false;
                this._isUsedZeroCube = false;
                // private _pAttrContainer: AttributeBlendContainer = null;
                //стек объектов храняих все юниформы и аттрибуты
                this._pDataPoolArray = new ObjectArray();
                this._pShaderUniformInfoMap = null;
                this._pShaderAttrInfoMap = null;
                this._pShaderUniformInfoList = null;
                this._pShaderAttrInfoList = null;
                this._pInputUniformInfoList = null;
                this._pInputSamplerInfoList = null;
                this._pInputSamplerArrayInfoList = null;
                this._pUnifromInfoForStructFieldMap = null;
                //if(has("PROFILE_MAKE")) {
                this._pMakeTime = [0., 0., 0., 0., 0.];
                this._iCount = 0;
                this._pComposer = pComposer;
                this._pPassBlend = pPassBlend;
            }
            Maker.prototype.isArray = function (sName) {
                return this.getLength(sName) > 0;
            };

            Maker.prototype.getType = function (sName) {
                return this._pShaderUniformInfoMap[sName].type;
            };

            Maker.prototype.getLength = function (sName) {
                return this._pShaderUniformInfoMap[sName].length;
            };

            Maker.prototype.getShaderProgram = function () {
                return this._pShaderProgram;
            };

            Maker.prototype.getAttributeInfo = function () {
                return this._pShaderAttrInfoList;
            };

            Maker.prototype.getUniformNames = function () {
                return this._pRealUniformNameList;
            };

            Maker.prototype._create = function (sVertex, sPixel) {
                var pRmgr = this._pComposer.getEngine().getResourceManager();

                // logger.log(this, sVertex, sPixel);
                var pProgram = pRmgr.createShaderProgram(".shader-prorgam-" + this.guid.toString());

                if (!pProgram.create(sVertex, sPixel)) {
                    return false;
                }

                this._pRealUniformNameList = pProgram._getActiveUniformNames();
                this._pRealAttrNameList = pProgram._getActiveAttributeNames();

                this._pShaderUniformInfoList = new Array(this._pRealUniformNameList.length);
                this._pShaderAttrInfoList = new Array(this._pRealAttrNameList.length);

                this._pShaderUniformInfoMap = {};
                this._pShaderAttrInfoMap = {};

                this._pShaderProgram = pProgram;

                for (var i = 0; i < this._pRealUniformNameList.length; i++) {
                    var sUniformName = this._pRealUniformNameList[i];
                    var pUniformInfo;

                    if (akra.config.WEBGL) {
                        pUniformInfo = createShaderUniformInfo(sUniformName, i, pProgram.getWebGLUniformLocation(sUniformName));
                    } else {
                        pUniformInfo = createShaderUniformInfo(sUniformName, i);
                    }

                    this._pUniformExistMap[sUniformName] = true;
                    this._pShaderUniformInfoList[i] = pUniformInfo;
                    this._pShaderUniformInfoMap[sUniformName] = pUniformInfo;
                }

                for (var i = 0; i < this._pRealAttrNameList.length; i++) {
                    var sAttrName = this._pRealAttrNameList[i];
                    var pAttrInfo = createShaderAttrInfo(sAttrName, i);

                    this._pAttrExistMap[sAttrName] = true;
                    this._pShaderAttrInfoList[i] = pAttrInfo;
                    this._pShaderAttrInfoMap[sAttrName] = pAttrInfo;
                }

                this._pUnifromInfoForStructFieldMap = {};

                if (akra.config.DEBUG) {
                    this["sVertex"] = sVertex;
                    this["sPixel"] = sPixel;
                }

                // logger.log(sVertex, sPixel);
                return true;
            };

            Maker.prototype._getShaderInput = function () {
                return this._pDataPoolArray.getLength() > 0 ? this._pDataPoolArray.pop() : this._createDataPool();
            };

            Maker.prototype._releaseShaderInput = function (pPool) {
                this._pDataPoolArray.push(pPool);
            };

            Maker.prototype.isUniformExists = function (sName) {
                return this._pUniformExistMap[sName] ? true : this._pUniformExistMap[sName] = false;
            };

            Maker.prototype.isAttrExists = function (sName) {
                return this._pAttrExistMap[sName] ? true : this._pAttrExistMap[sName] = false;
            };

            Maker.prototype._createDataPool = function () {
                var pInput = {
                    uniforms: {},
                    attrs: {},
                    renderStates: akra.render.createRenderStateMap()
                };

                for (var i = 0; i < this._pShaderUniformInfoList.length; i++) {
                    var pUniformInfo = this._pShaderUniformInfoList[i];

                    pInput.uniforms[i] = null;

                    if ((pUniformInfo.type === 18 /* k_Sampler2D */ || pUniformInfo.type === 19 /* k_SamplerCUBE */)) {
                        if (pUniformInfo.length > 0) {
                            pInput.uniforms[i] = new Array(pUniformInfo.length);

                            for (var j = 0; j < pUniformInfo.length; j++) {
                                pInput.uniforms[i][j] = akra.render.createSamplerState();
                            }
                        } else {
                            pInput.uniforms[i] = akra.render.createSamplerState();
                        }
                    }
                }

                for (var i = 0; i < this._pShaderAttrInfoList.length; i++) {
                    pInput.attrs[i] = null;
                }

                return pInput;
            };

            Maker.prototype.setUniform = function (iLocation, pValue) {
                if (this._pShaderUniformInfoList[iLocation].type !== 0 /* k_NotVar */) {
                    if (akra.config.WEBGL) {
                        var pUniformInfo = this._pShaderUniformInfoList[iLocation];
                        var pApplyValue = pValue || pUniformInfo.defaultValue;

                        if (pUniformInfo.lastValue !== pApplyValue) {
                            if (pUniformInfo.length === 0 && (pUniformInfo.type === 18 /* k_Sampler2D */ || pUniformInfo.type === 19 /* k_SamplerCUBE */)) {
                                if (akra.isNull(pUniformInfo.lastValue) || pUniformInfo.lastValue.texture !== pApplyValue.texture || pUniformInfo.lastValue.wrap_s !== pApplyValue.wrap_s || pUniformInfo.lastValue.warp_t !== pApplyValue.warp_t || pUniformInfo.lastValue.mag_filter !== pApplyValue.mag_filter || pUniformInfo.lastValue.min_filter !== pApplyValue.min_filter) {
                                    pUniformInfo.applyFunction.call(this._pShaderProgram, pUniformInfo.webGLLocation, pApplyValue);
                                }
                            } else {
                                pUniformInfo.applyFunction.call(this._pShaderProgram, pUniformInfo.webGLLocation, pApplyValue);
                            }

                            pUniformInfo.lastValue = pApplyValue;
                        }
                        //this._pShaderProgram[this._pShaderUniformInfoList[iLocation].applyFunctionName](this._pShaderUniformInfoList[iLocation].webGLLocation,
                        //	pValue || this._pShaderUniformInfoList[iLocation].defaultValue);
                    } else {
                        this._pShaderUniformInfoList[iLocation].applyFunction.call(this._pShaderProgram, this._pShaderUniformInfoList[iLocation].name, pValue || this._pShaderUniformInfoList[iLocation].defaultValue);
                        //this._pShaderProgram[this._pShaderUniformInfoList[iLocation].applyFunctionName](this._pShaderUniformInfoList[iLocation].name,
                        //	pValue || this._pShaderUniformInfoList[iLocation].defaultValue);
                    }
                }
            };

            Maker.prototype._freeUniformCache = function () {
                for (var i = 0; i < this._pShaderUniformInfoList.length; i++) {
                    this._pShaderUniformInfoList[i].lastValue = null;
                }
            };

            Maker.prototype._initInput = function (pPassInput, pBlend, pAttrs) {
                /* Initialize info about uniform variables(not samplers and video buffers) */
                var pUniformKeys = pPassInput.uniformKeys;
                this._pInputUniformInfoList = [];

                for (var i = 0; i < pUniformKeys.length; i++) {
                    var iNameIndex = pUniformKeys[i];
                    var sName = pPassInput._getUniformVarNameByIndex(iNameIndex);
                    var eType = pPassInput._getUniformType(iNameIndex);
                    var iLength = pPassInput._getUniformLength(iNameIndex);
                    var isArray = (iLength > 0);

                    var pInputUniformInfo = null;

                    if (eType === 22 /* k_Complex */) {
                        var pStructInfo = this.expandStructUniforms(pPassInput._getUniformVar(iNameIndex));
                        if (!akra.isNull(pStructInfo)) {
                            pInputUniformInfo = createInputUniformInfo(sName, iNameIndex, null, true);
                            pInputUniformInfo.structVarInfo = pStructInfo;
                            this._pInputUniformInfoList.push(pInputUniformInfo);
                        }
                    } else {
                        var sShaderName = isArray ? (sName + "[0]") : sName;

                        if (!this.isUniformExists(sShaderName)) {
                            continue;
                        }

                        var pShaderUniformInfo = this._pShaderUniformInfoMap[sShaderName];

                        pShaderUniformInfo.type = eType;
                        pShaderUniformInfo.length = iLength;

                        pInputUniformInfo = createInputUniformInfo(sName, iNameIndex, pShaderUniformInfo, false);
                        this._pInputUniformInfoList.push(pInputUniformInfo);
                    }
                }

                /* Initialize info about samplers*/
                var iTotalSamplerSlots = pBlend.getTotalActiveSlots();
                this._pInputSamplerInfoList = [];

                for (var i = 0; i < iTotalSamplerSlots; i++) {
                    var pShaderUniformInfo = null;
                    var pInputUniformInfo = null;

                    if (i === fx.SamplerBlender.ZERO_SLOT) {
                        this._isUsedZero2D = this.isUniformExists("as0");
                        this._isUsedZeroCube = this.isUniformExists("asc0");

                        if (this._isUsedZero2D) {
                            pShaderUniformInfo = this._pShaderUniformInfoMap["as0"];

                            pShaderUniformInfo.type = 4 /* k_Int */;
                            pShaderUniformInfo.length = 0;
                        }

                        if (this._isUsedZeroCube) {
                            pShaderUniformInfo = this._pShaderUniformInfoMap["asc0"];

                            pShaderUniformInfo.type = 4 /* k_Int */;
                            pShaderUniformInfo.length = 0;
                        }

                        continue;
                    }

                    var sRealSamplerName = "as" + i.toString();

                    if (!this.isUniformExists(sRealSamplerName)) {
                        continue;
                    }

                    var pSampler = pBlend.getSamplersBySlot(i).value(0);
                    var sSampler = pSampler._getSemantic() || pSampler._getName();
                    var iNameIndex = pPassInput._getUniformVarNameIndex(sSampler);
                    var eType = pSampler._getType()._isSampler2D() ? 18 /* k_Sampler2D */ : 19 /* k_SamplerCUBE */;

                    pShaderUniformInfo = this._pShaderUniformInfoMap[sRealSamplerName];

                    pShaderUniformInfo.type = eType;
                    pShaderUniformInfo.length = 0;

                    pInputUniformInfo = createInputUniformInfo(sSampler, iNameIndex, pShaderUniformInfo, false);
                    pInputUniformInfo.isCollapsedArray = (pSampler._getType()._getLength() > 0);

                    this._pInputSamplerInfoList.push(pInputUniformInfo);
                }

                /* Initialize info about array of samplers */
                var pSamplerArrayKeys = pPassInput.samplerArrayKeys;
                this._pInputSamplerArrayInfoList = [];

                for (var i = 0; i < pSamplerArrayKeys.length; i++) {
                    var iNameIndex = pSamplerArrayKeys[i];
                    var sName = pPassInput._getUniformVarNameByIndex(iNameIndex);
                    var eType = pPassInput._getUniformType(iNameIndex);
                    var iLength = pPassInput._getUniformLength(iNameIndex);
                    var sShaderName = sName + "[0]";
                    var pInputUniformInfo = null;

                    if (!this.isUniformExists(sShaderName)) {
                        continue;
                    }

                    var pShaderUniformInfo = this._pShaderUniformInfoMap[sShaderName];

                    pShaderUniformInfo.type = eType;
                    pShaderUniformInfo.length = iLength;

                    pInputUniformInfo = createInputUniformInfo(sName, iNameIndex, pShaderUniformInfo, false);

                    this._pInputSamplerArrayInfoList.push(pInputUniformInfo);
                }

                var pAttrInfoList = pAttrs.getAttrsInfo();

                var nPreparedAttrs = -1;
                var nPreparedBuffers = -1;

                for (var i = 0; i < pAttrInfoList.length; i++) {
                    var iSemanticIndex = i;
                    var pAttrInfo = pAttrInfoList[iSemanticIndex];
                    var sSemantic = pAttrInfo.name;
                    var iSlot = pAttrs.getSlotBySemanticIndex(iSemanticIndex);

                    if (iSlot === -1) {
                        continue;
                    }

                    var iBufferSlot = pAttrs.getBufferSlotBySemanticIndex(iSemanticIndex);

                    // is it not initied attr?
                    if (iSlot > nPreparedAttrs) {
                        var sAttrName = "aa" + iSlot.toString();
                        var sBufferName = "abs" + iBufferSlot.toString();

                        if (!this.isAttrExists(sAttrName)) {
                            continue;
                        }

                        var pShaderAttrInfo = this._pShaderAttrInfoMap[sAttrName];
                        var isMappable = iBufferSlot >= 0;
                        var pVertexTextureInfo = isMappable ? this._pShaderUniformInfoMap[sBufferName] : null;
                        var isComplex = pAttrs.getTypeBySemanticIndex(iSemanticIndex)._isComplex();

                        // need to init buffer
                        if (iBufferSlot > nPreparedBuffers) {
                            if (!this.isUniformExists(sBufferName)) {
                                akra.debug.error("This erroer must not be happen");
                                continue;
                            }

                            pVertexTextureInfo.type = 20 /* k_SamplerVertexTexture */;
                            pVertexTextureInfo.length = 0;
                        }

                        pShaderAttrInfo.semantic = sSemantic;
                        pShaderAttrInfo.isMappable = isMappable;
                        pShaderAttrInfo.isComplex = isComplex;
                        pShaderAttrInfo.vertexTextureInfo = pVertexTextureInfo;

                        nPreparedAttrs++;
                    }

                    //add offset uniforms
                    var pOffsetVars = pAttrs.getOffsetVarsBySemantic(sSemantic);

                    if (!akra.isNull(pOffsetVars)) {
                        var pShaderAttrInfo = this._pShaderAttrInfoList[iSlot];
                        var pOffsetInfoList = pShaderAttrInfo.offsets || new Array();

                        for (var j = 0; j < pOffsetVars.length; j++) {
                            var sOffsetSemantic = pOffsetVars[j]._getSemantic();
                            var sOffsetName = pOffsetVars[j]._getRealName();

                            if (this.isUniformExists(sOffsetName)) {
                                var pOffsetUniformInfo = this._pShaderUniformInfoMap[sOffsetName];
                                var fDefaultValue = pAttrs.getOffsetDefault(sOffsetName);

                                pOffsetUniformInfo.type = 3 /* k_Float */;
                                pOffsetUniformInfo.length = 0;

                                pOffsetInfoList.push(createShaderAttrOffsetInfo(sOffsetSemantic, pOffsetUniformInfo, fDefaultValue));
                            }
                        }

                        pShaderAttrInfo.offsets = pOffsetInfoList;
                    }
                }

                for (var i = 0; i < this._pShaderUniformInfoList.length; i++) {
                    this.prepareApplyFunctionForUniform(this._pShaderUniformInfoList[i]);
                }

                return true;
            };

            //}
            Maker.prototype._make = function (pPassInput, pBufferMap) {
                var pUniforms = pPassInput.uniforms;
                var pTextures = pPassInput.textures;
                var pSamplers = pPassInput.samplers;
                var pPassInputRenderStates = pPassInput.renderStates;
                var pSamplerArrays = pPassInput.samplerArrays;

                var pInput = this._getShaderInput();

                for (var i = 0; i < this._pInputUniformInfoList.length; i++) {
                    var pInfo = this._pInputUniformInfoList[i];

                    if (pInfo.isComplex) {
                        this.applyStructUniform(pInfo.structVarInfo, pUniforms[pInfo.nameIndex], pInput);
                    } else {
                        pInput.uniforms[pInfo.shaderVarInfo.location] = pUniforms[pInfo.nameIndex];
                    }
                }

                for (var i = 0; i < this._pInputSamplerInfoList.length; i++) {
                    var pInfo = this._pInputSamplerInfoList[i];

                    var pState = null;
                    var pTexture = null;

                    if (pInfo.isCollapsedArray) {
                        pState = pSamplerArrays[pInfo.nameIndex][0];
                    } else {
                        pState = pPassInput._getSamplerState(pInfo.nameIndex);
                    }

                    pTexture = pPassInput._getTextureForSamplerState(pState);

                    this.setSamplerState(pInput.uniforms[pInfo.shaderVarInfo.location], pTexture, pState);
                }

                for (var i = 0; i < this._pInputSamplerArrayInfoList.length; i++) {
                    var pInfo = this._pInputSamplerArrayInfoList[i];

                    var pSamplerStates = pSamplerArrays[pInfo.nameIndex];
                    var pInputStates = pInput.uniforms[pInfo.shaderVarInfo.location];

                    for (var j = 0; j < pInfo.shaderVarInfo.length; j++) {
                        var pTexture = pPassInput._getTextureForSamplerState(pSamplerStates[j]);
                        this.setSamplerState(pInputStates[j], pTexture, pSamplerStates[j]);
                    }
                }

                for (var i = 0; i < this._pShaderAttrInfoList.length; i++) {
                    var pAttrInfo = this._pShaderAttrInfoList[i];
                    var pFlow = pAttrInfo.isComplex ? pBufferMap.findFlow(pAttrInfo.semantic) || pBufferMap.getFlowBySemantic(pAttrInfo.semantic) : pBufferMap.getFlowBySemantic(pAttrInfo.semantic);

                    // pBufferMap.findFlow(pAttrInfo.semantic) || pBufferMap.getFlow(pAttrInfo.semantic, true):
                    // pBufferMap.getFlow(pAttrInfo.semantic, true);
                    pInput.attrs[pAttrInfo.location] = pFlow;

                    if (pAttrInfo.isMappable) {
                        pInput.uniforms[pAttrInfo.vertexTextureInfo.location] = pFlow.data.getBuffer();

                        if (!akra.isNull(pAttrInfo.offsets)) {
                            var pVertexDecl = pFlow.data.getVertexDeclaration();

                            for (var j = 0; j < pAttrInfo.offsets.length; j++) {
                                var pOffsetInfo = pAttrInfo.offsets[j];
                                var pElement = pVertexDecl.findElement(pOffsetInfo.semantic);

                                if (akra.isNull(pElement)) {
                                    pInput.uniforms[pOffsetInfo.shaderVarInfo.location] = pOffsetInfo.defaultValue;
                                } else {
                                    pInput.uniforms[pOffsetInfo.shaderVarInfo.location] = pElement.offset / 4.; /* offset in float */
                                }
                            }
                        }
                    }
                }

                if (this._isUsedZero2D) {
                    pInput.uniforms[this._pShaderUniformInfoMap["as0"].location] = 19;
                }

                if (this._isUsedZeroCube) {
                    pInput.uniforms[this._pShaderUniformInfoMap["asc0"].location] = 19;
                }

                akra.render.mergeRenderStateMap(pPassInputRenderStates, this._pPassBlend._getRenderStates(), pInput.renderStates);

                return pInput;
            };

            Maker.prototype.prepareApplyFunctionForUniform = function (pUniform) {
                if (pUniform.type !== 0 /* k_NotVar */) {
                    pUniform.applyFunction = this.getUniformApplyFunction(pUniform.type, (pUniform.length > 0));

                    //pUniform.applyFunctionName = this.getUniformApplyFunctionName(pUniform.type, (pUniform.length > 0));
                    pUniform.defaultValue = this.getUnifromDefaultValue(pUniform.type, (pUniform.length > 0));
                }
            };

            Maker.prototype.getUniformApplyFunction = function (eType, isArray) {
                if (akra.config.WEBGL) {
                    var pProgram = this._pShaderProgram;
                    if (isArray) {
                        switch (eType) {
                            case 3 /* k_Float */:
                                return pProgram._setFloat32Array;
                            case 4 /* k_Int */:
                                return pProgram._setInt32Array;
                            case 5 /* k_Bool */:
                                return pProgram._setInt32Array;

                            case 6 /* k_Float2 */:
                                return pProgram._setVec2Array;
                            case 7 /* k_Int2 */:
                                return pProgram._setVec2iArray;

                            case 9 /* k_Float3 */:
                                return pProgram._setVec3Array;
                            case 10 /* k_Int3 */:
                                return pProgram._setVec3iArray;

                            case 12 /* k_Float4 */:
                                return pProgram._setVec4Array;
                            case 13 /* k_Int4 */:
                                return pProgram._setVec4iArray;

                            case 16 /* k_Float3x3 */:
                                return pProgram._setMat3Array;
                            case 17 /* k_Float4x4 */:
                                return pProgram._setMat4Array;

                            case 18 /* k_Sampler2D */:
                                return pProgram._setSamplerArray;
                            case 19 /* k_SamplerCUBE */:
                                return pProgram._setSamplerArray;
                            default:
                                akra.logger.critical("Wrong uniform array type (" + eType + ")");
                        }
                    } else {
                        switch (eType) {
                            case 3 /* k_Float */:
                                return pProgram._setFloat;
                            case 4 /* k_Int */:
                                return pProgram._setInt;
                            case 5 /* k_Bool */:
                                return pProgram._setInt;

                            case 6 /* k_Float2 */:
                                return pProgram._setVec2;
                            case 7 /* k_Int2 */:
                                return pProgram._setVec2i;

                            case 9 /* k_Float3 */:
                                return pProgram._setVec3;
                            case 10 /* k_Int3 */:
                                return pProgram._setVec3i;

                            case 12 /* k_Float4 */:
                                return pProgram._setVec4;
                            case 13 /* k_Int4 */:
                                return pProgram._setVec4i;

                            case 16 /* k_Float3x3 */:
                                return pProgram._setMat3;
                            case 17 /* k_Float4x4 */:
                                return pProgram._setMat4;

                            case 18 /* k_Sampler2D */:
                                return pProgram._setSampler;
                            case 19 /* k_SamplerCUBE */:
                                return pProgram._setSampler;
                            case 20 /* k_SamplerVertexTexture */:
                                return pProgram._setVertexBuffer;
                            default:
                                akra.logger.critical("Wrong uniform type (" + eType + ")");
                        }
                    }
                } else {
                    if (isArray) {
                        switch (eType) {
                            case 3 /* k_Float */:
                                return this._pShaderProgram.setFloat32Array;
                            case 4 /* k_Int */:
                                return this._pShaderProgram.setInt32Array;

                            case 6 /* k_Float2 */:
                                return this._pShaderProgram.setVec2Array;
                            case 7 /* k_Int2 */:
                                return this._pShaderProgram.setVec2iArray;

                            case 9 /* k_Float3 */:
                                return this._pShaderProgram.setVec3Array;
                            case 10 /* k_Int3 */:
                                return this._pShaderProgram.setVec3iArray;

                            case 12 /* k_Float4 */:
                                return this._pShaderProgram.setVec4Array;
                            case 13 /* k_Int4 */:
                                return this._pShaderProgram.setVec4iArray;

                            case 16 /* k_Float3x3 */:
                                return this._pShaderProgram.setMat3Array;
                            case 17 /* k_Float4x4 */:
                                return this._pShaderProgram.setMat4Array;

                            case 18 /* k_Sampler2D */:
                                return this._pShaderProgram.setSamplerArray;
                            case 19 /* k_SamplerCUBE */:
                                return this._pShaderProgram.setSamplerArray;
                            default:
                                akra.logger.critical("Wrong uniform array type (" + eType + ")");
                        }
                    } else {
                        switch (eType) {
                            case 3 /* k_Float */:
                                return this._pShaderProgram.setFloat;
                            case 4 /* k_Int */:
                                return this._pShaderProgram.setInt;
                            case 5 /* k_Bool */:
                                return this._pShaderProgram.setInt;

                            case 6 /* k_Float2 */:
                                return this._pShaderProgram.setVec2;
                            case 7 /* k_Int2 */:
                                return this._pShaderProgram.setVec2i;

                            case 9 /* k_Float3 */:
                                return this._pShaderProgram.setVec3;
                            case 10 /* k_Int3 */:
                                return this._pShaderProgram.setVec3i;

                            case 12 /* k_Float4 */:
                                return this._pShaderProgram.setVec4;
                            case 13 /* k_Int4 */:
                                return this._pShaderProgram.setVec4i;

                            case 16 /* k_Float3x3 */:
                                return this._pShaderProgram.setMat3;
                            case 17 /* k_Float4x4 */:
                                return this._pShaderProgram.setMat4;

                            case 18 /* k_Sampler2D */:
                                return this._pShaderProgram.setSampler;
                            case 19 /* k_SamplerCUBE */:
                                return this._pShaderProgram.setSampler;
                            case 20 /* k_SamplerVertexTexture */:
                                return this._pShaderProgram.setVertexBuffer;
                            default:
                                akra.logger.critical("Wrong uniform type (" + eType + ")");
                        }
                    }
                }
            };

            Maker.prototype.getUniformApplyFunctionName = function (eType, isArray) {
                if (akra.config.WEBGL) {
                    var pProgram = this._pShaderProgram;
                    if (isArray) {
                        switch (eType) {
                            case 3 /* k_Float */:
                                return "_setFloat32Array";
                            case 4 /* k_Int */:
                                return "_setInt32Array";
                            case 5 /* k_Bool */:
                                return "_setInt32Array";

                            case 6 /* k_Float2 */:
                                return "_setVec2Array";
                            case 7 /* k_Int2 */:
                                return "_setVec2iArray";

                            case 9 /* k_Float3 */:
                                return "_setVec3Array";
                            case 10 /* k_Int3 */:
                                return "_setVec3iArray";

                            case 12 /* k_Float4 */:
                                return "_setVec4Array";
                            case 13 /* k_Int4 */:
                                return "_setVec4iArray";

                            case 16 /* k_Float3x3 */:
                                return "_setMat3Array";
                            case 17 /* k_Float4x4 */:
                                return "_setMat4Array";

                            case 18 /* k_Sampler2D */:
                                return "_setSamplerArray";
                            case 19 /* k_SamplerCUBE */:
                                return "_setSamplerArray";
                            default:
                                akra.logger.critical("Wrong uniform array type (" + eType + ")");
                        }
                    } else {
                        switch (eType) {
                            case 3 /* k_Float */:
                                return "_setFloat";
                            case 4 /* k_Int */:
                                return "_setInt";
                            case 5 /* k_Bool */:
                                return "_setInt";

                            case 6 /* k_Float2 */:
                                return "_setVec2";
                            case 7 /* k_Int2 */:
                                return "_setVec2i";

                            case 9 /* k_Float3 */:
                                return "_setVec3";
                            case 10 /* k_Int3 */:
                                return "_setVec3i";

                            case 12 /* k_Float4 */:
                                return "_setVec4";
                            case 13 /* k_Int4 */:
                                return "_setVec4i";

                            case 16 /* k_Float3x3 */:
                                return "_setMat3";
                            case 17 /* k_Float4x4 */:
                                return "_setMat4";

                            case 18 /* k_Sampler2D */:
                                return "_setSampler";
                            case 19 /* k_SamplerCUBE */:
                                return "_setSampler";
                            case 20 /* k_SamplerVertexTexture */:
                                return "_setVertexBuffer";
                            default:
                                akra.logger.critical("Wrong uniform type (" + eType + ")");
                        }
                    }
                } else {
                    if (isArray) {
                        switch (eType) {
                            case 3 /* k_Float */:
                                return "setFloat32Array";
                            case 4 /* k_Int */:
                                return "setInt32Array";

                            case 6 /* k_Float2 */:
                                return "setVec2Array";
                            case 7 /* k_Int2 */:
                                return "setVec2iArray";

                            case 9 /* k_Float3 */:
                                return "setVec3Array";
                            case 10 /* k_Int3 */:
                                return "setVec3iArray";

                            case 12 /* k_Float4 */:
                                return "setVec4Array";
                            case 13 /* k_Int4 */:
                                return "setVec4iArray";

                            case 16 /* k_Float3x3 */:
                                return "setMat3Array";
                            case 17 /* k_Float4x4 */:
                                return "setMat4Array";

                            case 18 /* k_Sampler2D */:
                                return "setSamplerArray";
                            case 19 /* k_SamplerCUBE */:
                                return "setSamplerArray";
                            default:
                                akra.logger.critical("Wrong uniform array type (" + eType + ")");
                        }
                    } else {
                        switch (eType) {
                            case 3 /* k_Float */:
                                return "setFloat";
                            case 4 /* k_Int */:
                                return "setInt";
                            case 5 /* k_Bool */:
                                return "setInt";

                            case 6 /* k_Float2 */:
                                return "setVec2";
                            case 7 /* k_Int2 */:
                                return "setVec2i";

                            case 9 /* k_Float3 */:
                                return "setVec3";
                            case 10 /* k_Int3 */:
                                return "setVec3i";

                            case 12 /* k_Float4 */:
                                return "setVec4";
                            case 13 /* k_Int4 */:
                                return "setVec4i";

                            case 16 /* k_Float3x3 */:
                                return "setMat3";
                            case 17 /* k_Float4x4 */:
                                return "setMat4";

                            case 18 /* k_Sampler2D */:
                                return "setSampler";
                            case 19 /* k_SamplerCUBE */:
                                return "setSampler";
                            case 20 /* k_SamplerVertexTexture */:
                                return "setVertexBuffer";
                            default:
                                akra.logger.critical("Wrong uniform type (" + eType + ")");
                        }
                    }
                }
            };

            Maker.prototype.getUnifromDefaultValue = function (eType, isArray) {
                if (isArray) {
                    return null;
                } else {
                    switch (eType) {
                        case 3 /* k_Float */:
                            return 0.;
                        case 4 /* k_Int */:
                            return 0;
                        case 5 /* k_Bool */:
                            return 0;

                        case 6 /* k_Float2 */:
                            return new Vec2(0);
                        case 7 /* k_Int2 */:
                            return new Vec2(0);
                        case 8 /* k_Bool2 */:
                            return new Vec2(0);

                        case 9 /* k_Float3 */:
                            return new Vec3(0);
                        case 10 /* k_Int3 */:
                            return new Vec3(0);
                        case 11 /* k_Bool3 */:
                            return new Vec3(0);

                        case 12 /* k_Float4 */:
                            return new Vec4(0);
                        case 13 /* k_Int4 */:
                            return new Vec4(0);
                        case 14 /* k_Bool4 */:
                            return new Vec4(0);

                        case 16 /* k_Float3x3 */:
                            return new Mat3(0);
                        case 17 /* k_Float4x4 */:
                            return new Mat4(0);

                        case 18 /* k_Sampler2D */:
                            return null;
                        case 19 /* k_SamplerCUBE */:
                            return null;
                        case 20 /* k_SamplerVertexTexture */:
                            return null;
                        default:
                            akra.logger.critical("Wrong uniform type (" + eType + ")");
                    }
                }
            };

            Maker.prototype.setSamplerState = function (pOut, pTexture, pFrom) {
                pOut.texture = pTexture;
                pOut.wrap_s = pFrom.wrap_s;
                pOut.wrap_t = pFrom.wrap_t;
                pOut.mag_filter = pFrom.mag_filter;
                pOut.min_filter = pFrom.min_filter;
            };

            Maker.prototype.expandStructUniforms = function (pVariable, sPrevName) {
                if (typeof sPrevName === "undefined") { sPrevName = ""; }
                var sRealName = pVariable._getRealName();

                if (sPrevName !== "") {
                    sPrevName += "." + sRealName;
                } else {
                    if (!this._pPassBlend._hasUniformWithName(sRealName)) {
                        return null;
                    }

                    sPrevName = sRealName;
                }

                var pVarType = pVariable._getType();
                var pFieldNameList = pVarType._getFieldNameList();
                var isArray = pVarType._isNotBaseArray();
                var iLength = isArray ? pVarType._getLength() : 1;

                if (isArray && (iLength === fx.instructions.Instruction.UNDEFINE_LENGTH || iLength === 0)) {
                    akra.logger.warn("Length of struct '" + sRealName + "' can not be undefined");
                    return null;
                }

                var pStructInfo = createUniformStructFieldInfo(sRealName, true, isArray);
                pStructInfo.fields = new Array();

                var sFieldPrevName = "";
                var pFieldInfoList = null;

                for (var i = 0; i < iLength; i++) {
                    if (isArray) {
                        pFieldInfoList = new Array();
                        sFieldPrevName = sPrevName + "[" + i + "]";
                    } else {
                        pFieldInfoList = pStructInfo.fields;
                        sFieldPrevName = sPrevName;
                    }

                    for (var j = 0; j < pFieldNameList.length; j++) {
                        var sFieldName = pFieldNameList[j];
                        var pField = pVarType._getField(sFieldName);
                        var pFieldInfo = null;

                        if (pField._getType()._isComplex()) {
                            pFieldInfo = this.expandStructUniforms(pField, sFieldPrevName);
                        } else {
                            var sFieldRealName = sFieldPrevName + "." + pField._getRealName();
                            var eFieldType = fx.VariableContainer.getVariableType(pField);
                            var iFieldLength = pField._getType()._getLength();
                            var isFieldArray = pField._getType()._isNotBaseArray();
                            var sFieldShaderName = sFieldRealName;

                            if (isFieldArray) {
                                sFieldShaderName += "[0]";
                            }

                            if (!this.isUniformExists(sFieldShaderName)) {
                                continue;
                            }

                            var pShaderUniformInfo = this._pShaderUniformInfoMap[sFieldShaderName];
                            pShaderUniformInfo.type = eFieldType;
                            pShaderUniformInfo.length = iFieldLength;

                            pFieldInfo = createUniformStructFieldInfo(pField._getRealName(), false, isFieldArray);
                            pFieldInfo.shaderVarInfo = pShaderUniformInfo;
                        }

                        if (!akra.isNull(pFieldInfo)) {
                            pFieldInfoList.push(pFieldInfo);
                        }
                    }

                    if (isArray && pFieldInfoList.length > 0) {
                        var pArrayElementInfo = createUniformStructFieldInfo(sRealName, true, false);
                        pArrayElementInfo.index = i;
                        pArrayElementInfo.fields = pFieldInfoList;

                        pStructInfo.fields.push(pArrayElementInfo);
                    }
                }

                if (pStructInfo.fields.length > 0) {
                    return pStructInfo;
                } else {
                    return null;
                }
            };

            Maker.prototype.applyStructUniform = function (pStructInfo, pValue, pInput) {
                if (!akra.isDefAndNotNull(pValue)) {
                    return;
                }

                if (pStructInfo.isArray) {
                    for (var i = 0; i < pStructInfo.fields.length; i++) {
                        var pFieldInfo = pStructInfo.fields[i];
                        if (akra.isDef(pValue[pFieldInfo.index])) {
                            this.applyStructUniform(pFieldInfo, pValue[pFieldInfo.index], pInput);
                        }
                    }
                } else {
                    for (var i = 0; i < pStructInfo.fields.length; i++) {
                        var pFieldInfo = pStructInfo.fields[i];
                        var pFieldValue = pValue[pFieldInfo.name];

                        if (akra.isDef(pFieldValue)) {
                            if (pFieldInfo.isComplex) {
                                this.applyStructUniform(pFieldInfo, pFieldValue, pInput);
                            } else {
                                pInput.uniforms[pFieldInfo.shaderVarInfo.location] = pFieldValue;
                            }
                        }
                    }
                }
            };

            Maker.prototype.applyUnifromArray = function (sName, eType, pValue) {
                switch (eType) {
                    case 3 /* k_Float */:
                        this._pShaderProgram.setFloat32Array(sName, pValue);
                        break;
                    case 4 /* k_Int */:
                        this._pShaderProgram.setInt32Array(sName, pValue);
                        break;

                    case 6 /* k_Float2 */:
                        this._pShaderProgram.setVec2Array(sName, pValue);
                        break;
                    case 7 /* k_Int2 */:
                        this._pShaderProgram.setVec2iArray(sName, pValue);
                        break;

                    case 9 /* k_Float3 */:
                        this._pShaderProgram.setVec3Array(sName, pValue);
                        break;
                    case 10 /* k_Int3 */:
                        this._pShaderProgram.setVec3iArray(sName, pValue);
                        break;

                    case 12 /* k_Float4 */:
                        this._pShaderProgram.setVec4Array(sName, pValue);
                        break;
                    case 13 /* k_Int4 */:
                        this._pShaderProgram.setVec4iArray(sName, pValue);
                        break;

                    case 16 /* k_Float3x3 */:
                        this._pShaderProgram.setMat3Array(sName, pValue);
                        break;
                    case 17 /* k_Float4x4 */:
                        this._pShaderProgram.setMat4Array(sName, pValue);
                        break;

                    case 18 /* k_Sampler2D */:
                        this._pShaderProgram.setSamplerArray(sName, pValue);
                        break;
                    case 19 /* k_SamplerCUBE */:
                        this._pShaderProgram.setSamplerArray(sName, pValue);
                        break;

                    default:
                        akra.logger.critical("Wrong uniform array type (" + eType + ") with name " + sName);
                }
            };

            Maker.prototype.applyUniform = function (sName, eType, pValue) {
                switch (eType) {
                    case 3 /* k_Float */:
                        this._pShaderProgram.setFloat(sName, pValue || 0.);
                        break;
                    case 4 /* k_Int */:
                        this._pShaderProgram.setInt(sName, pValue || 0);
                        break;
                    case 5 /* k_Bool */:
                        this._pShaderProgram.setInt(sName, pValue ? 1 : 0);
                        break;

                    case 6 /* k_Float2 */:
                        this._pShaderProgram.setVec2(sName, pValue || Vec2.temp(0));
                        break;
                    case 7 /* k_Int2 */:
                        this._pShaderProgram.setVec2i(sName, pValue || Vec2.temp(0));
                        break;

                    case 9 /* k_Float3 */:
                        this._pShaderProgram.setVec3(sName, pValue || Vec3.temp(0));
                        break;
                    case 10 /* k_Int3 */:
                        this._pShaderProgram.setVec3i(sName, pValue || Vec3.temp(0));
                        break;

                    case 12 /* k_Float4 */:
                        this._pShaderProgram.setVec4(sName, pValue || Vec4.temp(0));
                        break;
                    case 13 /* k_Int4 */:
                        this._pShaderProgram.setVec4i(sName, pValue || Vec4.temp(0));
                        break;

                    case 16 /* k_Float3x3 */:
                        this._pShaderProgram.setMat3(sName, pValue || Mat3.temp(0));
                        break;
                    case 17 /* k_Float4x4 */:
                        this._pShaderProgram.setMat4(sName, pValue || Mat4.temp(0));
                        break;

                    case 18 /* k_Sampler2D */:
                        this._pShaderProgram.setSampler(sName, pValue);
                        break;
                    case 19 /* k_SamplerCUBE */:
                        this._pShaderProgram.setSampler(sName, pValue);
                        break;
                    case 20 /* k_SamplerVertexTexture */:
                        this._pShaderProgram.setVertexBuffer(sName, pValue);
                        break;
                    default:
                        akra.logger.critical("Wrong uniform type (" + eType + ") with name " + sName);
                }
            };
            return Maker;
        })();
        fx.Maker = Maker;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../idl/ERenderStates.ts" />
/// <reference path="../idl/IAFXPassBlend.ts" />
/// <reference path="../idl/IAFXComposer.ts" />
/// <reference path="../idl/ITexture.ts" />
/// <reference path="../idl/IMap.ts" />
var akra;
(function (akra) {
    /// <reference path="../logger.ts" />
    /// <reference path="../render/render.ts" />
    /// <reference path="../util/ObjectArray.ts" />
    /// <reference path="../stringUtils/StringMinifier.ts" />
    /// <reference path="HashTree.ts" />
    /// <reference path="SamplerBlender.ts" />
    /// <reference path="TexcoordSwapper.ts" />
    /// <reference path="AttributeBlendContainer.ts" />
    /// <reference path="ComplexTypeBlendContainer.ts" />
    /// <reference path="ExtSystemDataContainer.ts" />
    /// <reference path="VariableBlendContainer.ts" />
    /// <reference path="SamplerBlender.ts" />
    /// <reference path="Composer.ts" />
    /// <reference path="Effect.ts" />
    /// <reference path="Maker.ts" />
    /// <reference path="../pool/resources/SurfaceMaterial.ts" />
    (function (fx) {
        var StringMinifier = akra.stringUtils.StringMinifier;

        var PassBlend = (function () {
            function PassBlend(pComposer) {
                //UNIQUE();
                this.guid = akra.guid();
                this._pComposer = null;
                this._pFXMakerHashTree = null;
                this._pExtSystemDataV = null;
                this._pComplexTypeContainerV = null;
                this._pForeignContainerV = null;
                this._pUniformContainerV = null;
                this._pSharedContainerV = null;
                this._pGlobalContainerV = null;
                this._pAttributeContainerV = null;
                this._pVaryingContainerV = null;
                this._pVertexOutType = null;
                this._pUsedFunctionListV = null;
                this._pPassFunctionListV = null;
                this._pTextureMapV = null;
                this._pExtSystemDataP = null;
                this._pComplexTypeContainerP = null;
                this._pForeignContainerP = null;
                this._pUniformContainerP = null;
                this._pSharedContainerP = null;
                this._pGlobalContainerP = null;
                this._pVaryingContainerP = null;
                this._pUsedFunctionListP = null;
                this._pPassFunctionListP = null;
                this._pTextureMapP = null;
                this._hasEmptyVertex = true;
                this._hasEmptyPixel = true;
                this._pPassStateMap = null;
                //Code fragments
                // private _isZeroSampler2dV: boolean = false;
                // private _isZeroSamplerCubeV: boolean = false;
                this._sUniformSamplerCodeV = "";
                this._sAttrBufferDeclCode = "";
                this._sAttrDeclCode = "";
                this._sAFXAttrDeclCode = "";
                this._sAttrBufferInitCode = "";
                this._sAFXAttrInitCode = "";
                this._sSystemExtBlockCodeV = "";
                this._sFunctionDefCodeV = "";
                this._sSharedVarCodeV = "";
                this._sVaryingDeclCodeV = "";
                this._sVertexOutDeclCode = "";
                this._sVertexOutToVaryingCode = "";
                this._sPassFunctionCallCodeV = "";
                // private _isZeroSampler2dP: boolean = false;
                // private _isZeroSamplerCubeP: boolean = false;
                this._sUniformSamplerCodeP = "";
                this._sSystemExtBlockCodeP = "";
                this._sFunctionDefCodeP = "";
                this._sSharedVarCodeP = "";
                this._sVaryingDeclCodeP = "";
                this._sPassFunctionCallCodeP = "";
                this._sVertexCode = "";
                this._sPixelCode = "";
                this._pDefaultSamplerBlender = null;
                this._pTexcoordSwapper = null;
                //For speed-up
                this._pSamplerByIdMap = null;
                this._pSamplerIdList = null;
                this._pSamplerArrayByIdMap = null;
                this._pSamplerArrayIdList = null;
                this._pPassInputForeignsHashMap = null;
                this._pPassInputSamplersHashMap = null;
                this._pBufferMapHashMap = null;
                this._pSurfaceMaterialHashMap = null;
                this._isSamplersPrepared = false;
                this._isBufferMapPrepared = false;
                this._isSurfaceMaterialPrepared = false;
                this._pComposer = pComposer;

                this._pFXMakerHashTree = new fx.HashTree();

                this._pExtSystemDataV = new fx.ExtSystemDataContainer();
                this._pComplexTypeContainerV = new fx.ComplexTypeBlendContainer();
                this._pForeignContainerV = new fx.VariableBlendContainer();
                this._pUniformContainerV = new fx.VariableBlendContainer();
                this._pSharedContainerV = new fx.VariableBlendContainer();
                this._pGlobalContainerV = new fx.VariableBlendContainer();
                this._pAttributeContainerV = new fx.AttributeBlendContainer();
                this._pVaryingContainerV = new fx.VariableBlendContainer();
                this._pVertexOutType = fx.Effect.getBaseVertexOutType();
                this._pUsedFunctionListV = [];
                this._pPassFunctionListV = [];
                this._pTextureMapV = {};

                this._pExtSystemDataP = new fx.ExtSystemDataContainer();
                this._pComplexTypeContainerP = new fx.ComplexTypeBlendContainer();
                this._pForeignContainerP = new fx.VariableBlendContainer();
                this._pUniformContainerP = new fx.VariableBlendContainer();
                this._pSharedContainerP = new fx.VariableBlendContainer();
                this._pGlobalContainerP = new fx.VariableBlendContainer();
                this._pVaryingContainerP = new fx.VariableBlendContainer();
                this._pUsedFunctionListP = [];
                this._pPassFunctionListP = [];
                this._pTextureMapP = {};

                this._pDefaultSamplerBlender = fx.Composer.pDefaultSamplerBlender;

                if (akra.isNull(PassBlend.texcoordSwapper)) {
                    PassBlend.texcoordSwapper = new fx.TexcoordSwapper();
                }

                if (akra.isNull(PassBlend.hashMinifier)) {
                    PassBlend.hashMinifier = new StringMinifier();
                }

                this._pTexcoordSwapper = PassBlend.texcoordSwapper;

                this._pPassStateMap = akra.render.createRenderStateMap();

                this._pPassInputForeignsHashMap = {};
                this._pPassInputSamplersHashMap = {};
                this._pBufferMapHashMap = {};
                this._pSurfaceMaterialHashMap = {};
            }
            PassBlend.prototype.initFromPassList = function (pPassList) {
                for (var i = 0; i < pPassList.length; i++) {
                    if (!this.addPass(pPassList[i])) {
                        return false;
                    }
                }

                if (!this.finalizeBlend()) {
                    return false;
                }

                return true;
            };

            PassBlend.prototype.generateFXMaker = function (pPassInput, pSurfaceMaterial, pBuffer) {
                pPassInput.setSurfaceMaterial(pSurfaceMaterial);

                var iForeignPartHash = this.prepareForeigns(pPassInput);
                var iSamplerPartHash = this.prepareSamplers(pPassInput, false);
                var iMaterialPartHash = this.prepareSurfaceMaterial(pSurfaceMaterial, false);
                var iBufferPartHash = this.prepareBufferMap(pBuffer, false);

                this._pFXMakerHashTree.release();
                var pMaker = this._pFXMakerHashTree.next(iForeignPartHash).next(iSamplerPartHash).next(iMaterialPartHash).next(iBufferPartHash).getContent();

                if (akra.isNull(pMaker)) {
                    if (akra.config.DEBUG) {
                        var fTime = akra.time();
                        PassBlend._pStats.totalMakers++;
                    }

                    if (!this._isBufferMapPrepared) {
                        this.prepareBufferMap(pBuffer, true);
                    }

                    if (!this._isSamplersPrepared) {
                        this.prepareSamplers(pPassInput, true);
                    }

                    this.applyForeigns(pPassInput);
                    this.swapTexcoords(pSurfaceMaterial);
                    this.generateShaderCode();
                    this.resetForeigns();

                    if (akra.config.DEBUG) {
                        PassBlend._pStats.shaderCodeGenerationTime += akra.time() - fTime;
                        fTime = akra.time();
                    }

                    pMaker = new fx.Maker(this._pComposer, this);
                    var isCreate = pMaker._create(this._sVertexCode, this._sPixelCode);

                    if (akra.config.DEBUG) {
                        PassBlend._pStats.makerGenerationTime += akra.time() - fTime;
                        fTime = akra.time();
                    }

                    if (!isCreate) {
                        akra.logger.critical("Can not create Maker");
                        return null;
                    }

                    pMaker._initInput(pPassInput, this._pDefaultSamplerBlender, this._pAttributeContainerV);

                    if (akra.config.DEBUG) {
                        PassBlend._pStats.makerInitTime += akra.time() - fTime;
                    }

                    this._pFXMakerHashTree.addContent(pMaker);
                    this._pDefaultSamplerBlender.clear();
                }

                return pMaker;
            };

            PassBlend.prototype._hasUniformWithName = function (sName) {
                return this.hasUniformWithName(sName);
            };

            PassBlend.prototype._hasUniformWithNameIndex = function (iNameIndex) {
                return this.hasUniformWithNameIndex(iNameIndex);
            };

            PassBlend.prototype._getRenderStates = function () {
                return this._pPassStateMap;
            };

            PassBlend.prototype.finalizeBlend = function () {
                if (!this.finalizeBlendForVertex()) {
                    return false;
                }

                if (!this.finalizeBlendForPixel()) {
                    return false;
                }

                this.syncVaryings();
                this.prepareFastObjects();

                return true;
            };

            PassBlend.prototype.syncVaryings = function () {
                var pVarInfoListV = this._pVaryingContainerV.getVarsInfo();
                var pVarForRemoveList = [];

                for (var i = 0; i < pVarInfoListV.length; i++) {
                    if (!this._pVaryingContainerP.hasVariableWithNameIndex(pVarInfoListV[i].nameIndex)) {
                        pVarForRemoveList.push(pVarInfoListV[i].name);
                    }
                }

                for (var i = 0; i < pVarForRemoveList.length; i++) {
                    this._pVaryingContainerV.removeVaribale(pVarForRemoveList[i]);
                }
            };

            PassBlend.prototype.addPass = function (pPass) {
                var pVertex = pPass._getVertexShader();
                var pPixel = pPass._getPixelShader();

                var pForeignMap = null;
                var pGlobalMap = null;
                var pSharedMap = null;
                var pUniformMap = null;
                var pTextureMap = null;
                var pAttributeMap = null;
                var pVaryingMap = null;
                var pComplexTypeMap = null;

                var pForeignKeys = null;
                var pGlobalKeys = null;
                var pSharedKeys = null;
                var pUniformKeys = null;
                var pTextureKeys = null;
                var pAttributeKeys = null;
                var pVaryingKeys = null;
                var pComplexTypeKeys = null;

                var pForeign = null;
                var pGlobal = null;
                var pShared = null;
                var pUniform = null;
                var pTexture = null;
                var pAttribute = null;
                var pVarying = null;
                var pComplexType = null;

                var pUsedFunctionList = null;
                var pUsedFunction = null;

                if (!akra.isNull(pVertex)) {
                    this._hasEmptyVertex = false;

                    //blend system data
                    this._pExtSystemDataV.addFromFunction(pVertex);

                    //blend foreigns
                    pForeignMap = pVertex._getForeignVariableMap();
                    pForeignKeys = pVertex._getForeignVariableKeys();

                    if (!akra.isNull(pForeignKeys)) {
                        for (var i = 0; i < pForeignKeys.length; i++) {
                            pForeign = pForeignMap[pForeignKeys[i]];

                            if (!this._pForeignContainerV.addVariable(pForeign, 3 /* k_Foreign */)) {
                                akra.logger.error("Could not add foreign variable");
                                return false;
                            }
                        }
                    }

                    //blend globals
                    pGlobalMap = pVertex._getGlobalVariableMap();
                    pGlobalKeys = pVertex._getGlobalVariableKeys();

                    if (!akra.isNull(pGlobalKeys)) {
                        for (var i = 0; i < pGlobalKeys.length; i++) {
                            pGlobal = pGlobalMap[pGlobalKeys[i]];

                            if (!this._pGlobalContainerV.addVariable(pGlobal, 4 /* k_Global */)) {
                                akra.logger.error("Could not add global variable");
                                return false;
                            }
                        }
                    }

                    //blend shareds
                    pSharedMap = pVertex._getSharedVariableMap();
                    pSharedKeys = pVertex._getSharedVariableKeys();

                    if (!akra.isNull(pSharedKeys)) {
                        for (var i = 0; i < pSharedKeys.length; i++) {
                            pShared = pSharedMap[pSharedKeys[i]];

                            if (!this._pSharedContainerV.addVariable(pShared, 0 /* k_Shared */)) {
                                akra.logger.error("Could not add shared variable");
                                return false;
                            }
                        }
                    }

                    //TODO: blend uniforms
                    pUniformMap = pVertex._getUniformVariableMap();
                    pUniformKeys = pVertex._getUniformVariableKeys();

                    if (!akra.isNull(pUniformKeys)) {
                        for (var i = 0; i < pUniformKeys.length; i++) {
                            pUniform = pUniformMap[pUniformKeys[i]];

                            if (akra.isNull(pUniform)) {
                                continue;
                            }

                            if (!this._pUniformContainerV.addVariable(pUniform, 1 /* k_Uniform */)) {
                                akra.logger.error("Could not add uniform variable");
                                return false;
                            }
                        }
                    }

                    //TODO: blend textures
                    pTextureMap = pVertex._getTextureVariableMap();
                    pTextureKeys = pVertex._getTextureVariableKeys();

                    if (!akra.isNull(pTextureKeys)) {
                        for (var i = 0; i < pTextureKeys.length; i++) {
                            pTexture = pTextureMap[pTextureKeys[i]];

                            if (akra.isNull(pTexture)) {
                                continue;
                            }

                            this._pTextureMapV[pTexture._getRealName()] = true;
                        }
                    }

                    //TODO: blend attributes
                    pAttributeMap = pVertex._getAttributeVariableMap();
                    pAttributeKeys = pVertex._getAttributeVariableKeys();

                    if (!akra.isNull(pAttributeKeys)) {
                        for (var i = 0; i < pAttributeKeys.length; i++) {
                            pAttribute = pAttributeMap[pAttributeKeys[i]];

                            if (!this._pAttributeContainerV.addAttribute(pAttribute)) {
                                akra.logger.error("Could not add attribute variable");
                                return false;
                            }
                        }
                    }

                    //TODO: blend varyings
                    pVaryingMap = pVertex._getVaryingVariableMap();
                    pVaryingKeys = pVertex._getVaryingVariableKeys();

                    if (!akra.isNull(pVaryingKeys)) {
                        for (var i = 0; i < pVaryingKeys.length; i++) {
                            pVarying = pVaryingMap[pVaryingKeys[i]];

                            if (pVarying._getSemantic() !== "POSITION") {
                                if (!this._pVaryingContainerV.addVariable(pVarying, 5 /* k_Varying */)) {
                                    akra.logger.error("Could not add varying variable");
                                    return false;
                                }
                            }
                        }
                    }

                    //blend used type
                    pComplexTypeMap = pVertex._getUsedComplexTypeMap();
                    pComplexTypeKeys = pVertex._getUsedComplexTypeKeys();

                    if (!akra.isNull(pComplexTypeKeys)) {
                        for (var i = 0; i < pComplexTypeKeys.length; i++) {
                            pComplexType = pComplexTypeMap[pComplexTypeKeys[i]];

                            if (!this._pComplexTypeContainerV.addComplexType(pComplexType)) {
                                akra.logger.error("Could not add type declaration");
                                return false;
                            }
                        }
                    }

                    //blend used functions
                    pUsedFunctionList = pVertex._getUsedFunctionList();

                    if (!akra.isNull(pUsedFunctionList)) {
                        for (var i = 0; i < pUsedFunctionList.length; i++) {
                            pUsedFunction = pUsedFunctionList[i];

                            if (this._pUsedFunctionListV.indexOf(pUsedFunction) === -1) {
                                this._pUsedFunctionListV.push(pUsedFunction);
                            }
                        }
                    }

                    var pVertexOut = pVertex._getReturnType()._getBaseType();

                    if (pVertexOut._isComplex()) {
                        this._pVertexOutType = this._pVertexOutType._blend(pVertexOut, 7 /* k_VertexOut */);
                    }
                    this._pPassFunctionListV.push(pVertex);
                }

                if (!akra.isNull(pPixel)) {
                    this._hasEmptyPixel = false;

                    //blend system data
                    this._pExtSystemDataP.addFromFunction(pPixel);

                    //blend foreigns
                    pForeignMap = pPixel._getForeignVariableMap();
                    pForeignKeys = pPixel._getForeignVariableKeys();

                    if (!akra.isNull(pForeignKeys)) {
                        for (var i = 0; i < pForeignKeys.length; i++) {
                            pForeign = pForeignMap[pForeignKeys[i]];

                            if (!this._pForeignContainerP.addVariable(pForeign, 3 /* k_Foreign */)) {
                                akra.logger.error("Could not add foreign variable");
                                return false;
                            }
                        }
                    }

                    //blend globals
                    pGlobalMap = pPixel._getGlobalVariableMap();
                    pGlobalKeys = pPixel._getGlobalVariableKeys();

                    if (!akra.isNull(pGlobalKeys)) {
                        for (var i = 0; i < pGlobalKeys.length; i++) {
                            pGlobal = pGlobalMap[pGlobalKeys[i]];

                            if (!this._pGlobalContainerP.addVariable(pGlobal, 4 /* k_Global */)) {
                                akra.logger.error("Could not add global variable");
                                return false;
                            }
                        }
                    }

                    //blend shareds
                    pSharedMap = pPixel._getSharedVariableMap();
                    pSharedKeys = pPixel._getSharedVariableKeys();

                    if (!akra.isNull(pSharedKeys)) {
                        for (var i = 0; i < pSharedKeys.length; i++) {
                            pShared = pSharedMap[pSharedKeys[i]];

                            if (!this._pSharedContainerP.addVariable(pShared, 0 /* k_Shared */)) {
                                akra.logger.error("Could not add shared variable");
                                return false;
                            }
                        }
                    }

                    //TODO: blend uniforms
                    pUniformMap = pPixel._getUniformVariableMap();
                    pUniformKeys = pPixel._getUniformVariableKeys();

                    if (!akra.isNull(pUniformKeys)) {
                        for (var i = 0; i < pUniformKeys.length; i++) {
                            pUniform = pUniformMap[pUniformKeys[i]];

                            if (akra.isNull(pUniform)) {
                                continue;
                            }

                            if (!this._pUniformContainerP.addVariable(pUniform, 1 /* k_Uniform */)) {
                                akra.logger.error("Could not add uniform variable");
                                return false;
                            }
                        }
                    }

                    //TODO: blend textures
                    pTextureMap = pPixel._getTextureVariableMap();
                    pTextureKeys = pPixel._getTextureVariableKeys();

                    if (!akra.isNull(pTextureKeys)) {
                        for (var i = 0; i < pTextureKeys.length; i++) {
                            pTexture = pTextureMap[pTextureKeys[i]];

                            if (akra.isNull(pTexture)) {
                                continue;
                            }

                            this._pTextureMapP[pTexture._getRealName()] = true;
                        }
                    }

                    //TODO: blend varyings
                    pVaryingMap = pPixel._getVaryingVariableMap();
                    pVaryingKeys = pPixel._getVaryingVariableKeys();

                    if (!akra.isNull(pVaryingKeys)) {
                        for (var i = 0; i < pVaryingKeys.length; i++) {
                            pVarying = pVaryingMap[pVaryingKeys[i]];

                            if (!this._pVaryingContainerP.addVariable(pVarying, 5 /* k_Varying */)) {
                                akra.logger.error("Could not add varying variable");
                                return false;
                            }
                        }
                    }

                    //blend used type
                    pComplexTypeMap = pPixel._getUsedComplexTypeMap();
                    pComplexTypeKeys = pPixel._getUsedComplexTypeKeys();

                    if (!akra.isNull(pComplexTypeKeys)) {
                        for (var i = 0; i < pComplexTypeKeys.length; i++) {
                            pComplexType = pComplexTypeMap[pComplexTypeKeys[i]];

                            if (!this._pComplexTypeContainerP.addComplexType(pComplexType)) {
                                akra.logger.error("Could not add type declaration");
                                return false;
                            }
                        }
                    }

                    //blend used functions
                    pUsedFunctionList = pPixel._getUsedFunctionList();

                    if (!akra.isNull(pUsedFunctionList)) {
                        for (var i = 0; i < pUsedFunctionList.length; i++) {
                            pUsedFunction = pUsedFunctionList[i];

                            if (this._pUsedFunctionListP.indexOf(pUsedFunction) === -1) {
                                this._pUsedFunctionListP.push(pUsedFunction);
                            }
                        }
                    }

                    this._pPassFunctionListP.push(pPixel);
                }

                akra.render.copyRenderStateMap(pPass._getRenderStates(), this._pPassStateMap);

                return true;
            };

            PassBlend.prototype.finalizeBlendForVertex = function () {
                if (this._hasEmptyVertex) {
                    return true;
                }

                if (!this.finalizeComplexTypeForShader(0 /* k_Vertex */)) {
                    return false;
                }

                this._pAttributeContainerV.finalize();
                this._pAttributeContainerV.generateOffsetMap();

                return true;
            };

            PassBlend.prototype.finalizeBlendForPixel = function () {
                if (this._hasEmptyPixel) {
                    return true;
                }

                if (!this.finalizeComplexTypeForShader(1 /* k_Pixel */)) {
                    return false;
                }

                return true;
            };

            PassBlend.prototype.enableVaringPrefixes = function (eType, bEnabled) {
                var pVars = null;

                if (eType === 0 /* k_Vertex */) {
                    pVars = this._pVaryingContainerV;
                } else {
                    pVars = this._pVaryingContainerP;
                }

                var pVarInfoList = pVars.getVarsInfo();

                for (var i = 0; i < pVarInfoList.length; i++) {
                    var pVarList = pVarInfoList[i].varList;

                    for (var j = 0; j < pVarList.length; j++) {
                        pVarList[j]._markAsVarying(bEnabled);
                    }
                }
            };

            PassBlend.prototype.finalizeComplexTypeForShader = function (eType) {
                var pTypeContainer = null;

                var pUniformContainer = null;
                var pGlobalContainer = null;
                var pSharedContainer = null;
                var pUsedFunctions = null;

                var pAttributeContainer = null;

                if (eType === 0 /* k_Vertex */) {
                    pTypeContainer = this._pComplexTypeContainerV;
                    pUniformContainer = this._pUniformContainerV;
                    pGlobalContainer = this._pGlobalContainerV;
                    pSharedContainer = this._pSharedContainerV;
                    pUsedFunctions = this._pUsedFunctionListV;
                    pAttributeContainer = this._pAttributeContainerV;
                } else if (eType === 1 /* k_Pixel */) {
                    pTypeContainer = this._pComplexTypeContainerP;
                    pUniformContainer = this._pUniformContainerP;
                    pGlobalContainer = this._pGlobalContainerP;
                    pSharedContainer = this._pSharedContainerP;
                    pUsedFunctions = this._pUsedFunctionListP;
                }

                if (!pTypeContainer.addFromVarConatiner(pUniformContainer) || !pTypeContainer.addFromVarConatiner(pGlobalContainer) || !pTypeContainer.addFromVarConatiner(pSharedContainer) || !pTypeContainer.addFromVarConatiner(pAttributeContainer)) {
                    return false;
                }

                for (var i = 0; i < pUsedFunctions.length; i++) {
                    var pReturnBaseType = pUsedFunctions[i]._getReturnType()._getBaseType();
                    if (pReturnBaseType._isComplex()) {
                        if (!pTypeContainer.addComplexType(pReturnBaseType)) {
                            return false;
                        }
                    }
                }

                return true;
            };

            PassBlend.prototype.hasUniformWithName = function (sName) {
                return this._pUniformContainerV.hasVariableWithName(sName) || this._pUniformContainerP.hasVariableWithName(sName);
            };

            PassBlend.prototype.hasUniformWithNameIndex = function (iNameIndex) {
                return this._pUniformContainerV.hasVariableWithNameIndex(iNameIndex) || this._pUniformContainerP.hasVariableWithNameIndex(iNameIndex);
            };

            // private hasUniform(pVar: IAFXVariableDeclInstruction): boolean {
            // 	return this.hasUniformWithName(pVar._getRealName());
            // }
            // private getUniformByName(sName: string): IAFXVariableDeclInstruction {
            // 	return this._pUniformContainerV.getVariableByName(sName) ||
            // 		   this._pUniformContainerP.getVariableByName(sName);
            // }
            PassBlend.prototype.prepareForeigns = function (pPassInput) {
                var iPassInputId = pPassInput.guid;
                var pForignsHashEntry = this._pPassInputForeignsHashMap[iPassInputId];

                if (akra.isDef(pForignsHashEntry) && pForignsHashEntry.modifyMark === pPassInput.getStatesInfo().foreignKey) {
                    return pForignsHashEntry.hash;
                } else {
                    var pForeignValues = pPassInput.foreigns;
                    var sHash = "";
                    var pVarInfoList = this._pForeignContainerV.getVarsInfo();

                    for (var i = 0; i < pVarInfoList.length; i++) {
                        sHash += pForeignValues[pVarInfoList[i].nameIndex].toString() + "%";
                    }

                    pVarInfoList = this._pForeignContainerP.getVarsInfo();

                    for (var i = 0; i < pVarInfoList.length; i++) {
                        sHash += pForeignValues[pVarInfoList[i].nameIndex].toString() + "%";
                    }

                    if (!akra.isDef(pForignsHashEntry)) {
                        pForignsHashEntry = {
                            hash: 0,
                            modifyMark: 0
                        };

                        this._pPassInputForeignsHashMap[iPassInputId] = pForignsHashEntry;
                    }

                    pForignsHashEntry.hash = PassBlend.hashMinifier.minify(sHash);
                    pForignsHashEntry.modifyMark = pPassInput.getStatesInfo().foreignKey;

                    return pForignsHashEntry.hash;
                }
            };

            PassBlend.prototype.prepareSamplers = function (pPassInput, isForce) {
                this._isSamplersPrepared = false;

                var iPassInputId = pPassInput.guid;
                var pSamplersHashEntry = this._pPassInputSamplersHashMap[iPassInputId];

                if (!isForce && akra.isDef(pSamplersHashEntry) && pSamplersHashEntry.modifyMark === pPassInput.getStatesInfo().samplerKey) {
                    return pSamplersHashEntry.hash;
                }

                var pBlender = this._pDefaultSamplerBlender;
                pBlender.clear();

                //Gum samplers
                var pSamplers = pPassInput.samplers;
                var pSamplersId = this._pSamplerIdList;

                for (var i = 0; i < pSamplersId.length; i++) {
                    var pSampler = this._pSamplerByIdMap[pSamplersId[i]];
                    var iNameIndex = pSampler._getNameIndex();

                    var pSamplerState = pSamplers[iNameIndex];
                    var pTexture = pPassInput._getTextureForSamplerState(pSamplerState);

                    if (akra.isNull(pTexture)) {
                        pBlender.addObjectToSlotById(pSampler, fx.SamplerBlender.ZERO_SLOT);
                    } else {
                        pBlender.addTextureSlot(pTexture.guid);
                        pBlender.addObjectToSlotById(pSampler, pTexture.guid);
                    }
                }

                //Gum sampler arrays
                var pSamplerArrays = pPassInput.samplerArrays;
                var pSamplerArraysId = this._pSamplerArrayIdList;

                for (var i = 0; i < pSamplerArraysId.length; i++) {
                    var pSamplerArray = this._pSamplerArrayByIdMap[pSamplerArraysId[i]];
                    var iNameIndex = pSamplerArray._getNameIndex();

                    var pSamplerStateList = pSamplerArrays[iNameIndex];
                    var isNeedToCollapse = true;
                    var pTexture = null;
                    var iLength = pPassInput.samplerArrayLength[iNameIndex];

                    for (var j = 0; j < iLength; j++) {
                        if (j === 0) {
                            pTexture = pPassInput._getTextureForSamplerState(pSamplerStateList[j]);
                        } else {
                            if (pTexture !== pPassInput._getTextureForSamplerState(pSamplerStateList[j])) {
                                isNeedToCollapse = false;
                            }
                        }
                    }

                    if (isNeedToCollapse) {
                        pSamplerArray._setCollapsed(true);

                        if (akra.isNull(pTexture)) {
                            pBlender.addObjectToSlotById(pSamplerArray, fx.SamplerBlender.ZERO_SLOT);
                        } else {
                            pBlender.addTextureSlot(pTexture.guid);
                            pBlender.addObjectToSlotById(pSamplerArray, pTexture.guid);
                        }
                    } else {
                        pSamplerArray._setCollapsed(false);
                    }
                }

                this._isSamplersPrepared = true;

                if (!akra.isDef(pSamplersHashEntry)) {
                    pSamplersHashEntry = {
                        hash: 0,
                        modifyMark: 0
                    };

                    this._pPassInputSamplersHashMap[iPassInputId] = pSamplersHashEntry;
                }

                pSamplersHashEntry.hash = PassBlend.hashMinifier.minify(pBlender.getHash());
                pSamplersHashEntry.modifyMark = pPassInput.getStatesInfo().samplerKey;

                return pSamplersHashEntry.hash;
            };

            PassBlend.prototype.prepareSurfaceMaterial = function (pMaterial, isForce) {
                this._isSurfaceMaterialPrepared = false;

                if (akra.isNull(pMaterial)) {
                    return 0;
                }

                var iMaterialId = pMaterial.guid;
                var pMaterialHashEntry = this._pSurfaceMaterialHashMap[iMaterialId];
                if (akra.isDef(pMaterialHashEntry) && pMaterialHashEntry.modifyMark === pMaterial.getTotalUpdatesOfTexcoords()) {
                    return pMaterialHashEntry.hash;
                } else {
                    var sMaterailHash = "";
                    for (var i = 0; i < akra.pool.resources.SurfaceMaterial.MAX_TEXTURES_PER_SURFACE; i++) {
                        var iTexcoord = pMaterial.texcoord(i);

                        if (i !== iTexcoord) {
                            sMaterailHash += i.toString() + "<" + iTexcoord.toString() + ".";
                        }
                    }

                    var iMaterialHash = PassBlend.hashMinifier.minify(sMaterailHash);

                    if (!akra.isDef(pMaterialHashEntry)) {
                        pMaterialHashEntry = {
                            hash: 0,
                            modifyMark: 0
                        };

                        this._pSurfaceMaterialHashMap[iMaterialId] = pMaterialHashEntry;
                    }

                    pMaterialHashEntry.hash = iMaterialHash;
                    pMaterialHashEntry.modifyMark = pMaterial.getTotalUpdatesOfTexcoords();

                    return iMaterialHash;
                }
            };

            PassBlend.prototype.prepareBufferMap = function (pMap, isForce) {
                this._isBufferMapPrepared = false;

                var iBufferMapHash = 0;

                var iBufferMapId = pMap.guid;
                var pBufferMapHashEntry = this._pBufferMapHashMap[iBufferMapId];

                if (!isForce && akra.isDef(pBufferMapHashEntry) && pBufferMapHashEntry.modifyMark === pMap.getTotalUpdates()) {
                    iBufferMapHash = pBufferMapHashEntry.hash;
                } else {
                    this._pAttributeContainerV.initFromBufferMap(pMap);
                    iBufferMapHash = PassBlend.hashMinifier.minify(this._pAttributeContainerV.getHash());

                    this._isBufferMapPrepared = true;

                    if (!akra.isDef(pBufferMapHashEntry)) {
                        pBufferMapHashEntry = {
                            hash: 0,
                            modifyMark: 0
                        };

                        this._pBufferMapHashMap[iBufferMapId] = pBufferMapHashEntry;
                    }

                    pBufferMapHashEntry.modifyMark = pMap.getTotalUpdates();
                    pBufferMapHashEntry.hash = iBufferMapHash;
                }

                return iBufferMapHash;
            };

            PassBlend.prototype.swapTexcoords = function (pMaterial) {
                this._pTexcoordSwapper.generateSwapCode(pMaterial, this._pAttributeContainerV);
            };

            PassBlend.prototype.isSamplerUsedInShader = function (pSampler, eType) {
                return (eType === 0 /* k_Vertex */ && this._pUniformContainerV.hasVariable(pSampler)) || (eType === 1 /* k_Pixel */ && this._pUniformContainerP.hasVariable(pSampler));
            };

            PassBlend.prototype.applyForeigns = function (pPassInput) {
                var pForeignValues = pPassInput.foreigns;
                var pKeys = pPassInput.foreignKeys;

                var pForeignsV = this._pForeignContainerV;
                var pForeignsP = this._pForeignContainerP;

                for (var i = 0; i < pKeys.length; i++) {
                    var iNameIndex = pKeys[i];
                    var pVarList = null;
                    var iVarBlendIndex = 0;
                    var pValue = pForeignValues[iNameIndex];

                    //if (pValue === 0) {
                    //	pValue = 1;
                    //}
                    iVarBlendIndex = pForeignsV.getKeyIndexByNameIndex(iNameIndex);
                    if (iVarBlendIndex !== -1) {
                        pVarList = pForeignsV.getVarList(iVarBlendIndex);

                        for (var j = 0; j < pVarList.length; j++) {
                            pVarList[j]._setValue(pValue);
                        }
                    }

                    iVarBlendIndex = pForeignsP.getKeyIndexByNameIndex(iNameIndex);
                    if (iVarBlendIndex !== -1) {
                        pVarList = pForeignsP.getVarList(iVarBlendIndex);

                        for (var j = 0; j < pVarList.length; j++) {
                            pVarList[j]._setValue(pValue);
                        }
                    }
                }
            };

            PassBlend.prototype.resetForeigns = function () {
                var pForeignsV = this._pForeignContainerV;
                var pForeignsP = this._pForeignContainerP;

                var pVarInfoList = pForeignsV.getVarsInfo();

                for (var i = 0; i < pVarInfoList.length; i++) {
                    var pVarInfo = pVarInfoList[i];
                    var pVarList = pVarInfo.varList;

                    for (var j = 0; j < pVarList.length; j++) {
                        pVarList[j]._setRealName(pVarInfo.name);
                    }
                }

                var pVarInfoList = pForeignsP.getVarsInfo();

                for (var i = 0; i < pVarInfoList.length; i++) {
                    var pVarInfo = pVarInfoList[i];
                    var pVarList = pVarInfo.varList;

                    for (var j = 0; j < pVarList.length; j++) {
                        pVarList[j]._setRealName(pVarInfo.name);
                    }
                }
            };

            PassBlend.prototype.generateShaderCode = function () {
                this.clearCodeFragments();
                this.reduceSamplers();
                this.reduceAttributes();

                this._sVertexCode = this.generateCodeForVertex();
                this._sPixelCode = this.generateCodeForPixel();

                this.resetSamplerVarsToDefault();
            };

            PassBlend.prototype.generateCodeForVertex = function () {
                var sCode = "";
                var eType = 0 /* k_Vertex */;

                sCode = this.generateSystemExtBlock(eType) + "\n" + this.generateTypeDels(eType) + "\n" + this.generateFunctionDefenitions(eType) + "\n" + this.generateSharedVars(eType) + "\n" + this.generateVertexOut() + "\n";

                this.enableVaringPrefixes(eType, true);
                sCode += this.generateVaryings(eType) + "\n";
                this.enableVaringPrefixes(eType, false);

                sCode += this.generateUniformSamplers(eType) + "\n" + this.generateUniformVars(eType) + "\n" + this.generateAttrBuffers() + "\n" + this.generateGlobalVars(eType) + "\n" + this.generateFunctions(eType) + "\n" + this.generateRealAttrs() + "\n" + this.generateAFXAttrs() + "\n" + this.generatePassFunctions(eType) + "\n" + "void main() {\n" + this.generateAttrBufferInit() + "\n" + this.generateAFXAttrInit() + "\n" + this.generateTexcoordSwap() + "\n" + this.generatePassFunctionCall(eType) + "\n" + this.generateVertexOutToVaryings() + "\n" + "}";

                return sCode;
            };

            PassBlend.prototype.generateCodeForPixel = function () {
                if (this._hasEmptyPixel) {
                    return "void main(){}";
                }

                var sCode = "";
                var eType = 1 /* k_Pixel */;

                this.enableVaringPrefixes(eType, true);

                sCode = this.generateSystemExtBlock(eType) + "\n" + "vec4 resultAFXColor;" + "\n" + this.generateTypeDels(eType) + "\n" + this.generateFunctionDefenitions(eType) + "\n" + this.generateSharedVars(eType) + "\n" + this.generateVaryings(eType) + "\n" + this.generateUniformSamplers(eType) + "\n" + this.generateUniformVars(eType) + "\n" + this.generateGlobalVars(eType) + "\n" + this.generateFunctions(eType) + "\n" + this.generatePassFunctions(eType) + "\n" + "void main() {\n" + this.generatePassFunctionCall(eType) + "\n" + "gl_FragColor = resultAFXColor;" + "\n" + "}";
                this.enableVaringPrefixes(eType, false);

                return sCode;
            };

            PassBlend.prototype.clearCodeFragments = function () {
                this._sUniformSamplerCodeV = "";

                this._sAttrBufferDeclCode = "";
                this._sAttrDeclCode = "";
                this._sAFXAttrDeclCode = "";
                this._sAttrBufferInitCode = "";
                this._sAFXAttrInitCode = "";

                this._sUniformSamplerCodeP = "";
            };

            PassBlend.prototype.reduceSamplers = function () {
                var pSamplerBlender = this._pDefaultSamplerBlender;
                var iTotalSlots = pSamplerBlender.getTotalActiveSlots();

                var sUniformSamplerCodeV = "";
                var sUniformSamplerCodeP = "";

                var isZeroSampler2DV = false;
                var isZeroSamplerCubeV = false;
                var isZeroSampler2DP = false;
                var isZeroSamplerCubeP = false;

                var isInVertex = false;
                var isInPixel = false;

                var sSamplerName = "";

                for (var i = 0; i < iTotalSlots; i++) {
                    var pSamplers = pSamplerBlender.getSamplersBySlot(i);

                    isInVertex = false;
                    isInPixel = false;

                    sSamplerName = "as" + i.toString();

                    for (var j = 0; j < pSamplers.getLength(); j++) {
                        var pSampler = pSamplers.value(j);
                        var iNameIndex = pSampler._getNameIndex();
                        var iIndexForSamplerV = this._pUniformContainerV.getKeyIndexByNameIndex(iNameIndex);
                        var iIndexForSamplerP = this._pUniformContainerP.getKeyIndexByNameIndex(iNameIndex);

                        if (i === fx.SamplerBlender.ZERO_SLOT) {
                            if (iIndexForSamplerV !== -1) {
                                this._pUniformContainerV.forEach(iIndexForSamplerV, PassBlend.fnSamplerReducer);

                                if (pSampler._getType()._isSampler2D()) {
                                    isZeroSampler2DV = true;
                                } else {
                                    isZeroSamplerCubeV = true;
                                    sSamplerName = "asc0";
                                }
                            }

                            if (iIndexForSamplerP !== -1) {
                                this._pUniformContainerP.forEach(iIndexForSamplerP, PassBlend.fnSamplerReducer);

                                if (pSampler._getType()._isSampler2D()) {
                                    isZeroSampler2DP = true;
                                } else {
                                    isZeroSamplerCubeP = true;
                                    sSamplerName = "asc0";
                                }
                            }
                        } else {
                            if (iIndexForSamplerV !== -1) {
                                isInVertex = true;
                            }
                            if (iIndexForSamplerP !== -1) {
                                isInPixel = true;
                            }
                        }

                        this._pUniformContainerV.setNameForEach(iIndexForSamplerV, sSamplerName);
                        this._pUniformContainerP.setNameForEach(iIndexForSamplerP, sSamplerName);
                    }

                    if (i === fx.SamplerBlender.ZERO_SLOT) {
                        if (isZeroSampler2DV) {
                            sUniformSamplerCodeV += "uniform sampler2D as0;";
                        }
                        if (isZeroSamplerCubeV) {
                            sUniformSamplerCodeV += "uniform samplerCube asc0;";
                        }
                        if (isZeroSampler2DP) {
                            sUniformSamplerCodeP += "uniform sampler2D as0;";
                        }
                        if (isZeroSamplerCubeP) {
                            sUniformSamplerCodeP += "uniform samplerCube asc0;";
                        }
                    } else {
                        if (isInVertex) {
                            sUniformSamplerCodeV += "uniform " + pSamplers.value(0)._getType()._getBaseType()._getRealName() + " " + sSamplerName + ";";
                        }

                        if (isInPixel) {
                            sUniformSamplerCodeP += "uniform " + pSamplers.value(0)._getType()._getBaseType()._getRealName() + " " + sSamplerName + ";";
                        }
                    }
                }

                this._sUniformSamplerCodeV = sUniformSamplerCodeV;
                this._sUniformSamplerCodeP = sUniformSamplerCodeP;
            };

            PassBlend.prototype.resetSamplerVarsToDefault = function () {
                var pSamplerBlender = this._pDefaultSamplerBlender;
                var iTotalSlots = pSamplerBlender.getTotalActiveSlots();

                pSamplerBlender.clearSamplerNames();
            };

            PassBlend.fnSamplerReducer = function (pSamplerVar) {
                pSamplerVar._defineByZero(true);
            };

            PassBlend.prototype.reduceAttributes = function () {
                var pAttributeContainer = this._pAttributeContainerV;
                var pAttrInfoList = pAttributeContainer.getAttrsInfo();

                var nPreparedBufferSlots = -1;
                var nPreparedAttributeSlots = -1;

                for (var i = 0; i < pAttrInfoList.length; i++) {
                    var iSemanticIndex = i;
                    var pAttrInfo = pAttrInfoList[iSemanticIndex];
                    var pAttributes = pAttributeContainer.getAttributeListBySemanticIndex(iSemanticIndex);
                    var iSlot = pAttributeContainer.getSlotBySemanticIndex(iSemanticIndex);
                    var iBufferSlot = -1;
                    var sAttrName = "";

                    //1) set buffer maps for shader attribures
                    if (iSlot === -1) {
                        for (var j = 0; j < pAttributes.length; j++) {
                            if (pAttributes[j]._getType()._isStrictPointer()) {
                                pAttributes[j]._getType()._getVideoBuffer()._defineByZero(true);
                            }
                        }
                    } else {
                        iBufferSlot = pAttributeContainer.getBufferSlotBySemanticIndex(iSemanticIndex);

                        sAttrName = "aa" + iSlot.toString();

                        if (iBufferSlot >= 0) {
                            var sSamplerBufferName = "abs" + iBufferSlot.toString();
                            var sHeaderBufferName = "abh" + iBufferSlot.toString();

                            var pBufferVar = null;

                            for (var j = 0; j < pAttributes.length; j++) {
                                pBufferVar = pAttributes[j]._getType()._getVideoBuffer();
                                pBufferVar._setVideoBufferRealName(sSamplerBufferName, sHeaderBufferName);
                            }

                            if (iBufferSlot > nPreparedBufferSlots) {
                                var pBufferVar = pAttributes[0]._getType()._getVideoBuffer();
                                this._sAttrBufferDeclCode += pBufferVar._toFinalCode() + ";\n";
                                this._sAttrBufferInitCode += pBufferVar._getVideoBufferInitExpr()._toFinalCode() + ";\n";
                                nPreparedBufferSlots++;
                            }
                        }

                        //2) gnerate real attrs
                        if (iSlot > nPreparedAttributeSlots) {
                            this._sAttrDeclCode += "attribute " + pAttributeContainer.getTypeForShaderAttributeBySemanticIndex(iSemanticIndex)._toFinalCode() + " " + sAttrName + ";\n";
                            nPreparedAttributeSlots++;
                        }
                    }

                    // 3) add afx attributes
                    var pAttribute = pAttributeContainer.getAttributeBySemanticIndex(iSemanticIndex);
                    var pAttributeType = pAttribute._getType();

                    this._sAFXAttrDeclCode += pAttribute._toFinalCode() + ";\n";

                    if (pAttributeType._isStrictPointer() || (pAttributeType._isPointer() && iBufferSlot >= 0)) {
                        var pAttrSubDecls = pAttribute._getSubVarDecls();

                        for (var j = 0; j < pAttrSubDecls.length; j++) {
                            this._sAFXAttrDeclCode += pAttrSubDecls[j]._toFinalCode() + ";\n";
                        }
                    }

                    if (iSlot >= 0) {
                        if (iBufferSlot >= 0) {
                            this._sAFXAttrInitCode += pAttributeType._getMainPointer()._getRealName() + "=" + sAttrName + ";";
                            this._sAFXAttrInitCode += pAttribute._getAttrExtractionBlock()._toFinalCode();
                        } else {
                            this._sAFXAttrInitCode += pAttribute._getRealName() + "=" + sAttrName + ";";
                        }
                    }
                }
            };

            PassBlend.prototype.generateSystemExtBlock = function (eType) {
                var pExtBlock = null;

                if (eType === 0 /* k_Vertex */) {
                    pExtBlock = this._pExtSystemDataV;
                    if (this._sSystemExtBlockCodeV !== "") {
                        return this._sSystemExtBlockCodeV;
                    }
                } else {
                    pExtBlock = this._pExtSystemDataP;
                    if (this._sSystemExtBlockCodeP !== "") {
                        return this._sSystemExtBlockCodeP;
                    }
                }

                var sCode = "";

                var pMacroses = pExtBlock.getMacroses();
                var pTypes = pExtBlock.getTypes();
                var pFunctions = pExtBlock.getFunctions();

                for (var i = 0; i < pMacroses.length; i++) {
                    sCode += pMacroses[i]._toFinalCode() + "\n";
                }

                for (var i = 0; i < pTypes.length; i++) {
                    sCode += pTypes[i]._toFinalCode() + "\n";
                }

                for (var i = 0; i < pFunctions.length; i++) {
                    sCode += pFunctions[i]._toFinalCode() + "\n";
                }

                if (eType === 0 /* k_Vertex */) {
                    this._sSystemExtBlockCodeV = sCode;
                } else {
                    sCode = "#define AKRA_FRAGMENT 1\n" + "precision highp float;\n" + "#extension GL_OES_standard_derivatives : enable\n" + sCode;
                    this._sSystemExtBlockCodeP = sCode;
                }

                return sCode;
            };

            PassBlend.prototype.generateTypeDels = function (eType) {
                var pTypeBlock = null;

                if (eType === 0 /* k_Vertex */) {
                    pTypeBlock = this._pComplexTypeContainerV;
                } else {
                    pTypeBlock = this._pComplexTypeContainerP;
                }

                var sCode = "";

                var pKeys = pTypeBlock.getKeys();
                var pTypes = pTypeBlock.getTypes();

                for (var i = 0; i < pKeys.length; i++) {
                    sCode += pTypes[pKeys[i]]._toDeclString() + ";\n";
                }

                return sCode;
            };

            PassBlend.prototype.generateFunctionDefenitions = function (eType) {
                var pFunctions = null;

                if (eType === 0 /* k_Vertex */) {
                    pFunctions = this._pUsedFunctionListV;
                    if (this._sFunctionDefCodeV !== "") {
                        return this._sFunctionDefCodeV;
                    }
                } else {
                    pFunctions = this._pUsedFunctionListP;
                    if (this._sFunctionDefCodeP !== "") {
                        return this._sFunctionDefCodeP;
                    }
                }

                var sCode = "";

                for (var i = 0; i < pFunctions.length; i++) {
                    sCode += pFunctions[i]._toFinalDefCode() + ";\n";
                }

                if (eType === 0 /* k_Vertex */) {
                    this._sFunctionDefCodeV = sCode;
                } else {
                    this._sFunctionDefCodeP = sCode;
                }

                return sCode;
            };

            PassBlend.prototype.generateSharedVars = function (eType) {
                var pVars = null;

                if (eType === 0 /* k_Vertex */) {
                    pVars = this._pSharedContainerV;
                    if (this._sSharedVarCodeV !== "") {
                        return this._sSharedVarCodeV;
                    }
                } else {
                    pVars = this._pSharedContainerP;
                    if (this._sSharedVarCodeP !== "") {
                        return this._sSharedVarCodeP;
                    }
                }

                var sCode = "";
                var pVarInfoList = pVars.getVarsInfo();

                for (var i = 0; i < pVarInfoList.length; i++) {
                    sCode += pVars.getDeclCodeForVar(i, true) + ";\n";
                }

                if (eType === 0 /* k_Vertex */) {
                    this._sSharedVarCodeV = sCode;
                } else {
                    this._sSharedVarCodeP = sCode;
                }

                return sCode;
            };

            PassBlend.prototype.generateVertexOut = function () {
                if (this._sVertexOutDeclCode === "") {
                    this._sVertexOutDeclCode = this._pVertexOutType._toDeclString() + " Out;\n";
                }

                return this._sVertexOutDeclCode;
            };

            PassBlend.prototype.generateVaryings = function (eType) {
                var pVars = null;

                if (eType === 0 /* k_Vertex */) {
                    pVars = this._pVaryingContainerV;

                    if (this._sVaryingDeclCodeV !== "") {
                        return this._sVaryingDeclCodeV;
                    }
                } else {
                    pVars = this._pVaryingContainerP;
                    if (this._sVaryingDeclCodeP !== "") {
                        return this._sVaryingDeclCodeP;
                    }
                }

                var sCode = "";
                var pVarInfoList = pVars.getVarsInfo();

                for (var i = 0; i < pVarInfoList.length; i++) {
                    sCode += "varying " + pVars.getDeclCodeForVar(i, false) + ";\n";
                }

                if (eType === 0 /* k_Vertex */) {
                    this._sVaryingDeclCodeV = sCode;
                } else {
                    this._sVaryingDeclCodeP = sCode;
                }

                return sCode;
            };

            PassBlend.prototype.generateUniformSamplers = function (eType) {
                if (eType === 0 /* k_Vertex */) {
                    return this._sUniformSamplerCodeV;
                } else {
                    return this._sUniformSamplerCodeP;
                }
            };

            PassBlend.prototype.generateUniformVars = function (eType) {
                var pVars = null;

                if (eType === 0 /* k_Vertex */) {
                    pVars = this._pUniformContainerV;
                } else {
                    pVars = this._pUniformContainerP;
                }

                var sCode = "";
                var pVarInfoList = pVars.getVarsInfo();

                for (var i = 0; i < pVarInfoList.length; i++) {
                    var pVar = pVars.getVariable(i);
                    var pType = pVars.getBlendType(i);

                    if (pType._isSampler() && (!pType._isArray() || pVar._isDefinedByZero() || pVar._isCollapsed())) {
                        continue;
                    }

                    sCode += "uniform " + pVars.getDeclCodeForVar(i, false) + ";\n";
                }

                return sCode;
            };

            PassBlend.prototype.generateAttrBuffers = function () {
                return this._sAttrBufferDeclCode;
            };

            PassBlend.prototype.generateGlobalVars = function (eType) {
                var pVars = null;

                if (eType === 0 /* k_Vertex */) {
                    pVars = this._pGlobalContainerV;
                } else {
                    pVars = this._pGlobalContainerP;
                }

                var sCode = "";
                var pVarInfoList = pVars.getVarsInfo();

                for (var i = 0; i < pVarInfoList.length; i++) {
                    sCode += pVars.getDeclCodeForVar(i, true) + ";\n";
                }

                return sCode;
            };

            PassBlend.prototype.generateFunctions = function (eType) {
                var pFunctions = null;

                if (eType === 0 /* k_Vertex */) {
                    pFunctions = this._pUsedFunctionListV;
                } else {
                    pFunctions = this._pUsedFunctionListP;
                }

                var sCode = "";

                for (var i = 0; i < pFunctions.length; i++) {
                    sCode += pFunctions[i]._toFinalCode() + "\n";
                }

                return sCode;
            };

            PassBlend.prototype.generatePassFunctions = function (eType) {
                var pFunctions = null;

                if (eType === 0 /* k_Vertex */) {
                    pFunctions = this._pPassFunctionListV;
                } else {
                    pFunctions = this._pPassFunctionListP;
                }

                var sCode = "";

                for (var i = 0; i < pFunctions.length; i++) {
                    sCode += pFunctions[i]._toFinalCode() + "\n";
                }

                return sCode;
            };

            PassBlend.prototype.generateRealAttrs = function () {
                return this._sAttrDeclCode;
            };

            PassBlend.prototype.generateAFXAttrs = function () {
                return this._sAFXAttrDeclCode;
            };

            PassBlend.prototype.generateAttrBufferInit = function () {
                return this._sAttrBufferInitCode;
            };

            PassBlend.prototype.generateAFXAttrInit = function () {
                return this._sAFXAttrInitCode;
            };

            PassBlend.prototype.generateTexcoordSwap = function () {
                return this._pTexcoordSwapper.getTmpDeclCode() + "\n" + this._pTexcoordSwapper.getTecoordSwapCode();
            };

            PassBlend.prototype.generatePassFunctionCall = function (eType) {
                var pFunctions = null;

                if (eType === 0 /* k_Vertex */) {
                    pFunctions = this._pPassFunctionListV;
                    if (this._sPassFunctionCallCodeV !== "") {
                        return this._sPassFunctionCallCodeV;
                    }
                } else {
                    pFunctions = this._pPassFunctionListP;
                    if (this._sPassFunctionCallCodeP !== "") {
                        return this._sPassFunctionCallCodeP;
                    }
                }

                var sCode = "";

                for (var i = 0; i < pFunctions.length; i++) {
                    sCode += pFunctions[i]._getRealName() + "();\n";
                }

                if (eType === 0 /* k_Vertex */) {
                    this._sPassFunctionCallCodeV = sCode;
                } else {
                    this._sPassFunctionCallCodeP = sCode;
                }

                return sCode;
            };

            PassBlend.prototype.generateVertexOutToVaryings = function () {
                if (this._sVertexOutToVaryingCode !== "") {
                    return this._sVertexOutToVaryingCode;
                }

                var pVars = this._pVaryingContainerV;
                var pVarInfoList = pVars.getVarsInfo();
                var sCode = "";

                //if (this._pAttributeContainerV.getAttributeBySemantic("POSITION")._getType()._isEqual(Effect.getSystemType("float4"))) {
                //	sCode += "gl_Position = POSITION;\ngl_PointSize = Out.PSIZE;\n";
                //}
                //else {
                //	sCode += "gl_Position=Out.POSITION;\ngl_PointSize=Out.PSIZE;\n";
                //}
                sCode += "gl_Position=Out.POSITION;\ngl_PointSize=Out.PSIZE;\n";

                for (var i = 0; i < pVarInfoList.length; i++) {
                    var sName = pVarInfoList[i].name;
                    if (sName !== "POSITION" && sName !== "PSIZE") {
                        sCode += "V_" + sName + "=" + "Out." + sName + ";\n";
                    }
                }

                this._sVertexOutToVaryingCode = sCode;
                return this._sVertexOutToVaryingCode;
            };

            PassBlend.prototype.prepareFastObjects = function () {
                this.prepareFastSamplers(0 /* k_Vertex */);
                this.prepareFastSamplers(1 /* k_Pixel */);
            };

            PassBlend.prototype.prepareFastSamplers = function (eType) {
                if (akra.isNull(this._pSamplerByIdMap)) {
                    this._pSamplerByIdMap = {};
                    this._pSamplerIdList = [];

                    this._pSamplerArrayByIdMap = {};
                    this._pSamplerArrayIdList = [];
                }

                var pContainer = eType === 0 /* k_Vertex */ ? this._pUniformContainerV : this._pUniformContainerP;
                var pVarInfoList = pContainer.getVarsInfo();

                for (var i = 0; i < pVarInfoList.length; i++) {
                    var pVar = pContainer.getVariable(i);

                    if (pVar._getType()._isSampler()) {
                        var id = pVar._getInstructionID();

                        if (!pVar._getType()._isArray() && !akra.isDef(this._pSamplerByIdMap[id])) {
                            this._pSamplerByIdMap[id] = pVar;
                            this._pSamplerIdList.push(id);
                        } else if (pVar._getType()._isArray() && !akra.isDef(this._pSamplerArrayByIdMap[id])) {
                            this._pSamplerArrayByIdMap[id] = pVar;
                            this._pSamplerArrayIdList.push(id);
                        }
                    }
                }
            };
            PassBlend.texcoordSwapper = null;
            PassBlend.hashMinifier = null;

            PassBlend._pStats = {
                shaderCodeGenerationTime: 0.0,
                makerGenerationTime: 0.0,
                makerInitTime: 0.0,
                totalMakers: 0
            };
            return PassBlend;
        })();
        fx.PassBlend = PassBlend;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../idl/IAFXBlender.ts" />
/// <reference path="../idl/IAFXInstruction.ts" />
var akra;
(function (akra) {
    /// <reference path="../logger.ts" />
    /// <reference path="../debug.ts" />
    /// <reference path="ComponentBlend.ts" />
    /// <reference path="PassBlend.ts" />
    /// <reference path="HashTree.ts" />
    /// <reference path="fx.ts" />
    (function (fx) {
        var Blender = (function () {
            function Blender(pComposer) {
                this._pComposer = null;
                this._pComponentBlendByHashMap = null;
                this._pBlendWithComponentMap = null;
                this._pBlendWithBlendMap = null;
                this._pPassBlendByHashMap = null;
                this._pPassBlendByIdMap = null;
                this._pPassBlendHashTree = null;
                this._pTmpRenderStateMap = akra.render.createRenderStateMap();
                this._pComposer = pComposer;

                this._pComponentBlendByHashMap = {};

                this._pBlendWithComponentMap = {};
                this._pBlendWithBlendMap = {};

                this._pPassBlendByHashMap = {};
                this._pPassBlendByIdMap = {};

                this._pPassBlendHashTree = new fx.HashTree();
            }
            Blender.prototype.addComponentToBlend = function (pComponentBlend, pComponent, iShift, iPass) {
                if (!akra.isNull(pComponentBlend) && pComponentBlend.containComponent(pComponent, iShift, iPass)) {
                    akra.debug.warn("You try to add already used component '" + pComponent.findResourceName() + "' in blend.");
                    return pComponentBlend;
                }

                if (iShift === fx.DEFAULT_SHIFT) {
                    if (pComponent.isPostEffect()) {
                        iShift = pComponentBlend.getTotalPasses();
                    } else {
                        iShift = 0;
                    }
                }

                var sBlendPartHash = akra.isDefAndNotNull(pComponentBlend) ? pComponentBlend.guid.toString() : "";
                var sComponentPartHash = pComponent.getHash(iShift, iPass);
                var sShortHash = sBlendPartHash + "+" + sComponentPartHash;

                if (akra.isDef(this._pBlendWithComponentMap[sShortHash])) {
                    return this._pBlendWithComponentMap[sShortHash];
                }

                var pNewBlend = null;

                if (akra.isNull(pComponentBlend)) {
                    pNewBlend = new fx.ComponentBlend(this._pComposer);
                } else {
                    pNewBlend = pComponentBlend.clone();
                }

                var pTechnique = pComponent.getTechnique();
                var pTechComponentList = pTechnique._getFullComponentList();
                var pTechComponentShiftList = pTechnique._getFullComponentShiftList();

                if (iPass === fx.ALL_PASSES) {
                    if (!akra.isNull(pTechComponentList)) {
                        for (var i = 0; i < pTechComponentList.length; i++) {
                            pNewBlend.addComponent(pTechComponentList[i], pTechComponentShiftList[i] + iShift, fx.ALL_PASSES);
                        }
                    }

                    pNewBlend.addComponent(pComponent, iShift, fx.ALL_PASSES);
                } else {
                    if (!akra.isNull(pTechComponentList)) {
                        for (var i = 0; i < pTechComponentList.length; i++) {
                            pNewBlend.addComponent(pTechComponentList[i], pTechComponentShiftList[i] + iShift, iPass - pTechComponentShiftList[i]);
                        }
                    }

                    pNewBlend.addComponent(pComponent, iShift, iPass);
                }

                this._pBlendWithComponentMap[sShortHash] = pNewBlend;

                var sNewBlendHash = pNewBlend.getHash();

                if (akra.isDef(this._pComponentBlendByHashMap[sNewBlendHash])) {
                    return this._pComponentBlendByHashMap[sNewBlendHash];
                } else {
                    this._pComponentBlendByHashMap[sNewBlendHash] = pNewBlend;
                }

                return pNewBlend;
            };

            Blender.prototype.removeComponentFromBlend = function (pComponentBlend, pComponent, iShift, iPass) {
                if (akra.isNull(pComponentBlend)) {
                    akra.logger.warn("You try to remove component '" + pComponent.getName() + "' with shift " + iShift.toString() + " from empty blend.");
                    return null;
                }

                var pComponentInfo = pComponentBlend.findAnyAddedComponentInfo(pComponent, iShift, iPass);
                if (akra.isNull(pComponentInfo)) {
                    akra.logger.warn("You try to remove component '" + pComponent.getName() + "' with shift " + iShift.toString() + " from blend that not contain it.");
                    return null;
                }

                if (iShift === fx.DEFAULT_SHIFT) {
                    if (pComponent.isPostEffect()) {
                        iShift = pComponentInfo.shift;
                    } else {
                        iShift = 0;
                    }
                }

                var sBlendPartHash = akra.isDefAndNotNull(pComponentBlend) ? pComponentBlend.guid.toString() : "";
                var sComponentPartHash = pComponent.getHash(iShift, iPass);
                var sShortHash = sBlendPartHash + "-" + sComponentPartHash;

                if (akra.isDef(this._pBlendWithComponentMap[sShortHash])) {
                    return this._pBlendWithComponentMap[sShortHash];
                }

                var pNewBlend = pComponentBlend.clone();

                var pTechnique = pComponent.getTechnique();
                var pTechComponentList = pTechnique._getFullComponentList();
                var pTechComponentShiftList = pTechnique._getFullComponentShiftList();

                if (iPass === fx.ALL_PASSES) {
                    if (!akra.isNull(pTechComponentList)) {
                        for (var i = 0; i < pTechComponentList.length; i++) {
                            pNewBlend.removeComponent(pTechComponentList[i], pTechComponentShiftList[i] + iShift, fx.ALL_PASSES);
                        }
                    }

                    pNewBlend.removeComponent(pComponent, iShift, fx.ALL_PASSES);
                } else {
                    if (!akra.isNull(pTechComponentList)) {
                        for (var i = 0; i < pTechComponentList.length; i++) {
                            pNewBlend.removeComponent(pTechComponentList[i], pTechComponentShiftList[i] + iShift, iPass - pTechComponentShiftList[i]);
                        }
                    }

                    pNewBlend.removeComponent(pComponent, iShift, iPass);
                }

                this._pBlendWithComponentMap[sShortHash] = pNewBlend;

                var sNewBlendHash = pNewBlend.getHash();

                if (akra.isDef(this._pComponentBlendByHashMap[sNewBlendHash])) {
                    return this._pComponentBlendByHashMap[sNewBlendHash];
                } else {
                    this._pComponentBlendByHashMap[sNewBlendHash] = pNewBlend;
                }

                return pNewBlend;
            };

            Blender.prototype.addBlendToBlend = function (pComponentBlend, pAddBlend, iShift) {
                //TODO: ADD CORRECT BLENDING FOR POSTEFFECTS
                if (akra.isNull(pComponentBlend)) {
                    return pAddBlend;
                }

                if (akra.isNull(pAddBlend)) {
                    return pComponentBlend;
                }

                var sShortHash = pComponentBlend.guid.toString() + "+" + pAddBlend.guid.toString();
                if (akra.isDef(this._pBlendWithBlendMap[sShortHash])) {
                    return this._pBlendWithBlendMap[sShortHash];
                }

                var pNewBlend = pComponentBlend.clone();

                var pAddComponentInfoList = pAddBlend._getComponentInfoList();

                for (var i = 0; i < pAddComponentInfoList.length; i++) {
                    pNewBlend.addComponent(pAddComponentInfoList[i].component, pAddComponentInfoList[i].shift + iShift, pAddComponentInfoList[i].pass);
                }

                this._pBlendWithBlendMap[sShortHash] = pNewBlend;

                var sNewBlendHash = pNewBlend.getHash();

                if (akra.isDef(this._pComponentBlendByHashMap[sNewBlendHash])) {
                    return this._pComponentBlendByHashMap[sNewBlendHash];
                } else {
                    this._pComponentBlendByHashMap[sNewBlendHash] = pNewBlend;
                }

                return pNewBlend;
            };

            Blender.prototype.generatePassBlend = function (pPassList, pComposerStates, pForeigns, pUniforms) {
                this._pPassBlendHashTree.release();

                akra.render.clearRenderStateMap(this._pTmpRenderStateMap);

                for (var i = 0; i < pPassList.length; i++) {
                    var pPass = pPassList[i];

                    pPass._evaluate(pComposerStates, pForeigns, pUniforms);

                    akra.render.copyRenderStateMap(pPass._getRenderStates(), this._pTmpRenderStateMap);

                    var pVertexShader = pPass._getVertexShader();
                    var pPixelShader = pPass._getPixelShader();

                    this._pPassBlendHashTree.has(akra.isNull(pVertexShader) ? 0 : pVertexShader._getInstructionID());
                    this._pPassBlendHashTree.has(akra.isNull(pPixelShader) ? 0 : pPixelShader._getInstructionID());
                }

                var pBlend = this._pPassBlendHashTree.getContent();

                if (!pBlend) {
                    var pNewPassBlend = new fx.PassBlend(this._pComposer);
                    var isOk = pNewPassBlend.initFromPassList(pPassList);

                    if (!isOk) {
                        return null;
                    }

                    this._pPassBlendHashTree.addContent(pNewPassBlend);
                    this._pPassBlendByIdMap[pNewPassBlend.guid] = pNewPassBlend;

                    return pNewPassBlend;
                } else {
                    akra.render.clearRenderStateMap(pBlend._getRenderStates());
                    akra.render.copyRenderStateMap(this._pTmpRenderStateMap, pBlend._getRenderStates());
                    return pBlend;
                }
            };

            Blender.prototype.getPassBlendById = function (id) {
                return this._pPassBlendByIdMap[id] || null;
            };
            return Blender;
        })();
        fx.Blender = Blender;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="idl/EDataTypes.ts" />
/// <reference path="logger.ts" />
var akra;
(function (akra) {
    function sizeof(eType) {
        switch (eType) {
            case 5120 /* BYTE */:
            case 5121 /* UNSIGNED_BYTE */:
                return 1;
            case 5122 /* SHORT */:
            case 5123 /* UNSIGNED_SHORT */:
                return 2;
            case 5124 /* INT */:
            case 5125 /* UNSIGNED_INT */:
            case 5126 /* FLOAT */:
                return 4;
            default:
                akra.logger.error("unknown data/image type used");
        }
    }
    akra.sizeof = sizeof;
})(akra || (akra = {}));
/// <reference path="../idl/IVertexDeclaration.ts" />
/// <reference path="../idl/IVertexElement.ts" />
/// <reference path="../idl/EDataTypes.ts" />
/// <reference path="../limit.ts" />
/// <reference path="../types.ts" />
/// <reference path="../config/config.ts" />
/// <reference path="Usage.ts" />
var akra;
(function (akra) {
    (function (_data) {
        /** @const */
        var UNKNOWN_OFFSET = akra.MAX_INT32;

        var VertexElement = (function () {
            function VertexElement(nCount, eType, eUsage, //mark invalid offset, for determine true offset in VertexDeclaration::_update();
            iOffset) {
                if (typeof nCount === "undefined") { nCount = 1; }
                if (typeof eType === "undefined") { eType = 5126 /* FLOAT */; }
                if (typeof eUsage === "undefined") { eUsage = _data.Usages.POSITION; }
                if (typeof iOffset === "undefined") { iOffset = UNKNOWN_OFFSET; }
                // this properties is /** readonly */ for public usage.
                this.size = 0;
                this.index = 0;
                this.semantics = _data.Usages.UNKNOWN;
                this.count = nCount;
                this.type = eType;
                this.usage = eUsage;
                this.offset = iOffset;

                this.update();
            }
            VertexElement.prototype.update = function () {
                this.size = this.count * akra.sizeof(this.type);
                this.index = 0;
                this.semantics = null;

                var pMatches = this.usage.match(/^(.*?\w)(\d+)$/i);

                if (!akra.isNull(pMatches)) {
                    this.semantics = pMatches[1];
                    this.index = parseInt(pMatches[2]);
                    // To avoid the colosseum between the "usage" of the element as POSITION & POSITION0,
                    // given that this is the same thing, here are the elements with index 0
                    // for "usage" with the POSITION.
                    // if (this.index === 0) {
                    // 	this.usage = this.semantics;
                    // }
                } else {
                    this.semantics = this.usage;
                }
            };

            VertexElement.prototype.clone = function () {
                return new VertexElement(this.count, this.type, this.usage, this.offset);
            };

            /**  */ VertexElement.hasUnknownOffset = function (pElement) {
                return (!akra.isDef(pElement.offset) || (pElement.offset === UNKNOWN_OFFSET));
            };

            /**  */ VertexElement.prototype.isEnd = function () {
                return this.semantics === _data.Usages.END;
            };

            VertexElement.prototype.toString = function () {
                if (akra.config.DEBUG) {
                    function _an(data, n, bBackward) {
                        if (typeof bBackward === "undefined") { bBackward = false; }
                        var s = String(data);

                        for (var i = 0, t = n - s.length; i < t; ++i) {
                            if (bBackward) {
                                s = " " + s;
                            } else {
                                s += " ";
                            }
                        }
                        return s;
                    }

                    var s = "[ USAGE: " + _an(this.usage == _data.Usages.END ? "<END>" : this.usage, 12) + ", OFFSET " + _an(this.offset, 4) + ", SIZE " + _an(this.size, 4) + " ]";

                    return s;
                }
                return null;
            };

            VertexElement.custom = function (sUsage, eType, iCount, iOffset) {
                if (typeof eType === "undefined") { eType = 5126 /* FLOAT */; }
                if (typeof iCount === "undefined") { iCount = 1; }
                if (typeof iOffset === "undefined") { iOffset = UNKNOWN_OFFSET; }
                return {
                    count: iCount,
                    type: eType,
                    usage: sUsage,
                    offset: iOffset
                };
            };

            VertexElement.float = function (sUsage, iOffset) {
                if (typeof iOffset === "undefined") { iOffset = UNKNOWN_OFFSET; }
                return VertexElement.custom(sUsage, 5126 /* FLOAT */, 1, iOffset);
            };

            VertexElement.float2 = function (sUsage, iOffset) {
                if (typeof iOffset === "undefined") { iOffset = UNKNOWN_OFFSET; }
                return VertexElement.custom(sUsage, 5126 /* FLOAT */, 2, iOffset);
            };

            VertexElement.float3 = function (sUsage, iOffset) {
                if (typeof iOffset === "undefined") { iOffset = UNKNOWN_OFFSET; }
                return VertexElement.custom(sUsage, 5126 /* FLOAT */, 3, iOffset);
            };

            VertexElement.float4 = function (sUsage, iOffset) {
                if (typeof iOffset === "undefined") { iOffset = UNKNOWN_OFFSET; }
                return VertexElement.custom(sUsage, 5126 /* FLOAT */, 4, iOffset);
            };

            VertexElement.float4x4 = function (sUsage, iOffset) {
                if (typeof iOffset === "undefined") { iOffset = UNKNOWN_OFFSET; }
                return VertexElement.custom(sUsage, 5126 /* FLOAT */, 16, iOffset);
            };

            VertexElement.int = function (sUsage, iOffset) {
                if (typeof iOffset === "undefined") { iOffset = UNKNOWN_OFFSET; }
                return VertexElement.custom(sUsage, 5124 /* INT */, 1, iOffset);
            };

            VertexElement.end = function (iOffset) {
                if (typeof iOffset === "undefined") { iOffset = 0; }
                return VertexElement.custom(_data.Usages.END, 5121 /* UNSIGNED_BYTE */, 0, iOffset);
            };
            return VertexElement;
        })();
        _data.VertexElement = VertexElement;
    })(akra.data || (akra.data = {}));
    var data = akra.data;
})(akra || (akra = {}));
/// <reference path="../idl/IRenderPass.ts" />
/// <reference path="../guid.ts" />
var akra;
(function (akra) {
    (function (render) {
        var RenderPass = (function () {
            function RenderPass(pTechnique, iPass) {
                this.guid = akra.guid();
                this._pTechnique = null;
                this._pRenderTarget = null;
                this._iPassNumber = 0;
                this._pInput = null;
                this._isActive = true;
                this._pTechnique = pTechnique;
                this._iPassNumber = iPass;
            }
            RenderPass.prototype.setForeign = function (sName, pValue) {
                this._pInput.setForeign(sName, pValue);
            };

            RenderPass.prototype.setTexture = function (sName, pTexture) {
                this._pInput.setTexture(sName, pTexture);
            };

            RenderPass.prototype.setUniform = function (sName, pValue) {
                this._pInput.setUniform(sName, pValue);
            };

            RenderPass.prototype.setStruct = function (sName, pValue) {
                this._pInput.setStruct(sName, pValue);
            };

            RenderPass.prototype.setRenderState = function (eState, eValue) {
                this._pInput.setRenderState(eState, eValue);
            };

            RenderPass.prototype.setSamplerTexture = function (sName, pTexture) {
                this._pInput.setSamplerTexture(sName, pTexture);
            };

            //  setSamplerState(sName: string, pState: IAFXSamplerState): void {
            // 	this._pInput.setSamplerState(sName, pState);
            // }
            RenderPass.prototype.getRenderTarget = function () {
                return this._pRenderTarget;
            };

            RenderPass.prototype.setRenderTarget = function (pTarget) {
                this._pRenderTarget = pTarget;
            };

            RenderPass.prototype.getPassInput = function () {
                return this._pInput;
            };

            RenderPass.prototype.setPassInput = function (pInput, isNeedRelocate) {
                //if (isNeedRelocate) {
                //	pInput._copyFrom(pInput);
                //}
                if (!akra.isNull(this._pInput)) {
                    this._pInput._release();
                }

                this._pInput = pInput;
            };

            RenderPass.prototype.blend = function (sComponentName, iPass) {
                return this._pTechnique.addComponent(sComponentName, this._iPassNumber, iPass);
            };

            RenderPass.prototype.activate = function () {
                this._isActive = true;
            };

            RenderPass.prototype.deactivate = function () {
                this._isActive = false;
            };

            RenderPass.prototype.isActive = function () {
                return this._isActive;
            };

            RenderPass.prototype.relocateOldInput = function (pNewInput) {
                //TODO: copy old uniforms to new
            };
            return RenderPass;
        })();
        render.RenderPass = RenderPass;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="../idl/IRenderTechnique.ts" />
var akra;
(function (akra) {
    /// <reference path="../guid.ts" />
    /// <reference path="../debug.ts" />
    /// <reference path="../events.ts" />
    /// <reference path="../util/ObjectArray.ts" />
    /// <reference path="RenderPass.ts" />
    /// <reference path="../fx/fx.ts" />
    (function (render) {
        var RenderTechnique = (function () {
            function RenderTechnique(pMethod) {
                if (typeof pMethod === "undefined") { pMethod = null; }
                this.guid = akra.guid();
                this._pMethod = null;
                this._isFreeze = false;
                this._pComposer = null;
                this._pPassList = null;
                this._pPassBlackList = null;
                this._iCurrentPass = 0;
                this._pCurrentPass = null;
                //private _iGlobalPostEffectsStart: uint = 0;
                /**
                * Only for read, because it`s pointer to ComponentBlend._pPassTypesList
                */
                this._pBlendPassTypesList = null;
                this._bHasPostEffectPass = false;
                this._iLastPostEffectPass = 0;
                this._iMinShiftOfOwnBlend = 0;
                this._pRenderMethodPassStateList = null;
                this.setupSignals();

                this._pPassList = [];
                this._pPassBlackList = [];

                if (!akra.isNull(pMethod)) {
                    this.setMethod(pMethod);
                }

                this._pRenderMethodPassStateList = new akra.util.ObjectArray();
            }
            RenderTechnique.prototype.setupSignals = function () {
                this.render = this.render || new akra.Signal(this);
            };

            RenderTechnique.prototype.copyTechniqueOwnComponentBlend = function (pFrom) {
                this._pComposer.copyTechniqueOwnComponentBlend(pFrom, this);
            };

            RenderTechnique.prototype.getModified = function () {
                return this.guid;
            };

            RenderTechnique.prototype.getTotalPasses = function () {
                return this._pComposer.getTotalPassesForTechnique(this);
            };

            RenderTechnique.prototype.destroy = function () {
            };

            RenderTechnique.prototype.getPass = function (iPass) {
                this._pComposer.prepareTechniqueBlend(this);
                return this._pPassList[iPass];
            };

            RenderTechnique.prototype.getMethod = function () {
                return this._pMethod;
            };

            RenderTechnique.prototype.setMethod = function (pMethod) {
                if (!akra.isNull(this._pMethod)) {
                    this._pMethod.altered.disconnect(this, this._updateMethod);
                    //this.disconnect(this._pMethod, SIGNAL(altered), SLOT(_updateMethod), EEventTypes.BROADCAST);
                }

                this._pMethod = pMethod;

                if (!akra.isNull(pMethod)) {
                    var pComposer = pMethod.getManager().getEngine().getComposer();
                    this._setComposer(pComposer);
                    pMethod.altered.connect(this, this._updateMethod);
                    //this.connect(pMethod, SIGNAL(altered), SLOT(_updateMethod), EEventTypes.BROADCAST);
                }

                this._updateMethod(pMethod);
            };

            RenderTechnique.prototype.setState = function (sName, pValue) {
            };

            RenderTechnique.prototype.setForeign = function (sName, pValue) {
            };

            RenderTechnique.prototype.setStruct = function (sName, pValue) {
                //skip
            };

            RenderTechnique.prototype.setTextureBySemantics = function (sName, pValue) {
            };

            RenderTechnique.prototype.setShadowSamplerArray = function (sName, pValue) {
            };

            RenderTechnique.prototype.setVec2BySemantic = function (sName, pValue) {
            };

            RenderTechnique.prototype.isReady = function () {
                return this._pMethod.isReady();
            };

            RenderTechnique.prototype.addComponent = function (pComponent, iShift, iPass) {
                if (typeof iShift === "undefined") { iShift = 0; }
                if (typeof iPass === "undefined") { iPass = akra.fx.ALL_PASSES; }
                if (akra.isNull(this._pComposer)) {
                    return false;
                }

                var pComponentPool = this._pComposer.getEngine().getResourceManager().getComponentPool();

                if (akra.isInt(pComponent)) {
                    pComponent = pComponentPool.getResource(pComponent);
                } else if (akra.isString(pComponent)) {
                    pComponent = pComponentPool.findResource(pComponent);
                }

                if (!akra.isDef(pComponent) || akra.isNull(pComponent)) {
                    akra.debug.error("Bad component for add.");
                    return false;
                }

                if (!this._pComposer.addOwnComponentToTechnique(this, pComponent, iShift, iPass)) {
                    akra.debug.error("Can not add component '" + pComponent.findResourceName() + "'");
                    return false;
                }

                this._iMinShiftOfOwnBlend = this._pComposer.getMinShiftForOwnTechniqueBlend(this);

                return true;
            };

            RenderTechnique.prototype.delComponent = function (pComponent, iShift, iPass) {
                if (typeof iShift === "undefined") { iShift = 0; }
                if (typeof iPass === "undefined") { iPass = akra.fx.ALL_PASSES; }
                if (akra.isNull(this._pComposer)) {
                    return false;
                }

                var pComponentPool = this._pComposer.getEngine().getResourceManager().getComponentPool();

                if (akra.isInt(pComponent)) {
                    pComponent = pComponentPool.getResource(pComponent);
                } else if (akra.isString(pComponent)) {
                    pComponent = pComponentPool.findResource(pComponent);
                }

                if (!akra.isDef(pComponent) || akra.isNull(pComponent)) {
                    akra.debug.error("Bad component for delete.");
                    return false;
                }

                if (!this._pComposer.removeOwnComponentToTechnique(this, pComponent, iShift, iPass)) {
                    akra.debug.error("Can not delete component '" + pComponent.findResourceName() + "'");
                    return false;
                }

                this._iMinShiftOfOwnBlend = this._pComposer.getMinShiftForOwnTechniqueBlend(this);

                return true;
            };

            RenderTechnique.prototype.hasComponent = function (sComponent, iShift, iPass) {
                if (typeof iShift === "undefined") { iShift = akra.fx.ANY_SHIFT; }
                if (typeof iPass === "undefined") { iPass = akra.fx.ANY_PASS; }
                return this._pMethod.getEffect().hasComponent(sComponent, iShift, iPass) || this.hasOwnComponent(sComponent, iShift, iPass);
            };

            RenderTechnique.prototype.hasOwnComponent = function (sComponent, iShift, iPass) {
                if (typeof iShift === "undefined") { iShift = akra.fx.ANY_SHIFT; }
                if (typeof iPass === "undefined") { iPass = akra.fx.ANY_PASS; }
                if (akra.isNull(this._pComposer)) {
                    return false;
                }

                var pComponentPool = this._pComposer.getEngine().getResourceManager().getComponentPool();
                var pComponent = null;

                pComponent = pComponentPool.findResource(sComponent);

                if (akra.isNull(pComponent)) {
                    return false;
                }

                return this._pComposer.hasOwnComponentInTechnique(this, pComponent, iShift, iPass);
            };

            RenderTechnique.prototype.hasPostEffect = function () {
                return this._bHasPostEffectPass;
            };

            RenderTechnique.prototype.isPostEffectPass = function (iPass) {
                return this._pBlendPassTypesList[iPass] === 2 /* POSTEFFECT */;
            };

            RenderTechnique.prototype.isLastPass = function (iPass) {
                var iMaxPass = this.getTotalPasses() - 1;

                if (iMaxPass === iPass) {
                    return true;
                }

                if (!this._pPassBlackList[iMaxPass]) {
                    return false;
                }

                for (var i = this._pPassBlackList.length - 2; i >= 0; i--) {
                    if (!this._pPassBlackList[i]) {
                        if (i !== iPass) {
                            return false;
                        } else {
                            return true;
                        }
                    }
                }

                return false;
            };

            RenderTechnique.prototype.isLastPostEffectPass = function (iPass) {
                return this._iLastPostEffectPass === iPass;
            };

            RenderTechnique.prototype.isFirstPass = function (iPass) {
                if (iPass === 0) {
                    return true;
                }

                if (!this._pPassBlackList[0]) {
                    return false;
                }

                for (var i = 1; i < this._pPassBlackList.length; i++) {
                    if (!this._pPassBlackList[i]) {
                        if (i !== iPass) {
                            return false;
                        } else {
                            return true;
                        }
                    }
                }

                return false;
            };

            RenderTechnique.prototype.isFreeze = function () {
                return this._isFreeze;
            };

            RenderTechnique.prototype.updatePasses = function (bSaveOldUniformValue) {
                this._isFreeze = true;

                var iTotalPasses = this.getTotalPasses();

                for (var i = this._pPassList.length; i < iTotalPasses; i++) {
                    if (!akra.isDef(this._pPassBlackList[i]) || this._pPassBlackList[i] === false) {
                        this._pPassList[i] = new render.RenderPass(this, i);
                        this._pPassBlackList[i] = false;
                    }
                }

                for (var i = 0; i < iTotalPasses; i++) {
                    if (!this._pPassBlackList[i]) {
                        var pInput = this._pComposer.getPassInputBlendForTechnique(this, i);
                        if (!akra.isNull(pInput)) {
                            this._pPassList[i].setPassInput(pInput, bSaveOldUniformValue);
                            this._pPassList[i].activate();
                        } else {
                            this._pPassList[i].deactivate();
                        }
                    }
                }

                this._isFreeze = false;
            };

            RenderTechnique.prototype._setComposer = function (pComposer) {
                this._pComposer = pComposer;
            };

            RenderTechnique.prototype._getComposer = function () {
                return this._pComposer;
            };

            RenderTechnique.prototype._renderTechnique = function (pViewport, pRenderable, pSceneObject) {
                if (akra.isNull(this._pComposer)) {
                    return;
                }

                var pComposer = this._pComposer;

                pComposer.prepareTechniqueBlend(this);
                pComposer._setCurrentViewport(pViewport);
                pComposer._setCurrentSceneObject(pSceneObject);
                pComposer._setCurrentRenderableObject(pRenderable);
                pComposer.applySurfaceMaterial(this._pMethod.getSurfaceMaterial());

                this._isFreeze = true;

                this.takePassInputsFromRenderMethod();

                var iTotalPasses = this.getTotalPasses();
                for (var i = 0; i < iTotalPasses; i++) {
                    if (this._pPassBlackList[i] === false && this._pPassList[i].isActive()) {
                        this.activatePass(i);
                        this.render.emit(i, pRenderable, pSceneObject, pViewport);
                        pViewport.render.emit(this, i, pRenderable, pSceneObject);
                        pComposer.renderTechniquePass(this, i);
                    }
                }

                this._isFreeze = false;
                pComposer._setDefaultCurrentState();
            };

            RenderTechnique.prototype._updateMethod = function (pMethod) {
                this.informComposer();
                this.prepareRenderMethodPassStateInfo(pMethod);
            };

            RenderTechnique.prototype._blockPass = function (iPass) {
                this._pPassBlackList[iPass] = true;
                this._pComposer.prepareTechniqueBlend(this);

                // this._pPassList[iPass] = null;
                this.updatePassTypesInfo();
            };

            //_setPostEffectsFrom(iPass: uint): void {
            //	this._iGlobalPostEffectsStart = iPass;
            //}
            RenderTechnique.prototype._setBlendPassTypes = function (pTypes) {
                this._pBlendPassTypesList = pTypes;
                this.updatePassTypesInfo();
            };

            RenderTechnique.prototype.updatePassTypesInfo = function () {
                if (akra.isNull(this._pBlendPassTypesList)) {
                    return;
                }

                for (var i = 0; i < this._pBlendPassTypesList.length; i++) {
                    if (!this._pPassBlackList[i]) {
                        if (this._pBlendPassTypesList[i] === 2 /* POSTEFFECT */) {
                            this._bHasPostEffectPass = true;
                            this._iLastPostEffectPass = i;
                        }
                    }
                }
            };

            RenderTechnique.prototype.informComposer = function () {
                if (!akra.isNull(this._pComposer)) {
                    this._pComposer.markTechniqueAsNeedUpdate(this);
                }
            };

            RenderTechnique.prototype.prepareRenderMethodPassStateInfo = function (pMethod) {
                var iLength = this._pRenderMethodPassStateList.getLength();

                for (var i = 0; i < iLength; i++) {
                    this.freePassState(this._pRenderMethodPassStateList.value(i));
                }

                this._pRenderMethodPassStateList.clear();

                if (akra.isNull(pMethod)) {
                    return;
                }

                var iMethodTotalPasses = pMethod.getEffect().getTotalPasses();

                for (var i = 0; i < iMethodTotalPasses; i++) {
                    var pState = this.getFreePassState();
                    pState.uniformKey = 0;
                    pState.foreignKey = 0;
                    pState.samplerKey = 0;
                    pState.renderStatesKey = 0;

                    this._pRenderMethodPassStateList.push(pState);
                }
            };

            /**
            * Copy input data from render method to render technique.
            * It's nessasery for adding ability.......
            */
            RenderTechnique.prototype.takePassInputsFromRenderMethod = function () {
                if (akra.isNull(this._pMethod)) {
                    return;
                }

                var iRenderMethodStartPass = (this._iMinShiftOfOwnBlend < 0) ? (-this._iMinShiftOfOwnBlend) : 0;
                var iTotalPasses = this._pMethod.getEffect().getTotalPasses();

                for (var i = 0; i < iTotalPasses; i++) {
                    if (this._pPassBlackList[i + iRenderMethodStartPass]) {
                        continue;
                    }

                    var pRenderMethodPassInput = this._pMethod._getPassInput(i);
                    var pPassInput = this._pPassList[i].getPassInput();

                    if (akra.isNull(pRenderMethodPassInput) || akra.isNull(pPassInput)) {
                        continue;
                    }

                    var pOldStates = this._pRenderMethodPassStateList.value(i);
                    var pCurrentStates = pRenderMethodPassInput.getStatesInfo();

                    if (pOldStates.uniformKey !== pCurrentStates.uniformKey) {
                        pPassInput._copyUniformsFromInput(pRenderMethodPassInput);
                        pOldStates.uniformKey = pCurrentStates.uniformKey;
                    }

                    if (pOldStates.foreignKey !== pCurrentStates.foreignKey) {
                        pPassInput._copyForeignsFromInput(pRenderMethodPassInput);
                        pOldStates.foreignKey = pCurrentStates.foreignKey;
                    }

                    if (pOldStates.samplerKey !== pCurrentStates.samplerKey) {
                        pPassInput._copySamplersFromInput(pRenderMethodPassInput);
                        pOldStates.samplerKey = pCurrentStates.samplerKey;
                    }

                    if (pOldStates.renderStatesKey !== pCurrentStates.renderStatesKey) {
                        pPassInput._copyRenderStatesFromInput(pRenderMethodPassInput);
                        pOldStates.renderStatesKey = pCurrentStates.renderStatesKey;
                    }
                }
            };

            RenderTechnique.prototype.activatePass = function (iPass) {
                this._iCurrentPass = iPass;
                this._pCurrentPass = this._pPassList[iPass];
            };

            RenderTechnique.prototype.getFreePassState = function () {
                if (RenderTechnique.pRenderMethodPassStatesPool.getLength() > 0) {
                    return RenderTechnique.pRenderMethodPassStatesPool.pop();
                } else {
                    return {
                        uniformKey: 0,
                        foreignKey: 0,
                        samplerKey: 0,
                        renderStatesKey: 0
                    };
                }
            };

            RenderTechnique.prototype.freePassState = function (pState) {
                RenderTechnique.pRenderMethodPassStatesPool.push(pState);
            };
            RenderTechnique.pRenderMethodPassStatesPool = new akra.util.ObjectArray();
            return RenderTechnique;
        })();
        render.RenderTechnique = RenderTechnique;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="../idl/IRenderableObject.ts" />
/// <reference path="../idl/IRenderMethod.ts" />
/// <reference path="../idl/IMap.ts" />
var akra;
(function (akra) {
    /// <reference path="RenderTechnique.ts" />
    /// <reference path="../data/VertexElement.ts" />
    /// <reference path="../config/config.ts" />
    /// <reference path="../debug.ts" />
    /// <reference path="../events.ts" />
    /// <reference path="../guid.ts" />
    (function (render) {
        var VE = akra.data.VertexElement;
        var DEFAULT_RM = akra.config.defaultName;
        var DEFAULT_RT = akra.config.defaultName;

        var RenderableObject = (function () {
            function RenderableObject(eType) {
                if (typeof eType === "undefined") { eType = 0 /* UNKNOWN */; }
                this.guid = akra.guid();
                this._pRenderData = null;
                this._pTechnique = null;
                this._pTechniqueMap = {};
                this._bShadow = true;
                this._bVisible = true;
                this._bFrozen = false;
                this._bWireframeOverlay = false;
                this.setupSignals();

                this._eRenderableType = eType;
            }
            RenderableObject.prototype.setupSignals = function () {
                this.shadowed = this.shadowed || new akra.Signal(this);
                this.beforeRender = this.beforeRender || new akra.Signal(this);

                this.click = this.click || new akra.Signal(this);

                this.mousemove = this.mousemove || new akra.Signal(this);
                this.mousedown = this.mousedown || new akra.Signal(this);
                this.mouseup = this.mouseup || new akra.Signal(this);
                this.mouseover = this.mouseover || new akra.Signal(this);
                this.mouseout = this.mouseout || new akra.Signal(this);
                this.mousewheel = this.mousewheel || new akra.Signal(this);

                this.dragstart = this.dragstart || new akra.Signal(this);
                this.dragstop = this.dragstop || new akra.Signal(this);
                this.dragging = this.dragging || new akra.Signal(this);
            };

            RenderableObject.prototype.getType = function () {
                return this._eRenderableType;
            };

            RenderableObject.prototype.getEffect = function () {
                return this._pTechnique.getMethod().getEffect();
            };

            RenderableObject.prototype.getSurfaceMaterial = function () {
                return this._pTechnique.getMethod().getSurfaceMaterial();
            };

            RenderableObject.prototype.getMaterial = function () {
                return this.getSurfaceMaterial().getMaterial();
            };

            RenderableObject.prototype.getData = function () {
                return this._pRenderData;
            };

            RenderableObject.prototype.getRenderMethod = function () {
                return this._pTechnique.getMethod();
            };

            RenderableObject.prototype.getRenderID = function (pObject) {
                if (typeof pObject === "undefined") { pObject = null; }
                var pComposer = this._pRenderData._getComposer();
                return pComposer._calcRenderID(pObject, this);
            };

            RenderableObject.prototype.setRenderMethod = function (pMethod) {
                this.switchRenderMethod(pMethod);
            };

            RenderableObject.prototype.getShadow = function () {
                return this._bShadow;
            };

            RenderableObject.prototype.setShadow = function (bShadow) {
                if (this._bShadow !== bShadow) {
                    this._bShadow = bShadow;

                    //debug.log("MeshSubset(" + this.guid + ")::setShadow(" + bShadow + ")");
                    //console.trace();
                    this.shadowed.emit(bShadow);
                }
            };

            RenderableObject.prototype._setRenderData = function (pData) {
                this._pRenderData = pData;
                return;
            };

            RenderableObject.prototype._setup = function (pRenderer, csDefaultMethod) {
                if (typeof csDefaultMethod === "undefined") { csDefaultMethod = null; }
                this._pRenderer = pRenderer;

                if (!this.addRenderMethod(csDefaultMethod) || this.switchRenderMethod(null) === false) {
                    akra.logger.critical("cannot add & switch render method to default");
                }
            };

            RenderableObject.prototype.getRenderer = function () {
                return this._pRenderer;
            };

            RenderableObject.prototype.destroy = function () {
                this._pRenderer = null;
                this._pTechnique = null;

                for (var i in this._pTechniqueMap) {
                    this._pTechniqueMap[i].destroy();
                }

                this._pTechniqueMap = null;
            };

            RenderableObject.prototype.addRenderMethod = function (csMethod, csName) {
                var pTechnique = new render.RenderTechnique;
                var pRmgr = this.getRenderer().getEngine().getResourceManager();
                var pMethod = null;

                if (!akra.isDefAndNotNull(csMethod)) {
                    csMethod = DEFAULT_RM;
                }

                if (akra.isString(csMethod) || arguments.length === 0) {
                    pMethod = pRmgr.createRenderMethod((csMethod) + this.guid);

                    if (!akra.isDefAndNotNull(pMethod)) {
                        akra.logger.critical("resource manager failed to create method...");
                        return false;
                    }

                    //adding empty, but NOT NULL effect & material
                    pMethod.setSurfaceMaterial(pRmgr.createSurfaceMaterial(csMethod + ".material." + this.guid));
                    pMethod.setEffect(pRmgr.createEffect(csMethod + ".effect." + this.guid));
                } else {
                    pMethod = arguments[0];
                }

                akra.debug.assert(pMethod.getManager().getEngine().getRenderer() === this._pRenderer, "Render method should belong to the same engine instance that the renderable object.");

                pTechnique.setMethod(pMethod);

                //pTechnique.name = csName || DEFAULT_RT;
                this._pTechniqueMap[csName || DEFAULT_RT] = pTechnique;

                return true;
            };

            RenderableObject.prototype.switchRenderMethod = function (pNameOrMethod) {
                var pTechnique;
                var sName = null;

                if (akra.isNull(pNameOrMethod)) {
                    sName = DEFAULT_RT;
                } else if (akra.isString(pNameOrMethod)) {
                    sName = pNameOrMethod;
                } else if (akra.isDefAndNotNull(pNameOrMethod)) {
                    sName = pNameOrMethod.findResourceName();

                    if (!akra.isDefAndNotNull(this._pTechniqueMap[sName])) {
                        if (!this.addRenderMethod(pNameOrMethod, sName)) {
                            return false;
                        }
                    }
                }

                pTechnique = this._pTechniqueMap[sName];

                if (akra.isDefAndNotNull(pTechnique)) {
                    this._pTechnique = pTechnique;
                    return true;
                }

                return false;
            };

            RenderableObject.prototype.removeRenderMethod = function (csName) {
                var pTechnique = this._pTechniqueMap[csName];

                if (akra.isDefAndNotNull(pTechnique)) {
                    delete this._pTechniqueMap[csName || DEFAULT_RT];
                    return true;
                }

                return false;
            };

            RenderableObject.prototype.getRenderMethodByName = function (csName) {
                if (typeof csName === "undefined") { csName = null; }
                var pTechnique = this._pTechniqueMap[csName || DEFAULT_RT];
                return pTechnique ? pTechnique.getMethod() : null;
            };

            RenderableObject.prototype.getRenderMethodDefault = function () {
                return this.getRenderMethodByName(DEFAULT_RM);
            };

            RenderableObject.prototype.isReadyForRender = function () {
                return this._bVisible && this._pTechnique.isReady();
            };

            RenderableObject.prototype.isAllMethodsLoaded = function () {
                for (var i in this._pTechniqueMap) {
                    var pMethod = this._pTechniqueMap[i].getMethod();

                    if (!akra.isDefAndNotNull(pMethod) || pMethod.isReady()) {
                        return false;
                    }
                }

                return true;
            };

            RenderableObject.prototype.isFrozen = function () {
                return this._bFrozen;
            };

            RenderableObject.prototype.wireframe = function (bEnable, bOverlay) {
                if (typeof bEnable === "undefined") { bEnable = true; }
                if (typeof bOverlay === "undefined") { bOverlay = true; }
                var pDefaultRm = this.getRenderMethodDefault();

                if (!bEnable) {
                    if (pDefaultRm.getEffect().hasComponent("akra.system.wireframe")) {
                        pDefaultRm.getEffect().delComponent("akra.system.wireframe", 0, 0);
                    }
                    return;
                }

                if (this.getData().useSingleIndex()) {
                    return false;

                    //TODO: calc right positions, for wireframed data.
                    if (!this.getData().hasSemantics("BARYCENTRIC")) {
                        //var ePrimType: EPrimitiveTypes = this.getData().getPrimitiveType();
                        //if (ePrimType !== EPrimitiveTypes.TRIANGLELIST/* && ePrimType !== EPrimitiveTypes.TRIANGLESTRIP*/) {
                        //	logger.warn("wireframe supported only for TRIANGLELIST");
                        //	return false;
                        //}
                        //var pIndicesU16: Uint16Array = <Uint16Array>(<IIndexData>this.getData().getIndices()).getTypedData();
                        //var pBarycentric: Float32Array = new Float32Array(pIndicesU16.length);
                        //var pIndices: Float32Array = new Float32Array(pIndicesU16.length);
                        //if (ePrimType == EPrimitiveTypes.TRIANGLELIST) {
                        //	for (var n = 0; n < pIndicesU16.length; ++n) {
                        //		pIndices[pIndicesU16[n]] = n;
                        //		pBarycentric[n] = pIndicesU16[n] % 3;
                        //	}
                        //}
                        //this.getData()._allocateData(<any>[VE.float('BARYCENTRIC')], pBarycentric, ERenderDataTypes.INDEXED);
                        //this.getData().allocateAttribute([VE.float('BARYCENTRIC_INDEX')], pIndices, ERenderDataAttributeTypes.STATIC, true);
                        //this.getData().index('BARYCENTRIC', 'BARYCENTRIC_INDEX');
                    }
                } else if (this.getData().getDataLocation("BARYCENTRIC") == -1) {
                    var ePrimType = this.getData().getPrimitiveType();

                    if (ePrimType !== 4 /* TRIANGLELIST */) {
                        akra.logger.warn("wireframe supported only for TRIANGLELIST");
                        return false;
                    }

                    //var iPosition: int = this.getData().getDataLocation('POSITION');
                    var pIndices = this.getData().getIndexFor("POSITION");

                    // var pIndices: Float32Array = <any>this.data._getFlow("POSITION").mapper.data.getTypedData(this.data._getFlow("POSITION").mapper.semantics);
                    var pBarycentric = new Float32Array(pIndices.length);

                    if (ePrimType == 4 /* TRIANGLELIST */) {
                        for (var n = 0; n < pIndices.length; ++n) {
                            pIndices[n] = n;
                            pBarycentric[n] = n % 3;
                        }
                    }

                    this.getData().allocateData([VE.float('BARYCENTRIC')], pBarycentric);
                    this.getData().allocateIndex([VE.float('BARYCENTRIC_INDEX')], pIndices);

                    this.getData().index('BARYCENTRIC', 'BARYCENTRIC_INDEX');
                }

                this._bWireframeOverlay = bOverlay;

                pDefaultRm.getEffect().addComponent("akra.system.wireframe", 0, 0);
            };

            RenderableObject.prototype.render = function (pViewport, csMethod, pSceneObject) {
                if (typeof csMethod === "undefined") { csMethod = null; }
                if (typeof pSceneObject === "undefined") { pSceneObject = null; }
                if (!this.isReadyForRender() || (!akra.isNull(pSceneObject) && pSceneObject.isHidden())) {
                    return;
                }

                if (!this.switchRenderMethod(csMethod)) {
                    //debug.error("could not switch render method <" + csMethod + ">");
                    return;
                }

                this.beforeRender.emit(pViewport, this._pTechnique.getMethod());

                this.getData()._draw(this._pTechnique, pViewport, this, pSceneObject);
            };

            RenderableObject.prototype.getTechnique = function (sName) {
                if (typeof sName === "undefined") { sName = DEFAULT_RT; }
                return this._pTechniqueMap[sName || DEFAULT_RT] || null;
            };

            RenderableObject.prototype.getTechniqueDefault = function () {
                return this.getTechnique(DEFAULT_RT);
            };

            RenderableObject.prototype._draw = function () {
                akra.logger.error("RenderableObject::_draw() pure virtual method() isn't callable!!");
            };

            RenderableObject.prototype.isVisible = function () {
                return this._bVisible;
            };
            RenderableObject.prototype.setVisible = function (bVisible) {
                if (typeof bVisible === "undefined") { bVisible = true; }
                this._bVisible = bVisible;
            };
            return RenderableObject;
        })();
        render.RenderableObject = RenderableObject;

        function isScreen(pObject) {
            return pObject.getType() === 2 /* SCREEN */;
        }
        render.isScreen = isScreen;

        function isSprite(pObject) {
            return pObject.getType() === 3 /* SPRITE */;
        }
        render.isSprite = isSprite;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="IVec2.ts" />
var akra;
(function (akra) {
    ;
})(akra || (akra = {}));
/// <reference path="../idl/IRay2d.ts" />
/// <reference path="../math/math.ts" />
var akra;
(function (akra) {
    (function (geometry) {
        var Vec2 = akra.math.Vec2;

        var Ray2d = (function () {
            function Ray2d() {
                this.point = new Vec2();
                this.normal = new Vec2();
            }
            return Ray2d;
        })();
        geometry.Ray2d = Ray2d;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
/// <reference path="../idl/IRay3d.ts" />
/// <reference path="../math/math.ts" />
var akra;
(function (akra) {
    (function (geometry) {
        var Vec3 = akra.math.Vec3;

        var Ray3d = (function () {
            function Ray3d() {
                this.point = new Vec3();
                this.normal = new Vec3();
            }
            return Ray3d;
        })();
        geometry.Ray3d = Ray3d;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
/// <reference path="IRay2d.ts" />
var akra;
(function (akra) {
    ;
})(akra || (akra = {}));
/// <reference path="../idl/ISegment2d.ts" />
/// <reference path="Ray2d.ts" />
var akra;
(function (akra) {
    (function (geometry) {
        var Segment2d = (function () {
            function Segment2d() {
                this.ray = new geometry.Ray2d();
                this.distance = 0.;
            }
            Segment2d.prototype.getPoint = function () {
                return this.ray.point;
            };

            Segment2d.prototype.setPoint = function (v2fPoint) {
                this.ray.point.set(v2fPoint);
            };

            Segment2d.prototype.getNormal = function () {
                return this.ray.normal;
            };

            Segment2d.prototype.setNormal = function (v2fNormal) {
                this.ray.normal.set(v2fNormal);
            };
            return Segment2d;
        })();
        geometry.Segment2d = Segment2d;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
/// <reference path="IRay3d.ts" />
var akra;
(function (akra) {
    ;
})(akra || (akra = {}));
/// <reference path="../idl/ISegment3d.ts" />
/// <reference path="Ray3d.ts" />
var akra;
(function (akra) {
    (function (geometry) {
        var Segment3d = (function () {
            function Segment3d() {
                this.ray = new geometry.Ray3d();
                this.distance = 0.;
            }
            Segment3d.prototype.getPoint = function () {
                return this.ray.point;
            };

            Segment3d.prototype.setPoint = function (v3fPoint) {
                this.ray.point.set(v3fPoint);
            };

            Segment3d.prototype.getNormal = function () {
                return this.ray.normal;
            };

            Segment3d.prototype.setNormal = function (v3fNormal) {
                this.ray.normal.set(v3fNormal);
            };
            return Segment3d;
        })();
        geometry.Segment3d = Segment3d;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
/// <reference path="../idl/ICircle.ts" />
/// <reference path="../math/math.ts" />
var akra;
(function (akra) {
    (function (geometry) {
        var Vec2 = akra.math.Vec2;

        var Circle = (function () {
            function Circle(fCenterX, fCenterY, fRadius) {
                var n = arguments.length;

                switch (n) {
                    case 1:
                        var pCircle = arguments[0];
                        this.center = new Vec2(pCircle.center);
                        this.radius = pCircle.radius;
                        break;
                    case 2:
                        var v2fCenter = arguments[0];

                        //var fRadius: float = arguments[1];
                        this.center = new Vec2(v2fCenter);
                        this.radius = arguments[1];
                        ;
                        break;
                    case 3:
                        this.center = new Vec2(arguments[0], arguments[1]);
                        this.radius = arguments[2];
                        break;
                    default:
                        this.center = new Vec2();
                        this.radius = 0.;
                        break;
                }
            }
            Circle.prototype.set = function (fCenterX, fCenterY, fRadius) {
                var nArgumentsLength = arguments.length;

                switch (nArgumentsLength) {
                    case 1:
                        var pCircle = arguments[0];
                        this.center.set(pCircle.center);
                        this.radius = pCircle.radius;
                        break;
                    case 2:
                        var v2fCenter = arguments[0];

                        //var fRadius: float = arguments[1];
                        this.center.set(v2fCenter);
                        this.radius = arguments[1];
                        break;
                    case 3:
                        this.center.set(arguments[0], arguments[1]);
                        this.radius = arguments[2];
                        break;
                    default:
                        this.center.set(0.);
                        this.radius = 0.;
                }

                return this;
            };

            /**  */ Circle.prototype.clear = function () {
                this.center.clear();
                this.radius = 0.;

                return this;
            };

            /**  */ Circle.prototype.isEqual = function (pCircle) {
                return this.center.isEqual(pCircle.center) && (this.radius == pCircle.radius);
            };

            /**  */ Circle.prototype.isClear = function () {
                return this.center.isClear() && (this.radius === 0.);
            };

            /**  */ Circle.prototype.isValid = function () {
                return (this.radius >= 0.);
            };

            /**  */ Circle.prototype.offset = function (v2fOffset) {
                this.center.add(v2fOffset);
                return this;
            };

            /**  */ Circle.prototype.expand = function (fInc) {
                this.radius += fInc;
                return this;
            };

            /**  */ Circle.prototype.normalize = function () {
                this.radius = akra.math.abs(this.radius);
                return this;
            };
            return Circle;
        })();
        geometry.Circle = Circle;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
/// <reference path="../idl/ISphere.ts" />
/// <reference path="../math/math.ts" />
/// <reference path="Circle.ts" />
var akra;
(function (akra) {
    (function (geometry) {
        var Vec3 = akra.math.Vec3;
        var Vec4 = akra.math.Vec4;
        var Quat4 = akra.math.Quat4;
        var Mat3 = akra.math.Mat3;

        var Sphere = (function () {
            function Sphere(fCenterX, fCenterY, fCenterZ, fRadius) {
                var nArgumentsLength = arguments.length;

                switch (nArgumentsLength) {
                    case 1:
                        var pSphere = arguments[0];

                        this.center = new Vec3(pSphere.v3fCenter);
                        this.radius = pSphere.fRadius;
                        break;
                    case 2:
                        var v3fCenter = arguments[0];

                        //var fRadius: float = arguments[1];
                        this.center = new Vec3(v3fCenter);
                        this.radius = arguments[1];
                        break;
                    case 4:
                        this.center = new Vec3(arguments[0], arguments[1], arguments[2]);
                        this.radius = arguments[3];
                        break;
                    default:
                        this.center = new Vec3();
                        this.radius = 0.;
                        break;
                }
            }
            Sphere.prototype.getCircle = function () {
                var v3fCenter = this.center;
                return new geometry.Circle(v3fCenter.x, v3fCenter.y, this.radius);
            };

            Sphere.prototype.setCircle = function (pCircle) {
                var v3fCenter = this.center;
                var v2fCircleCenter = pCircle.center;
                v3fCenter.x = v2fCircleCenter.x;
                v3fCenter.y = v2fCircleCenter.y;
                this.radius = pCircle.radius;
            };

            Sphere.prototype.getZ = function () {
                return this.center.z;
            };

            Sphere.prototype.setZ = function (fZ) {
                this.center.z = fZ;
            };

            Sphere.prototype.set = function (fCenterX, fCenterY, fCenterZ, fRadius) {
                var nArgumentsLength = arguments.length;

                switch (nArgumentsLength) {
                    case 1:
                        var pSphere = arguments[0];

                        this.center.set(pSphere.center);
                        this.radius = pSphere.radius;
                        break;
                    case 2:
                        var v3fCenter = arguments[0];

                        //var fRadius: float = arguments[1];
                        this.center.set(v3fCenter);
                        this.radius = arguments[1];
                        break;
                    case 4:
                        this.center.set(arguments[0], arguments[1], arguments[2]);
                        this.radius = arguments[3];
                        break;
                    default:
                        this.center.set(0.);
                        this.radius = 0.;
                        break;
                }

                return this;
            };

            /**  */ Sphere.prototype.clear = function () {
                this.center.clear();
                this.radius = 0.;

                return this;
            };

            /**  */ Sphere.prototype.isEqual = function (pSphere) {
                return this.center.isEqual(pSphere.center) && (this.radius == pSphere.radius);
            };

            /**  */ Sphere.prototype.isClear = function () {
                return this.center.isClear() && (this.radius === 0.);
            };

            /**  */ Sphere.prototype.isValid = function () {
                return (this.radius >= 0.);
            };

            /**  */ Sphere.prototype.offset = function (v3fOffset) {
                this.center.add(v3fOffset);
                return this;
            };

            /**  */ Sphere.prototype.expand = function (fInc) {
                this.radius += fInc;
                return this;
            };

            /**  */ Sphere.prototype.normalize = function () {
                this.radius = akra.math.abs(this.radius);
                return this;
            };

            Sphere.prototype.transform = function (m4fMatrix) {
                var v4fTmp = Vec4.temp(this.center, 1.);
                v4fTmp = m4fMatrix.multiplyVec4(v4fTmp);

                this.center.set(v4fTmp.clone("xyz"));

                var m3fTmp = m4fMatrix.toMat3(Mat3.temp());
                var v3fScale = Vec3.temp();

                m3fTmp.decompose(Quat4.temp(), v3fScale);

                var fScaleX = akra.math.abs(v3fScale.x);
                var fScaleY = akra.math.abs(v3fScale.y);
                var fScaleZ = akra.math.abs(v3fScale.z);

                var fMaxScale;

                if (fScaleX >= fScaleY && fScaleX >= fScaleZ) {
                    fMaxScale = fScaleX;
                } else if (fScaleY >= fScaleX && fScaleY >= fScaleZ) {
                    fMaxScale = fScaleY;
                } else {
                    fMaxScale = fScaleZ;
                }

                this.radius *= fMaxScale;

                return this;
            };
            return Sphere;
        })();
        geometry.Sphere = Sphere;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
/// <reference path="../idl/IRect2d.ts" />
/// <reference path="../math/math.ts" />
/// <reference path="../logger.ts" />
/// <reference path="Circle.ts" />
var akra;
(function (akra) {
    (function (geometry) {
        var Vec2 = akra.math.Vec2;

        var Rect2d = (function () {
            function Rect2d(fX0, fX1, fY0, fY1) {
                var nArgumentsLength = arguments.length;

                switch (nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 2:
                        this.set(arguments[0], arguments[1]);
                        break;
                    case 4:
                        this.set(arguments[0], arguments[1], arguments[2], arguments[3]);
                        break;
                    default:
                        this.x0 = this.x1 = this.y0 = this.y1 = 0.;
                        break;
                }
            }
            Rect2d.prototype.getLeft = function () {
                return this.x0;
            };

            Rect2d.prototype.getTop = function () {
                return this.y0;
            };

            Rect2d.prototype.getWidth = function () {
                return this.x1 - this.x0;
            };

            Rect2d.prototype.getHeight = function () {
                return this.y1 - this.y0;
            };

            Rect2d.prototype.set = function (fX0, fX1, fY0, fY1) {
                var nArgumentsLength = arguments.length;

                switch (nArgumentsLength) {
                    case 1:
                        if (arguments[0] instanceof Rect2d) {
                            var pRect = arguments[0];

                            this.x0 = pRect.x0;
                            this.x1 = pRect.x1;
                            this.y0 = pRect.y0;
                            this.y1 = pRect.y1;
                        } else {
                            var v2fSizes = arguments[0];

                            this.x1 = v2fSizes.x * 0.5;
                            this.x0 = -this.x1;

                            this.y1 = v2fSizes.y * 0.5;
                            this.y0 = -this.y1;
                        }
                        break;
                    case 2:
                        if (akra.isNumber(arguments[0])) {
                            var fSizeX = arguments[0];
                            var fSizeY = arguments[1];

                            this.x1 = fSizeX * 0.5;
                            this.x0 = -this.x1;

                            this.y1 = fSizeY * 0.5;
                            this.y0 = -this.y1;
                        } else {
                            this.x0 = arguments[0].x;
                            this.y0 = arguments[0].y;

                            this.x1 = arguments[1].x;
                            this.y1 = arguments[1].y;
                        }
                        break;
                    case 4:
                        this.x0 = arguments[0];
                        this.x1 = arguments[1];
                        this.y0 = arguments[2];
                        this.y1 = arguments[3];
                        break;
                    default:
                        this.x0 = this.x1 = this.y0 = this.y1 = 0.;
                        break;
                }

                return this;
            };

            Rect2d.prototype.setFloor = function (pRect) {
                this.x0 = akra.math.floor(pRect.x0);
                this.x1 = akra.math.floor(pRect.x1);
                this.y0 = akra.math.floor(pRect.y0);
                this.y1 = akra.math.floor(pRect.y1);

                return this;
            };

            Rect2d.prototype.setCeil = function (pRect) {
                this.x0 = akra.math.ceil(pRect.x0);
                this.x1 = akra.math.ceil(pRect.x1);
                this.y0 = akra.math.ceil(pRect.y0);
                this.y1 = akra.math.ceil(pRect.y1);

                return this;
            };

            Rect2d.prototype.clear = function () {
                this.x0 = this.x1 = this.y0 = this.y1 = 0.;
                return this;
            };

            Rect2d.prototype.addSelf = function () {
                if (akra.isFloat(arguments[0])) {
                    var fValue = arguments[0];

                    this.x0 += fValue;
                    this.x1 += fValue;
                    this.y0 += fValue;
                    this.y1 += fValue;
                } else {
                    var v2fVec = arguments[0];

                    this.x0 += v2fVec.x;
                    this.x1 += v2fVec.x;

                    this.y0 += v2fVec.y;
                    this.y1 += v2fVec.y;
                }

                return this;
            };

            Rect2d.prototype.subSelf = function () {
                if (akra.isFloat(arguments[0])) {
                    var fValue = arguments[0];

                    this.x0 -= fValue;
                    this.x1 -= fValue;
                    this.y0 -= fValue;
                    this.y1 -= fValue;
                } else {
                    var v2fVec = arguments[0];

                    this.x0 -= v2fVec.x;
                    this.x1 -= v2fVec.x;

                    this.y0 -= v2fVec.y;
                    this.y1 -= v2fVec.y;
                }

                return this;
            };

            Rect2d.prototype.multSelf = function () {
                if (akra.isFloat(arguments[0])) {
                    var fValue = arguments[0];

                    this.x0 *= fValue;
                    this.x1 *= fValue;
                    this.y0 *= fValue;
                    this.y1 *= fValue;
                } else {
                    var v2fVec = arguments[0];

                    this.x0 *= v2fVec.x;
                    this.x1 *= v2fVec.x;

                    this.y0 *= v2fVec.y;
                    this.y1 *= v2fVec.y;
                }

                return this;
            };

            Rect2d.prototype.divSelf = function () {
                if (akra.isFloat(arguments[0])) {
                    var fValue = arguments[0];
                    akra.logger.assert(fValue != 0., "divide by zero error");

                    var fInvValue = 1. / fValue;

                    this.x0 *= fInvValue;
                    this.x1 *= fInvValue;
                    this.y0 *= fInvValue;
                    this.y1 *= fInvValue;
                } else {
                    var v2fVec = arguments[0];

                    akra.logger.assert(v2fVec.x != 0., "divide by zero error");
                    akra.logger.assert(v2fVec.y != 0., "divide by zero error");

                    var fInvX = 1. / v2fVec.x;
                    var fInvY = 1. / v2fVec.y;

                    this.x0 *= fInvX;
                    this.x1 *= fInvX;

                    this.y0 *= fInvY;
                    this.y1 *= fInvY;
                }

                return this;
            };

            Rect2d.prototype.offset = function (fOffsetX, fOffsetY) {
                if (arguments.length === 1) {
                    var v2fOffset = arguments[0];

                    this.x0 += v2fOffset.x;
                    this.x1 += v2fOffset.x;

                    this.y0 += v2fOffset.y;
                    this.y1 += v2fOffset.y;
                } else {
                    this.x0 += arguments[0];
                    this.x1 += arguments[0];

                    this.y0 += arguments[1];
                    this.y1 += arguments[1];
                }

                return this;
            };

            Rect2d.prototype.expand = function (fValueX, fValueY) {
                if (arguments.length == 1) {
                    if (akra.isFloat(arguments[0])) {
                        var fValue = arguments[0];

                        this.x0 -= fValue;
                        this.x1 += fValue;

                        this.y0 -= fValue;
                        this.y1 += fValue;
                    } else {
                        var v2fValue = arguments[0];

                        this.x0 -= v2fValue.x;
                        this.x1 += v2fValue.x;

                        this.y0 -= v2fValue.y;
                        this.y1 += v2fValue.y;
                    }
                } else {
                    //arguments.length == 2
                    this.x0 -= arguments[0];
                    this.x1 += arguments[0];

                    this.y0 -= arguments[1];
                    this.y1 += arguments[1];
                }

                return this;
            };

            Rect2d.prototype.expandX = function (fValue) {
                this.x0 -= fValue;
                this.x1 += fValue;

                return this;
            };

            Rect2d.prototype.expandY = function (fValue) {
                this.y0 -= fValue;
                this.y1 += fValue;

                return this;
            };

            Rect2d.prototype.resize = function () {
                var fSizeX, fSizeY;

                if (arguments.length == 1) {
                    var v2fSize = arguments[0];

                    fSizeX = v2fSize.x;
                    fSizeY = v2fSize.y;
                } else {
                    fSizeX = arguments[0];
                    fSizeY = arguments[1];
                }

                this.x1 = (this.x0 + this.x1 + fSizeX) * 0.5;
                this.x0 = this.x1 - fSizeX;

                this.y1 = (this.y0 + this.y1 + fSizeY) * 0.5;
                this.y0 = this.y1 - fSizeY;

                return this;
            };

            Rect2d.prototype.resizeX = function (fSize) {
                this.x1 = (this.x0 + this.x1 + fSize) * 0.5;
                this.x0 = this.x1 - fSize;

                return this;
            };

            Rect2d.prototype.resizeY = function (fSize) {
                this.y1 = (this.y0 + this.y1 + fSize) * 0.5;
                this.y0 = this.y1 - fSize;

                return this;
            };

            Rect2d.prototype.resizeMax = function (fSpanX, fSpanY) {
                if (arguments.length == 1) {
                    var v2fSpan = arguments[0];

                    this.x1 = this.x0 + v2fSpan.x;
                    this.y1 = this.y0 + v2fSpan.y;
                } else {
                    this.x1 = this.x0 + arguments[0];
                    this.y1 = this.y0 + arguments[1];
                }

                return this;
            };

            Rect2d.prototype.resizeMaxX = function (fSpan) {
                this.x1 = this.x0 + fSpan;
                return this;
            };

            Rect2d.prototype.resizeMaxY = function (fSpan) {
                this.y1 = this.y0 + fSpan;
                return this;
            };

            Rect2d.prototype.resizeMin = function (fSpanX, fSpanY) {
                if (arguments.length == 1) {
                    var v2fSpan = arguments[0];

                    this.x0 = this.x1 - v2fSpan.x;
                    this.y0 = this.y1 - v2fSpan.y;
                } else {
                    this.x0 = this.x1 - arguments[0];
                    this.y0 = this.y1 - arguments[1];
                }

                return this;
            };

            Rect2d.prototype.resizeMinX = function (fSpan) {
                this.x0 = this.x1 - fSpan;
                return this;
            };

            Rect2d.prototype.resizeMinY = function (fSpan) {
                this.y0 = this.y1 - fSpan;
                return this;
            };

            Rect2d.prototype.unionPoint = function () {
                if (arguments.length === 1) {
                    var v2fPoint = arguments[0];

                    this.x0 = akra.math.min(this.x0, v2fPoint.x);
                    this.x1 = akra.math.max(this.x1, v2fPoint.x);

                    this.y0 = akra.math.min(this.y0, v2fPoint.y);
                    this.y1 = akra.math.max(this.y1, v2fPoint.y);
                } else {
                    var fX = arguments[0];
                    var fY = arguments[1];

                    this.x0 = akra.math.min(this.x0, fX);
                    this.x1 = akra.math.max(this.x1, fX);

                    this.y0 = akra.math.min(this.y0, fY);
                    this.y1 = akra.math.max(this.y1, fY);
                }

                return this;
            };

            Rect2d.prototype.unionRect = function (pRect) {
                this.normalize();
                pRect.normalize();

                this.x0 = akra.math.min(this.x0, pRect.x0);
                this.x1 = akra.math.max(this.x1, pRect.x1);

                this.y0 = akra.math.min(this.y0, pRect.y0);
                this.y1 = akra.math.max(this.y1, pRect.y1);

                return this;
            };

            Rect2d.prototype.negate = function (pDestination) {
                if (!akra.isDef(pDestination)) {
                    pDestination = this;
                }

                return pDestination.set(-this.x1, -this.x0, -this.y1, -this.y0);
            };

            Rect2d.prototype.normalize = function () {
                var fTmp;
                if (this.x0 > this.x1) {
                    fTmp = this.x0;
                    this.x0 = this.x1;
                    this.x1 = fTmp;
                }
                if (this.y0 > this.y1) {
                    fTmp = this.y0;
                    this.y0 = this.y1;
                    this.y1 = fTmp;
                }
                return this;
            };

            Rect2d.prototype.isEqual = function (pRect) {
                return this.x0 == pRect.x0 && this.x1 == pRect.x1 && this.y0 == pRect.y0 && this.y1 == pRect.y1;
            };

            Rect2d.prototype.isClear = function () {
                return this.x0 == 0. && this.x1 == 0. && this.y0 == 0. && this.y1 == 0.;
            };

            Rect2d.prototype.isValid = function () {
                return this.x0 <= this.x1 && this.y0 <= this.y1;
            };

            Rect2d.prototype.isPointInRect = function (v2fPoint) {
                var x = v2fPoint.x;
                var y = v2fPoint.y;

                return (this.x0 <= x && x <= this.x1) && (this.y0 <= y && y <= this.y1);
            };

            Rect2d.prototype.midPoint = function (v2fDestination) {
                if (!akra.isDef(v2fDestination)) {
                    v2fDestination = new Vec2();
                }

                v2fDestination.x = (this.x0 + this.x1) * 0.5;
                v2fDestination.y = (this.y0 + this.y1) * 0.5;

                return v2fDestination;
            };

            Rect2d.prototype.midX = function () {
                return (this.x0 + this.x1) * 0.5;
            };

            Rect2d.prototype.midY = function () {
                return (this.y0 + this.y1) * 0.5;
            };

            Rect2d.prototype.size = function (v2fDestination) {
                if (!akra.isDef(v2fDestination)) {
                    v2fDestination = new Vec2();
                }

                v2fDestination.x = this.x1 - this.x0;
                v2fDestination.y = this.y1 - this.y0;

                return v2fDestination;
            };

            Rect2d.prototype.sizeX = function () {
                return this.x1 - this.x0;
            };

            Rect2d.prototype.sizeY = function () {
                return this.y1 - this.y0;
            };

            Rect2d.prototype.minPoint = function (v2fDestination) {
                if (!akra.isDef(v2fDestination)) {
                    v2fDestination = new Vec2();
                }

                v2fDestination.x = this.x0;
                v2fDestination.y = this.y0;

                return v2fDestination;
            };

            Rect2d.prototype.maxPoint = function (v2fDestination) {
                if (!akra.isDef(v2fDestination)) {
                    v2fDestination = new Vec2();
                }

                v2fDestination.x = this.x1;
                v2fDestination.y = this.y1;

                return v2fDestination;
            };

            Rect2d.prototype.area = function () {
                return (this.x1 - this.x0) * (this.y1 - this.y0);
            };

            /**
            * counter-clockwise
            * x0,y0 -> x1,y0 -> x1,y1 -> x0,y1;
            */
            Rect2d.prototype.corner = function (iIndex, v2fDestination) {
                if (!akra.isDef(v2fDestination)) {
                    v2fDestination = new Vec2();
                }

                akra.logger.assert(0 <= iIndex && iIndex < 4, "invalid index");

                switch (iIndex) {
                    case 0:
                        v2fDestination.set(this.x0, this.y0);
                        break;
                    case 1:
                        v2fDestination.set(this.x1, this.y0);
                        break;
                    case 2:
                        v2fDestination.set(this.x1, this.y1);
                        break;
                    case 3:
                        v2fDestination.set(this.x0, this.y1);
                        break;
                }
                return v2fDestination;
            };

            Rect2d.prototype.createBoundingCircle = function (pCircle) {
                if (!akra.isDef(pCircle)) {
                    pCircle = new geometry.Circle();
                }

                var fX0 = this.x0, fX1 = this.x1;
                var fY0 = this.y0, fY1 = this.y1;

                var fHalfSizeX = (fX1 - fX0) * 0.5;
                var fHalfSizeY = (fY1 - fY0) * 0.5;

                pCircle.set((fX0 + fX1) * 0.5, (fY0 + fY1) * 0.5, akra.math.sqrt(fHalfSizeX * fHalfSizeX + fHalfSizeY * fHalfSizeY));

                return pCircle;
            };

            Rect2d.prototype.distanceToPoint = function (v2fPoint) {
                var fX = v2fPoint.x, fY = v2fPoint.y;

                var fX0 = this.x0, fY0 = this.y0;
                var fX1 = this.x1, fY1 = this.y1;

                var fXN, fYN;

                fXN = (akra.math.abs(fX0 - fX) < akra.math.abs(fX1 - fX)) ? fX0 : fX1;
                fYN = (akra.math.abs(fY0 - fY) < akra.math.abs(fY1 - fY)) ? fY0 : fY1;

                return akra.math.sqrt((fXN - fX) * (fXN - fX) + (fYN - fY) * (fYN - fY));
            };

            Rect2d.prototype.toString = function () {
                return "(" + this.x0 + ", " + this.y0 + ") --> (" + this.x1 + ", " + this.y1 + ")";
            };
            return Rect2d;
        })();
        geometry.Rect2d = Rect2d;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
/// <reference path="../idl/IRect3d.ts" />
/// <reference path="../idl/IRect2d.ts" />
/// <reference path="../math/math.ts" />
/// <reference path="../gen/generate.ts" />
/// <reference path="../logger.ts" />
/// <reference path="geometry.ts" />
var akra;
(function (akra) {
    (function (geometry) {
        var __11 = akra.math.__11;
        var __12 = akra.math.__12;
        var __13 = akra.math.__13;
        var __14 = akra.math.__14;
        var __21 = akra.math.__21;
        var __22 = akra.math.__22;
        var __23 = akra.math.__23;
        var __24 = akra.math.__24;
        var __31 = akra.math.__31;
        var __32 = akra.math.__32;
        var __33 = akra.math.__33;
        var __34 = akra.math.__34;

        var Vec3 = akra.math.Vec3;

        var pBuffer;
        var iElement;

        var Rect3d = (function () {
            function Rect3d(fX0, fX1, fY0, fY1, fZ0, fZ1) {
                var nArgumentsLength = arguments.length;

                switch (nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 2:
                        this.set(arguments[0], arguments[1]);
                        break;
                    case 3:
                        this.set(arguments[0], arguments[1], arguments[2]);
                        break;
                    case 6:
                        this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                        break;
                    default:
                        this.x0 = this.x1 = this.y0 = this.y1 = this.z0 = this.z1 = 0.;
                        break;
                }
            }
            Rect3d.prototype.getRect2d = function () {
                return new geometry.Rect2d(this.x0, this.x1, this.y0, this.y1);
            };

            Rect3d.prototype.setRect2d = function (pRect) {
                this.x0 = pRect.x0;
                this.x1 = pRect.x1;
                this.y0 = pRect.y0;
                this.y1 = pRect.y1;
            };

            Rect3d.prototype.set = function (fX0, fX1, fY0, fY1, fZ0, fZ1) {
                var nArgumentsLength = arguments.length;

                switch (nArgumentsLength) {
                    case 1:
                        if (arguments[0] instanceof Rect3d) {
                            var pRect = arguments[0];

                            this.x0 = pRect.x0;
                            this.x1 = pRect.x1;
                            this.y0 = pRect.y0;
                            this.y1 = pRect.y1;
                            this.z0 = pRect.z0;
                            this.z1 = pRect.z1;
                        } else {
                            var v3fSize = arguments[0];

                            this.x1 = v3fSize.x * 0.5;
                            this.x0 = -this.x1;

                            this.y1 = v3fSize.y * 0.5;
                            this.y0 = -this.y1;

                            this.z1 = v3fSize.z * 0.5;
                            this.z0 = -this.z1;
                        }
                        break;
                    case 2:
                        var v3fMinPoint = arguments[0];
                        var v3fMaxPoint = arguments[1];

                        this.x0 = v3fMinPoint.x;
                        this.y0 = v3fMinPoint.y;
                        this.z0 = v3fMinPoint.z;

                        this.x1 = v3fMaxPoint.x;
                        this.y1 = v3fMaxPoint.y;
                        this.z1 = v3fMaxPoint.z;
                        break;
                    case 3:
                        var fSizeX = arguments[0];
                        var fSizeY = arguments[1];
                        var fSizeZ = arguments[2];

                        this.x1 = fSizeX * 0.5;
                        this.x0 = -this.x1;

                        this.y1 = fSizeY * 0.5;
                        this.y0 = -this.y1;

                        this.z1 = fSizeZ * 0.5;
                        this.z0 = -this.z1;
                        break;
                    case 6:
                        this.x0 = arguments[0];
                        this.x1 = arguments[1];

                        this.y0 = arguments[2];
                        this.y1 = arguments[3];

                        this.z0 = arguments[4];
                        this.z1 = arguments[5];
                        break;
                    default:
                        this.x0 = this.x1 = this.y0 = this.y1 = this.z0 = this.z1 = 0.;
                        break;
                }
                return this;
            };

            Rect3d.prototype.setFloor = function (pRect) {
                this.x0 = akra.math.floor(pRect.x0);
                this.x1 = akra.math.floor(pRect.x1);
                this.y0 = akra.math.floor(pRect.y0);
                this.y1 = akra.math.floor(pRect.y1);
                this.z0 = akra.math.floor(pRect.z0);
                this.z1 = akra.math.floor(pRect.z1);

                return this;
            };

            Rect3d.prototype.setCeil = function (pRect) {
                this.x0 = akra.math.ceil(pRect.x0);
                this.x1 = akra.math.ceil(pRect.x1);
                this.y0 = akra.math.ceil(pRect.y0);
                this.y1 = akra.math.ceil(pRect.y1);
                this.z0 = akra.math.ceil(pRect.z0);
                this.z1 = akra.math.ceil(pRect.z1);

                return this;
            };

            Rect3d.prototype.clear = function () {
                this.x0 = this.x1 = this.y0 = this.y1 = this.z0 = this.z1 = 0.;
                return this;
            };

            Rect3d.prototype.addSelf = function () {
                if (akra.isFloat(arguments[0])) {
                    var fValue = arguments[0];

                    this.x0 += fValue;
                    this.x1 += fValue;
                    this.y0 += fValue;
                    this.y1 += fValue;
                    this.z0 += fValue;
                    this.z1 += fValue;
                } else {
                    var v3fVec = arguments[0];

                    this.x0 += v3fVec.x;
                    this.x1 += v3fVec.x;

                    this.y0 += v3fVec.y;
                    this.y1 += v3fVec.y;

                    this.z0 += v3fVec.z;
                    this.z1 += v3fVec.z;
                }

                return this;
            };

            Rect3d.prototype.subSelf = function () {
                if (akra.isFloat(arguments[0])) {
                    var fValue = arguments[0];

                    this.x0 -= fValue;
                    this.x1 -= fValue;
                    this.y0 -= fValue;
                    this.y1 -= fValue;
                    this.z0 -= fValue;
                    this.z1 -= fValue;
                } else {
                    var v3fVec = arguments[0];

                    this.x0 -= v3fVec.x;
                    this.x1 -= v3fVec.x;

                    this.y0 -= v3fVec.y;
                    this.y1 -= v3fVec.y;

                    this.z0 -= v3fVec.z;
                    this.z1 -= v3fVec.z;
                }

                return this;
            };

            Rect3d.prototype.multSelf = function () {
                if (akra.isFloat(arguments[0])) {
                    var fValue = arguments[0];

                    this.x0 *= fValue;
                    this.x1 *= fValue;
                    this.y0 *= fValue;
                    this.y1 *= fValue;
                    this.z0 *= fValue;
                    this.z1 *= fValue;
                } else {
                    var v3fVec = arguments[0];

                    this.x0 *= v3fVec.x;
                    this.x1 *= v3fVec.x;

                    this.y0 *= v3fVec.y;
                    this.y1 *= v3fVec.y;

                    this.z0 *= v3fVec.z;
                    this.z1 *= v3fVec.z;
                }

                return this;
            };

            Rect3d.prototype.divSelf = function () {
                if (akra.isFloat(arguments[0])) {
                    var fValue = arguments[0];

                    akra.logger.assert(fValue != 0.0, "divide by zero error");

                    var fInvValue = 1. / fValue;

                    this.x0 *= fInvValue;
                    this.x1 *= fInvValue;
                    this.y0 *= fInvValue;
                    this.y1 *= fInvValue;
                    this.z0 *= fInvValue;
                    this.z1 *= fInvValue;
                } else {
                    var v3fVec = arguments[0];

                    akra.logger.assert(v3fVec.x != 0.0, "divide by zero error");
                    akra.logger.assert(v3fVec.y != 0.0, "divide by zero error");
                    akra.logger.assert(v3fVec.z != 0.0, "divide by zero error");

                    var fInvX = 1. / v3fVec.x;
                    var fInvY = 1. / v3fVec.y;
                    var fInvZ = 1. / v3fVec.z;

                    this.x0 *= fInvX;
                    this.x1 *= fInvX;

                    this.y0 *= fInvY;
                    this.y1 *= fInvY;

                    this.z0 *= fInvZ;
                    this.z1 *= fInvZ;
                }

                return this;
            };

            Rect3d.prototype.offset = function (fOffsetX, fOffsetY, fOffsetZ) {
                if (arguments.length === 1) {
                    var v3fOffset = arguments[0];

                    this.x0 += v3fOffset.x;
                    this.x1 += v3fOffset.x;

                    this.y0 += v3fOffset.y;
                    this.y1 += v3fOffset.y;

                    this.z0 += v3fOffset.z;
                    this.z1 += v3fOffset.z;
                } else {
                    this.x0 += arguments[0];
                    this.x1 += arguments[0];

                    this.y0 += arguments[1];
                    this.y1 += arguments[1];

                    this.z0 += arguments[2];
                    this.z1 += arguments[2];
                }

                return this;
            };

            Rect3d.prototype.expand = function (fValueX, fValueY, fValueZ) {
                if (arguments.length === 1) {
                    if (akra.isFloat(arguments[0])) {
                        var fValue = arguments[0];

                        this.x0 -= fValue;
                        this.x1 += fValue;

                        this.y0 -= fValue;
                        this.y1 += fValue;

                        this.z0 -= fValue;
                        this.z1 += fValue;
                    } else {
                        var v3fVec = arguments[0];

                        this.x0 -= v3fVec.x;
                        this.x1 += v3fVec.x;

                        this.y0 -= v3fVec.y;
                        this.y1 += v3fVec.y;

                        this.z0 -= v3fVec.z;
                        this.z1 += v3fVec.z;
                    }
                } else {
                    //arguments.length === 3
                    this.x0 -= arguments[0];
                    this.x1 += arguments[0];

                    this.y0 -= arguments[1];
                    this.y1 += arguments[1];

                    this.z0 -= arguments[2];
                    this.z1 += arguments[2];
                }

                return this;
            };

            Rect3d.prototype.expandX = function (fValue) {
                this.x0 -= fValue;
                this.x1 += fValue;

                return this;
            };

            Rect3d.prototype.expandY = function (fValue) {
                this.y0 -= fValue;
                this.y1 += fValue;

                return this;
            };

            Rect3d.prototype.expandZ = function (fValue) {
                this.z0 -= fValue;
                this.z1 += fValue;

                return this;
            };

            Rect3d.prototype.resize = function () {
                var fSizeX, fSizeY, fSizeZ;

                if (arguments.length === 1) {
                    var v3fSize = arguments[0];

                    fSizeX = v3fSize.x;
                    fSizeY = v3fSize.y;
                    fSizeZ = v3fSize.z;
                } else {
                    fSizeX = arguments[0];
                    fSizeY = arguments[1];
                    fSizeZ = arguments[2];
                }

                this.x1 = (this.x0 + this.x1 + fSizeX) * 0.5;
                this.x0 = this.x1 - fSizeX;

                this.y1 = (this.y0 + this.y1 + fSizeY) * 0.5;
                this.y0 = this.y1 - fSizeY;

                this.z1 = (this.z0 + this.z1 + fSizeZ) * 0.5;
                this.z0 = this.z1 - fSizeZ;

                return this;
            };

            Rect3d.prototype.resizeX = function (fSize) {
                this.x1 = (this.x0 + this.x1 + fSize) * 0.5;
                this.x0 = this.x1 - fSize;

                return this;
            };

            Rect3d.prototype.resizeY = function (fSize) {
                this.y1 = (this.y0 + this.y1 + fSize) * 0.5;
                this.y0 = this.y1 - fSize;

                return this;
            };

            Rect3d.prototype.resizeZ = function (fSize) {
                this.z1 = (this.z0 + this.z1 + fSize) * 0.5;
                this.z0 = this.z1 - fSize;

                return this;
            };

            Rect3d.prototype.resizeMax = function (fSpanX, fSpanY, fSpanZ) {
                if (arguments.length === 1) {
                    var v3fSpan = arguments[0];

                    this.x1 = this.x0 + v3fSpan.x;
                    this.y1 = this.y0 + v3fSpan.y;
                    this.z1 = this.z0 + v3fSpan.z;
                } else {
                    //arguments.length === 3
                    this.x1 = this.x0 + arguments[0];
                    this.y1 = this.y0 + arguments[1];
                    this.z1 = this.z0 + arguments[2];
                }

                return this;
            };

            Rect3d.prototype.resizeMaxX = function (fSpan) {
                this.x1 = this.x0 + fSpan;
                return this;
            };

            Rect3d.prototype.resizeMaxY = function (fSpan) {
                this.y1 = this.y0 + fSpan;
                return this;
            };

            Rect3d.prototype.resizeMaxZ = function (fSpan) {
                this.z1 = this.z0 + fSpan;
                return this;
            };

            Rect3d.prototype.resizeMin = function (fSpanX, fSpanY, fSpanZ) {
                if (arguments.length === 1) {
                    var v3fSpan = arguments[0];

                    this.x0 = this.x1 - v3fSpan.x;
                    this.y0 = this.y1 - v3fSpan.y;
                    this.z0 = this.z1 - v3fSpan.z;
                } else {
                    //arguments.length === 3
                    this.x0 = this.x1 - arguments[0];
                    this.y0 = this.y1 - arguments[1];
                    this.z0 = this.z1 - arguments[2];
                }

                return this;
            };

            Rect3d.prototype.resizeMinX = function (fSpan) {
                this.x0 = this.x1 - fSpan;
                return this;
            };

            Rect3d.prototype.resizeMinY = function (fSpan) {
                this.y0 = this.y1 - fSpan;
                return this;
            };

            Rect3d.prototype.resizeMinZ = function (fSpan) {
                this.z0 = this.z1 - fSpan;
                return this;
            };

            Rect3d.prototype.unionPoint = function (fX, fY, fZ) {
                if (arguments.length === 1) {
                    var v3fPoint = arguments[0];

                    this.x0 = akra.math.min(this.x0, v3fPoint.x);
                    this.x1 = akra.math.max(this.x1, v3fPoint.x);

                    this.y0 = akra.math.min(this.y0, v3fPoint.y);
                    this.y1 = akra.math.max(this.y1, v3fPoint.y);

                    this.z0 = akra.math.min(this.z0, v3fPoint.z);
                    this.z1 = akra.math.max(this.z1, v3fPoint.z);
                } else {
                    //arguments.length === 3
                    this.x0 = akra.math.min(this.x0, arguments[0]);
                    this.x1 = akra.math.max(this.x1, arguments[0]);

                    this.y0 = akra.math.min(this.y0, arguments[1]);
                    this.y1 = akra.math.max(this.y1, arguments[1]);

                    this.z0 = akra.math.min(this.z0, arguments[2]);
                    this.z1 = akra.math.max(this.z1, arguments[2]);
                }

                return this;
            };

            Rect3d.prototype.unionRect = function (pRect) {
                this.normalize();
                pRect.normalize();

                this.x0 = akra.math.min(this.x0, pRect.x0);
                this.x1 = akra.math.max(this.x1, pRect.x1);

                this.y0 = akra.math.min(this.y0, pRect.y0);
                this.y1 = akra.math.max(this.y1, pRect.y1);

                this.z0 = akra.math.min(this.z0, pRect.z0);
                this.z1 = akra.math.max(this.z1, pRect.z1);

                return this;
            };

            Rect3d.prototype.negate = function (pDestination) {
                if (!akra.isDef(pDestination)) {
                    pDestination = this;
                }

                return pDestination.set(-this.x1, -this.x0, -this.y1, -this.y0, -this.z1, -this.z0);
            };

            Rect3d.prototype.normalize = function () {
                var fTmp;
                if (this.x0 > this.x1) {
                    fTmp = this.x0;
                    this.x0 = this.x1;
                    this.x1 = fTmp;
                }
                if (this.y0 > this.y1) {
                    fTmp = this.y0;
                    this.y0 = this.y1;
                    this.y1 = fTmp;
                }
                if (this.z0 > this.z1) {
                    fTmp = this.z0;
                    this.z0 = this.z1;
                    this.z1 = fTmp;
                }

                return this;
            };

            Rect3d.prototype.transform = function (m4fMatrix) {
                var pData = m4fMatrix.data;

                var a11 = pData[__11], a12 = pData[__12], a13 = pData[__13], a14 = pData[__14];
                var a21 = pData[__21], a22 = pData[__22], a23 = pData[__23], a24 = pData[__24];
                var a31 = pData[__31], a32 = pData[__32], a33 = pData[__33], a34 = pData[__34];

                var fX0 = this.x0, fX1 = this.x1;
                var fY0 = this.y0, fY1 = this.y1;
                var fZ0 = this.z0, fZ1 = this.z1;

                //base point
                var fBaseX = a11 * fX0 + a12 * fY0 + a13 * fZ0 + a14;
                var fBaseY = a21 * fX0 + a22 * fY0 + a23 * fZ0 + a24;
                var fBaseZ = a31 * fX0 + a32 * fY0 + a33 * fZ0 + a34;

                //new x vector
                var fXNewX = a11 * (fX1 - fX0);
                var fXNewY = a21 * (fX1 - fX0);
                var fXNewZ = a31 * (fX1 - fX0);

                //new y vector
                var fYNewX = a12 * (fY1 - fY0);
                var fYNewY = a22 * (fY1 - fY0);
                var fYNewZ = a32 * (fY1 - fY0);

                //new z vector
                var fZNewX = a13 * (fZ1 - fZ0);
                var fZNewY = a23 * (fZ1 - fZ0);
                var fZNewZ = a33 * (fZ1 - fZ0);

                var fXMultX = (fXNewX > 0.) ? 1. : 0.;
                var fYMultX = (fYNewX > 0.) ? 1. : 0.;
                var fZMultX = (fZNewX > 0.) ? 1. : 0.;

                var fXMultY = (fXNewY > 0.) ? 1. : 0.;
                var fYMultY = (fYNewY > 0.) ? 1. : 0.;
                var fZMultY = (fZNewY > 0.) ? 1. : 0.;

                var fXMultZ = (fXNewZ > 0.) ? 1. : 0.;
                var fYMultZ = (fYNewZ > 0.) ? 1. : 0.;
                var fZMultZ = (fZNewZ > 0.) ? 1. : 0.;

                this.x1 = fBaseX + fXMultX * fXNewX + fYMultX * fYNewX + fZMultX * fZNewX;
                this.y1 = fBaseY + fXMultY * fXNewY + fYMultY * fYNewY + fZMultY * fZNewY;
                this.z1 = fBaseZ + fXMultZ * fXNewZ + fYMultZ * fYNewZ + fZMultZ * fZNewZ;

                this.x0 = fBaseX + (1. - fXMultX) * fXNewX + (1. - fYMultX) * fYNewX + (1. - fZMultX) * fZNewX;
                this.y0 = fBaseY + (1. - fXMultY) * fXNewY + (1. - fYMultY) * fYNewY + (1. - fZMultY) * fZNewY;
                this.z0 = fBaseZ + (1. - fXMultZ) * fXNewZ + (1. - fYMultZ) * fYNewZ + (1. - fZMultZ) * fZNewZ;

                return this;
            };

            Rect3d.prototype.isEqual = function (pRect) {
                return this.x0 == pRect.x0 && this.x1 == pRect.x1 && this.y0 == pRect.y0 && this.y1 == pRect.y1 && this.z0 == pRect.z0 && this.z1 == pRect.z1;
            };

            Rect3d.prototype.isClear = function () {
                return this.x0 == 0. && this.x1 == 0. && this.y0 == 0. && this.y1 == 0. && this.z0 == 0. && this.z1 == 0.;
            };

            Rect3d.prototype.isValid = function () {
                return this.x0 <= this.x1 && this.y0 <= this.y1 && this.z0 <= this.z1;
            };

            Rect3d.prototype.isPointInRect = function (v3fPoint) {
                var x = v3fPoint.x;
                var y = v3fPoint.y;
                var z = v3fPoint.z;

                return (this.x0 <= x && x <= this.x1) && (this.y0 <= y && y <= this.y1) && (this.z0 <= z && z <= this.z1);
            };

            Rect3d.prototype.midPoint = function (v3fDestination) {
                if (!akra.isDef(v3fDestination)) {
                    v3fDestination = new Vec3();
                }

                return v3fDestination.set((this.x0 + this.x1) * 0.5, (this.y0 + this.y1) * 0.5, (this.z0 + this.z1) * 0.5);
            };

            Rect3d.prototype.midX = function () {
                return (this.x0 + this.x1) * 0.5;
            };

            Rect3d.prototype.midY = function () {
                return (this.y0 + this.y1) * 0.5;
            };

            Rect3d.prototype.midZ = function () {
                return (this.z0 + this.z1) * 0.5;
            };

            Rect3d.prototype.size = function (v3fDestination) {
                if (!akra.isDef(v3fDestination)) {
                    v3fDestination = new Vec3();
                }

                return v3fDestination.set(this.x1 - this.x0, this.y1 - this.y0, this.z1 - this.z0);
            };

            Rect3d.prototype.sizeX = function () {
                return this.x1 - this.x0;
            };

            Rect3d.prototype.sizeY = function () {
                return this.y1 - this.y0;
            };

            Rect3d.prototype.sizeZ = function () {
                return this.z1 - this.z0;
            };

            Rect3d.prototype.minPoint = function (v3fDestination) {
                if (!akra.isDef(v3fDestination)) {
                    v3fDestination = new Vec3();
                }

                return v3fDestination.set(this.x0, this.y0, this.z0);
            };

            Rect3d.prototype.maxPoint = function (v3fDestination) {
                if (!akra.isDef(v3fDestination)) {
                    v3fDestination = new Vec3();
                }

                return v3fDestination.set(this.x1, this.y1, this.z1);
            };

            Rect3d.prototype.volume = function () {
                return (this.x1 - this.x0) * (this.y1 - this.y0) * (this.z1 - this.z0);
            };

            /**
            * counter-clockwise and from bottom
            * x0,y0,z0 -> x1,y0,z0 -> x1,y1,z0 -> x0,y1,z0 ->
            * x0,y0,z1 -> x1,y0,z1 -> x1,y1,z1 -> x0,y1,z1
            */
            Rect3d.prototype.corner = function (iIndex, v3fDestination) {
                if (!akra.isDef(v3fDestination)) {
                    v3fDestination = new Vec3();
                }

                akra.logger.assert(0 <= iIndex && iIndex < 8, "invalid index");

                switch (iIndex) {
                    case 0:
                        v3fDestination.set(this.x0, this.y0, this.z0);
                        break;
                    case 1:
                        v3fDestination.set(this.x1, this.y0, this.z0);
                        break;
                    case 2:
                        v3fDestination.set(this.x1, this.y1, this.z0);
                        break;
                    case 3:
                        v3fDestination.set(this.x0, this.y1, this.z0);
                        break;
                    case 4:
                        v3fDestination.set(this.x0, this.y0, this.z1);
                        break;
                    case 5:
                        v3fDestination.set(this.x1, this.y0, this.z1);
                        break;
                    case 6:
                        v3fDestination.set(this.x1, this.y1, this.z1);
                        break;
                    case 7:
                        v3fDestination.set(this.x0, this.y1, this.z1);
                        break;
                }
                return v3fDestination;
            };

            Rect3d.prototype.createBoundingSphere = function (pSphere) {
                if (!akra.isDef(pSphere)) {
                    pSphere = new geometry.Sphere();
                }

                var fX0 = this.x0, fX1 = this.x1;
                var fY0 = this.y0, fY1 = this.y1;
                var fZ0 = this.z0, fZ1 = this.z1;

                var fHalfSizeX = (fX1 - fX0) * 0.5;
                var fHalfSizeY = (fY1 - fY0) * 0.5;
                var fHalfSizeZ = (fZ1 - fZ0) * 0.5;

                pSphere.set((fX0 + fX1) * 0.5, (fY0 + fY1) * 0.5, (fZ0 + fZ1) * 0.5, akra.math.sqrt(fHalfSizeX * fHalfSizeX + fHalfSizeY * fHalfSizeY + fHalfSizeZ * fHalfSizeZ));

                return pSphere;
            };

            Rect3d.prototype.distanceToPoint = function (v3fPoint) {
                var fX = v3fPoint.x, fY = v3fPoint.y, fZ = v3fPoint.z;

                var fX0 = this.x0, fY0 = this.y0, fZ0 = this.z0;
                var fX1 = this.x1, fY1 = this.y1, fZ1 = this.z1;

                var fXN, fYN, fZN;

                fXN = (akra.math.abs(fX0 - fX) < akra.math.abs(fX1 - fX)) ? fX0 : fX1;
                fYN = (akra.math.abs(fY0 - fY) < akra.math.abs(fY1 - fY)) ? fY0 : fY1;
                fZN = (akra.math.abs(fZ0 - fZ) < akra.math.abs(fZ1 - fZ)) ? fZ0 : fZ1;

                return akra.math.sqrt((fXN - fX) * (fXN - fX) + (fYN - fY) * (fYN - fY) + (fZN - fZ) * (fZN - fZ));
            };

            Rect3d.prototype.toString = function () {
                return "(" + this.x0 + ", " + this.y0 + ", " + this.z0 + ") --> (" + this.x1 + ", " + this.y1 + ", " + this.z1 + ")";
            };

            Rect3d.temp = function () {
                Rect3d._iElement = (Rect3d._iElement === Rect3d._pBuffer.length - 1 ? 0 : Rect3d._iElement);
                var p = Rect3d._pBuffer[Rect3d._iElement++];
                return p.set.apply(p, arguments);
            };
            Rect3d._pBuffer = akra.gen.array(128, Rect3d);
            Rect3d._iElement = 0;
            return Rect3d;
        })();
        geometry.Rect3d = Rect3d;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
/// <reference path="IVec2.ts" />
/// <reference path="ICircle.ts" />
/// <reference path="../idl/IPlane2d.ts" />
/// <reference path="../math/math.ts" />
var akra;
(function (akra) {
    (function (geometry) {
        var Vec2 = akra.math.Vec2;

        var Plane2d = (function () {
            function Plane2d(v2fPoint1, v2fPoint2) {
                this.normal = new Vec2();
                this.distance = 0.;

                var nArgumentsLength = arguments.length;

                switch (nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 2:
                        this.set(arguments[0], arguments[1]);
                        break;
                    default:
                        break;
                }
            }
            Plane2d.prototype.set = function (v2fPoint1, v2fPoint2) {
                var nArgumentsLength = arguments.length;

                switch (nArgumentsLength) {
                    case 1:
                        var pPlane = arguments[0];

                        this.normal.set(pPlane.normal);
                        this.distance = pPlane.distance;
                        break;
                    case 2:
                        if (akra.isFloat(arguments[1])) {
                            this.normal.set(arguments[0]);
                            this.distance = arguments[1];
                        } else {
                            var v2fLine = Vec2.temp(arguments[1]).subtract(arguments[0]);
                            var v2fNormal = this.normal;

                            v2fNormal.set(-v2fLine.y, v2fLine.x);
                            this.distance = -v2fNormal.dot(arguments[0]);
                        }
                        break;
                    default:
                        this.normal.clear();
                        this.distance = 0.;
                        break;
                }

                return this.normalize();
            };

            /**  */ Plane2d.prototype.clear = function () {
                this.normal.clear();
                this.distance = 0.;
                return this;
            };

            /**  */ Plane2d.prototype.negate = function () {
                this.normal.negate();
                this.distance = -this.distance;
                return this;
            };

            Plane2d.prototype.normalize = function () {
                var v2fNormal = this.normal;

                var x = v2fNormal.x;
                var y = v2fNormal.y;

                var fLength = akra.math.sqrt(x * x + y * y);

                if (fLength !== 0.) {
                    var fInvLength = 1. / fLength;

                    v2fNormal.x = x * fInvLength;
                    v2fNormal.y = y * fInvLength;

                    this.distance = this.distance * fInvLength;
                }

                return this;
            };

            /**  */ Plane2d.prototype.isEqual = function (pPlane) {
                return this.normal.isEqual(pPlane.normal) && (this.distance == pPlane.distance);
            };

            /*предполагается работа только с нормализованной плоскостью*/
            Plane2d.prototype.projectPointToPlane = function (v2fPoint, v2fDestination) {
                if (!akra.isDef(v2fDestination)) {
                    v2fDestination = new Vec2();
                }

                var v2fNormal = this.normal;
                var fDistance = this.distance + v2fNormal.dot(v2fPoint);

                v2fDestination.x = v2fPoint.x - fDistance * v2fNormal.x;
                v2fDestination.y = v2fPoint.y - fDistance * v2fNormal.y;

                return v2fDestination;
            };

            Plane2d.prototype.solveForX = function (fY) {
                /*Ax+By+d=0;
                x=-(d+By)/A;*/
                var v2fNormal = this.normal;

                if (v2fNormal.x !== 0.) {
                    return -(this.distance + v2fNormal.y * fY) / v2fNormal.x;
                }
                return 0.;
            };

            Plane2d.prototype.solveForY = function (fX) {
                /*Ax+By+d=0;
                y=-(d+Ax)/B;*/
                var v2fNormal = this.normal;

                if (v2fNormal.y !== 0.) {
                    return -(this.distance + v2fNormal.x * fX) / v2fNormal.y;
                }
                return 0.;
            };

            /*предполагается работа только с нормализованной плоскостью*/
            /**  */ Plane2d.prototype.signedDistance = function (v2fPoint) {
                return this.distance + this.normal.dot(v2fPoint);
            };

            Plane2d.prototype.toString = function () {
                return "normal: " + this.normal.toString() + "; distance: " + this.distance;
            };
            return Plane2d;
        })();
        geometry.Plane2d = Plane2d;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
/// <reference path="../geometry.ts" />
/// <reference path="../../math/math.ts" />
var akra;
(function (akra) {
    (function (geometry) {
        (function (_intersect) {
            var Vec2 = akra.math.Vec2;
            var Vec3 = akra.math.Vec3;

            function plane2dRay2d(pPlane, pRay) {
                var fDistance = pPlane.signedDistance(pRay.point);
                var fNdotV = pPlane.normal.dot(pRay.normal);

                if (fDistance == 0.) {
                    return true;
                } else {
                    if (fNdotV == 0.) {
                        return false;
                    } else {
                        if (fDistance / fNdotV < 0.) {
                            return true;
                        } else {
                            return false;
                        }
                    }
                }
            }
            _intersect.plane2dRay2d = plane2dRay2d;

            function plane3dRay3d(pPlane, pRay) {
                var fDistance = pPlane.signedDistance(pRay.point);
                var fNdotV = pPlane.normal.dot(pRay.normal);

                if (fDistance == 0.) {
                    return true;
                } else {
                    if (fNdotV == 0.) {
                        return false;
                    } else {
                        if (fDistance / fNdotV < 0.) {
                            return true;
                        } else {
                            return false;
                        }
                    }
                }
            }
            _intersect.plane3dRay3d = plane3dRay3d;

            function circleRay2d(pCircle, pRay) {
                var v2fCenterToPoint = pRay.point.subtract(pCircle.center, Vec2.temp());

                var v2fNormal = pRay.normal;

                //a*t^2+ 2b*t + c = 0;
                var fA = v2fNormal.lengthSquare();
                var fB = v2fCenterToPoint.dot(v2fNormal);
                var fC = v2fCenterToPoint.lengthSquare() - pCircle.radius * pCircle.radius;

                var fDiscriminant = fB * fB - fA * fC;

                if (fDiscriminant < 0.) {
                    return false;
                }

                var fSqrtDiscriminant = akra.math.sqrt(fDiscriminant);

                var fT1 = (-fB + fSqrtDiscriminant) / fA;

                //var fT2: float = (-fB - fSqrtDiscriminant)/fA;
                //fT2 don't needed because fT2 < fT1 always
                //since fA > 0
                if (fT1 < 0.) {
                    return false;
                } else {
                    return true;
                }
            }
            _intersect.circleRay2d = circleRay2d;

            function sphereRay3d(pSphere, pRay) {
                var v3fCenterToPoint = pRay.point.subtract(pSphere.center, Vec3.temp());

                var v3fNormal = pRay.normal;

                //a*t^2+ 2b*t + c = 0;
                var fA = v3fNormal.lengthSquare();
                var fB = v3fCenterToPoint.dot(v3fNormal);
                var fC = v3fCenterToPoint.lengthSquare() - pSphere.radius * pSphere.radius;

                var fDiscriminant = fB * fB - fA * fC;

                if (fDiscriminant < 0.) {
                    return false;
                }

                var fSqrtDiscriminant = akra.math.sqrt(fDiscriminant);

                var fT1 = (-fB + fSqrtDiscriminant) / fA;

                //var fT2: float = (-fB - fSqrtDiscriminant)/fA;
                //fT2 don't needed because fT2 < fT1 always
                //since fA > 0
                if (fT1 < 0.) {
                    return false;
                } else {
                    return true;
                }
            }
            _intersect.sphereRay3d = sphereRay3d;

            function rect2dRay2d(pRect, pRay) {
                var v2fNormal = pRay.normal;
                var v2fPoint = pRay.point;

                var fT1, fT2;

                var fX1, fX2;
                var fY1, fY2;

                if (v2fNormal.x != 0.) {
                    fT1 = (pRect.x0 - v2fPoint.x) / v2fNormal.x;
                    fT2 = (pRect.x1 - v2fPoint.x) / v2fNormal.x;
                } else {
                    fT1 = (pRect.y0 - v2fPoint.y) / v2fNormal.y;
                    fT2 = (pRect.y1 - v2fPoint.y) / v2fNormal.y;
                }

                if (fT1 < 0 && fT2 < 0) {
                    return false;
                }

                fT1 = akra.math.max(fT1, 0.);
                fT2 = akra.math.max(fT2, 0.);

                fX1 = v2fPoint.x + fT1 * v2fNormal.x;
                fX2 = v2fPoint.x + fT2 * v2fNormal.x;

                fY1 = v2fPoint.y + fT1 * v2fNormal.y;
                fY2 = v2fPoint.y + fT2 * v2fNormal.y;

                if ((fX1 < pRect.x0 && fX2 < pRect.x0) || (fX1 > pRect.x1 && fX2 > pRect.x1) || (fY1 < pRect.y0 && fY2 < pRect.y0) || (fY1 > pRect.y1 && fY2 > pRect.y1)) {
                    return false;
                }

                return true;
            }
            _intersect.rect2dRay2d = rect2dRay2d;

            function rect3dRay3d(pRect, pRay) {
                var v3fNormal = pRay.normal;
                var v3fPoint = pRay.point;

                var fT1, fT2;

                var fX1, fX2;
                var fY1, fY2;
                var fZ1, fZ2;

                if (v3fNormal.x != 0.) {
                    fT1 = (pRect.x0 - v3fPoint.x) / v3fNormal.x;
                    fT2 = (pRect.x1 - v3fPoint.x) / v3fNormal.x;
                } else if (v3fNormal.y != 0.) {
                    fT1 = (pRect.y0 - v3fPoint.y) / v3fNormal.y;
                    fT2 = (pRect.y1 - v3fPoint.y) / v3fNormal.y;
                } else {
                    fT1 = (pRect.z0 - v3fPoint.z) / v3fNormal.z;
                    fT2 = (pRect.z1 - v3fPoint.z) / v3fNormal.z;
                }

                if (fT1 < 0 && fT2 < 0) {
                    return false;
                }

                fT1 = akra.math.max(fT1, 0.);
                fT2 = akra.math.max(fT2, 0.);

                fX1 = v3fPoint.x + fT1 * v3fNormal.x;
                fX2 = v3fPoint.x + fT2 * v3fNormal.x;

                fY1 = v3fPoint.y + fT1 * v3fNormal.y;
                fY2 = v3fPoint.y + fT2 * v3fNormal.y;

                fZ1 = v3fPoint.z + fT1 * v3fNormal.z;
                fZ2 = v3fPoint.z + fT2 * v3fNormal.z;

                if ((fX1 < pRect.x0 && fX2 < pRect.x0) || (fX1 > pRect.x1 && fX2 > pRect.x1) || (fY1 < pRect.y0 && fY2 < pRect.y0) || (fY1 > pRect.y1 && fY2 > pRect.y1) || (fZ1 < pRect.z0 && fZ2 < pRect.z0) || (fZ1 > pRect.z1 && fZ2 > pRect.z1)) {
                    return false;
                }

                return true;
            }
            _intersect.rect3dRay3d = rect3dRay3d;

            function circleCircle(pCircle1, pCircle2) {
                var v2fCenter1 = pCircle1.center;
                var v2fCenter2 = pCircle2.center;

                var fX = v2fCenter2.x - v2fCenter1.x;
                var fY = v2fCenter2.y - v2fCenter1.y;

                var fContactRadius = pCircle1.radius + pCircle2.radius;

                if ((fX * fX + fY * fY) > fContactRadius * fContactRadius) {
                    return false;
                }
                return true;
            }
            _intersect.circleCircle = circleCircle;

            function sphereSphere(pSphere1, pSphere2) {
                var v3fCenter1 = pSphere1.center;
                var v3fCenter2 = pSphere2.center;

                var fX = v3fCenter2.x - v3fCenter1.x;
                var fY = v3fCenter2.y - v3fCenter1.y;
                var fZ = v3fCenter2.z - v3fCenter1.z;

                var fContactRadius = pSphere1.radius + pSphere2.radius;

                if ((fX * fX + fY * fY + fZ * fZ) > fContactRadius * fContactRadius) {
                    return false;
                }
                return true;
            }
            _intersect.sphereSphere = sphereSphere;

            function rect2dCircle(pRect, pCircle) {
                var v2fCenter = pCircle.center;
                var fOffsetX = 0., fOffsetY = 0.;
                var nInside = 0;

                if (v2fCenter.x < pRect.x0) {
                    fOffsetX = pRect.x0 - v2fCenter.x;
                } else if (v2fCenter.x > pRect.x1) {
                    fOffsetX = v2fCenter.x - pRect.x1;
                } else {
                    nInside++;
                }

                if (v2fCenter.y < pRect.y0) {
                    fOffsetY = pRect.y0 - v2fCenter.y;
                } else if (v2fCenter.y > pRect.y1) {
                    fOffsetY = v2fCenter.y - pRect.y1;
                } else {
                    nInside++;
                }

                //if nInside == 2 then circle inside rect
                if (nInside === 2) {
                    return true;
                }

                var fOffsetLengthSquare = fOffsetX * fOffsetX + fOffsetY * fOffsetY;
                var fRadius = pCircle.radius;

                if (fOffsetLengthSquare > fRadius * fRadius) {
                    return false;
                }
                return true;
            }
            _intersect.rect2dCircle = rect2dCircle;

            function rect3dSphere(pRect, pSphere) {
                var v3fCenter = pSphere.center;
                var fOffsetX = 0., fOffsetY = 0., fOffsetZ = 0.;
                var nInside = 0;

                if (v3fCenter.x < pRect.x0) {
                    fOffsetX = pRect.x0 - v3fCenter.x;
                } else if (v3fCenter.x > pRect.x1) {
                    fOffsetX = v3fCenter.x - pRect.x1;
                } else {
                    nInside++;
                }

                if (v3fCenter.y < pRect.y0) {
                    fOffsetY = pRect.y0 - v3fCenter.y;
                } else if (v3fCenter.y > pRect.y1) {
                    fOffsetY = v3fCenter.y - pRect.y1;
                } else {
                    nInside++;
                }

                if (v3fCenter.z < pRect.z0) {
                    fOffsetZ = pRect.z0 - v3fCenter.z;
                } else if (v3fCenter.z > pRect.z1) {
                    fOffsetZ = v3fCenter.z - pRect.z1;
                } else {
                    nInside++;
                }

                //if nInside == 3 then sphere inside rect
                if (nInside === 3) {
                    return true;
                }

                var fOffsetLengthSquare = fOffsetX * fOffsetX + fOffsetY * fOffsetY + fOffsetZ * fOffsetZ;
                var fRadius = pSphere.radius;

                if (fOffsetLengthSquare > fRadius * fRadius) {
                    return false;
                }
                return true;
            }
            _intersect.rect3dSphere = rect3dSphere;

            function rect2dRect2d(pRect1, pRect2, pResult) {
                if (!akra.isDef(pResult)) {
                    var fX0 = akra.math.max(pRect1.x0, pRect2.x0);
                    var fX1 = akra.math.min(pRect1.x1, pRect2.x1);
                    if (fX0 <= fX1) {
                        var fY0 = akra.math.max(pRect1.y0, pRect2.y0);
                        var fY1 = akra.math.min(pRect1.y1, pRect2.y1);
                        if (fY0 <= fY1) {
                            return true;
                        }
                    }
                    return false;
                } else {
                    pResult.x0 = akra.math.max(pRect1.x0, pRect2.x0);
                    pResult.x1 = akra.math.min(pRect1.x1, pRect2.x1);

                    pResult.y0 = akra.math.max(pRect1.y0, pRect2.y0);
                    pResult.y1 = akra.math.min(pRect1.y1, pRect2.y1);

                    return pResult.isValid();
                }
            }
            _intersect.rect2dRect2d = rect2dRect2d;

            function rect3dRect3d(pRect1, pRect2, pResult) {
                if (!akra.isDef(pResult)) {
                    var fX0 = akra.math.max(pRect1.x0, pRect2.x0);
                    var fX1 = akra.math.min(pRect1.x1, pRect2.x1);
                    if (fX0 <= fX1) {
                        var fY0 = akra.math.max(pRect1.y0, pRect2.y0);
                        var fY1 = akra.math.min(pRect1.y1, pRect2.y1);
                        if (fY0 <= fY1) {
                            var fZ0 = akra.math.max(pRect1.z0, pRect2.z0);
                            var fZ1 = akra.math.min(pRect1.z1, pRect2.z1);
                            if (fZ0 <= fZ1) {
                                return true;
                            }
                        }
                    }
                    return false;
                } else {
                    pResult.x0 = akra.math.max(pRect1.x0, pRect2.x0);
                    pResult.x1 = akra.math.min(pRect1.x1, pRect2.x1);

                    pResult.y0 = akra.math.max(pRect1.y0, pRect2.y0);
                    pResult.y1 = akra.math.min(pRect1.y1, pRect2.y1);

                    pResult.z0 = akra.math.max(pRect1.z0, pRect2.z0);
                    pResult.z1 = akra.math.min(pRect1.z1, pRect2.z1);

                    return pResult.isValid();
                }
            }
            _intersect.rect3dRect3d = rect3dRect3d;

            function intersect(pRect1, pRect2, pResult) {
                var nArgumentsLength = arguments.length;

                if (nArgumentsLength === 3) {
                    if (arguments[2] instanceof geometry.Rect2d) {
                        return rect2dRect2d(arguments[0], arguments[1], arguments[2]);
                    } else {
                        return rect3dRect3d(arguments[0], arguments[1], arguments[2]);
                    }
                } else {
                    var pArg0 = arguments[0];
                    var pArg1 = arguments[1];

                    if (pArg1 instanceof geometry.Ray2d) {
                        if (pArg0 instanceof geometry.Plane2d) {
                            return plane2dRay2d(pArg0, pArg1);
                        } else if (pArg0 instanceof geometry.Circle) {
                            return circleRay2d(pArg0, pArg1);
                        } else {
                            return rect2dRay2d(pArg0, pArg1);
                        }
                    } else if (pArg1 instanceof geometry.Ray3d) {
                        if (pArg0 instanceof geometry.Plane3d) {
                            return plane3dRay3d(pArg0, pArg1);
                        } else if (pArg0 instanceof geometry.Sphere) {
                            return sphereRay3d(pArg0, pArg1);
                        } else {
                            return rect3dRay3d(pArg0, pArg1);
                        }
                    } else if (pArg1 instanceof geometry.Circle) {
                        if (pArg0 instanceof geometry.Circle) {
                            return circleCircle(pArg0, pArg1);
                        } else {
                            return rect2dCircle(pArg0, pArg1);
                        }
                    } else if (pArg1 instanceof geometry.Sphere) {
                        if (pArg0 instanceof geometry.Sphere) {
                            return sphereSphere(pArg0, pArg1);
                        } else {
                            return rect3dSphere(pArg0, pArg1);
                        }
                    } else {
                        if (pArg0 instanceof geometry.Rect2d) {
                            return rect2dRect2d(pArg0, pArg1);
                        } else {
                            return rect3dRect3d(pArg0, pArg1);
                        }
                    }
                }
            }
            _intersect.intersect = intersect;
        })(geometry.intersect || (geometry.intersect = {}));
        var intersect = geometry.intersect;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
/// <reference path="../idl/IPlane3d.ts" />
/// <reference path="../math/math.ts" />
/// <reference path="intersect/intersect.ts" />
var akra;
(function (akra) {
    (function (geometry) {
        var Vec3 = akra.math.Vec3;

        var Plane3d = (function () {
            function Plane3d() {
                this.normal = new Vec3();
                this.distance = 0.;

                var nArgumentsLength = arguments.length;

                switch (nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 2:
                        this.set(arguments[0], arguments[1]);
                        break;
                    case 3:
                        this.set(arguments[0], arguments[1], arguments[2]);
                        break;
                    default:
                        break;
                }
            }
            Plane3d.prototype.set = function () {
                var nArgumentsLength = arguments.length;

                switch (nArgumentsLength) {
                    case 1:
                        var pPlane = arguments[0];

                        this.normal.set(pPlane.normal);
                        this.distance = pPlane.distance;
                        break;
                    case 2:
                        this.normal.set(arguments[0]);
                        this.distance = arguments[1];
                        break;
                    case 3:
                        var v3fPoint1 = arguments[0];
                        var v3fPoint2 = arguments[1];
                        var v3fPoint3 = arguments[2];

                        var x1 = v3fPoint2.x - v3fPoint1.x;
                        var y1 = v3fPoint2.y - v3fPoint1.y;
                        var z1 = v3fPoint2.z - v3fPoint1.z;

                        var x2 = v3fPoint3.x - v3fPoint1.x;
                        var y2 = v3fPoint3.y - v3fPoint1.y;
                        var z2 = v3fPoint3.z - v3fPoint1.z;

                        var x = y1 * z2 - y2 * z1;
                        var y = z1 * x2 - z2 * x1;
                        var z = x1 * y2 - x2 * y1;

                        this.distance = -(x * v3fPoint1.x + y * v3fPoint1.y + z * v3fPoint1.z);
                        this.normal.set(x, y, z);

                        break;
                    default:
                        this.normal.clear();
                        this.distance = 0.;
                        break;
                }

                return this.normalize();
            };

            Plane3d.prototype.clear = function () {
                this.normal.clear();
                this.distance = 0.;
                return this;
            };

            Plane3d.prototype.negate = function () {
                this.normal.negate();
                this.distance = -this.distance;
                return this;
            };

            Plane3d.prototype.normalize = function () {
                var v3fNormal = this.normal;
                var x = v3fNormal.x, y = v3fNormal.y, z = v3fNormal.z;

                var fLength = akra.math.sqrt(x * x + y * y + z * z);

                if (fLength !== 0.) {
                    var fInvLength = 1. / fLength;

                    v3fNormal.x = x * fInvLength;
                    v3fNormal.y = y * fInvLength;
                    v3fNormal.z = z * fInvLength;

                    this.distance *= fInvLength;
                }

                return this;
            };

            Plane3d.prototype.isEqual = function (pPlane) {
                return this.normal.isEqual(pPlane.normal) && (this.distance == pPlane.distance);
            };

            /*предполагается работа только с нормализованной плоскостью*/
            Plane3d.prototype.projectPointToPlane = function (v3fPoint, v3fDestination) {
                if (!akra.isDef(v3fDestination)) {
                    v3fDestination = new Vec3();
                }

                var v3fNormal = this.normal;
                var fDistance = this.distance + v3fNormal.dot(v3fPoint);

                v3fDestination.x = v3fPoint.x - fDistance * v3fNormal.x;
                v3fDestination.y = v3fPoint.y - fDistance * v3fNormal.y;
                v3fDestination.z = v3fPoint.z - fDistance * v3fNormal.z;

                return v3fDestination;
            };

            Plane3d.prototype.solveForX = function (fY, fZ) {
                /*Ax+By+Cz+D=0;
                x = -(D+By+Cz)/A;*/
                var v3fNormal = this.normal;

                if (v3fNormal.x !== 0.) {
                    return -(this.distance + v3fNormal.y * fY + v3fNormal.z * fZ) / v3fNormal.x;
                }
                return 0.;
            };

            Plane3d.prototype.solveForY = function (fX, fZ) {
                /*Ax+By+Cz+D=0;
                y = -(D+Ax+Cz)/B;*/
                var v3fNormal = this.normal;

                if (v3fNormal.y !== 0.) {
                    return -(this.distance + v3fNormal.x * fX + v3fNormal.z * fZ) / v3fNormal.y;
                }
                return 0.;
            };

            Plane3d.prototype.solveForZ = function (fX, fY) {
                /*Ax+By+Cz+D=0;
                z = -(D+Ax+By)/C;*/
                var v3fNormal = this.normal;

                if (v3fNormal.z !== 0.) {
                    return -(this.distance + v3fNormal.x * fX + v3fNormal.y * fY) / v3fNormal.z;
                }

                return 0.;
            };

            Plane3d.prototype.intersectRay3d = function (pRay, vDest) {
                if (!geometry.intersect.plane3dRay3d(this, pRay)) {
                    return false;
                }

                var r0 = pRay.point;
                var n = this.normal;
                var l = pRay.normal;
                var d = this.distance;

                var t0 = -(r0.dot(n) + d) / (l.dot(n));

                vDest.set(r0.x + l.x * t0, r0.y + l.y * t0, r0.z + l.z * t0);
                return true;
            };

            Plane3d.prototype.signedDistance = function (v3fPoint) {
                return this.distance + this.normal.dot(v3fPoint);
            };

            Plane3d.prototype.toString = function () {
                return "normal: " + this.normal.toString() + "; distance: " + this.distance;
            };
            return Plane3d;
        })();
        geometry.Plane3d = Plane3d;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EPlaneClassifications) {
        /**
        * ax+by+cz+d=0
        * PLANE_FRONT - объект находится перед плоскостью, то есть по направлению нормали
        * PLANE_BACK - объект находится за плостостью, то есть против направления нормали
        */
        EPlaneClassifications[EPlaneClassifications["PLANE_FRONT"] = 0] = "PLANE_FRONT";
        EPlaneClassifications[EPlaneClassifications["PLANE_BACK"] = 1] = "PLANE_BACK";
        EPlaneClassifications[EPlaneClassifications["PLANE_INTERSECT"] = 2] = "PLANE_INTERSECT";
    })(akra.EPlaneClassifications || (akra.EPlaneClassifications = {}));
    var EPlaneClassifications = akra.EPlaneClassifications;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EVolumeClassifications) {
        EVolumeClassifications[EVolumeClassifications["NO_RELATION"] = 0] = "NO_RELATION";
        EVolumeClassifications[EVolumeClassifications["EQUAL"] = 1] = "EQUAL";
        EVolumeClassifications[EVolumeClassifications["A_CONTAINS_B"] = 2] = "A_CONTAINS_B";
        EVolumeClassifications[EVolumeClassifications["B_CONTAINS_A"] = 3] = "B_CONTAINS_A";
        EVolumeClassifications[EVolumeClassifications["INTERSECTING"] = 4] = "INTERSECTING";
    })(akra.EVolumeClassifications || (akra.EVolumeClassifications = {}));
    var EVolumeClassifications = akra.EVolumeClassifications;
})(akra || (akra = {}));
/// <reference path="../../idl/EVolumeClassifications.ts" />
/// <reference path="../../idl/EPlaneClassifications.ts" />
/// <reference path="../geometry.ts" />
var akra;
(function (akra) {
    (function (geometry) {
        (function (classify) {
            var Vec2 = akra.math.Vec2;
            var Vec3 = akra.math.Vec3;

            var v2fTemp1 = new Vec2;
            var v2fTemp2 = new Vec2;

            var v3fTemp1 = new Vec3;
            var v3fTemp2 = new Vec3;

            function planeCircle(pPlane, pCircle) {
                var fDistance = pPlane.signedDistance(pCircle.center);
                var fRadius = pCircle.radius;

                if (fDistance > fRadius) {
                    return 0 /* PLANE_FRONT */;
                } else if (fDistance < -fRadius) {
                    return 1 /* PLANE_BACK */;
                } else {
                    return 2 /* PLANE_INTERSECT */;
                }
            }
            classify.planeCircle = planeCircle;

            function planeSphere(pPlane, pSphere) {
                var fDistance = pPlane.signedDistance(pSphere.center);
                var fRadius = pSphere.radius;

                if (fDistance > fRadius) {
                    return 0 /* PLANE_FRONT */;
                } else if (fDistance < -fRadius) {
                    return 1 /* PLANE_BACK */;
                } else {
                    return 2 /* PLANE_INTERSECT */;
                }
            }
            classify.planeSphere = planeSphere;

            function planeRect2d(pPlane, pRect) {
                var v2fMinPoint = v2fTemp1;
                var v2fMaxPoint = v2fTemp2;

                var v2fNormal = pPlane.normal;

                if (v2fNormal.x > 0.) {
                    v2fMinPoint.x = pRect.x0;
                    v2fMaxPoint.x = pRect.x1;
                } else {
                    v2fMinPoint.x = pRect.x1;
                    v2fMaxPoint.x = pRect.x0;
                }

                if (v2fNormal.y > 0.) {
                    v2fMinPoint.y = pRect.y0;
                    v2fMaxPoint.y = pRect.y1;
                } else {
                    v2fMinPoint.y = pRect.y1;
                    v2fMaxPoint.y = pRect.y0;
                }

                var fMinDistance = pPlane.signedDistance(v2fMinPoint);
                var fMaxDistance = pPlane.signedDistance(v2fMaxPoint);

                if (fMinDistance * fMaxDistance <= 0.) {
                    return 2 /* PLANE_INTERSECT */;
                } else if (fMaxDistance < 0.) {
                    return 1 /* PLANE_BACK */;
                } else {
                    return 0 /* PLANE_FRONT */;
                }
            }
            classify.planeRect2d = planeRect2d;

            function planeRect3d(pPlane, pRect) {
                var v3fMinPoint = v3fTemp1;
                var v3fMaxPoint = v3fTemp2;

                var v3fNormal = pPlane.normal;

                if (v3fNormal.x > 0.) {
                    v3fMinPoint.x = pRect.x0;
                    v3fMaxPoint.x = pRect.x1;
                } else {
                    v3fMinPoint.x = pRect.x1;
                    v3fMaxPoint.x = pRect.x0;
                }

                if (v3fNormal.y > 0.) {
                    v3fMinPoint.y = pRect.y0;
                    v3fMaxPoint.y = pRect.y1;
                } else {
                    v3fMinPoint.y = pRect.y1;
                    v3fMaxPoint.y = pRect.y0;
                }

                if (v3fNormal.z > 0.) {
                    v3fMinPoint.z = pRect.z0;
                    v3fMaxPoint.z = pRect.z1;
                } else {
                    v3fMinPoint.z = pRect.z1;
                    v3fMaxPoint.z = pRect.z0;
                }

                var fMinDistance = pPlane.signedDistance(v3fMinPoint);
                var fMaxDistance = pPlane.signedDistance(v3fMaxPoint);

                if (fMinDistance * fMaxDistance <= 0.) {
                    return 2 /* PLANE_INTERSECT */;
                } else if (fMaxDistance <= 0.) {
                    return 1 /* PLANE_BACK */;
                } else {
                    return 0 /* PLANE_FRONT */;
                }
            }
            classify.planeRect3d = planeRect3d;

            function plane(pPlane, pRect) {
                var pArg0 = arguments[0];
                var pArg1 = arguments[1];

                if (pArg0 instanceof geometry.Plane2d) {
                    if (pArg1 instanceof geometry.Circle) {
                        return planeCircle(pArg0, pArg1);
                    } else {
                        return planeRect2d(pArg0, pArg1);
                    }
                } else {
                    if (pArg1 instanceof geometry.Sphere) {
                        return planeSphere(pArg0, pArg1);
                    } else {
                        return planeRect3d(pArg0, pArg1);
                    }
                }
            }
            classify.plane = plane;

            function rect2d(pRectA, pRectB) {
                var fRectAX0 = pRectA.x0, fRectAX1 = pRectA.x1;
                var fRectAY0 = pRectA.y0, fRectAY1 = pRectA.y1;

                var fRectBX0 = pRectB.x0, fRectBX1 = pRectB.x1;
                var fRectBY0 = pRectB.y0, fRectBY1 = pRectB.y1;

                if ((fRectAX1 < fRectBX0 || fRectBX1 < fRectAX0) || (fRectAY1 < fRectBY0 || fRectAY1 < fRectBY0)) {
                    return 0 /* NO_RELATION */;
                }

                if ((fRectAX0 == fRectBX0 && fRectAX1 == fRectBX1) && (fRectAY0 == fRectBY0 && fRectAY1 == fRectBY1)) {
                    return 1 /* EQUAL */;
                }

                if ((fRectAX0 <= fRectBX0 && fRectBX1 <= fRectAX1) && (fRectAY0 <= fRectBY0 && fRectBY1 <= fRectAY1)) {
                    return 2 /* A_CONTAINS_B */;
                }

                if ((fRectBX0 <= fRectAX0 && fRectAX1 <= fRectBX1) && (fRectBY0 <= fRectAY0 && fRectAY1 <= fRectBY1)) {
                    return 3 /* B_CONTAINS_A */;
                }

                return 4 /* INTERSECTING */;
            }
            classify.rect2d = rect2d;

            function rect3d(pRectA, pRectB) {
                var fRectAX0 = pRectA.x0, fRectAX1 = pRectA.x1;
                var fRectAY0 = pRectA.y0, fRectAY1 = pRectA.y1;
                var fRectAZ0 = pRectA.z0, fRectAZ1 = pRectA.z1;

                var fRectBX0 = pRectB.x0, fRectBX1 = pRectB.x1;
                var fRectBY0 = pRectB.y0, fRectBY1 = pRectB.y1;
                var fRectBZ0 = pRectB.z0, fRectBZ1 = pRectB.z1;

                if ((fRectAX1 < fRectBX0 || fRectBX1 < fRectAX0) || (fRectAY1 < fRectBY0 || fRectAY1 < fRectBY0) || (fRectAZ1 < fRectBZ0 || fRectAZ1 < fRectBZ0)) {
                    return 0 /* NO_RELATION */;
                }

                if ((fRectAX0 == fRectBX0 && fRectAX1 == fRectBX1) && (fRectAY0 == fRectBY0 && fRectAY1 == fRectBY1) && (fRectAZ0 == fRectBZ0 && fRectAZ1 == fRectBZ1)) {
                    return 1 /* EQUAL */;
                }

                if ((fRectAX0 <= fRectBX0 && fRectBX1 <= fRectAX1) && (fRectAY0 <= fRectBY0 && fRectBY1 <= fRectAY1) && (fRectAZ0 <= fRectBZ0 && fRectBZ1 <= fRectAZ1)) {
                    return 2 /* A_CONTAINS_B */;
                }

                if ((fRectBX0 <= fRectAX0 && fRectAX1 <= fRectBX1) && (fRectBY0 <= fRectAY0 && fRectAY1 <= fRectBY1) && (fRectBZ0 <= fRectAZ0 && fRectAZ1 <= fRectBZ1)) {
                    return 3 /* B_CONTAINS_A */;
                }

                return 4 /* INTERSECTING */;
            }
            classify.rect3d = rect3d;

            function frustumRect3d(pFrustum, pRect) {
                var kClassification;
                var isIntersect = false;

                kClassification = planeRect3d(pFrustum.leftPlane, pRect);
                if (kClassification == 0 /* PLANE_FRONT */) {
                    return 0 /* NO_RELATION */;
                } else if (kClassification == 2 /* PLANE_INTERSECT */) {
                    isIntersect = true;
                }

                kClassification = planeRect3d(pFrustum.rightPlane, pRect);
                if (kClassification == 0 /* PLANE_FRONT */) {
                    return 0 /* NO_RELATION */;
                } else if (kClassification == 2 /* PLANE_INTERSECT */) {
                    isIntersect = true;
                }

                kClassification = planeRect3d(pFrustum.topPlane, pRect);
                if (kClassification == 0 /* PLANE_FRONT */) {
                    return 0 /* NO_RELATION */;
                } else if (kClassification == 2 /* PLANE_INTERSECT */) {
                    isIntersect = true;
                }

                kClassification = planeRect3d(pFrustum.bottomPlane, pRect);
                if (kClassification == 0 /* PLANE_FRONT */) {
                    return 0 /* NO_RELATION */;
                } else if (kClassification == 2 /* PLANE_INTERSECT */) {
                    isIntersect = true;
                }

                kClassification = planeRect3d(pFrustum.nearPlane, pRect);
                if (kClassification == 0 /* PLANE_FRONT */) {
                    return 0 /* NO_RELATION */;
                } else if (kClassification == 2 /* PLANE_INTERSECT */) {
                    isIntersect = true;
                }

                kClassification = planeRect3d(pFrustum.farPlane, pRect);
                if (kClassification == 0 /* PLANE_FRONT */) {
                    return 0 /* NO_RELATION */;
                } else if (kClassification == 2 /* PLANE_INTERSECT */) {
                    isIntersect = true;
                }

                if (isIntersect) {
                    return 4 /* INTERSECTING */;
                } else {
                    return 2 /* A_CONTAINS_B */;
                }
            }
            classify.frustumRect3d = frustumRect3d;
        })(geometry.classify || (geometry.classify = {}));
        var classify = geometry.classify;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
/// <reference path="../idl/IFrustum.ts" />
/// <reference path="../idl/EPlaneClassifications.ts" />
/// <reference path="../math/math.ts" />
/// <reference path="classify/classify.ts" />
/// <reference path="../gen/generate.ts" />
/// <reference path="../logger.ts" />
/// <reference path="geometry.ts" />
var akra;
(function (akra) {
    (function (geometry) {
        var Vec3 = akra.math.Vec3;
        var Vec4 = akra.math.Vec4;

        //import Quat4 = math.Quat4;
        var Mat3 = akra.math.Mat3;

        var Frustum = (function () {
            function Frustum(pLeftPlane, pRightPlane, pTopPlane, pBottomPlane, pNearPlane, pFarPlane) {
                this._pFrustumVertices = null;
                this.leftPlane = new geometry.Plane3d();
                this.rightPlane = new geometry.Plane3d();
                this.topPlane = new geometry.Plane3d();
                this.bottomPlane = new geometry.Plane3d();
                this.nearPlane = new geometry.Plane3d();
                this.farPlane = new geometry.Plane3d();

                var nArgumentsLength = arguments.length;

                switch (nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 6:
                        this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                        break;
                    default:
                        break;
                }
            }
            Frustum.prototype.getFrustumVertices = function () {
                return this._pFrustumVertices;
            };

            Frustum.prototype.set = function (pLeftPlane, pRightPlane, pTopPlane, pBottomPlane, pNearPlane, pFarPlane) {
                var nArgumentsLength = arguments.length;

                switch (nArgumentsLength) {
                    case 1:
                        var pFrustum = arguments[0];

                        this.leftPlane.set(pFrustum.leftPlane);
                        this.rightPlane.set(pFrustum.rightPlane);
                        this.topPlane.set(pFrustum.topPlane);
                        this.bottomPlane.set(pFrustum.bottomPlane);
                        this.nearPlane.set(pFrustum.nearPlane);
                        this.farPlane.set(pFrustum.farPlane);
                        break;
                    case 6:
                        this.leftPlane.set(arguments[0]);
                        this.rightPlane.set(arguments[1]);
                        this.topPlane.set(arguments[2]);
                        this.bottomPlane.set(arguments[3]);
                        this.nearPlane.set(arguments[4]);
                        this.farPlane.set(arguments[5]);
                        break;
                    default:
                        this.leftPlane.clear();
                        this.rightPlane.clear();
                        this.topPlane.clear();
                        this.bottomPlane.clear();
                        this.nearPlane.clear();
                        this.farPlane.clear();
                        break;
                }

                return this;
            };

            Frustum.prototype.calculateFrustumVertices = function () {
                if (this._pFrustumVertices == null) {
                    this._pFrustumVertices = new Array(8);

                    for (var i = 0; i < 8; i++) {
                        this._pFrustumVertices[i] = new Vec3();
                    }
                }

                var v3fLeftNormal = this.leftPlane.normal;
                var v3fRightNormal = this.rightPlane.normal;
                var v3fTopNormal = this.topPlane.normal;
                var v3fBottomNormal = this.bottomPlane.normal;
                var v3fNearNormal = this.nearPlane.normal;
                var v3fFarNormal = this.farPlane.normal;

                var fLeft = -this.leftPlane.distance;
                var fRight = -this.rightPlane.distance;
                var fTop = -this.topPlane.distance;
                var fBottom = -this.bottomPlane.distance;
                var fNear = -this.nearPlane.distance;
                var fFar = -this.farPlane.distance;

                var m3fTemp = Mat3.temp();
                var pFrustumVertices = this._pFrustumVertices;

                //first left-bottom-near
                pFrustumVertices[0].set(fLeft, fBottom, fNear);
                m3fTemp.set(v3fLeftNormal.x, v3fBottomNormal.x, v3fNearNormal.x, v3fLeftNormal.y, v3fBottomNormal.y, v3fNearNormal.y, v3fLeftNormal.z, v3fBottomNormal.z, v3fNearNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[0]);

                //second right-bottom-near
                pFrustumVertices[1].set(fRight, fBottom, fNear);
                m3fTemp.set(v3fRightNormal.x, v3fBottomNormal.x, v3fNearNormal.x, v3fRightNormal.y, v3fBottomNormal.y, v3fNearNormal.y, v3fRightNormal.z, v3fBottomNormal.z, v3fNearNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[1]);

                //third left-top-near
                pFrustumVertices[2].set(fLeft, fTop, fNear);
                m3fTemp.set(v3fLeftNormal.x, v3fTopNormal.x, v3fNearNormal.x, v3fLeftNormal.y, v3fTopNormal.y, v3fNearNormal.y, v3fLeftNormal.z, v3fTopNormal.z, v3fNearNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[2]);

                //forth right-top-near
                pFrustumVertices[3].set(fRight, fTop, fNear);
                m3fTemp.set(v3fRightNormal.x, v3fTopNormal.x, v3fNearNormal.x, v3fRightNormal.y, v3fTopNormal.y, v3fNearNormal.y, v3fRightNormal.z, v3fTopNormal.z, v3fNearNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[3]);

                //fifth left-bottom-far
                pFrustumVertices[4].set(fLeft, fBottom, fFar);
                m3fTemp.set(v3fLeftNormal.x, v3fBottomNormal.x, v3fFarNormal.x, v3fLeftNormal.y, v3fBottomNormal.y, v3fFarNormal.y, v3fLeftNormal.z, v3fBottomNormal.z, v3fFarNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[4]);

                //sixth right-bottom-far
                pFrustumVertices[5].set(fRight, fBottom, fFar);
                m3fTemp.set(v3fRightNormal.x, v3fBottomNormal.x, v3fFarNormal.x, v3fRightNormal.y, v3fBottomNormal.y, v3fFarNormal.y, v3fRightNormal.z, v3fBottomNormal.z, v3fFarNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[5]);

                //seventh left-top-far
                pFrustumVertices[6].set(fLeft, fTop, fFar);
                m3fTemp.set(v3fLeftNormal.x, v3fTopNormal.x, v3fFarNormal.x, v3fLeftNormal.y, v3fTopNormal.y, v3fFarNormal.y, v3fLeftNormal.z, v3fTopNormal.z, v3fFarNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[6]);

                //eighth right-top-far
                pFrustumVertices[7].set(fRight, fTop, fFar);
                m3fTemp.set(v3fRightNormal.x, v3fTopNormal.x, v3fFarNormal.x, v3fRightNormal.y, v3fTopNormal.y, v3fFarNormal.y, v3fRightNormal.z, v3fTopNormal.z, v3fFarNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[7]);

                return pFrustumVertices;
            };

            Frustum.prototype.extractFromMatrix = function (m4fProjection, m4fWorld, pSearchRect) {
                if (akra.isNull(this._pFrustumVertices)) {
                    this._pFrustumVertices = new Array(8);

                    for (var i = 0; i < 8; i++) {
                        this._pFrustumVertices[i] = new Vec3();
                    }
                }

                var pFrustumVertices = this._pFrustumVertices;

                var v4fLeftBottomNear = Vec4.temp();
                var v4fRightBottomNear = Vec4.temp();
                var v4fLeftTopNear = Vec4.temp();
                var v4fRightTopNear = Vec4.temp();

                var v4fLeftBottomFar = Vec4.temp();
                var v4fRightBottomFar = Vec4.temp();
                var v4fLeftTopFar = Vec4.temp();
                var v4fRightTopFar = Vec4.temp();

                m4fProjection.unproj(Vec3.temp(-1, -1, -1), v4fLeftBottomNear);
                m4fProjection.unproj(Vec3.temp(1, -1, -1), v4fRightBottomNear);
                m4fProjection.unproj(Vec3.temp(-1, 1, -1), v4fLeftTopNear);
                m4fProjection.unproj(Vec3.temp(1, 1, -1), v4fRightTopNear);

                m4fProjection.unproj(Vec3.temp(-1, -1, 1), v4fLeftBottomFar);
                m4fProjection.unproj(Vec3.temp(1, -1, 1), v4fRightBottomFar);
                m4fProjection.unproj(Vec3.temp(-1, 1, 1), v4fLeftTopFar);
                m4fProjection.unproj(Vec3.temp(1, 1, 1), v4fRightTopFar);

                if (akra.isDef(m4fWorld)) {
                    m4fWorld.multiplyVec4(v4fLeftBottomNear);
                    m4fWorld.multiplyVec4(v4fRightBottomNear);
                    m4fWorld.multiplyVec4(v4fLeftTopNear);
                    m4fWorld.multiplyVec4(v4fRightTopNear);

                    m4fWorld.multiplyVec4(v4fLeftBottomFar);
                    m4fWorld.multiplyVec4(v4fRightBottomFar);
                    m4fWorld.multiplyVec4(v4fLeftTopFar);
                    m4fWorld.multiplyVec4(v4fRightTopFar);
                }

                var v3fLeftBottomNear = pFrustumVertices[0].set(v4fLeftBottomNear.clone("xyz"));
                var v3fRightBottomNear = pFrustumVertices[1].set(v4fRightBottomNear.clone("xyz"));
                var v3fLeftTopNear = pFrustumVertices[2].set(v4fLeftTopNear.clone("xyz"));
                var v3fRightTopNear = pFrustumVertices[3].set(v4fRightTopNear.clone("xyz"));

                var v3fLeftBottomFar = pFrustumVertices[4].set(v4fLeftBottomFar.clone("xyz"));
                var v3fRightBottomFar = pFrustumVertices[5].set(v4fRightBottomFar.clone("xyz"));
                var v3fLeftTopFar = pFrustumVertices[6].set(v4fLeftTopFar.clone("xyz"));
                var v3fRightTopFar = pFrustumVertices[7].set(v4fRightTopFar.clone("xyz"));

                //filling search rectangle
                if (akra.isDef(pSearchRect)) {
                    pSearchRect.set(v3fLeftBottomNear, v3fLeftBottomNear);

                    pSearchRect.unionPoint(v3fRightBottomNear);
                    pSearchRect.unionPoint(v3fLeftTopNear);
                    pSearchRect.unionPoint(v3fRightTopNear);

                    pSearchRect.unionPoint(v3fLeftBottomFar);
                    pSearchRect.unionPoint(v3fRightBottomFar);
                    pSearchRect.unionPoint(v3fLeftTopFar);
                    pSearchRect.unionPoint(v3fRightTopFar);
                }

                //calculating planes
                this.leftPlane.set(v3fLeftTopNear, v3fLeftTopFar, v3fLeftBottomNear);
                this.rightPlane.set(v3fRightBottomFar, v3fRightTopFar, v3fRightBottomNear);
                this.topPlane.set(v3fLeftTopNear, v3fRightTopNear, v3fLeftTopFar);
                this.bottomPlane.set(v3fRightBottomFar, v3fRightBottomNear, v3fLeftBottomFar);
                this.nearPlane.set(v3fLeftTopNear, v3fLeftBottomNear, v3fRightTopNear);
                this.farPlane.set(v3fRightBottomFar, v3fLeftBottomFar, v3fRightTopFar);

                return this;
            };

            /**  */ Frustum.prototype.isEqual = function (pFrustum) {
                return (this.leftPlane.isEqual(pFrustum.leftPlane) && this.rightPlane.isEqual(pFrustum.rightPlane) && this.topPlane.isEqual(pFrustum.topPlane) && this.bottomPlane.isEqual(pFrustum.bottomPlane) && this.nearPlane.isEqual(pFrustum.nearPlane) && this.farPlane.isEqual(pFrustum.farPlane));
            };

            //output - array of vertices in counterclockwise order (around plane normal as axis)
            //if destination don't submitted returned array from temp vectors
            Frustum.prototype.getPlanePoints = function (sPlaneKey, pDestination) {
                var pPoints = (arguments.length === 2) ? pDestination : [Vec3.temp(), Vec3.temp(), Vec3.temp(), Vec3.temp()];

                var pFrustumVertices = this.getFrustumVertices();
                if (pFrustumVertices === null) {
                    pFrustumVertices = this.calculateFrustumVertices();
                }

                switch (sPlaneKey) {
                    case "leftPlane":
                        pPoints[0].set(pFrustumVertices[6]);
                        pPoints[1].set(pFrustumVertices[4]);
                        pPoints[2].set(pFrustumVertices[0]);
                        pPoints[3].set(pFrustumVertices[2]);
                        break;
                    case "rightPlane":
                        pPoints[0].set(pFrustumVertices[7]);
                        pPoints[1].set(pFrustumVertices[3]);
                        pPoints[2].set(pFrustumVertices[1]);
                        pPoints[3].set(pFrustumVertices[5]);
                        break;
                    case "topPlane":
                        pPoints[0].set(pFrustumVertices[7]);
                        pPoints[1].set(pFrustumVertices[6]);
                        pPoints[2].set(pFrustumVertices[2]);
                        pPoints[3].set(pFrustumVertices[3]);
                        break;
                    case "bottomPlane":
                        pPoints[0].set(pFrustumVertices[5]);
                        pPoints[1].set(pFrustumVertices[1]);
                        pPoints[2].set(pFrustumVertices[0]);
                        pPoints[3].set(pFrustumVertices[4]);
                        break;
                    case "nearPlane":
                        pPoints[0].set(pFrustumVertices[3]);
                        pPoints[1].set(pFrustumVertices[2]);
                        pPoints[2].set(pFrustumVertices[0]);
                        pPoints[3].set(pFrustumVertices[1]);
                        break;
                    case "farPlane":
                        pPoints[0].set(pFrustumVertices[7]);
                        pPoints[1].set(pFrustumVertices[5]);
                        pPoints[2].set(pFrustumVertices[4]);
                        pPoints[3].set(pFrustumVertices[6]);
                        break;
                    default:
                        akra.logger.assert(false, "invalid plane key");
                        break;
                }
                return pPoints;
            };

            Frustum.prototype.testPoint = function (v3fPoint) {
                if (this.leftPlane.signedDistance(v3fPoint) > 0. || this.rightPlane.signedDistance(v3fPoint) > 0. || this.topPlane.signedDistance(v3fPoint) > 0. || this.bottomPlane.signedDistance(v3fPoint) > 0. || this.nearPlane.signedDistance(v3fPoint) > 0. || this.farPlane.signedDistance(v3fPoint) > 0.) {
                    return false;
                }
                return true;
            };

            Frustum.prototype.testRect = function (pRect) {
                if (geometry.classify.planeRect3d(this.leftPlane, pRect) == 0 /* PLANE_FRONT */ || geometry.classify.planeRect3d(this.rightPlane, pRect) == 0 /* PLANE_FRONT */ || geometry.classify.planeRect3d(this.topPlane, pRect) == 0 /* PLANE_FRONT */ || geometry.classify.planeRect3d(this.bottomPlane, pRect) == 0 /* PLANE_FRONT */ || geometry.classify.planeRect3d(this.nearPlane, pRect) == 0 /* PLANE_FRONT */ || geometry.classify.planeRect3d(this.farPlane, pRect) == 0 /* PLANE_FRONT */) {
                    return false;
                }
                return true;
            };

            Frustum.prototype.testSphere = function (pSphere) {
                if (geometry.classify.planeSphere(this.leftPlane, pSphere) == 0 /* PLANE_FRONT */ || geometry.classify.planeSphere(this.rightPlane, pSphere) == 0 /* PLANE_FRONT */ || geometry.classify.planeSphere(this.topPlane, pSphere) == 0 /* PLANE_FRONT */ || geometry.classify.planeSphere(this.bottomPlane, pSphere) == 0 /* PLANE_FRONT */ || geometry.classify.planeSphere(this.nearPlane, pSphere) == 0 /* PLANE_FRONT */ || geometry.classify.planeSphere(this.farPlane, pSphere) == 0 /* PLANE_FRONT */) {
                    return false;
                }
                return true;
            };

            Frustum.prototype.testFrustum = function (pFrustum) {
                var pFrustumVertices1 = this.getFrustumVertices();
                var pFrustumVertices2 = pFrustum.getFrustumVertices();

                if (pFrustumVertices1 == null) {
                    pFrustumVertices1 = this.calculateFrustumVertices();
                }
                if (pFrustumVertices2 == null) {
                    pFrustumVertices2 = pFrustum.calculateFrustumVertices();
                }

                var pFrustumPlanes = Frustum.frustumPlanesKeys;

                var nTest;

                for (var i = 0; i < 6; i++) {
                    var pPlane = this[pFrustumPlanes[i]];

                    nTest = 0;

                    for (var j = 0; j < 8; j++) {
                        if (pPlane.signedDistance(pFrustumVertices2[j]) > 0) {
                            nTest++;
                        }
                    }

                    if (nTest == 8) {
                        //frustums don't intersecting
                        return false;
                    }
                }

                for (var i = 0; i < 6; i++) {
                    var pPlane = pFrustum[pFrustumPlanes[i]];

                    nTest = 0;

                    for (var j = 0; j < 8; j++) {
                        if (pPlane.signedDistance(pFrustumVertices1[j]) > 0) {
                            nTest++;
                        }
                    }

                    if (nTest == 8) {
                        //frustums don't intersecting
                        return false;
                    }
                }

                return true;
            };

            Frustum.prototype.getViewDirection = function (v3fDirection) {
                if (!akra.isDef(v3fDirection)) {
                    v3fDirection = new Vec3();
                }

                v3fDirection.set(0);

                if (akra.isNull(this._pFrustumVertices)) {
                    this.calculateFrustumVertices();
                }

                for (var i = 4; i < 8; i++) {
                    v3fDirection.add(this._pFrustumVertices[i]);
                }

                for (var i = 0; i < 4; i++) {
                    v3fDirection.subtract(this._pFrustumVertices[i]);
                }

                return v3fDirection.normalize();
            };

            Frustum.prototype.toString = function () {
                var sStr = "";

                for (var i = 0; i < 6; i++) {
                    var sKey = Frustum.frustumPlanesKeys[i];
                    sStr += sKey + ":\n";
                    sStr += this[sKey].toString() + "\n";
                }

                return sStr;
            };

            Frustum.frustumPlanesKeys = [
                "leftPlane", "rightPlane", "topPlane",
                "bottomPlane", "nearPlane", "farPlane"];
            return Frustum;
        })();
        geometry.Frustum = Frustum;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
/// <reference path="../idl/IVertexData.ts" />
/// <reference path="../idl/IVertexElement.ts" />
/// <reference path="../math/math.ts" />
/// <reference path="Ray2d.ts" />
/// <reference path="Ray3d.ts" />
/// <reference path="Segment2d.ts" />
/// <reference path="Segment3d.ts" />
/// <reference path="Box.ts" />
/// <reference path="Circle.ts" />
/// <reference path="Sphere.ts" />
/// <reference path="Rect2d.ts" />
/// <reference path="Rect3d.ts" />
/// <reference path="Plane2d.ts" />
/// <reference path="Plane3d.ts" />
/// <reference path="Frustum.ts" />
/// <reference path="../data/Usage.ts" />
var akra;
(function (akra) {
    (function (geometry) {
        var Vec3 = akra.math.Vec3;

        var usage = akra.data.Usages;

        //function computeBoundingBox(pVertexData: IVertexData, pBoundingBox: IRect3d): boolean;
        //function computeDataForCascadeBoundingBox(pBoundingBox: IRect3d, ppVertexes: float[], ppIndexes: uint[], fMinSize?: float): boolean;
        //function computeBoundingSphere(pVertexData: IVertexData, pSphere: ISphere, bFastMethod?: boolean, pBoundingBox?: IRect3d): boolean;
        //function computeBoundingSphereFast(pVertexData: IVertexData, pSphere: ISphere, pBoundingBox?: IRect3d): boolean;
        //function computeBoundingSphereMinimal(pVertexData: IVertexData, pSphere: ISphere): boolean;
        //function computeGeneralizingSphere(pSphereA: ISphere, pSphereB: ISphere, pSphereDest?: ISphere): boolean;
        //function computeDataForCascadeBoundingSphere(pBoundingSphere: ISphere, ppVertexes: float[], ppIndexes: uint[], fMinSize?: float): boolean;
        /**
        * Computes a coordinate-axis oriented bounding box.
        */
        function computeBoundingBox(pVertexData, pBoundingBox) {
            var fX0 = 0, fY0 = 0, fZ0 = 0, fX1 = 0, fY1 = 0, fZ1 = 0;
            var fTemp, pTempData;
            var i = 0;
            var pVertexDeclaration, pVertexElement, pData;
            var nStride, nCount;

            pVertexDeclaration = pVertexData.getVertexDeclaration();

            if (akra.isNull(pVertexDeclaration))
                return false;

            pVertexElement = pVertexDeclaration.findElement(usage.POSITION, 3);

            if (akra.isNull(pVertexElement))
                return false;

            nCount = pVertexData.getLength();
            nStride = pVertexElement.size;

            pData = pVertexData.getData(pVertexElement.offset, pVertexElement.size);

            if (akra.isNull(pData))
                return false;

            pTempData = new Float32Array(pData, 0, 3);
            fX0 = fX1 = pTempData[0];
            fY0 = fY1 = pTempData[1];
            fZ0 = fZ1 = pTempData[2];

            for (i = nStride; i < nStride * nCount; i += nStride) {
                pTempData = new Float32Array(pData, i, 3);
                fTemp = pTempData[0];
                fX0 = fX0 > fTemp ? fTemp : fX0; /*Min*/
                fX1 = fX1 > fTemp ? fX1 : fTemp; /*Max*/

                fTemp = pTempData[1];
                fY0 = fY0 > fTemp ? fTemp : fY0; /*Min*/
                fY1 = fY1 > fTemp ? fY1 : fTemp; /*Max*/

                fTemp = pTempData[2];
                fZ0 = fZ0 > fTemp ? fTemp : fZ0; /*Min*/
                fZ1 = fZ1 > fTemp ? fZ1 : fTemp; /*Max*/
            }

            pBoundingBox.set(fX0, fX1, fY0, fY1, fZ0, fZ1);

            return true;
        }
        geometry.computeBoundingBox = computeBoundingBox;

        /** расчет данных для отрисовки бокса */
        function computeDataForCascadeBoundingBox(pBoundingBox, ppVertexes, ppIndexes, fMinSize) {
            if (typeof fMinSize === "undefined") { fMinSize = .25; }
            var pInd;
            var pPoints;
            var i, j, k;

            pPoints = new Array(8);

            for (i = 0; i < 8; i++) {
                pPoints[i] = new Array(4);
                for (j = 0; j < 4; j++)
                    pPoints[i][j] = new Vec3(0);
            }

            //Выставление точек Rect3d
            pPoints[0][0].set([pBoundingBox.x0, pBoundingBox.y0, pBoundingBox.z0]);
            pPoints[1][0].set([pBoundingBox.x0, pBoundingBox.y1, pBoundingBox.z0]);
            pPoints[2][0].set([pBoundingBox.x0, pBoundingBox.y0, pBoundingBox.z1]);
            pPoints[3][0].set([pBoundingBox.x0, pBoundingBox.y1, pBoundingBox.z1]);
            pPoints[4][0].set([pBoundingBox.x1, pBoundingBox.y0, pBoundingBox.z0]);
            pPoints[5][0].set([pBoundingBox.x1, pBoundingBox.y1, pBoundingBox.z0]);
            pPoints[6][0].set([pBoundingBox.x1, pBoundingBox.y0, pBoundingBox.z1]);
            pPoints[7][0].set([pBoundingBox.x1, pBoundingBox.y1, pBoundingBox.z1]);

            var fTempFunc = function (pPoints, iPoint, iToPoint1, iToPoint2, iToPoint3) {
                for (var i = 0; i < 3; i++) {
                    pPoints[arguments[i + 2]][0].subtract(pPoints[iPoint][0], pPoints[iPoint][i + 1]);

                    if (pPoints[iPoint][i + 1].length() > fMinSize) {
                        pPoints[iPoint][i + 1].scale(0.1);
                    }

                    pPoints[iPoint][i + 1].add(pPoints[iPoint][0]);
                }
            };

            fTempFunc(pPoints, 0, 1, 2, 4);
            fTempFunc(pPoints, 1, 0, 3, 5);
            fTempFunc(pPoints, 2, 0, 3, 6);
            fTempFunc(pPoints, 3, 1, 2, 7);
            fTempFunc(pPoints, 4, 0, 5, 6);
            fTempFunc(pPoints, 5, 1, 4, 7);
            fTempFunc(pPoints, 6, 2, 4, 7);
            fTempFunc(pPoints, 7, 3, 5, 6);

            for (i = 0; i < 8; i++) {
                for (j = 0; j < 4; j++) {
                    ppVertexes[i * 12 + j * 3 + 0] = pPoints[i][j].x;
                    ppVertexes[i * 12 + j * 3 + 1] = pPoints[i][j].y;
                    ppVertexes[i * 12 + j * 3 + 2] = pPoints[i][j].z;
                }
            }

            pInd = [
                0, 1, 0, 2, 0, 3,
                4, 5, 4, 6, 4, 7,
                8, 9, 8, 10, 8, 11,
                12, 13, 12, 14, 12, 15,
                16, 17, 16, 18, 16, 19,
                20, 21, 20, 22, 20, 23,
                24, 25, 24, 26, 24, 27,
                28, 29, 28, 30, 28, 31
            ];

            for (var i = 0; i < pInd.length; ++i) {
                ppIndexes[i] = pInd[i];
            }

            return true;
        }
        geometry.computeDataForCascadeBoundingBox = computeDataForCascadeBoundingBox;

        /** подсчет обобщающей сферы над двумя сферами */
        function computeGeneralizingSphere(pSphereA, pSphereB, pSphereDest) {
            if (!akra.isDef(pSphereDest)) {
                pSphereDest = pSphereA;
            }

            var fR1 = pSphereA.radius;
            var fR2 = pSphereB.radius;
            var v3fC1 = pSphereA.center;
            var v3fC2 = pSphereB.center;

            var v3fD = new Vec3;

            v3fC1.subtract(v3fC2, v3fD);

            var fD = v3fD.length();

            if (fD < fR1 && fR1 > fR2) {
                pSphereDest.set(pSphereA);
                return false;
            }

            if (fD < fR2) {
                pSphereDest.set(pSphereB);
                return false;
            }

            var v3fN = new Vec3;
            v3fD.normalize(v3fN);

            pSphereDest.radius = v3fD.add(v3fN.scale(fR1 + fR2)).length() / 2.0;

            var v3fTemp = v3fD;
            pSphereDest.center = v3fC1.add(v3fC2, v3fTemp).add(v3fN.scale((fR1 - fR2) / (fR1 + fR2))).scale(.5);

            return true;
        }
        geometry.computeGeneralizingSphere = computeGeneralizingSphere;

        /** расчет данных для отрисовки сферы */
        function computeDataForCascadeBoundingSphere(pBoundingSphere, ppVertexes, ppIndexes, fMinSize) {
            if (typeof fMinSize === "undefined") { fMinSize = 0.25; }
            var fTheta, fDelta, fAlpha;
            var nCount = 10;
            var i, j, k;

            fDelta = akra.math.TWO_PI / nCount;

            for (i = 0; i <= nCount / 2; i++) {
                fTheta = -akra.math.PI + (i * fDelta);

                for (j = 0; j <= nCount; j++) {
                    fAlpha = j * fDelta;
                    ppVertexes[(i * (nCount + 1) + j) * 3 + 0] = pBoundingSphere.center.x + pBoundingSphere.radius * akra.math.sin(fTheta) * akra.math.cos(fAlpha);
                    ppVertexes[(i * (nCount + 1) + j) * 3 + 1] = pBoundingSphere.center.y + pBoundingSphere.radius * akra.math.sin(fTheta) * akra.math.sin(fAlpha);
                    ppVertexes[(i * (nCount + 1) + j) * 3 + 2] = pBoundingSphere.center.z + pBoundingSphere.radius * akra.math.cos(fTheta);
                }
            }

            for (i = 0; i < nCount / 2; i++) {
                for (j = 0; j < nCount; j++) {
                    ppIndexes[(i * (nCount) + j) * 12 + 0] = i * (nCount + 1) + j;
                    ppIndexes[(i * (nCount) + j) * 12 + 1] = i * (nCount + 1) + j + 1;

                    ppIndexes[(i * (nCount) + j) * 12 + 2] = i * (nCount + 1) + j + 2 + nCount;
                    ppIndexes[(i * (nCount) + j) * 12 + 3] = i * (nCount + 1) + j;

                    ppIndexes[(i * (nCount) + j) * 12 + 4] = i * (nCount + 1) + j + 1;
                    ppIndexes[(i * (nCount) + j) * 12 + 5] = i * (nCount + 1) + j + 2 + nCount;

                    ppIndexes[(i * (nCount) + j) * 12 + 6] = i * (nCount + 1) + j;
                    ppIndexes[(i * (nCount) + j) * 12 + 7] = i * (nCount + 1) + j + 1 + nCount;

                    ppIndexes[(i * (nCount) + j) * 12 + 8] = i * (nCount + 1) + j + 2 + nCount;
                    ppIndexes[(i * (nCount) + j) * 12 + 9] = i * (nCount + 1) + j + 1 + nCount;

                    ppIndexes[(i * (nCount) + j) * 12 + 10] = i * (nCount + 1) + j + 2 + nCount;
                    ppIndexes[(i * (nCount) + j) * 12 + 11] = i * (nCount + 1) + j;
                }
            }

            return true;
        }
        geometry.computeDataForCascadeBoundingSphere = computeDataForCascadeBoundingSphere;

        /**
        * Computes a bounding sphere.
        * При использование быстрого вычисления, опционально можно получить баундинг бокс.
        */
        function computeBoundingSphere(pVertexData, pSphere, bFastMethod, pBoundingBox) {
            if (typeof bFastMethod === "undefined") { bFastMethod = true; }
            if (typeof pBoundingBox === "undefined") { pBoundingBox = null; }
            if (bFastMethod) {
                return computeBoundingSphereFast(pVertexData, pSphere, pBoundingBox);
            } else {
                return computeBoundingSphereMinimal(pVertexData, pSphere);
            }
        }
        geometry.computeBoundingSphere = computeBoundingSphere;

        /**
        * Computes a bounding sphere - not minimal. Also if it need compute dounding box
        */
        function computeBoundingSphereFast(pVertexData, pSphere, pBoundingBox) {
            if (typeof pBoundingBox === "undefined") { pBoundingBox = null; }
            var i;
            var pVertexDeclaration, pVertexElement;
            var nCount, nStride;
            var pData, pTempData;

            pVertexDeclaration = pVertexData.getVertexDeclaration();

            if (akra.isNull(pVertexDeclaration)) {
                return false;
            }

            pVertexElement = pVertexDeclaration.findElement(usage.POSITION, 3);

            if (akra.isNull(pVertexElement)) {
                return false;
            }

            nCount = pVertexData.getLength();
            nStride = pVertexElement.size;

            pData = pVertexData.getData(pVertexElement.offset, pVertexElement.size);

            if (akra.isNull(pData)) {
                return false;
            }

            if (akra.isNull(pBoundingBox)) {
                pBoundingBox = geometry.Rect3d.temp();
            }

            if (pBoundingBox.isClear()) {
                if (!computeBoundingBox(pVertexData, pBoundingBox)) {
                    return false;
                }
            }

            var fCenterX = (pBoundingBox.x0 + pBoundingBox.x1) / 2;
            var fCenterY = (pBoundingBox.y0 + pBoundingBox.y1) / 2;
            var fCenterZ = (pBoundingBox.z0 + pBoundingBox.z1) / 2;
            var fRadius = 0;
            var fDistance = 0;

            for (i = 0; i < nStride * nCount; i += nStride) {
                pTempData = new Float32Array(pData, i, 3);
                fDistance = (pTempData[0] - fCenterX) * (pTempData[0] - fCenterX) + (pTempData[1] - fCenterY) * (pTempData[1] - fCenterY) + (pTempData[2] - fCenterZ) * (pTempData[2] - fCenterZ);
                fRadius = fDistance > fRadius ? fDistance : fRadius;
            }

            pSphere.set(fCenterX, fCenterY, fCenterZ, akra.math.sqrt(fRadius));

            return true;
        }
        geometry.computeBoundingSphereFast = computeBoundingSphereFast;

        /**
        * Computes a bounding sphere - minimal.
        */
        function computeBoundingSphereMinimal(pVertexData, pSphere) {
            var i = 0, j = 0, k = 0;
            var points = [];
            var length = 0;
            var isAdd = false;
            var isNew = true;
            var fDiametr = 0;
            var fDistance = 0;

            var pVertexDeclaration, pVertexElement;
            var nCount, nStride;
            var pData, pTempData1, pTempData2;

            pVertexDeclaration = pVertexData.getVertexDeclaration();

            if (akra.isNull(pVertexData)) {
                return false;
            }

            if (akra.isNull(pVertexDeclaration)) {
                return false;
            }

            pVertexElement = pVertexDeclaration.findElement(usage.POSITION, 3);

            if (akra.isNull(pVertexElement))
                return false;

            nCount = pVertexData.getLength();
            nStride = pVertexElement.size;

            pData = pVertexData.getData(pVertexElement.offset, pVertexElement.size);

            if (!pData)
                return false;

            for (i = 0; i < nStride * nCount; i += nStride) {
                isNew = true;
                isAdd = false;
                pTempData1 = new Float32Array(pData, i, 3);

                for (k = 0; k < points.length; k += 3) {
                    if (points[k] == pTempData1[0] && points[k + 1] == pTempData1[1] && points[k + 2] == pTempData1[2]) {
                        isNew = false;
                        break;
                    }
                }

                if (isNew) {
                    for (j = i + nStride; j < nStride * nCount; j += nStride) {
                        pTempData2 = new Float32Array(pData, j, 3);
                        fDistance = (pTempData1[0] - pTempData2[0]) * (pTempData1[0] - pTempData2[0]) + (pTempData1[1] - pTempData2[1]) * (pTempData1[1] - pTempData2[1]) + (pTempData1[2] - pTempData2[2]) * (pTempData1[2] - pTempData2[2]);
                        if (fDistance > fDiametr) {
                            fDiametr = fDistance;
                            isAdd = true;
                            points[0] = pTempData2[0];
                            points[1] = pTempData2[1];
                            points[2] = pTempData2[2];
                            length = 3;
                        } else if (fDistance.toFixed(7) == fDiametr.toFixed(7)) {
                            isAdd = true;
                            for (k = 0; k < points.length; k += 3) {
                                if (points[k] == pTempData2[0] && points[k + 1] == pTempData2[1] && points[k + 2] == pTempData2[2]) {
                                    isNew = false;
                                    break;
                                }
                            }
                            if (isNew) {
                                points[length] = pTempData2[0];
                                points[length + 1] = pTempData2[1];
                                points[length + 2] = pTempData2[2];
                                length += 3;
                            }
                        }
                    }
                    if (isAdd) {
                        points[length] = pTempData1[0];
                        points[length + 1] = pTempData1[1];
                        points[length + 2] = pTempData1[2];
                        length += 3;
                    }
                }
            }

            var fX = 0, fY = 0, fZ = 0;

            for (i = 0; i < points.length; i += 3) {
                fX += points[i];
                fY += points[i + 1];
                fZ += points[i + 2];
            }

            var x = pSphere.center.x = fX / points.length * 3;
            var y = pSphere.center.y = fY / points.length * 3;
            var z = pSphere.center.z = fZ / points.length * 3;

            pSphere.radius = akra.math.sqrt((points[0] - x) * (points[0] - x) + (points[1] - y) * (points[1] - y) + (points[2] - z) * (points[2] - z));
            return true;
        }
        geometry.computeBoundingSphereMinimal = computeBoundingSphereMinimal;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
/// <reference path="../idl/IViewport.ts" />
/// <reference path="../idl/ICamera.ts" />
/// <reference path="../idl/IRID.ts" />
var akra;
(function (akra) {
    /// <reference path="../events.ts" />
    /// <reference path="../color/colors.ts" />
    /// <reference path="../bf/bf.ts" />
    /// <reference path="../config/config.ts" />
    /// <reference path="../math/math.ts" />
    /// <reference path="../debug.ts" />
    /// <reference path="../geometry/Rect2d.ts" />
    /// <reference path="../util/ObjectArray.ts" />
    /// <reference path="../guid.ts" />
    (function (render) {
        var Color = akra.color.Color;

        //NOTE: This signal is not called directly from the viewport, call derives from render technique.
        var RenderSignal = (function (_super) {
            __extends(RenderSignal, _super);
            function RenderSignal() {
                _super.apply(this, arguments);
            }
            RenderSignal.prototype.emit = function (pTechnique, iPass, pRenderable, pSceneObject) {
                //is mouse under the viewport
                var pViewport = this.getSender();
                pViewport._onRender(pTechnique, iPass, pRenderable, pSceneObject);

                //EMIT_BROADCAST(render, _CALL(pTechnique, iPass, pRenderable, pSceneObject));
                _super.prototype.emit.call(this, pTechnique, iPass, pRenderable, pSceneObject);
            };
            return RenderSignal;
        })(akra.Signal);

        var Viewport = (function () {
            /**
            * @param csRenderMethod Name of render technique, that will be selected in the renderable for render.
            */
            function Viewport(pCamera, csRenderMethod, fLeft, fTop, fWidth, fHeight, iZIndex) {
                if (typeof csRenderMethod === "undefined") { csRenderMethod = null; }
                if (typeof fLeft === "undefined") { fLeft = 0.; }
                if (typeof fTop === "undefined") { fTop = 0.; }
                if (typeof fWidth === "undefined") { fWidth = 1.; }
                if (typeof fHeight === "undefined") { fHeight = 1.; }
                if (typeof iZIndex === "undefined") { iZIndex = 0; }
                this.guid = akra.guid();
                this._pCamera = null;
                this._pTarget = null;
                this._iActLeft = 0;
                this._iActTop = 0;
                this._iActWidth = 1;
                this._iActHeight = 1;
                this._pDepthRange = { min: -1., max: 1. };
                this._pViewportState = {
                    cullingMode: 1 /* NONE */,
                    depthTest: true,
                    depthWrite: true,
                    depthFunction: 2 /* LESS */,
                    clearColor: new Color(0., 0., 0., 0.),
                    clearDepth: 1.,
                    clearBuffers: 1 /* COLOR */ | 2 /* DEPTH */
                };
                this._bClearEveryFrame = true;
                this._bUpdated = false;
                this._iVisibilityMask = 0xFFFFFFFF;
                this._sMaterialSchemeName = akra.config.material.name;
                this._isAutoUpdated = true;
                this._csDefaultRenderMethod = null;
                this._isDepthRangeUpdated = false;
                //show/hide
                this._bHidden = false;
                //user events handing
                this._iUserEvents = 0;
                this.setupSignals();

                this._fRelLeft = fLeft;
                this._fRelTop = fTop;
                this._fRelWidth = fWidth;
                this._fRelHeight = fHeight;

                this._iZIndex = iZIndex;

                this._csDefaultRenderMethod = csRenderMethod;

                this._setCamera(pCamera);
            }
            Viewport.prototype.setupSignals = function () {
                this.viewportDimensionsChanged = this.viewportDimensionsChanged || new akra.Signal(this);
                this.viewportCameraChanged = this.viewportCameraChanged || new akra.Signal(this);

                this.render = this.render || new RenderSignal(this);

                this.dragstart = this.dragstart || new akra.Signal(this);
                this.dragstop = this.dragstop || new akra.Signal(this);
                this.dragging = this.dragging || new akra.Signal(this);

                this.click = this.click || new akra.Signal(this);
                this.mousemove = this.mousemove || new akra.Signal(this);

                this.mousedown = this.mousedown || new akra.Signal(this);
                this.mouseup = this.mouseup || new akra.Signal(this);

                this.mouseover = this.mouseover || new akra.Signal(this);
                this.mouseout = this.mouseout || new akra.Signal(this);
                this.mousewheel = this.mousewheel || new akra.Signal(this);
            };

            Viewport.prototype.getLeft = function () {
                return this._fRelLeft;
            };

            Viewport.prototype.getTop = function () {
                return this._fRelTop;
            };

            Viewport.prototype.getWidth = function () {
                return this._fRelWidth;
            };

            Viewport.prototype.getHeight = function () {
                return this._fRelHeight;
            };

            Viewport.prototype.getActualLeft = function () {
                return this._iActLeft;
            };

            Viewport.prototype.getActualTop = function () {
                return this._iActTop;
            };

            Viewport.prototype.getActualWidth = function () {
                return this._iActWidth;
            };

            Viewport.prototype.getActualHeight = function () {
                return this._iActHeight;
            };

            Viewport.prototype.getZIndex = function () {
                return this._iZIndex;
            };

            Viewport.prototype.getType = function () {
                return -1 /* DEFAULT */;
            };

            Viewport.prototype.getBackgroundColor = function () {
                return this._pViewportState.clearColor;
            };

            Viewport.prototype.setBackgroundColor = function (cColor) {
                this._pViewportState.clearColor.set(cColor);
            };

            Viewport.prototype.getDepthClear = function () {
                return this._pViewportState.clearDepth;
            };

            Viewport.prototype.setDepthClear = function (fDepthClearValue) {
                this._pViewportState.clearDepth = fDepthClearValue;
            };

            Viewport.prototype._setDefaultRenderMethod = function (sMethod) {
                this._csDefaultRenderMethod = sMethod;
            };

            Viewport.prototype.destroy = function () {
                var pRenderer = this._pTarget.getRenderer();
                if (pRenderer && pRenderer._getViewport() === this) {
                    pRenderer._setViewport(null);
                }
            };

            Viewport.prototype.clear = function (iBuffers, cColor, fDepth, iStencil) {
                if (typeof iBuffers === "undefined") { iBuffers = 1 /* COLOR */ | 2 /* DEPTH */; }
                if (typeof cColor === "undefined") { cColor = Color.BLACK; }
                if (typeof fDepth === "undefined") { fDepth = 1.; }
                if (typeof iStencil === "undefined") { iStencil = 0; }
                var pRenderer = this._pTarget.getRenderer();

                if (pRenderer) {
                    var pCurrentViewport = pRenderer._getViewport();

                    if (pCurrentViewport === this) {
                        pRenderer.clearFrameBuffer(iBuffers, cColor, fDepth, iStencil);
                    } else {
                        pRenderer._setViewport(this);
                        pRenderer.clearFrameBuffer(iBuffers, cColor, fDepth, iStencil);
                        pRenderer._setViewport(pCurrentViewport);
                    }
                }
            };

            Viewport.prototype.getTarget = function () {
                return this._pTarget;
            };

            Viewport.prototype.getCamera = function () {
                return this._pCamera;
            };

            Viewport.prototype.setCamera = function (pCamera) {
                if (akra.isDefAndNotNull(pCamera)) {
                    if (this._pCamera._getLastViewport() == this) {
                        this._pCamera._keepLastViewport(null);
                    }
                }

                this._setCamera(pCamera);
                this.viewportCameraChanged.emit();

                return true;
            };

            Viewport.prototype._setCamera = function (pCamera) {
                this._pCamera = pCamera;

                if (akra.isDefAndNotNull(pCamera)) {
                    // update aspect ratio of new camera if needed.
                    if (!pCamera.isConstantAspect()) {
                        pCamera.setAspect(this._iActWidth / this._iActHeight);
                    }
                    pCamera._keepLastViewport(this);
                }
            };

            Viewport.prototype.setDimensions = function (fLeft, fTop, fWidth, fHeight) {
                var pRect;
                if (akra.isNumber(arguments[0])) {
                    this._fRelLeft = fLeft;
                    this._fRelTop = fTop;
                    this._fRelWidth = fWidth;
                    this._fRelHeight = fHeight;
                } else {
                    pRect = arguments[0];
                    this._fRelLeft = pRect.getLeft();
                    this._fRelTop = pRect.getTop();
                    this._fRelWidth = pRect.getWidth();
                    this._fRelHeight = pRect.getHeight();
                }

                this._updateDimensions();

                return true;
            };

            Viewport.prototype.getActualDimensions = function () {
                return new akra.geometry.Rect2d(this._iActLeft, this._iActTop, this._iActWidth, this._iActHeight);
            };

            Viewport.prototype.setClearEveryFrame = function (isClear, iBuffers) {
                if (typeof iBuffers === "undefined") { iBuffers = 1 /* COLOR */ | 2 /* DEPTH */; }
                this._bClearEveryFrame = isClear;
                this._pViewportState.clearBuffers = iBuffers;
            };

            Viewport.prototype.getClearEveryFrame = function () {
                return this._bClearEveryFrame;
            };

            Viewport.prototype.getClearBuffers = function () {
                return this._pViewportState.clearBuffers;
            };

            Viewport.prototype.setDepthParams = function (bDepthTest, bDepthWrite, eDepthFunction) {
                this._pViewportState.depthTest = bDepthTest;
                this._pViewportState.depthWrite = bDepthWrite;
                this._pViewportState.depthFunction = eDepthFunction;
            };

            Viewport.prototype.setCullingMode = function (eCullingMode) {
                this._pViewportState.cullingMode = eCullingMode;
            };

            Viewport.prototype.setAutoUpdated = function (bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                this._isAutoUpdated = bValue;
            };
            Viewport.prototype.isAutoUpdated = function () {
                return this._isAutoUpdated;
            };

            Viewport.prototype._updateDimensions = function (bEmitEvent) {
                if (typeof bEmitEvent === "undefined") { bEmitEvent = true; }
                var fHeight = this._pTarget.getHeight();
                var fWidth = this._pTarget.getWidth();

                this._iActLeft = akra.math.round(this._fRelLeft * fWidth);
                this._iActTop = akra.math.round(this._fRelTop * fHeight);
                this._iActWidth = akra.math.round(this._fRelWidth * fWidth);
                this._iActHeight = akra.math.round(this._fRelHeight * fHeight);

                // This will check if the cameras getAutoAspectRatio() property is set.
                // If it's true its aspect ratio is fit to the current viewport
                // If it's false the camera remains unchanged.
                // This allows cameras to be used to render to many viewports,
                // which can have their own dimensions and aspect ratios.
                if (this._pCamera) {
                    if (!this._pCamera.isConstantAspect())
                        this._pCamera.setAspect(this._iActWidth / this._iActHeight);
                }

                this._bUpdated = true;

                if (bEmitEvent) {
                    this.viewportDimensionsChanged.emit();
                }
            };

            Viewport.prototype.hide = function (bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                if (bValue !== this._bHidden) {
                    this.clear();
                    this._bHidden = bValue;
                }
            };

            Viewport.prototype.update = function () {
                if (this._bHidden) {
                    return;
                }

                if (akra.isDefAndNotNull(this._pCamera)) {
                    this._pCamera._keepLastViewport(this);
                }

                this.startFrame();

                this._isDepthRangeUpdated = false;

                this._updateImpl();

                this.endFrame();
            };

            Viewport.prototype._updateImpl = function () {
                if (this._pCamera) {
                    this.renderAsNormal(this._csDefaultRenderMethod, this._pCamera);
                }
            };

            Viewport.prototype.startFrame = function () {
                if (this._bClearEveryFrame) {
                    this.clear(this._pViewportState.clearBuffers, this._pViewportState.clearColor, this._pViewportState.clearDepth);
                }
            };

            Viewport.prototype.renderObject = function (pRenderable, csMethod) {
                if (typeof csMethod === "undefined") { csMethod = null; }
                pRenderable.render(this, csMethod || this._csDefaultRenderMethod, null);
            };

            Viewport.prototype.endFrame = function () {
                this.getTarget().getRenderer().executeQueue(true);
            };

            Viewport.prototype.renderAsNormal = function (csMethod, pCamera) {
                var pVisibleObjects = pCamera.display();
                var pRenderable;

                for (var i = 0; i < pVisibleObjects.getLength(); ++i) {
                    pVisibleObjects.value(i).prepareForRender(this);
                }

                for (var i = 0; i < pVisibleObjects.getLength(); ++i) {
                    var pSceneObject = pVisibleObjects.value(i);

                    for (var j = 0; j < pSceneObject.getTotalRenderable(); j++) {
                        pRenderable = pSceneObject.getRenderable(j);

                        if (!akra.isNull(pRenderable)) {
                            pRenderable.render(this, csMethod, pSceneObject);
                        }
                    }
                }
            };

            Viewport.prototype._onRender = function (pTechnique, iPass, pRenderable, pSceneObject) {
            };

            Viewport.prototype._setTarget = function (pTarget) {
                if (!akra.isNull(this._pTarget)) {
                    akra.logger.critical("render target already exists in this viewport");
                    //this.disconnect(this._pTarget, SIGNAL(resized), SLOT(_updateDimensions));
                }

                this._pTarget = pTarget;

                if (!akra.isNull(this._pTarget)) {
                    //FIXME: unsafe <any> conversion used for _updateDimensins
                    this._pTarget.resized.connect(this, this._updateDimensions);
                    this._updateDimensions();
                    this._setCamera(this._pCamera);
                }
            };

            Viewport.prototype.isUpdated = function () {
                return this._bUpdated;
            };

            Viewport.prototype.enableSupportForUserEvent = function (iType) {
                if (akra.isNull(this.getTarget())) {
                    return 0;
                }

                //get events that have not yet been activated
                var iNotActivate = (this._iUserEvents ^ akra.MAX_INT32) & iType;

                this._iUserEvents = akra.bf.setAll(this._iUserEvents, iNotActivate);

                this.getTarget().enableSupportForUserEvent(iType);

                return iNotActivate;
            };

            Viewport.prototype.isUserEventSupported = function (eType) {
                return akra.bf.testAny(this._iUserEvents, eType);
            };

            Viewport.prototype._clearUpdatedFlag = function () {
                this._bUpdated = false;
            };

            Viewport.prototype._getNumRenderedPolygons = function () {
                return this._pCamera ? this._pCamera._getNumRenderedFaces() : 0;
            };

            Viewport.prototype._getViewportState = function () {
                return this._pViewportState;
            };

            Viewport.RenderSignal = RenderSignal;
            return Viewport;
        })();
        render.Viewport = Viewport;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="Viewport.ts" />
//#define DEFAULT_TEXTUREVIEW_NAME ".see_texture"
var akra;
(function (akra) {
    (function (render) {
        var DEFAULT_TEXTUREVIEW_NAME = ".see_texture";

        var Vec4 = akra.math.Vec4;

        var TextureViewport = (function (_super) {
            __extends(TextureViewport, _super);
            function TextureViewport(pTexture, fLeft, fTop, fWidth, fHeight, iZIndex) {
                if (typeof fLeft === "undefined") { fLeft = 0.; }
                if (typeof fTop === "undefined") { fTop = 0.; }
                if (typeof fWidth === "undefined") { fWidth = 1.; }
                if (typeof fHeight === "undefined") { fHeight = 1.; }
                if (typeof iZIndex === "undefined") { iZIndex = 0; }
                _super.call(this, null, DEFAULT_TEXTUREVIEW_NAME, fLeft, fTop, fWidth, fHeight, iZIndex);
                this._v4fMapping = new Vec4(0., 0., 1., 1.);

                this._pTargetTexture = pTexture;
            }
            TextureViewport.prototype.getType = function () {
                return 4 /* TEXTUREVIEWPORT */;
            };

            TextureViewport.prototype.getEffect = function () {
                return this._pEffect;
            };

            TextureViewport.prototype._setTarget = function (pTarget) {
                _super.prototype._setTarget.call(this, pTarget);

                var pEngine = this.getTarget().getRenderer().getEngine();
                var pResMgr = pEngine.getResourceManager();
                var pDefferedView = new render.Screen(pEngine.getRenderer());

                var pSeeTextureMethod = pResMgr.createRenderMethod(DEFAULT_TEXTUREVIEW_NAME + this.guid);
                var pSeeTextureEffect = pResMgr.createEffect(DEFAULT_TEXTUREVIEW_NAME + this.guid);

                pSeeTextureEffect.addComponent("akra.system.texture_to_screen");
                pSeeTextureMethod.setEffect(pSeeTextureEffect);

                pDefferedView.addRenderMethod(pSeeTextureMethod, DEFAULT_TEXTUREVIEW_NAME);

                this._pDeferredView = pDefferedView;
                this._pEffect = pSeeTextureEffect;
            };

            TextureViewport.prototype._updateImpl = function () {
                this._pDeferredView.render(this, DEFAULT_TEXTUREVIEW_NAME);
            };

            TextureViewport.prototype.setMapping = function (x, y, w, h) {
                this._v4fMapping.set(x, y, w, h);
                // console.log("set mapping > ", x, y, w, h, this._v4fMapping.toString());
            };

            TextureViewport.prototype._onRender = function (pTechnique, iPass, pRenderable, pSceneObject) {
                var pPass = pTechnique.getPass(iPass);

                pPass.setTexture("TEXTURE_FOR_SCREEN", this._pTargetTexture);
                pPass.setUniform("VIEWPORT", this._v4fMapping);

                _super.prototype._onRender.call(this, pTechnique, iPass, pRenderable, pSceneObject);
            };
            return TextureViewport;
        })(render.Viewport);
        render.TextureViewport = TextureViewport;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="IViewport.ts" />
/// <reference path="IRID.ts" />
/// <reference path="IColor.ts" />
var akra;
(function (akra) {
    

    

    

    

    

    (function (EShadingModel) {
        EShadingModel[EShadingModel["BLINNPHONG"] = 0] = "BLINNPHONG";
        EShadingModel[EShadingModel["PHONG"] = 1] = "PHONG";
        EShadingModel[EShadingModel["PBS_SIMPLE"] = 2] = "PBS_SIMPLE";
    })(akra.EShadingModel || (akra.EShadingModel = {}));
    var EShadingModel = akra.EShadingModel;
    ;
})(akra || (akra = {}));
/// <reference path="IViewport3D.ts" />
/// <reference path="IRID.ts" />
/// <reference path="IColor.ts" />
/// <reference path="ILightPoint.ts" />
/// <reference path="IShadowCaster.ts" />
/// <reference path="ITexture.ts" />
/// <reference path="IRenderTarget.ts" />
/// <reference path="ICamera.ts" />
/// <reference path="ILightPoint.ts" />
/// <reference path="ICamera.ts" />
/// <reference path="Viewport.ts" />
var akra;
(function (akra) {
    (function (render) {
        var ViewportWithTransparencyMode = (function (_super) {
            __extends(ViewportWithTransparencyMode, _super);
            function ViewportWithTransparencyMode() {
                _super.apply(this, arguments);
                this._bTransparencyMode = false;
            }
            ViewportWithTransparencyMode.prototype.setTransparencyMode = function (bValue) {
                this._bTransparencyMode = bValue;
            };

            ViewportWithTransparencyMode.prototype.renderAsNormal = function (csMethod, pCamera) {
                var pVisibleObjects = pCamera.display();
                var pRenderable;

                for (var i = 0; i < pVisibleObjects.getLength(); ++i) {
                    pVisibleObjects.value(i).prepareForRender(this);
                }

                for (var i = 0; i < pVisibleObjects.getLength(); ++i) {
                    var pSceneObject = pVisibleObjects.value(i);

                    for (var j = 0; j < pSceneObject.getTotalRenderable(); j++) {
                        pRenderable = pSceneObject.getRenderable(j);

                        if (!akra.isNull(pRenderable) && !akra.isNull(pRenderable.getRenderMethodByName(csMethod)) && (this._bTransparencyMode || !pRenderable.getRenderMethodByName(csMethod).getMaterial().isTransparent())) {
                            pRenderable.render(this, csMethod, pSceneObject);
                        }
                    }
                }
            };
            return ViewportWithTransparencyMode;
        })(render.Viewport);
        render.ViewportWithTransparencyMode = ViewportWithTransparencyMode;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="../idl/IViewport3D.ts" />
var akra;
(function (akra) {
    /// <reference path="Viewport.ts" />
    /// <reference path="../events.ts" />
    /// <reference path="../color/colors.ts" />
    /// <reference path="../bf/bf.ts" />
    /// <reference path="../config/config.ts" />
    /// <reference path="../math/math.ts" />
    /// <reference path="../debug.ts" />
    (function (render) {
        var Vec3 = akra.math.Vec3;
        var Vec4 = akra.math.Vec4;

        //3D events
        var DragstartSignal = (function (_super) {
            __extends(DragstartSignal, _super);
            function DragstartSignal() {
                _super.apply(this, arguments);
            }
            DragstartSignal.prototype.emit = function (eBtn, x, y) {
                var pViewport = this.getSender();
                pViewport._keepLastMousePosition(x, y);

                if (!pViewport.isUserEventSupported(64 /* DRAGSTART */)) {
                    return;
                }

                var p = pViewport._pick(x, y);

                pViewport._setUserEventDragTarget(p.object, p.renderable);

                if (akra.isNull(p.object) || (p.object.isUserEventSupported(64 /* DRAGSTART */))) {
                    p.object && p.object.dragstart.emit(pViewport, p.renderable, x, y);
                    p.renderable && p.renderable.dragstart.emit(pViewport, p.object, x, y);
                }

                _super.prototype.emit.call(this, eBtn, x, y);
            };
            return DragstartSignal;
        })(akra.Signal);

        var DragstopSignal = (function (_super) {
            __extends(DragstopSignal, _super);
            function DragstopSignal() {
                _super.apply(this, arguments);
            }
            DragstopSignal.prototype.emit = function (eBtn, x, y) {
                var pViewport = this.getSender();
                pViewport._keepLastMousePosition(x, y);

                if (!pViewport.isUserEventSupported(128 /* DRAGSTOP */)) {
                    return;
                }

                var p = pViewport._getUserEventDragTarget();

                if (akra.isNull(p.object) || (p.object.isUserEventSupported(128 /* DRAGSTOP */))) {
                    p.object && p.object.dragstop.emit(pViewport, p.renderable, x, y);
                    p.renderable && p.renderable.dragstop.emit(pViewport, p.object, x, y);
                }

                _super.prototype.emit.call(this, eBtn, x, y);
            };
            return DragstopSignal;
        })(akra.Signal);

        var DraggingSignal = (function (_super) {
            __extends(DraggingSignal, _super);
            function DraggingSignal() {
                _super.apply(this, arguments);
            }
            DraggingSignal.prototype.emit = function (eBtn, x, y, dx, dy) {
                var pViewport = this.getSender();

                pViewport._keepLastMousePosition(x, y);

                if (!pViewport.isUserEventSupported(256 /* DRAGGING */)) {
                    return;
                }

                var p = pViewport._getUserEventDragTarget();

                if (akra.isNull(p.object) || (p.object.isUserEventSupported(256 /* DRAGGING */))) {
                    p.object && p.object.dragging.emit(pViewport, p.renderable, x, y);
                    p.renderable && p.renderable.dragging.emit(pViewport, p.object, x, y);
                }

                _super.prototype.emit.call(this, eBtn, x, y, dx, dy);
            };
            return DraggingSignal;
        })(akra.Signal);

        var ClickSignal = (function (_super) {
            __extends(ClickSignal, _super);
            function ClickSignal() {
                _super.apply(this, arguments);
            }
            ClickSignal.prototype.emit = function (x, y) {
                var pViewport = this.getSender();

                pViewport._keepLastMousePosition(x, y);
                _super.prototype.emit.call(this, x, y);

                if (!pViewport.isUserEventSupported(1 /* CLICK */)) {
                    return;
                }

                var p = pViewport._pick(x, y);

                if (akra.isNull(p.object) || (p.object.isUserEventSupported(1 /* CLICK */))) {
                    p.object && p.object.click.emit(pViewport, p.renderable, x, y);
                    p.renderable && p.renderable.click.emit(pViewport, p.object, x, y);
                }
            };
            return ClickSignal;
        })(akra.Signal);

        var MousemoveSignal = (function (_super) {
            __extends(MousemoveSignal, _super);
            function MousemoveSignal() {
                _super.apply(this, arguments);
            }
            MousemoveSignal.prototype.emit = function (x, y) {
                var pViewport = this.getSender();

                pViewport._keepLastMousePosition(x, y);
                _super.prototype.emit.call(this, x, y);

                if (!pViewport.isUserEventSupported(2 /* MOUSEMOVE */)) {
                    return;
                }

                var p = pViewport._pick(x, y);

                if (akra.isNull(p.object) || (p.object.isUserEventSupported(2 /* MOUSEMOVE */))) {
                    p.object && p.object.mousemove.emit(pViewport, p.renderable, x, y);
                    p.renderable && p.renderable.mousemove.emit(pViewport, p.object, x, y);
                }
            };
            return MousemoveSignal;
        })(akra.Signal);

        var MousedownSignal = (function (_super) {
            __extends(MousedownSignal, _super);
            function MousedownSignal() {
                _super.apply(this, arguments);
            }
            MousedownSignal.prototype.emit = function (eBtn, x, y) {
                var pViewport = this.getSender();

                pViewport._keepLastMousePosition(x, y);
                _super.prototype.emit.call(this, eBtn, x, y);

                if (!pViewport.isUserEventSupported(4 /* MOUSEDOWN */)) {
                    return;
                }

                var p = pViewport._pick(x, y);

                if (akra.isNull(p.object) || (p.object.isUserEventSupported(4 /* MOUSEDOWN */))) {
                    p.object && p.object.mousedown.emit(pViewport, p.renderable, x, y);
                    p.renderable && p.renderable.mousedown.emit(pViewport, p.object, x, y);
                }
            };
            return MousedownSignal;
        })(akra.Signal);

        var MouseupSignal = (function (_super) {
            __extends(MouseupSignal, _super);
            function MouseupSignal() {
                _super.apply(this, arguments);
            }
            MouseupSignal.prototype.emit = function (eBtn, x, y) {
                var pViewport = this.getSender();
                pViewport._keepLastMousePosition(x, y);

                _super.prototype.emit.call(this, eBtn, x, y);

                if (!pViewport.isUserEventSupported(8 /* MOUSEUP */)) {
                    return;
                }

                var p = pViewport._pick(x, y);

                if (akra.isNull(p.object) || (p.object.isUserEventSupported(8 /* MOUSEUP */))) {
                    p.object && p.object.mouseup.emit(pViewport, p.renderable, x, y);
                    p.renderable && p.renderable.mouseup.emit(pViewport, p.object, x, y);
                }
            };
            return MouseupSignal;
        })(akra.Signal);

        var MouseoverSignal = (function (_super) {
            __extends(MouseoverSignal, _super);
            function MouseoverSignal() {
                _super.apply(this, arguments);
            }
            MouseoverSignal.prototype.emit = function (x, y) {
                var pViewport = this.getSender();

                pViewport._keepLastMousePosition(x, y);
                pViewport._setMouseCaptured(true);
                _super.prototype.emit.call(this, x, y);
            };
            return MouseoverSignal;
        })(akra.Signal);

        var MouseoutSignal = (function (_super) {
            __extends(MouseoutSignal, _super);
            function MouseoutSignal() {
                _super.apply(this, arguments);
            }
            MouseoutSignal.prototype.emit = function (x, y) {
                var pViewport = this.getSender();

                pViewport._keepLastMousePosition(x, y);
                pViewport._setMouseCaptured(false);

                //FIXME: do not create object this!
                pViewport._handleMouseInout(null, x, y);
                _super.prototype.emit.call(this, x, y);
            };
            return MouseoutSignal;
        })(akra.Signal);

        var MousewheelSignal = (function (_super) {
            __extends(MousewheelSignal, _super);
            function MousewheelSignal() {
                _super.apply(this, arguments);
            }
            MousewheelSignal.prototype.emit = function (x, y, fDelta) {
                var pViewport = this.getSender();

                pViewport._keepLastMousePosition(x, y);
                _super.prototype.emit.call(this, x, y, fDelta);

                if (!pViewport.isUserEventSupported(512 /* MOUSEWHEEL */)) {
                    return;
                }

                var p = pViewport._pick(x, y);

                if (akra.isNull(p.object) || (p.object.isUserEventSupported(512 /* MOUSEWHEEL */))) {
                    p.object && p.object.mousewheel.emit(pViewport, p.renderable, x, y, fDelta);
                    p.renderable && p.renderable.mousewheel.emit(pViewport, p.object, x, y, fDelta);
                }
            };
            return MousewheelSignal;
        })(akra.Signal);

        var Viewport3D = (function (_super) {
            __extends(Viewport3D, _super);
            function Viewport3D() {
                _super.apply(this, arguments);
                //get last mouse postion backend
                this._pMousePositionLast = { x: 0, y: 0 };
                //is mouse under the viewport?
                this._bMouseIsCaptured = false;
                //Specifies whether the object is perfect choice in a given frame
                this._b3DRequirePick = true;
                this._p3DEventPickLast = { object: null, renderable: null, x: -1, y: -1 };
                this._p3DEventPickPrev = { object: null, renderable: null, x: -1, y: -1 };
                this._p3DEventDragTarget = { object: null, renderable: null };
                this._b3DEventsSupport = true;
            }
            Viewport3D.prototype.setupSignals = function () {
                this.dragstart = this.dragstart || new DragstartSignal(this);
                this.dragstop = this.dragstop || new DragstopSignal(this);
                this.dragging = this.dragging || new DraggingSignal(this);

                this.click = this.click || new ClickSignal(this);
                this.mousemove = this.mousemove || new MousemoveSignal(this);

                this.mousedown = this.mousedown || new MousedownSignal(this);
                this.mouseup = this.mouseup || new MouseupSignal(this);

                this.mouseover = this.mouseover || new MouseoverSignal(this);
                this.mouseout = this.mouseout || new MouseoutSignal(this);
                this.mousewheel = this.mousewheel || new MousewheelSignal(this);

                _super.prototype.setupSignals.call(this);
            };

            /** @copydoc IViewport3D::getEffect() */
            Viewport3D.prototype.getEffect = function () {
                return null;
            };

            Viewport3D.prototype.update = function () {
                _super.prototype.update.call(this);

                //frame updated, pick required, if needed
                this._b3DRequirePick = true;
            };

            /** @copydoc IViewport3D::enable3DEvents() */
            Viewport3D.prototype.enable3DEvents = function (bEnable) {
                if (typeof bEnable === "undefined") { bEnable = true; }
                this._b3DEventsSupport = bEnable;
            };

            /** @copydoc IViewport3D::is3DEventsSupported() */
            Viewport3D.prototype.is3DEventsSupported = function () {
                return this._b3DEventsSupport;
            };

            /** @copydoc IViewport3D::touch() */
            Viewport3D.prototype.touch = function () {
                this._handleMouseInout(null, 0, 0);
            };

            /** @copydoc IViewport3D::pick() */
            Viewport3D.prototype.pick = function (x, y, pDest) {
                if (typeof pDest === "undefined") { pDest = { object: null, renderable: null, x: 0, y: 0 }; }
                akra.debug.log("pick();");
                var pComposer = this.getTarget().getRenderer().getEngine().getComposer();
                var iRid = this._getRenderId(x, y);
                var pObject = pComposer._getObjectByRid(iRid);
                var pRenderable = null;

                if (akra.isNull(pObject) || !pObject.isFrozen()) {
                    pRenderable = pComposer._getRenderableByRid(iRid);
                } else {
                    pObject = null;
                }

                pDest.renderable = pRenderable;
                pDest.object = pObject;
                pDest.x = x;
                pDest.y = y;

                return pDest;
            };

            /** @copydoc IViewport3D::getObject() */
            Viewport3D.prototype.getObject = function (x, y) {
                return this.pick(x, y, Viewport3D.PICK_CONTAINER).object;
            };

            /** @copydoc IViewport3D::getRenderable() */
            Viewport3D.prototype.getRenderable = function (x, y) {
                return this.pick(x, y, Viewport3D.PICK_CONTAINER).renderable;
            };

            Viewport3D.prototype._getDepthRangeImpl = function () {
                return { min: -1, max: 1 };
            };

            /** @copydoc IViewport3D::getDepth() */
            Viewport3D.prototype.getDepth = function (x, y) {
                return 1.0;
            };

            /** @copydoc IViewport3D::getDepthRange() */
            Viewport3D.prototype.getDepthRange = function () {
                if (!this._isDepthRangeUpdated) {
                    this._isDepthRangeUpdated = true;
                    var pDepthRange = this._getDepthRangeImpl();

                    this._pDepthRange.min = pDepthRange.min;
                    this._pDepthRange.max = pDepthRange.max;
                }

                return this._pDepthRange;
            };

            /** @copydoc IViewport3D::isMouseCaptured() */
            Viewport3D.prototype.isMouseCaptured = function () {
                return this._bMouseIsCaptured;
            };

            Viewport3D.prototype.projectPoint = function (v3fPoint, v3fDestination) {
                var pCamera = this.getCamera();
                var v3fResult = pCamera.projectPoint(v3fPoint, v3fDestination);

                if (akra.isNull(v3fResult)) {
                    return null;
                }

                var fX = v3fResult.x;
                var fY = v3fResult.y;
                var fZ = v3fResult.z;

                fX = fX * 0.5 + 0.5;
                fY = fY * 0.5 + 0.5;
                fZ = fZ * 0.5 + 0.5;

                //from top left angle of element
                fX = this.getActualLeft() + this.getActualWidth() * fX;
                fY = this.getActualTop() + this.getActualHeight() * fY;

                return v3fResult.set(fX, fY, fZ);
            };

            Viewport3D.prototype.unprojectPoint = function (a0, a1, a2) {
                var x, y;
                var v3fDestination;

                if (akra.isNumber(arguments[0])) {
                    x = akra.math.round(arguments[0]);
                    y = akra.math.round(arguments[1]);
                    v3fDestination = arguments[2];
                } else {
                    x = arguments[0].x;
                    y = arguments[0].y;
                    v3fDestination = arguments[1];
                }

                if (!akra.isDef(v3fDestination)) {
                    v3fDestination = new Vec3;
                }

                var pCamera = this.getCamera();
                var m4fProjection = pCamera.getProjectionMatrix();
                var m4fWorld = pCamera.getWorldMatrix();

                var v4fIn = Vec4.temp(), v4fOut = Vec4.temp();

                //Transformation of normalized coordinates between -1 and 1
                v4fIn.x = ((x - this.getActualLeft()) / this.getActualWidth() * 2.0 - 1.0);

                //Y-axis look down for viewport, but look UP in GL
                v4fIn.y = ((y - this.getActualTop()) / this.getActualHeight() * 2.0 - 1.0);
                v4fIn.z = 2.0 * this.getDepth(x, y) - 1.0;
                v4fIn.w = 1.0;

                v3fDestination.set(m4fWorld.multiplyVec4(m4fProjection.unproj(v4fIn, v4fOut)).clone("xyz"));
                return v3fDestination;
            };

            /** @return Cached pick result, limited - one pick per frame maximum. */
            Viewport3D.prototype._pick = function (x, y) {
                if (this.isPickResultRecalcNeeded()) {
                    //save last pick result
                    this._p3DEventPickPrev.renderable = this._p3DEventPickLast.renderable;
                    this._p3DEventPickPrev.object = this._p3DEventPickLast.object;
                    this._p3DEventPickPrev.x = this._p3DEventPickLast.x;
                    this._p3DEventPickPrev.y = this._p3DEventPickLast.y;

                    //save new pick result
                    this.pick(x, y, this._p3DEventPickLast);

                    this._b3DRequirePick = false;
                }

                return this._p3DEventPickLast;
            };

            /** @return Is pick required for current frame? */
            Viewport3D.prototype.isPickResultRecalcNeeded = function () {
                return this._b3DRequirePick && this._b3DEventsSupport;
            };

            //friends for RenderSignal.
            Viewport3D.prototype._handleMouseInout = function (pCurr, x, y) {
                var pPrev = this._p3DEventPickPrev;

                var pCurrObject = null;
                var pCurrRenderable = null;

                if (pCurr) {
                    pCurrObject = pCurr.object;
                    pCurrRenderable = pCurr.renderable;
                }

                if (pCurrObject !== pPrev.object) {
                    if (!akra.isNull(pPrev.object) && pPrev.object.isUserEventSupported(32 /* MOUSEOUT */)) {
                        pPrev.object.mouseout.emit(this, pPrev.renderable, x, y);
                    }

                    if (!akra.isNull(pCurrObject) && pCurrObject.isUserEventSupported(16 /* MOUSEOVER */)) {
                        pCurrObject.mouseover.emit(this, pCurrRenderable, x, y);
                    }
                }

                if (pCurrRenderable !== pPrev.renderable) {
                    if (!akra.isNull(pPrev.renderable) && (akra.isNull(pPrev.object) || pPrev.object.isUserEventSupported(32 /* MOUSEOUT */))) {
                        pPrev.renderable.mouseout.emit(this, pPrev.object, x, y);
                    }

                    if (!akra.isNull(pCurrRenderable) && (akra.isNull(pCurrObject) || pCurrObject.isUserEventSupported(32 /* MOUSEOUT */))) {
                        pCurrRenderable.mouseover.emit(this, pCurrObject, x, y);
                    }
                }

                return pCurr;
            };

            Viewport3D.prototype._keepLastMousePosition = function (x, y) {
                this._pMousePositionLast.x = x;
                this._pMousePositionLast.y = y;
            };

            Viewport3D.prototype._getLastMousePosition = function () {
                return this._pMousePositionLast;
            };

            Viewport3D.prototype._setUserEventDragTarget = function (pObject, pRenderable) {
                if (typeof pObject === "undefined") { pObject = null; }
                if (typeof pRenderable === "undefined") { pRenderable = null; }
                this._p3DEventDragTarget.object = pObject;
                this._p3DEventDragTarget.renderable = pRenderable;
            };

            Viewport3D.prototype._getUserEventDragTarget = function () {
                return this._p3DEventDragTarget;
            };

            Viewport3D.prototype._setMouseCaptured = function (bValue) {
                this._bMouseIsCaptured = bValue;
            };

            Viewport3D.prototype._getRenderId = function (x, y) {
                return 0;
            };

            Viewport3D.prototype._onRender = function (pTechnique, iPass, pRenderable, pSceneObject) {
                if (this.isMouseCaptured() && iPass === 0 && (this.isUserEventSupported(16 /* MOUSEOVER */) || this.isUserEventSupported(32 /* MOUSEOUT */))) {
                    //check, if the object are loss the mouse
                    var pPos = this._getLastMousePosition();
                    var x = pPos.x;
                    var y = pPos.y;

                    this._handleMouseInout(this._pick(x, y), x, y);
                }
            };

            Viewport3D.DraggingSignal = DraggingSignal;
            Viewport3D.DragstartSignal = DragstartSignal;
            Viewport3D.DragstopSignal = DragstopSignal;

            Viewport3D.MousedownSignal = MousedownSignal;
            Viewport3D.MouseupSignal = MouseupSignal;

            Viewport3D.MouseoverSignal = MouseoverSignal;
            Viewport3D.MouseoutSignal = MouseoutSignal;

            Viewport3D.MousewheelSignal = MousewheelSignal;
            Viewport3D.MousemoveSignal = MousemoveSignal;

            Viewport3D.ClickSignal = ClickSignal;

            Viewport3D.PICK_CONTAINER = { x: 0, y: 0, renderable: null, object: null };
            return Viewport3D;
        })(render.Viewport);
        render.Viewport3D = Viewport3D;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="ILightPoint.ts" />
/// <reference path="ICamera.ts" />
/// <reference path="ISceneModel.ts" />
/// <reference path="IVec3.ts" />
/// <reference path="../idl/ILightPoint.ts" />
/// <reference path="../idl/IShaderInput.ts" />
/// <reference path="../idl/IAFXSamplerState.ts" />
/// <reference path="../idl/IOmniLight.ts" />
/// <reference path="../idl/IProjectLight.ts" />
/// <reference path="../idl/ISunLight.ts" />
var akra;
(function (akra) {
    /// <reference path="../fx/PassInputBlend.ts" />
    (function (render) {
        

        var Vec3 = akra.math.Vec3;
        var Vec4 = akra.math.Vec4;
        var Mat4 = akra.math.Mat4;

        var LightData = (function () {
            function LightData() {
                this.DIFFUSE = new Vec4();
                this.AMBIENT = new Vec4();
                this.SPECULAR = new Vec4();
                this.POSITION = new Vec3();
                this.ATTENUATION = new Vec3();
            }
            LightData.prototype.set = function (pLightParam, v3fPosition) {
                this.DIFFUSE.set(pLightParam.diffuse);
                this.AMBIENT.set(pLightParam.ambient);
                this.SPECULAR.set(pLightParam.specular);
                this.ATTENUATION.set(pLightParam.attenuation);
                this.POSITION.set(v3fPosition);

                return this;
            };
            return LightData;
        })();
        render.LightData = LightData;

        var SunLightData = (function () {
            function SunLightData() {
                this.SUN_DIRECTION = new Vec3();
                this.EYE_POSITION = new Vec3();
                this.GROUNDC0 = new Vec3();
                this.GROUNDC1 = new Vec3();
                this.HG = new Vec3;
                this.SKY_DOME_ID = 0;
            }
            SunLightData.prototype.set = function (pSunParam, iSunDomeId) {
                this.SUN_DIRECTION.set(pSunParam.sunDir);
                this.EYE_POSITION.set(pSunParam.eyePosition);
                this.GROUNDC0.set(pSunParam.groundC0);
                this.GROUNDC1.set(pSunParam.groundC1);
                this.HG.set(pSunParam.hg);
                this.SKY_DOME_ID = iSunDomeId;

                return this;
            };
            return SunLightData;
        })();
        render.SunLightData = SunLightData;

        //////////////////////////////////////
        var UniformOmni = (function () {
            function UniformOmni() {
                this.LIGHT_DATA = new LightData();
            }
            UniformOmni.prototype.setLightData = function (pLightParam, v3fPosition) {
                this.LIGHT_DATA.set(pLightParam, v3fPosition);

                return this;
            };

            UniformOmni.temp = function () {
                UniformOmni._iElement = (UniformOmni._iElement === UniformOmni._pBuffer.length - 1 ? 0 : UniformOmni._iElement);
                var p = UniformOmni._pBuffer[UniformOmni._iElement++];
                return p;
            };
            UniformOmni._pBuffer = akra.gen.array(200, UniformOmni);
            UniformOmni._iElement = 0;
            return UniformOmni;
        })();
        render.UniformOmni = UniformOmni;

        //////////////////////////////////////
        var UniformProject = (function () {
            function UniformProject() {
                this.LIGHT_DATA = new LightData();
                this.SHADOW_MATRIX = new Mat4();
            }
            UniformProject.prototype.setLightData = function (pLightParam, v3fPosition) {
                this.LIGHT_DATA.set(pLightParam, v3fPosition);

                return this;
            };

            UniformProject.prototype.setMatrix = function (m4fMatrix) {
                this.SHADOW_MATRIX.set(m4fMatrix);
                return this;
            };

            UniformProject.temp = function () {
                UniformProject._iElement = (UniformProject._iElement === UniformProject._pBuffer.length - 1 ? 0 : UniformProject._iElement);
                var p = UniformProject._pBuffer[UniformProject._iElement++];
                return p;
            };
            UniformProject._pBuffer = akra.gen.array(200, UniformProject);
            UniformProject._iElement = 0;
            return UniformProject;
        })();
        render.UniformProject = UniformProject;

        //////////////////////////////////////
        var UniformProjectShadow = (function () {
            function UniformProjectShadow() {
                this.LIGHT_DATA = new LightData();
                this.TO_LIGHT_SPACE = new Mat4();
                this.REAL_PROJECTION_MATRIX = new Mat4();
                this.OPTIMIZED_PROJECTION_MATRIX = new Mat4();
                this.SHADOW_SAMPLER = render.createSamplerState();
            }
            UniformProjectShadow.prototype.setLightData = function (pLightParam, v3fPosition) {
                this.LIGHT_DATA.set(pLightParam, v3fPosition);
                return this;
            };

            UniformProjectShadow.prototype.setMatrix = function (m4fToLightSpace, m4fRealProj, m4fOptimizedProj) {
                this.TO_LIGHT_SPACE.set(m4fToLightSpace);
                this.REAL_PROJECTION_MATRIX.set(m4fRealProj);
                this.OPTIMIZED_PROJECTION_MATRIX.set(m4fOptimizedProj);

                return this;
            };

            UniformProjectShadow.prototype.setSampler = function (pTexture) {
                this.SHADOW_SAMPLER.texture = pTexture;
                return this;
            };

            UniformProjectShadow.temp = function () {
                UniformProjectShadow._iElement = (UniformProjectShadow._iElement === UniformProjectShadow._pBuffer.length - 1 ? 0 : UniformProjectShadow._iElement);
                var p = UniformProjectShadow._pBuffer[UniformProjectShadow._iElement++];
                return p;
            };
            UniformProjectShadow._pBuffer = akra.gen.array(20, UniformProjectShadow);
            UniformProjectShadow._iElement = 0;
            return UniformProjectShadow;
        })();
        render.UniformProjectShadow = UniformProjectShadow;

        //////////////////////////////////////
        var UniformOmniShadow = (function () {
            function UniformOmniShadow() {
                this.LIGHT_DATA = new LightData;
                this.TO_LIGHT_SPACE = [
                    new Mat4, new Mat4, new Mat4,
                    new Mat4, new Mat4, new Mat4
                ];
                this.OPTIMIZED_PROJECTION_MATRIX = [
                    new Mat4, new Mat4, new Mat4,
                    new Mat4, new Mat4, new Mat4
                ];
                this.SHADOW_SAMPLER = [
                    render.createSamplerState(), render.createSamplerState(), render.createSamplerState(),
                    render.createSamplerState(), render.createSamplerState(), render.createSamplerState()
                ];
            }
            UniformOmniShadow.prototype.setLightData = function (pLightParam, v3fPosition) {
                this.LIGHT_DATA.set(pLightParam, v3fPosition);
                return this;
            };

            UniformOmniShadow.prototype.setMatrix = function (m4fToLightSpace, m4fOptimizedProj, index) {
                this.TO_LIGHT_SPACE[index].set(m4fToLightSpace);
                this.OPTIMIZED_PROJECTION_MATRIX[index].set(m4fOptimizedProj);
                return this;
            };

            UniformOmniShadow.prototype.setSampler = function (pTexture, index) {
                this.SHADOW_SAMPLER[index].texture = pTexture;
                return this;
            };

            UniformOmniShadow.temp = function () {
                UniformOmniShadow._iElement = (UniformOmniShadow._iElement === UniformOmniShadow._pBuffer.length - 1 ? 0 : UniformOmniShadow._iElement);
                var p = UniformOmniShadow._pBuffer[UniformOmniShadow._iElement++];
                return p;
            };
            UniformOmniShadow._pBuffer = akra.gen.array(3, UniformOmniShadow);
            UniformOmniShadow._iElement = 0;
            return UniformOmniShadow;
        })();
        render.UniformOmniShadow = UniformOmniShadow;

        //////////////////////////////////////
        var UniformSun = (function () {
            function UniformSun() {
                this.LIGHT_DATA = new SunLightData();
            }
            UniformSun.prototype.setLightData = function (pSunParam, iSunDomeId) {
                this.LIGHT_DATA.set(pSunParam, iSunDomeId);
                return this;
            };

            UniformSun.temp = function () {
                UniformSun._iElement = (UniformSun._iElement === UniformSun._pBuffer.length - 1 ? 0 : UniformSun._iElement);
                var p = UniformSun._pBuffer[UniformSun._iElement++];
                return p;
            };
            UniformSun._pBuffer = akra.gen.array(3, UniformSun);
            UniformSun._iElement = 0;
            return UniformSun;
        })();
        render.UniformSun = UniformSun;

        //////////////////////////////////////
        var UniformSunShadow = (function () {
            function UniformSunShadow() {
                this.LIGHT_DATA = new SunLightData();
                this.SHADOW_SAMPLER = render.createSamplerState();
                this.TO_LIGHT_SPACE = new Mat4();
                this.OPTIMIZED_PROJECTION_MATRIX = new Mat4();
            }
            UniformSunShadow.prototype.setLightData = function (pSunParam, iSunDomeId) {
                this.LIGHT_DATA.set(pSunParam, iSunDomeId);

                return this;
            };

            UniformSunShadow.prototype.setSampler = function (pTexture) {
                this.SHADOW_SAMPLER.texture = pTexture;
                return this;
            };

            UniformSunShadow.prototype.setMatrix = function (m4fToLightSpace, m4fOptimizedProj) {
                this.TO_LIGHT_SPACE.set(m4fToLightSpace);
                this.OPTIMIZED_PROJECTION_MATRIX.set(m4fOptimizedProj);

                return this;
            };

            UniformSunShadow.temp = function () {
                UniformSunShadow._iElement = (UniformSunShadow._iElement === UniformSunShadow._pBuffer.length - 1 ? 0 : UniformSunShadow._iElement);
                var p = UniformSunShadow._pBuffer[UniformSunShadow._iElement++];
                return p;
            };
            UniformSunShadow._pBuffer = akra.gen.array(3, UniformSunShadow);
            UniformSunShadow._iElement = 0;
            return UniformSunShadow;
        })();
        render.UniformSunShadow = UniformSunShadow;

        var UniformOmniRestricted = (function (_super) {
            __extends(UniformOmniRestricted, _super);
            function UniformOmniRestricted() {
                _super.apply(this, arguments);
                this.POINT0 = new Vec3();
                this.POINT1 = new Vec3();
                this.TO_LIGHT_SPACE = new Mat4();
            }
            UniformOmniRestricted.prototype.setRestrictedData = function (pBound, m4fToLightSpace) {
                this.POINT0.set(pBound.x0, pBound.y0, pBound.z0);
                this.POINT1.set(pBound.x1, pBound.y1, pBound.z1);
                this.TO_LIGHT_SPACE.set(m4fToLightSpace);
            };

            UniformOmniRestricted.temp = function () {
                UniformOmniRestricted._iElementR = (UniformOmniRestricted._iElementR === UniformOmniRestricted._pBufferR.length - 1 ? 0 : UniformOmniRestricted._iElementR);
                var p = UniformOmniRestricted._pBufferR[UniformOmniRestricted._iElementR++];
                return p;
            };
            UniformOmniRestricted._pBufferR = akra.gen.array(200, UniformOmniRestricted);
            UniformOmniRestricted._iElementR = 0;
            return UniformOmniRestricted;
        })(UniformOmni);
        render.UniformOmniRestricted = UniformOmniRestricted;

        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="../idl/IViewport3D.ts" />
var akra;
(function (akra) {
    /// <reference path="Viewport3D.ts" />
    /// <reference path="LightingUniforms.ts" />
    (function (render) {
        var Vec3 = akra.math.Vec3;
        var Vec4 = akra.math.Vec4;
        var Mat4 = akra.math.Mat4;

        var ShadedViewport = (function (_super) {
            __extends(ShadedViewport, _super);
            function ShadedViewport() {
                _super.apply(this, arguments);
                this._pLightingUnifoms = {
                    omni: [],
                    project: [],
                    sun: [],
                    omniShadows: [],
                    projectShadows: [],
                    sunShadows: [],
                    textures: [],
                    samplersOmni: [],
                    samplersProject: [],
                    samplersSun: [],
                    omniRestricted: []
                };
                this._pLightPoints = null;
                this._pTextureForTransparentObjects = null;
                this._eShadingModel = 1 /* PHONG */;
                this._pDefaultEnvMap = null;
                this._isTransparencySupported = true;
                this._isShadowEnabled = true;
                this._bManualUpdateForLightUniforms = false;
                this._pDepthBufferTexture = null;
            }
            ShadedViewport.prototype.getDepthTexture = function () {
                return this._pDepthBufferTexture;
            };

            ShadedViewport.prototype.setDepthTexture = function (pTexture) {
                this._pDepthBufferTexture = pTexture;
            };

            ShadedViewport.prototype.getLightSources = function () {
                return this._pLightPoints;
            };

            ShadedViewport.prototype.setShadingModel = function (eModel) {
                this._eShadingModel = eModel;
            };

            ShadedViewport.prototype.getShadingModel = function () {
                return this._eShadingModel;
            };

            ShadedViewport.prototype.setDefaultEnvironmentMap = function (pEnvMap) {
                this._pDefaultEnvMap = pEnvMap;
            };

            ShadedViewport.prototype.getDefaultEnvironmentMap = function () {
                return this._pDefaultEnvMap;
            };

            ShadedViewport.prototype.setTransparencySupported = function (bEnable) {
                this._isTransparencySupported = bEnable;
            };

            ShadedViewport.prototype.isTransparencySupported = function () {
                return this._isTransparencySupported;
            };

            ShadedViewport.prototype.setShadowEnabled = function (bValue) {
                this._isShadowEnabled = bValue;
            };

            ShadedViewport.prototype.isShadowEnabled = function () {
                return this._isShadowEnabled;
            };

            ShadedViewport.prototype._setLightUniformsManual = function (bValue, pUniformsMap) {
                this._bManualUpdateForLightUniforms = bValue;

                if (bValue && akra.isDefAndNotNull(pUniformsMap)) {
                    this._pLightingUnifoms = pUniformsMap;
                } else if (!bValue) {
                    this._pLightingUnifoms = {
                        omni: [],
                        project: [],
                        sun: [],
                        omniShadows: [],
                        projectShadows: [],
                        sunShadows: [],
                        textures: [],
                        samplersOmni: [],
                        samplersProject: [],
                        samplersSun: [],
                        omniRestricted: []
                    };
                }
            };

            ShadedViewport.prototype._getTransparencyViewport = function () {
                return null;
            };

            ShadedViewport.prototype._isManualUpdateForLightUniforms = function () {
                return this._bManualUpdateForLightUniforms;
            };

            ShadedViewport.prototype.createLightingUniforms = function (pCamera, pLightPoints, pUniforms) {
                if (this._bManualUpdateForLightUniforms) {
                    return;
                }

                var pLight;
                var pOmniLight;
                var pProjectLight;
                var pSunLight;
                var i, j;
                var pUniformData;
                var pCameraView = pCamera.getViewMatrix();

                var v4fLightPosition = Vec4.temp();
                var v3fLightTransformPosition = Vec3.temp();
                var v4fTemp = Vec4.temp();

                var pShadowCaster;
                var m4fShadow, m4fToLightSpace;

                var iLastTextureIndex = 0;

                //var sTexture: string = "TEXTURE";
                var pEngine = this.getTarget().getRenderer().getEngine();

                this.resetUniforms();

                for (i = 0; i < pLightPoints.getLength(); i++) {
                    pLight = pLightPoints.value(i);

                    //all cameras in list already enabled
                    // if (!pLight.enabled) {
                    //     continue;
                    // }
                    v4fLightPosition.set(pLight.getWorldPosition(), 1.);
                    pCameraView.multiplyVec4(v4fLightPosition, v4fTemp);
                    v3fLightTransformPosition.set(v4fTemp.x, v4fTemp.y, v4fTemp.z);

                    if (pLight.getLightType() === 2 /* OMNI */) {
                        pOmniLight = pLight;

                        if (this.isShadowEnabled() && pLight.isShadowCaster()) {
                            pUniformData = render.UniformOmniShadow.temp();
                            pUniformData.setLightData(pLight.getParams(), v3fLightTransformPosition);

                            var pDepthCube = pOmniLight.getDepthTextureCube();
                            var pShadowCasterCube = pOmniLight.getShadowCaster();

                            for (j = 0; j < 6; ++j) {
                                pShadowCaster = pShadowCasterCube[j];
                                m4fToLightSpace = pShadowCaster.getViewMatrix().multiply(pCamera.getWorldMatrix(), Mat4.temp());
                                pUniforms.textures.push(pDepthCube[j]);

                                //sTexture = "TEXTURE" + (pUniforms.textures.length - 1);
                                pUniformData.setSampler(pDepthCube[j], j);
                                pUniforms.samplersOmni.push(pUniformData.SHADOW_SAMPLER[j]);
                                pUniformData.setMatrix(m4fToLightSpace, pShadowCaster.getOptimizedProjection(), j);
                            }

                            pUniforms.omniShadows.push(pUniformData);
                        } else {
                            if (pLight.isRestricted()) {
                                pUniformData = render.UniformOmniRestricted.temp();
                                pUniformData.setLightData(pLight.getParams(), v3fLightTransformPosition);

                                m4fToLightSpace = pLight.getInverseWorldMatrix().multiply(pCamera.getWorldMatrix(), Mat4.temp());
                                pUniformData.setRestrictedData(pLight.getRestrictedLocalBounds(), m4fToLightSpace);
                                pUniforms.omniRestricted.push(pUniformData);
                            } else {
                                pUniformData = render.UniformOmni.temp();
                                pUniformData.setLightData(pLight.getParams(), v3fLightTransformPosition);
                                pUniforms.omni.push(pUniformData);
                            }
                        }
                    } else if (pLight.getLightType() === 1 /* PROJECT */) {
                        pProjectLight = pLight;
                        pShadowCaster = pProjectLight.getShadowCaster();

                        if (this.isShadowEnabled() && pLight.isShadowCaster() && pShadowCaster.isShadowCasted()) {
                            pUniformData = render.UniformProjectShadow.temp();
                            pUniformData.setLightData(pLight.getParams(), v3fLightTransformPosition);

                            m4fToLightSpace = pShadowCaster.getViewMatrix().multiply(pCamera.getWorldMatrix(), Mat4.temp());
                            pUniforms.textures.push(pProjectLight.getDepthTexture());

                            //sTexture = "TEXTURE" + (pUniforms.textures.length - 1);
                            pUniformData.setSampler(pProjectLight.getDepthTexture());
                            pUniforms.samplersProject.push(pUniformData.SHADOW_SAMPLER);
                            pUniformData.setMatrix(m4fToLightSpace, pShadowCaster.getProjectionMatrix(), pShadowCaster.getOptimizedProjection());
                            pUniforms.projectShadows.push(pUniformData);
                        } else {
                            pUniformData = render.UniformProject.temp();
                            pUniformData.setLightData(pLight.getParams(), v3fLightTransformPosition);
                            m4fShadow = pShadowCaster.getProjViewMatrix().multiply(pCamera.getWorldMatrix(), Mat4.temp());
                            pUniformData.setMatrix(m4fShadow);
                            pUniforms.project.push(pUniformData);
                        }
                    } else if (pLight.getLightType() === 3 /* SUN */) {
                        pSunLight = pLight;
                        pShadowCaster = pSunLight.getShadowCaster();

                        if (this.isShadowEnabled() && pLight.isShadowCaster()) {
                            pUniformData = render.UniformSunShadow.temp();
                            var pSkyDome = pSunLight.getSkyDome();
                            var iSkyDomeId = pEngine.getComposer()._calcRenderID(pSkyDome, pSkyDome.getRenderable(0), false);
                            pUniformData.setLightData(pLight.getParams(), iSkyDomeId);
                            pUniforms.sunShadows.push(pUniformData);

                            pUniforms.textures.push(pSunLight.getDepthTexture());

                            //sTexture = "TEXTURE" + (pUniforms.textures.length - 1);
                            pUniformData.setSampler(pSunLight.getDepthTexture());
                            pUniforms.samplersSun.push(pUniformData.SHADOW_SAMPLER);

                            m4fToLightSpace = pShadowCaster.getViewMatrix().multiply(pCamera.getWorldMatrix(), Mat4.temp());
                            pUniformData.setMatrix(m4fToLightSpace, pShadowCaster.getOptimizedProjection());
                        } else {
                            pUniformData = render.UniformSun.temp();
                            var pSkyDome = pSunLight.getSkyDome();
                            var iSkyDomeId = pEngine.getComposer()._calcRenderID(pSkyDome, pSkyDome.getRenderable(0), false);
                            pUniformData.setLightData(pLight.getParams(), iSkyDomeId);
                            pUniforms.sun.push(pUniformData);
                        }
                    } else {
                        akra.logger.critical("Invalid light point type detected.");
                    }
                }
            };

            ShadedViewport.prototype.resetUniforms = function () {
                var pUniforms = this._pLightingUnifoms;
                pUniforms.omni.clear();
                pUniforms.project.clear();
                pUniforms.sun.clear();
                pUniforms.omniShadows.clear();
                pUniforms.projectShadows.clear();
                pUniforms.sunShadows.clear();
                pUniforms.textures.clear();
                pUniforms.samplersProject.clear();
                pUniforms.samplersOmni.clear();
                pUniforms.samplersSun.clear();

                pUniforms.omniRestricted.clear();
            };

            ShadedViewport.prototype.initTextureForTransparentObjects = function () {
                var pResMgr = this.getTarget().getRenderer().getEngine().getResourceManager();
                var pTexture = pResMgr.createTexture("lpp-trasparency-texture-" + this.guid);
                var pDepthTexture = this.getDepthTexture();

                pTexture.create(pDepthTexture.getWidth(), pDepthTexture.getHeight(), 1, null, 512 /* RENDERTARGET */, 0, 0, 3553 /* TEXTURE_2D */, 28 /* R8G8B8A8 */);

                var pRenderTarget = pTexture.getBuffer().getRenderTarget();
                pRenderTarget.attachDepthTexture(pDepthTexture);

                pRenderTarget.setAutoUpdated(false);

                var pViewport = new render.ForwardViewport(this.getCamera(), 0, 0, this.getActualWidth() / pDepthTexture.getWidth(), this.getActualHeight() / pDepthTexture.getHeight());
                pViewport._renderOnlyTransparentObjects(true);
                pRenderTarget.addViewport(pViewport);

                pViewport.setClearEveryFrame(true, 1 /* COLOR */);
                pViewport.setBackgroundColor(new akra.color.Color(0, 0, 0, 0));

                this._pTextureForTransparentObjects = pTexture;
                pViewport.setShadingModel(this.getShadingModel());
                pViewport.setDefaultEnvironmentMap(this.getDefaultEnvironmentMap());

                pViewport._setLightUniformsManual(true, this._pLightingUnifoms);
            };
            return ShadedViewport;
        })(render.Viewport3D);
        render.ShadedViewport = ShadedViewport;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="../idl/IVertexDeclaration.ts" />
/// <reference path="../limit.ts" />
/// <reference path="../types.ts" />
/// <reference path="Usage.ts" />
/// <reference path="VertexElement.ts" />
/// <reference path="../logger.ts" />
/// <reference path="../config/config.ts" />
var akra;
(function (akra) {
    (function (data) {
        var VertexDeclaration = (function () {
            function VertexDeclaration(pElements) {
                ///** readonly */ property for public usage
                this.stride = 0;
                this._pElements = [];
                if (arguments.length > 0 && akra.isDefAndNotNull(pElements)) {
                    this.append.apply(this, arguments);
                }
            }
            VertexDeclaration.prototype.getLength = function () {
                return this._pElements.length;
            };

            VertexDeclaration.prototype.element = function (i) {
                return this._pElements[i] || null;
            };

            VertexDeclaration.prototype.append = function (pData) {
                var pElements;

                if (!akra.isArray(arguments[0])) {
                    pElements = arguments;
                } else {
                    pElements = arguments[0];
                }

                for (var i = 0; i < pElements.length; i++) {
                    var pElement = pElements[i];
                    var iOffset;

                    if (data.VertexElement.hasUnknownOffset(pElement)) {
                        //add element to end
                        iOffset = this.stride;
                    } else {
                        iOffset = pElement.offset;
                    }

                    var pVertexElement = new data.VertexElement(pElement.count, pElement.type, pElement.usage, iOffset);

                    this._pElements.push(pVertexElement);

                    var iStride = iOffset + pVertexElement.size;

                    if (this.stride < iStride) {
                        this.stride = iStride;
                    }
                }

                return this._update();
            };

            VertexDeclaration.prototype._update = function () {
                var iStride;

                for (var i = 0; i < this.getLength(); ++i) {
                    //move "END" element to end of declaration
                    if (this._pElements[i].usage === data.Usages.END) {
                        this._pElements.swap(i, i + 1);
                    }

                    //recalc total stride
                    iStride = this._pElements[i].size + this._pElements[i].offset;

                    if (this.stride < iStride) {
                        this.stride = iStride;
                    }
                }

                var pLast = this._pElements.last;

                if (pLast.usage === data.Usages.END && pLast.offset < this.stride) {
                    pLast.offset = this.stride;
                }

                return true;
            };

            VertexDeclaration.prototype.extend = function (decl) {
                var pDecl = decl;
                var pElement;

                for (var i = 0; i < this.getLength(); ++i) {
                    for (var j = 0; j < pDecl.getLength(); ++j) {
                        if (pDecl.element(j).usage == this._pElements[i].usage) {
                            akra.logger.log('inconsistent declarations:', this, pDecl);

                            //'The attempt to combine the declaration containing the exact same semantics.'
                            return false;
                        }
                    }
                }

                for (var i = 0; i < pDecl.getLength(); i++) {
                    pElement = pDecl.element(i).clone();
                    pElement.offset += this.stride;
                    this._pElements.push(pElement);
                }

                return this._update();
            };

            VertexDeclaration.prototype.hasSemantics = function (sSemantics) {
                return this.findElement(sSemantics) !== null;
            };

            VertexDeclaration.prototype.findElement = function (sSemantics, iCount) {
                if (typeof iCount === "undefined") { iCount = akra.MAX_INT32; }
                sSemantics = sSemantics.toUpperCase();

                for (var i = 0; i < this.getLength(); ++i) {
                    if (this._pElements[i].usage === sSemantics && (iCount === akra.MAX_INT32 || this._pElements[i].count == iCount)) {
                        return this._pElements[i];
                    }
                }

                return null;
            };

            VertexDeclaration.prototype.clone = function () {
                var pElements = [];
                var pDecl;

                for (var i = 0; i < this.getLength(); ++i) {
                    pElements.push(this._pElements[i].clone());
                }

                pDecl = new VertexDeclaration(pElements);

                if (pDecl._update()) {
                    return pDecl;
                }

                return null;
            };

            VertexDeclaration.prototype.toString = function () {
                if (akra.config.DEBUG) {
                    var s = "\n";

                    s += "  VERTEX DECLARATION ( " + this.stride + " b. ) \n";
                    s += "---------------------------------------\n";

                    for (var i = 0; i < this.getLength(); ++i) {
                        s += this._pElements[i].toString() + '\n';
                    }

                    return s;
                }

                return null;
            };

            VertexDeclaration.normalize = function (pData) {
                if (akra.isNull(pData)) {
                    return null;
                }

                if (!(pData instanceof VertexDeclaration)) {
                    if (!Array.isArray(pData) && akra.isDefAndNotNull(pData)) {
                        pData = [pData];
                    }

                    pData = new VertexDeclaration(pData);
                }

                return pData;
            };
            return VertexDeclaration;
        })();
        data.VertexDeclaration = VertexDeclaration;
    })(akra.data || (akra.data = {}));
    var data = akra.data;
})(akra || (akra = {}));
/// <reference path="RenderableObject.ts" />
/// <reference path="../data/VertexDeclaration.ts" />
var akra;
(function (akra) {
    (function (render) {
        var VE = akra.data.VertexElement;
        var DeclUsages = akra.data.Usages;

        var Screen = (function (_super) {
            __extends(Screen, _super);
            function Screen(pRenderer, pCollection) {
                _super.call(this, 2 /* SCREEN */);

                if (!akra.isDefAndNotNull(pCollection)) {
                    pCollection = pRenderer.getEngine().createRenderDataCollection(0);
                }

                var pData = pCollection.getEmptyRenderData(5 /* TRIANGLESTRIP */);

                pData.allocateAttribute(akra.data.VertexDeclaration.normalize([VE.float2(DeclUsages.POSITION)]), new Float32Array([-1, -1, -1, 1, 1, -1, 1, 1]));

                this._pRenderData = pData;
                this._setup(pRenderer);
            }
            return Screen;
        })(render.RenderableObject);
        render.Screen = Screen;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
// IRenderTexture export interface
// [write description here...]
/// <reference path="IRenderTarget.ts" />
/// <reference path="IPixelBox.ts" />
/// <reference path="../../idl/IHardwareBuffer.ts" />
var akra;
(function (akra) {
    (function (pool) {
        /// <reference path="../../bf/bf.ts" />
        /// <reference path="../../logger.ts" />
        /// <reference path="../../debug.ts" />
        /// <reference path="../ResourcePoolItem.ts" />
        (function (resources) {
            var HardwareBuffer = (function (_super) {
                __extends(HardwareBuffer, _super);
                // byteLength: uint = 0;
                // length: uint = 0;
                function HardwareBuffer() {
                    _super.call(this);
                    this._iFlags = 0;
                    this._isLocked = false;
                    this._pBackupCopy = null;
                    this._pBackupUpdated = false;
                    this._bIgnoreHardwareUpdate = false;
                }
                HardwareBuffer.prototype.getByteLength = function () {
                    return 0;
                };

                HardwareBuffer.prototype.getLength = function () {
                    return 0;
                };

                HardwareBuffer.prototype.isValid = function () {
                    return false;
                };

                HardwareBuffer.prototype.isDynamic = function () {
                    return akra.bf.testAny(this._iFlags, 2 /* DYNAMIC */);
                };

                HardwareBuffer.prototype.isStatic = function () {
                    return akra.bf.testAny(this._iFlags, 1 /* STATIC */);
                };

                HardwareBuffer.prototype.isStream = function () {
                    return akra.bf.testAny(this._iFlags, 128 /* STREAM */);
                };

                HardwareBuffer.prototype.isReadable = function () {
                    return akra.bf.testAny(this._iFlags, 4 /* READABLE */);
                };

                HardwareBuffer.prototype.isBackupPresent = function () {
                    return this._pBackupCopy != null;
                };

                HardwareBuffer.prototype.isSoftware = function () {
                    return akra.bf.testAny(this._iFlags, 16 /* SOFTWARE */);
                };

                HardwareBuffer.prototype.isAligned = function () {
                    return akra.bf.testAny(this._iFlags, 32 /* ALIGNMENT */);
                };

                HardwareBuffer.prototype.isLocked = function () {
                    return this._isLocked;
                };

                HardwareBuffer.prototype.clone = function (pSrc) {
                    return false;
                };

                HardwareBuffer.prototype.getFlags = function () {
                    return this._iFlags;
                };

                HardwareBuffer.prototype.readData = function (iOffset, iSize, ppDest) {
                    return false;
                };

                HardwareBuffer.prototype.writeData = function (pData, iOffset, iSize, bDiscardWholeBuffer) {
                    if (typeof bDiscardWholeBuffer === "undefined") { bDiscardWholeBuffer = false; }
                    return false;
                };

                HardwareBuffer.prototype.copyData = function (pSrcBuffer, iSrcOffset, iDstOffset, iSize, bDiscardWholeBuffer) {
                    if (typeof bDiscardWholeBuffer === "undefined") { bDiscardWholeBuffer = false; }
                    var pData = pSrcBuffer.lock(iSrcOffset, iSize);
                    this.writeData(pData, iDstOffset, iSize, bDiscardWholeBuffer);
                    pSrcBuffer.unlock();
                    return true;
                };

                HardwareBuffer.prototype.create = function (iSize, iFlags) {
                    if (typeof iFlags === "undefined") { iFlags = 0; }
                    iFlags |= 1 /* STATIC */;

                    if (akra.bf.testAny(iFlags, 2 /* DYNAMIC */)) {
                        iFlags = akra.bf.clearAll(iFlags, 1 /* STATIC */);

                        if (akra.bf.testAny(iFlags, 8 /* BACKUP_COPY */)) {
                            iFlags = akra.bf.clearAll(iFlags, 4 /* READABLE */);
                        }
                    }

                    this._iFlags = iFlags;

                    this.notifyCreated();
                    this.notifyRestored();

                    return true;
                };

                HardwareBuffer.prototype.destroy = function () {
                    this._iFlags = 0;
                    this.notifyDestroyed();
                    this.notifyUnloaded();
                };

                HardwareBuffer.prototype.resize = function (iSize) {
                    return false;
                };

                HardwareBuffer.prototype.lock = function () {
                    akra.logger.assert(!this.isLocked(), "Cannot lock this buffer, it is already locked!");

                    var iOffset = 0, iSize = 0, iLockFlags = 0;

                    if (arguments.length == 1) {
                        iLockFlags = arguments[0];
                        iOffset = 0;
                        iSize = this.getByteLength();
                    } else {
                        iOffset = arguments[0];
                        iSize = arguments[1];
                        iLockFlags = (arguments.length === 3) ? arguments[2] : 4 /* READABLE */;
                    }

                    var pResult = null;

                    if ((iOffset + iSize) > this.getByteLength()) {
                        akra.logger.error("Lock request out of bounds.", "HardwareBuffer::lock");
                    } else if (this.isBackupPresent()) {
                        if (!akra.bf.testAny(iLockFlags, 2 /* WRITE */)) {
                            // we have to assume a read / write lock so we use the shadow buffer
                            // and tag for sync on unlock()
                            this._pBackupUpdated = true;
                        }

                        pResult = this._pBackupCopy.lock(iOffset, iSize, iLockFlags);
                    } else {
                        // Lock the real buffer if there is no shadow buffer
                        pResult = this.lockImpl(iOffset, iSize, iLockFlags);
                        this._isLocked = true;
                    }

                    this._iLockStart = iOffset;
                    this._iLockSize = iSize;

                    return pResult;
                };

                HardwareBuffer.prototype.unlock = function () {
                    akra.logger.assert(this.isLocked(), "Cannot unlock this buffer, it is not locked!");

                    // If we used the shadow buffer this time...
                    if (this._pBackupCopy && this._pBackupCopy.isLocked()) {
                        this._pBackupCopy.unlock();

                        // Potentially update the 'real' buffer from the shadow buffer
                        this.restoreFromBackup();
                    } else {
                        // Otherwise, unlock the real one
                        this.unlockImpl();
                        this._isLocked = false;
                    }
                };

                HardwareBuffer.prototype.restoreFromBackup = function () {
                    if (this._pBackupCopy && this._pBackupUpdated && !this._bIgnoreHardwareUpdate) {
                        // Do this manually to avoid locking problems
                        var pBackupData = this._pBackupCopy.lockImpl(this._iLockStart, this._iLockSize, 1 /* READ */);

                        // Lock with discard if the whole buffer was locked, otherwise normal
                        var iLockFlags;

                        if (this._iLockStart == 0 && this._iLockSize == this.getByteLength()) {
                            iLockFlags = 4 /* DISCARD */;
                        } else {
                            iLockFlags = 3 /* NORMAL */;
                        }

                        var pRealData = this.lockImpl(this._iLockStart, this._iLockSize, iLockFlags);

                        // Copy backup to real
                        this.copyBackupToRealImpl(pRealData, pBackupData, iLockFlags);

                        this.unlockImpl();
                        this._pBackupCopy.unlockImpl();
                        this._pBackupUpdated = false;

                        return true;
                    }

                    return false;
                };

                HardwareBuffer.prototype.createResource = function () {
                    // innitialize the resource (called once)
                    akra.debug.assert(!this.isResourceCreated(), "The resource has already been created.");

                    // signal that the resource is now created,
                    // but has not been enabled
                    //this.notifyCreated();
                    this.notifyDisabled();

                    return true;
                };

                HardwareBuffer.prototype.destroyResource = function () {
                    // destroy the resource
                    //
                    // we permit redundant calls to destroy, so there are no asserts here
                    //
                    if (this.isResourceCreated()) {
                        // disable the resource
                        this.disableResource();
                        this.destroy();
                        return true;
                    }

                    return false;
                };

                HardwareBuffer.prototype.restoreResource = function () {
                    akra.debug.assert(this.isResourceCreated(), "The resource has not been created.");

                    this.notifyRestored();
                    return true;
                };

                HardwareBuffer.prototype.disableResource = function () {
                    akra.debug.assert(this.isResourceCreated(), "The resource has not been created.");

                    this.notifyDisabled();
                    return true;
                };

                HardwareBuffer.prototype.lockImpl = function (iOffset, iSize, iLockFlags) {
                    return null;
                };

                HardwareBuffer.prototype.unlockImpl = function () {
                };

                HardwareBuffer.prototype.copyBackupToRealImpl = function (pRealData, pBackupData, iLockFlags) {
                };
                return HardwareBuffer;
            })(pool.ResourcePoolItem);
            resources.HardwareBuffer = HardwareBuffer;
        })(pool.resources || (pool.resources = {}));
        var resources = pool.resources;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="../idl/IPixelBuffer.ts" />
var akra;
(function (akra) {
    /// <reference path="../pool/resources/HardwareBuffer.ts" />
    /// <reference path="../geometry/Box.ts" />
    /// <reference path="../pixelUtil/PixelBox.ts" />
    /// <reference path="webgl.ts" />
    (function (webgl) {
        var WebGLPixelBuffer = (function (_super) {
            __extends(WebGLPixelBuffer, _super);
            function WebGLPixelBuffer() {
                _super.call(this);
                this._iWidth = 0;
                this._iHeight = 0;
                this._iDepth = 0;
                // Pitches (offsets between rows and slices)
                this._iRowPitch = 0;
                this._iSlicePitch = 0;
                this._eFormat = 0 /* UNKNOWN */;
                //webgl specific
                this._pCurrentLock = null;
                this._pLockedBox = null;
                this._iCurrentLockFlags = 0;
                this._pBuffer = null;
                this._iWebGLInternalFormat = 0;
            }
            WebGLPixelBuffer.prototype.getByteLength = function () {
                return this._iByteSize;
            };

            WebGLPixelBuffer.prototype.getWidth = function () {
                return this._iWidth;
            };

            WebGLPixelBuffer.prototype.getHeight = function () {
                return this._iHeight;
            };

            WebGLPixelBuffer.prototype.getDepth = function () {
                return this._iDepth;
            };

            WebGLPixelBuffer.prototype.getFormat = function () {
                return this._eFormat;
            };

            //upload(download) data to(from) videocard.
            WebGLPixelBuffer.prototype.upload = function (pData, pDestBox) {
                akra.logger.critical("Upload not possible for this pixelbuffer type");
            };

            WebGLPixelBuffer.prototype.download = function (pData) {
                akra.logger.critical("Download not possible for this pixelbuffer type");
            };

            WebGLPixelBuffer.prototype._bindToFramebuffer = function (pAttachment, iZOffset) {
                akra.logger.critical("Framebuffer bind not possible for this pixelbuffer type");
            };

            WebGLPixelBuffer.prototype._getWebGLFormat = function () {
                return this._iWebGLInternalFormat;
            };

            WebGLPixelBuffer.prototype._clearRTT = function (iZOffset) {
            };

            WebGLPixelBuffer.prototype.reset = function (iWidth, iHeight) {
                if (typeof iWidth === "undefined") { iWidth = this._iWidth; }
                if (typeof iHeight === "undefined") { iHeight = iWidth; }
                this._iWidth = iWidth;
                this._iHeight = iHeight;
            };

            WebGLPixelBuffer.prototype.create = function () {
                if (arguments.length === 1) {
                    akra.logger.critical("Invalid number of arguments. For PixelBuffer it must be six");
                }
                var iWidth = arguments[0];
                var iHeight = arguments[1];
                var iDepth = arguments[2];
                var eFormat = arguments[3];
                var iFlags = arguments[4];

                _super.prototype.create.call(this, iFlags);

                this._iWidth = iWidth;
                this._iHeight = iHeight;
                this._iDepth = iDepth;
                this._eFormat = eFormat;

                this._iRowPitch = iWidth;
                this._iSlicePitch = iHeight * iWidth;
                this._iByteSize = iHeight * iWidth * akra.pixelUtil.getNumElemBytes(eFormat);

                this._pBuffer = new akra.pixelUtil.PixelBox(iWidth, iHeight, iDepth, eFormat);
                this._iWebGLInternalFormat = 0 /* NONE */;

                return true;
            };

            WebGLPixelBuffer.prototype.destroy = function () {
                this._pBuffer = null;

                _super.prototype.destroy.call(this);
            };

            WebGLPixelBuffer.prototype.destroyResource = function () {
                this.destroy();
                this.notifyDestroyed();
                return true;
            };

            WebGLPixelBuffer.prototype.readData = function () {
                akra.logger.critical("Reading a byte range is not implemented. Use blitToMemory.");
                return false;
            };

            WebGLPixelBuffer.prototype.writeData = function () {
                akra.logger.critical("Writing a byte range is not implemented. Use blitFromMemory.");
                return false;
            };

            WebGLPixelBuffer.prototype.readPixels = function (pDestBox) {
                this.download(pDestBox);
                return true;
            };

            WebGLPixelBuffer.prototype.blit = function (pSource, pSrcBox, pDestBox) {
                if (arguments.length == 1) {
                    return this.blit(pSource, new akra.geometry.Box(0, 0, 0, pSource.getWidth(), pSource.getHeight(), pSource.getDepth()), new akra.geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth));
                } else {
                    if (pSource === this) {
                        akra.logger.critical("Source must not be the same object");
                    }

                    var pSrclock = pSource.lock(pSrcBox, 1 /* READ */);

                    var eLockMethod = 3 /* NORMAL */;
                    if (pDestBox.left === 0 && pDestBox.top === 0 && pDestBox.front === 0 && pDestBox.right === this._iWidth && pDestBox.bottom === this._iHeight && pDestBox.back === this._iDepth) {
                        // Entire buffer -- we can discard the previous contents
                        eLockMethod = 4 /* DISCARD */;
                    }

                    var pDstlock = this.lock(pDestBox, eLockMethod);

                    if (pDstlock.getWidth() != pSrclock.getWidth() || pDstlock.getHeight() != pSrclock.getHeight() || pDstlock.getDepth() != pSrclock.getDepth()) {
                        // Scaling desired
                        pSrclock.scale(pDstlock);
                    } else {
                        // No scaling needed
                        akra.pixelUtil.bulkPixelConversion(pSrclock, pDstlock);
                    }

                    this.unlock();
                    pSource.unlock();

                    return true;
                }
            };

            WebGLPixelBuffer.prototype.unwrapFromCubeTexture = function (pCubeTex) {
                return false;
            };

            WebGLPixelBuffer.prototype.blitFromMemory = function () {
                var pSource;
                var pDestBox;

                pSource = arguments[0];

                if (arguments.length === 1) {
                    pDestBox = new akra.geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
                    return this.blitFromMemory(pSource, pDestBox);
                } else {
                    pDestBox = arguments[1];
                }

                if (!this._pBuffer.contains(pDestBox)) {
                    akra.logger.critical("Destination box out of range");
                }

                var pScaledBox;

                if (pSource.getWidth() != pDestBox.getWidth() || pSource.getHeight() != pDestBox.getHeight() || pSource.getDepth() != pDestBox.getDepth()) {
                    // Scale to destination size.
                    // This also does pixel format conversion if needed
                    this.allocateBuffer();
                    pScaledBox = this._pBuffer.getSubBox(pDestBox);
                    pScaledBox.setConsecutive();

                    pSource.scale(pScaledBox, 2 /* BILINEAR */);
                } else if ((pSource.format !== this._eFormat) || (webgl.getWebGLFormat(pSource.format) === 0)) {
                    // Extents match, but format is not accepted as valid source format for GL
                    // do conversion in temporary buffer
                    this.allocateBuffer();
                    pScaledBox = this._pBuffer.getSubBox(pDestBox);
                    pScaledBox.setConsecutive();
                    debugger;
                    akra.pixelUtil.bulkPixelConversion(pSource, pScaledBox);
                    // if(this._eFormat === EPixelFormats.A4R4G4B4)
                    // {
                    //     // ARGB->BGRA
                    //     convertToWebGLformat(pScaledBox, pScaledBox);
                    // }
                } else {
                    this.allocateBuffer();
                    pScaledBox = pSource;
                }

                this.upload(pScaledBox, pDestBox);
                this.freeBuffer();

                return true;
            };

            WebGLPixelBuffer.prototype.blitToMemory = function () {
                var pSrcBox;
                var pDest;

                if (arguments.length === 1) {
                    pDest = arguments[0];
                    pSrcBox = new akra.geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
                    return this.blitToMemory(pSrcBox, pDest);
                } else {
                    pSrcBox = arguments[0];
                    pDest = arguments[1];
                }

                if (!this._pBuffer.contains(pSrcBox)) {
                    akra.logger.critical("source box out of range");
                }

                if (pSrcBox.left == 0 && pSrcBox.right == this._iWidth && pSrcBox.top == 0 && pSrcBox.bottom == this._iHeight && pSrcBox.front == 0 && pSrcBox.back == this._iDepth && pDest.getWidth() == this._iWidth && pDest.getHeight() == this._iHeight && pDest.getDepth() == this._iDepth && webgl.getWebGLFormat(pDest.format) != 0) {
                    // The direct case: the user wants the entire texture in a format supported by GL
                    // so we don't need an intermediate buffer
                    this.download(pDest);
                } else {
                    // Use buffer for intermediate copy
                    this.allocateBuffer();

                    // Download entire buffer
                    this.download(this._pBuffer);

                    if (pSrcBox.getWidth() != pDest.getWidth() || pSrcBox.getHeight() != pDest.getHeight() || pSrcBox.getDepth() != pDest.getDepth()) {
                        // We need scaling
                        this._pBuffer.getSubBox(pSrcBox).scale(pDest, 2 /* BILINEAR */);
                    } else {
                        // Just copy the bit that we need
                        akra.pixelUtil.bulkPixelConversion(this._pBuffer.getSubBox(pSrcBox), pDest);
                    }
                    this.freeBuffer();
                }

                return true;
            };

            WebGLPixelBuffer.prototype.getRenderTarget = function () {
                return null;
            };

            WebGLPixelBuffer.prototype.lock = function () {
                var pLockBox = null;
                var iLockFlags = 0;

                if (akra.isInt(arguments[0])) {
                    var iOffset;
                    var iSize;

                    if (arguments.length === 1) {
                        iLockFlags = arguments[0];
                        iOffset = 0;
                        iSize = this.getByteLength();
                    } else {
                        iOffset = arguments[0];
                        iSize = arguments[1];
                        iLockFlags = (arguments.length === 3) ? arguments[2] : 4 /* READABLE */;
                    }

                    akra.logger.assert(!this.isLocked(), "Cannot lock this buffer, it is already locked!");
                    akra.logger.assert(iOffset === 0 && iSize === this.getByteLength(), "Cannot lock memory region, most lock box or entire buffer");

                    pLockBox = new akra.geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
                } else {
                    pLockBox = arguments[0];
                }

                if (this.isBackupPresent()) {
                    if (!akra.bf.testAny(iLockFlags, 2 /* WRITE */)) {
                        // we have to assume a read / write lock so we use the shadow buffer
                        // and tag for sync on unlock()
                        this._pBackupUpdated = true;
                    }

                    this._pCurrentLock = (this._pBackupCopy).lock(pLockBox, iLockFlags);
                } else {
                    this._pCurrentLock = this.lockImpl(pLockBox, iLockFlags);
                    this._isLocked = true;
                }

                return this._pCurrentLock;
            };

            WebGLPixelBuffer.prototype.allocateBuffer = function () {
                if (!akra.isNull(this._pBuffer.data)) {
                    return;
                }

                this._pBuffer.data = new Uint8Array(this.getByteLength());
            };

            WebGLPixelBuffer.prototype.freeBuffer = function () {
                if (akra.bf.testAny(this._iFlags, 1 /* STATIC */)) {
                    this._pBuffer.data = null;
                }
            };

            WebGLPixelBuffer.prototype.lockImpl = function () {
                if (arguments.length === 3) {
                    akra.logger.critical("lockImpl(offset,length) is not valid for PixelBuffers and should never be called");
                }

                var pLockBox = arguments[0];
                var iLockFlags = arguments[1];

                this.allocateBuffer();

                if (!akra.bf.testAny(iLockFlags, 4 /* DISCARD */) && akra.bf.testAny(this._iFlags, 4 /* READABLE */)) {
                    this.download(this._pBuffer);
                }

                this._iCurrentLockFlags = iLockFlags;
                this._pLockedBox = pLockBox;

                return this._pBuffer.getSubBox(pLockBox);
            };

            WebGLPixelBuffer.prototype.unlockImpl = function () {
                if (akra.bf.testAny(this._iCurrentLockFlags, 2 /* WRITE */)) {
                    // From buffer to card, only upload if was locked for writing
                    this.upload(this._pCurrentLock, this._pLockedBox);
                }

                this.freeBuffer();
            };
            return WebGLPixelBuffer;
        })(akra.pool.resources.HardwareBuffer);
        webgl.WebGLPixelBuffer = WebGLPixelBuffer;
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
/// <reference path="../idl/ITexture.ts" />
/// <reference path="../idl/IResourcePool.ts" />
/// <reference path="../idl/IRenderTexture.ts" />
var akra;
(function (akra) {
    /// <reference path="../pixelUtil/PixelBox.ts" />
    /// <reference path="WebGLPixelBuffer.ts" />
    /// <reference path="WebGLRenderer.ts" />
    (function (webgl) {
        var SQUARE_VERTICES = new Float32Array([
            -1.0, -1.0,
            1.0, -1.0,
            -1.0, 1.0,
            1.0, 1.0]);
        var TEXCOORDS = new Float32Array(12);

        function computeLog(iValue) {
            var i = 0;

            /* Error! */
            if (iValue === 0)
                return -1;

            for (; ;) {
                if (iValue & 1) {
                    /* Error! */
                    if (iValue !== 1)
                        return -1;
                    return i;
                }
                iValue = iValue >> 1;
                i++;
            }
        }
        webgl.computeLog = computeLog;

        var WebGLTextureBuffer = (function (_super) {
            __extends(WebGLTextureBuffer, _super);
            function WebGLTextureBuffer() {
                _super.apply(this, arguments);
                this._eTarget = null;
                this._eFaceTarget = null;
                this._pWebGLTexture = null;
                this._iFace = 0;
                this._iLevel = 0;
                this._bSoftwareMipmap = false;
                this._pRTTList = null;
            }
            WebGLTextureBuffer.prototype._clearRTT = function (iZOffset) {
                this._pRTTList[iZOffset] = null;
            };

            WebGLTextureBuffer.prototype.reset = function (iWidth, iHeight) {
                if (typeof iWidth === "undefined") { iWidth = this._iWidth; }
                if (typeof iHeight === "undefined") { iHeight = iWidth; }
                //TODO: check format
                iWidth = akra.math.ceilingPowerOfTwo(iWidth);
                iHeight = akra.math.ceilingPowerOfTwo(iHeight);

                this._iWidth = this._iLevel === 0 ? iWidth : iWidth / Math.pow(2.0, this._iLevel);
                this._iHeight = this._iLevel === 0 ? iHeight : iHeight / Math.pow(2.0, this._iLevel);

                var pWebGLRenderer = this.getManager().getEngine().getRenderer();

                //pWebGLRenderer.debug(true, true);
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);

                pWebGLContext.texImage2D(this._eFaceTarget, this._iLevel, webgl.getClosestWebGLInternalFormat(webgl.getSupportedAlternative(this._eFormat)), this._iWidth, this._iHeight, 0, webgl.getWebGLFormat(this._eFormat), webgl.getWebGLDataType(this._eFormat), null);

                this._iByteSize = akra.pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
                this._pBuffer.setPosition(0, 0, this._iWidth, this._iHeight, 0, this._iDepth);

                pWebGLRenderer.bindWebGLTexture(this._eTarget, null);

                this.notifyResized();
                //pWebGLRenderer.debug(false, false);
            };

            WebGLTextureBuffer.prototype.notifyResized = function () {
                if (!akra.isNull(this._pRTTList)) {
                    for (var i = 0; i < this._pRTTList.length; ++i) {
                        var pRTT = this._pRTTList[i];
                        pRTT.resized.emit(pRTT.getWidth(), pRTT.getHeight());
                    }
                }
            };

            WebGLTextureBuffer.prototype.create = function () {
                if (arguments.length < 6) {
                    akra.logger.critical("Invalid number of params. For WebGLTextureBuffer");
                }

                var eTarget = arguments[0];
                var pTexture = arguments[1];
                var iWidth = arguments[2];
                var iHeight = arguments[3];
                var iInternalFormat = arguments[4];
                var iFormat = arguments[5];
                var iFace = arguments[6];
                var iLevel = arguments[7];
                var iFlags = arguments[8];
                var bSoftwareMipmap = arguments[9];

                var pWebGLRenderer = this.getManager().getEngine().getRenderer();

                pWebGLRenderer.bindWebGLTexture(eTarget, pTexture);

                this._eTarget = eTarget;
                this._pWebGLTexture = pTexture;
                this._iFace = iFace;
                this._iLevel = iLevel;
                this._iFlags = iFlags;
                this._bSoftwareMipmap = bSoftwareMipmap;

                this._eFaceTarget = eTarget;

                if (eTarget === 34067 /* TEXTURE_CUBE_MAP */) {
                    this._eFaceTarget = 34069 /* TEXTURE_CUBE_MAP_POSITIVE_X */ + iFace;
                }

                this._iWidth = iLevel === 0 ? iWidth : iWidth / Math.pow(2.0, iLevel);
                this._iHeight = iLevel === 0 ? iHeight : iHeight / Math.pow(2.0, iLevel);
                this._iDepth = 1;

                this._iWebGLInternalFormat = iInternalFormat;
                this._eFormat = webgl.getClosestAkraFormat(iInternalFormat, iFormat);

                this._iRowPitch = this._iWidth;
                this._iSlicePitch = this._iHeight * this._iWidth;
                this._iByteSize = akra.pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);

                this._pBuffer = new akra.pixelUtil.PixelBox(this._iWidth, this._iHeight, this._iDepth, this._eFormat);

                if (this._iWidth === 0 || this._iHeight === 0 || this._iDepth === 0) {
                    // We are invalid, do not allocate a buffer
                    return false;
                }

                // Is this a render target?
                if (akra.bf.testAny(this._iFlags, 512 /* RENDERTARGET */)) {
                    // Create render target for each slice
                    this._pRTTList = new Array();
                    for (var iZOffset = 0; iZOffset < this._iDepth; ++iZOffset) {
                        var pRenderTexture = new webgl.WebGLRenderTexture(pWebGLRenderer, this);
                        this._pRTTList.push(pRenderTexture);
                        pWebGLRenderer.attachRenderTarget(pRenderTexture);
                    }
                }

                var pProgram = this.getManager().getShaderProgramPool().findResource("WEBgl.blit_texture_buffer");
                var sFloatToVec4Func = "\
				vec4 floatToVec4(float value){                      \n\
					float data = value;                             \n\
					vec4 result = vec4(0.);                         \n\
																	\n\
					if(data == 0.){                                 \n\
						float signedZeroTest = 1./value;            \n\
						if(signedZeroTest < 0.){                    \n\
							result.x = 128.;                        \n\
						}                                           \n\
						return result/255.;                         \n\
					}                                               \n\
																	\n\
					if(data < 0.){                                  \n\
						result.x=128.;                              \n\
						data = -data;                               \n\
					}                                               \n\
																	\n\
					float power = 0.;                               \n\
					bool isFinish = false;                          \n\
					for(int i=0;i<128;i++){                         \n\
						if(isFinish){                               \n\
							break;                                  \n\
						}                                           \n\
																	\n\
						if(data >= 2.) {                            \n\
							if(!isFinish){                          \n\
								data = data * 0.5;                  \n\
								power += 1.;                        \n\
								if (power == 127.) {                \n\
									isFinish = true;                \n\
								}                                   \n\
							}                                       \n\
						}                                           \n\
						else if(data < 1.) {                        \n\
							if(!isFinish){                          \n\
								data = data * 2.;                   \n\
								power -= 1.;                        \n\
								if (power == -126.) {               \n\
									isFinish = true;                \n\
								}                                   \n\
							}                                       \n\
						}                                           \n\
						else {                                      \n\
							isFinish = true;                        \n\
						}                                           \n\
					}                                               \n\
																	\n\
					if(power == -126. && data < 1.){                \n\
						power = 0.;                                 \n\
					}                                               \n\
					else{                                           \n\
						power = power+127.;                         \n\
						data = data - 1.;                           \n\
					}                                               \n\
																	\n\
					result.x+=floor(power/2.);                      \n\
					result.y = mod(power,2.)*128.;                  \n\
																	\n\
					data *= 128.;                                   \n\
																	\n\
					result.y += floor(data);                        \n\
																	\n\
					data -= floor(data);                            \n\
					data *= 256.;                                   \n\
																	\n\
					result.z = floor(data);                         \n\
																	\n\
					data -= floor(data);                            \n\
					data *= 256.;                                   \n\
																	\n\
					result.w = floor(data);                         \n\
																	\n\
					return result/255.;                             \n\
				}                                                   \n";

                if (akra.isNull(pProgram)) {
                    pProgram = this.getManager().getShaderProgramPool().createResource("WEBgl.blit_texture_buffer");
                    pProgram.create("                                                                                                   \n\
				attribute vec2 POSITION;                                                                            \n\
				attribute vec3 TEXCOORD;                                                                            \n\
																													\n\
				varying vec3 texcoord;                                                                              \n\
																													\n\
				void main(void){                                                                                    \n\
					texcoord = TEXCOORD;                                                                            \n\
					gl_Position = vec4(POSITION, 0., 1.);                                                           \n\
				}                                                                                                   \n\
				", "                                                   \n\
				precision highp float;           	                \n\
				varying vec3 texcoord;                              \n\
				uniform sampler2D uSampler;                         \n\
																	\n\
				void main(void) {                                   \n\
					vec4 color;                                     \n\
					color = texture2D(uSampler, texcoord.xy);       \n\
					gl_FragColor = color;                           \n\
				}                                                   \n\
				");
                }

                pProgram = this.getManager().getShaderProgramPool().findResource("WEBgl.decode_depth32_texture");

                if (akra.isNull(pProgram)) {
                    pProgram = this.getManager().getShaderProgramPool().createResource("WEBgl.decode_depth32_texture");
                    pProgram.create("                                                                                                   \n\
				attribute vec2 POSITION;                                                                            \n\
				attribute vec3 TEXCOORD;                                                                            \n\
																													\n\
				varying vec3 texcoord;                                                                              \n\
																													\n\
				void main(void){                                                                                    \n\
					texcoord = TEXCOORD;                                                                            \n\
					gl_Position = vec4(POSITION, 0., 1.);                                                           \n\
				}                                                                                                   \n\
				", "                                                   \n\
				precision highp float;                          	\n\
				varying vec3 texcoord;                              \n\
				uniform sampler2D uSampler;                         \n\
																	\n\
				" + sFloatToVec4Func + "\
																	\n\
				void main(void) {                                   \n\
					vec4 color;                                     \n\
					color = texture2D(uSampler, vec2(texcoord.x, 1. - texcoord.y));         \n\
					vec4 t = floatToVec4(color.r);                  \n\
					gl_FragColor = vec4(t.a, t.b, t.g, t.r);        \n\
				}                                                   \n\
				");
                }

                pProgram = this.getManager().getShaderProgramPool().findResource("WEBgl.decode_float32_texture");

                if (akra.isNull(pProgram)) {
                    pProgram = this.getManager().getShaderProgramPool().createResource("WEBgl.decode_float32_texture");
                    pProgram.create("                                                                                                   \n\
				attribute vec2 POSITION;                                                                            \n\
				attribute vec3 TEXCOORD;                                                                            \n\
																													\n\
				varying vec3 texcoord;                                                                              \n\
				varying vec2 dest_texcoord;                                                                         \n\
																													\n\
				void main(void){                                                                                    \n\
					texcoord = TEXCOORD;                                                                            \n\
					gl_Position = vec4(POSITION, 0., 1.);                                                           \n\
					dest_texcoord.xy = (POSITION.xy + 1.  ) /2.;                                                    \n\
				}                                                                                                   \n\
				", "                                                   \n\
				precision highp float;                          	\n\
																	\n\
				varying vec3 texcoord;                              \n\
				uniform sampler2D uSampler;                         \n\
				uniform int dst_width;                              \n\
				uniform int dst_height;                             \n\
				uniform int src_components_num;                     \n\
				varying vec2 dest_texcoord;                         \n\
				" + sFloatToVec4Func + "\
																	\n\
				void main(void) {                                   \n\
																	\n\
					float pixel = dest_texcoord.x * float(dst_width);   \n\
					float value;                                    \n\
					int comp = int(mod(pixel, float(src_components_num)));  \n\
					vec4 color = texture2D(uSampler, vec2(texcoord.x, 1. - texcoord.y));\n\
																	\n\
					if (comp == 0)                                  \n\
						value = color.r;                            \n\
					if (comp == 1)                                  \n\
						value = color.g;                            \n\
					if (comp == 2)                                  \n\
						value = color.b;                            \n\
					if (comp == 3)                                  \n\
						value = color.a;                            \n\
																	\n\
					vec4 t = floatToVec4(value);                    \n\
																	\n\
					gl_FragColor = vec4(t.a, t.b, t.g, t.r);        \n\
				}\
				");
                }

                pProgram = this.getManager().getShaderProgramPool().findResource("WEBgl.unwrap_cube_texture");
                if (akra.isNull(pProgram)) {
                    pProgram = this.getManager().getShaderProgramPool().createResource("WEBgl.unwrap_cube_texture");
                    pProgram.create("                                                                                                   \n\
				attribute vec2 POSITION;                                                                            \n\
				attribute vec3 TEXCOORD;                                                                            \n\
																													\n\
				varying vec3 texcoord;                                                                              \n\
																													\n\
				void main(void){                                                                                    \n\
					texcoord = TEXCOORD;                                                                            \n\
					gl_Position = vec4(POSITION, 0., 1.);                                                           \n\
				}                                                                                                   \n\
				", "                                                   \n\
				precision highp float;                          	\n\
				varying vec3 texcoord;                              \n\
				uniform samplerCube cubeSampler;                    \n\
																	\n\
				vec4 getCubeDirLod(samplerCube sampler, float texel_size, vec3 v, int side, int lod) {                                \n\
												\n\
												\n\
												\n\
												\n\
												\n\
												\n\
					return vec4(0.);                            \n\
				}                               \n\
				vec4 getCubeLod(samplerCube sampler, float texel_size, vec3 v, int side, int lod) {                                   \n\
					if(lod>6) {                                   \n\
						return vec4(0.,0.,0.,1.);                \n\
					}           \n\
					else {                             \n\
						vec4 color = vec4(0.,0.,0.,1.);                                           \n\
						/* float sum_size = pow(2.,float(lod));                              \n\
						float local_texel_size = texel_size * sum_size;                                                \n\
						vec3 min_pixel;                                                \n\
						vec3 max_pixel;                                                \n\
						if(side==1) {                                      \n\
							vec2 pixel_num = vec2( (v.x+1.-local_texel_size)*0.5, (v.y+1.-local_texel_size)*0.5 );      \n\
							min_pixel = vec3( ((pixel_num.x+0.5*texel_size)*2.-1.),  ((pixel_num.y+0.5*texel_size)*2.-1.), 1.);                                        \n\
							max_pixel = vec3( (((pixel_num.x+local_texel_size)+0.5*texel_size)*2.-1.),  (((pixel_num.y+local_texel_size)+0.5*texel_size)*2.-1.), 1.);                                        \n\
						}                                           \n\
						else if(side==2) {                                      \n\
							vec2 pixel_num = vec2( (v.y+1.-local_texel_size)*0.5, (v.z+1.-local_texel_size)*0.5 );      \n\
							min_pixel = vec3(-1.,  ((pixel_num.x+0.5*texel_size)*2.-1.),  ((pixel_num.y+0.5*texel_size)*2.-1.));                                        \n\
							max_pixel = vec3(-1.,  ((pixel_num.x+0.5*texel_size)*2.-1.),  (((pixel_num.y+local_texel_size)+0.5*texel_size)*2.-1.));                                        \n\
						}                                           \n\
						else if(side==3) {                                      \n\
							vec2 pixel_num = vec2( (v.x+1.-local_texel_size)*0.5, (v.z+1.-local_texel_size)*0.5 );      \n\
							min_pixel = vec3( ((pixel_num.x+0.5*texel_size)*2.-1.), 1.,  ((pixel_num.y+0.5*texel_size)*2.-1.));                                        \n\
							max_pixel = vec3( (((pixel_num.x+local_texel_size)+0.5*texel_size)*2.-1.), 1.,  (((pixel_num.y+local_texel_size)+0.5*texel_size)*2.-1.));                                        \n\
						}                                           \n\
						else if(side==4) {                                      \n\
							vec2 pixel_num = vec2( (v.x+1.-local_texel_size)*0.5, (v.y+1.-local_texel_size)*0.5 );      \n\
							min_pixel = vec3( ((pixel_num.x+0.5*texel_size)*2.-1.),  ((pixel_num.y+0.5*texel_size)*2.-1.), -1.);                                        \n\
							max_pixel = vec3( (((pixel_num.x+local_texel_size)+0.5*texel_size)*2.-1.),  (((pixel_num.y+local_texel_size)+0.5*texel_size)*2.-1.), -1.);                                        \n\
						}                                           \n\
						else if(side==5) {                                      \n\
							vec2 pixel_num = vec2( (v.y+1.-local_texel_size)*0.5, (v.z+1.-local_texel_size)*0.5 );      \n\
							min_pixel = vec3(1.,  ((pixel_num.x+0.5*texel_size)*2.-1.),  ((pixel_num.y+0.5*texel_size)*2.-1.));                                        \n\
							max_pixel = vec3(1.,  ((pixel_num.x+0.5*texel_size)*2.-1.),  (((pixel_num.y+local_texel_size)+0.5*texel_size)*2.-1.));                                        \n\
						}                                           \n\
						else {                                      \n\
							vec2 pixel_num = vec2( (v.x+1.-local_texel_size)*0.5, (v.z+1.-local_texel_size)*0.5 );      \n\
							min_pixel = vec3( ((pixel_num.x+0.5*texel_size)*2.-1.), -1.,  ((pixel_num.y+0.5*texel_size)*2.-1.));                                        \n\
							max_pixel = vec3( (((pixel_num.x+local_texel_size)+0.5*texel_size)*2.-1.), -1.,  (((pixel_num.y+local_texel_size)+0.5*texel_size)*2.-1.));                                        \n\
						}                                         \n\
						for(int i=0;i<64;i++) {                  \n\
							if(float(i)>=sum_size) {             \n\
								break;                                \n\
							}                                         \n\
							else {                                      \n\
								for(int j=0;j<64;j++) {                    \n\
									if(float(j)>=sum_size) {             \n\
										break;                                \n\
									}                                         \n\
									else {                                      \n\
										if(side == 1 || side == 4) {                 \n\
											color += textureCube(sampler, min_pixel+(max_pixel-min_pixel)*vec3(float(i)/sum_size, float(j)/sum_size, 1.)) / sum_size / sum_size;                    \n\
										}                                   \n\
										else if(side == 2 || side == 5) {                 \n\
											color += textureCube(sampler, min_pixel+(max_pixel-min_pixel)*vec3(1., float(i)/sum_size, float(j)/sum_size)) / sum_size / sum_size;                    \n\
										}                                   \n\
										else if(side == 3 || side == 6) {                 \n\
											color += textureCube(sampler, min_pixel+(max_pixel-min_pixel)*vec3(float(i)/sum_size, 1., float(j)/sum_size)) / sum_size / sum_size;                    \n\
										}                                   \n\
										else {                 \n\
											\n\
										}                                   \n\
									}                                           \n\
								}                                           \n\
							}                                           \n\
						}*/                                               \n\
																	   \n\
						float power = pow(2.,float(lod));                        \n\
						float local_texel_size = texel_size * power;                \n\
																	   \n\
						if(side==1 || side == 4) {                                      \n\
							v.x = (v.x)/(1.-local_texel_size);                           \n\
							v.y = (v.y)/(1.-local_texel_size);                           \n\
							if(abs(1.-v.x)<0.5*texel_size) {          \n\
								v.x = 1.;                        \n\
							}                                     \n\
							else if(abs(1.+v.x)<0.5*texel_size) {          \n\
								v.x = -1.;                        \n\
							}                                     \n\
							if(abs(1.-v.y)<0.5*texel_size) {          \n\
								v.y = 1.;                        \n\
							}                                     \n\
							else if(abs(1.+v.y)<0.5*texel_size) {          \n\
								v.y = -1.;                        \n\
							}                                     \n\
						}                                           \n\
						else if(side==2 || side==5) {                                      \n\
							v.y = (v.y)/(1.-local_texel_size);                           \n\
							v.z = (v.z)/(1.-local_texel_size);                           \n\
							if(abs(1.-v.z)<0.5*texel_size) {          \n\
								v.z = 1.;                        \n\
							}                                     \n\
							else if(abs(1.+v.z)<0.5*texel_size) {          \n\
								v.z = -1.;                        \n\
							}                                     \n\
							if(abs(1.-v.y)<0.5*texel_size) {          \n\
								v.y = 1.;                        \n\
							}                                     \n\
							else if(abs(1.+v.y)<0.5*texel_size) {          \n\
								v.y = -1.;                        \n\
							}                                     \n\
						}                                           \n\
						else if(side==3 || side==6) {                                      \n\
							v.x = (v.x)/(1.-local_texel_size);                           \n\
							v.z = (v.z)/(1.-local_texel_size);                           \n\
							if(abs(1.-v.x)<0.5*texel_size) {          \n\
								v.x = 1.;                        \n\
							}                                     \n\
							else if(abs(1.+v.x)<0.5*texel_size) {          \n\
								v.x = -1.;                        \n\
							}                                     \n\
							if(abs(1.-v.z)<0.5*texel_size) {          \n\
								v.z = 1.;                        \n\
							}                                     \n\
							else if(abs(1.+v.z)<0.5*texel_size) {          \n\
								v.z = -1.;                        \n\
							}                                     \n\
						}                                           \n\
						vec3 forward = normalize(v);                                  \n\
						vec3 right = normalize(cross(forward,vec3(0.,1.,0.)));                \n\
						if(abs(length(right))<0.95) {                             \n\
							right = vec3(1.,0.,0.);                                \n\
						}                                                            \n\
						vec3 up = cross(forward,right);                      \n\
						float steps = power*2.;                              \n\
						float angle = asin(texel_size*steps)*0.5*float(lod);                              \n\
						for(int i=0;i<128;i++) {                                                                           \n\
							if(float(i)>=steps) {                                                                           \n\
								break;                                                                                       \n\
							}                                                                                                 \n\
							else {                                                                                             \n\
								for(int j=0;j<128;j++) {                                                                        \n\
									if(float(j)>=steps) {                                                                        \n\
										break;                                                                                    \n\
									}                                                                                              \n\
									else {                                                                                          \n\
										float phi = angle*(-0.5+(float(i)+0.5)/steps);                                               \n\
										float theta = angle*(-0.5+(float(j)+0.5)/steps);                                              \n\
										vec3 dir = forward*cos(theta)*cos(phi) + right*cos(theta)*sin(phi) + up*sin(theta);                  \n\
										color += textureCube(sampler, dir) / steps / steps;                    \n\
									}                                           \n\
								}                                           \n\
							}                                           \n\
						}                                               \n\
						/* if(abs(v.x)==1.&&abs(v.y)==1.||abs(v.z)==1.&&abs(v.y)==1.||abs(v.x)==1.&&abs(v.z)==1.) {         \n\
							color=vec4(1.,0.,0.,1.);                           \n\
						}  */                                                     \n\
						return color;                                               \n\
					}                                               \n\
				}                                                   \n\
																	\n\
				void main(void) {                                   \n\
					vec4 color;                                     \n\
					vec4 pos = vec4(texcoord.x*2.-1.,texcoord.y*2.-1.,0.,0.); \n\
					int lod = 0;            \n\
					if(pos.x < 0.) {        \n\
						pos.x = pos.x*2.+1.;                \n\
						for(int i=0;i<8;i++) {        \n\
							if(pos.x < 0. || pos.y < 0.) {   \n\
								break;                \n\
							} \n\
							else {    \n\
								lod++;        \n\
								pos.w = float(lod);  \n\
								pos.x = (pos.x - 0.5)*2.;  \n\
								pos.y = (pos.y - 0.5)*2.;  \n\
							}            \n\
						} \n\
						if(pos.y >= 0.) {    \n\
							 pos.z = 3.;       \n\
							 pos.x = pos.x*2.+1.; \n\
							 pos.y = pos.y*2.-1.; \n\
						}           \n\
						else if(pos.x < 0.) { \n\
							 pos.z = 1.;       \n\
							 pos.x = pos.x*2.+1.;       \n\
							 pos.y = pos.y*2.+1.;       \n\
						}            \n\
						else {          \n\
							 pos.z = 2.;       \n\
							 pos.x = pos.x*2.-1.;       \n\
							 pos.y = pos.y*2.+1.;       \n\
						}               \n\
					}                       \n\
					else { \n\
						pos.x = pos.x*2.-1.;                \n\
						for(int i=0;i<8;i++) {        \n\
							if(pos.x < 0. || pos.y >= 0.) {   \n\
								break;                \n\
							} \n\
							else {    \n\
								lod++;        \n\
								pos.w = float(lod);  \n\
								pos.x = (pos.x - 0.5)*2.;  \n\
								pos.y = (pos.y + 0.5)*2.;  \n\
							}            \n\
						} \n\
						if(pos.y < 0.) {    \n\
							 pos.z = 6.;       \n\
							 pos.x = pos.x*2.+1.; \n\
							 pos.y = pos.y*2.+1.; \n\
						}           \n\
						else if(pos.x < 0.) { \n\
							 pos.z = 4.;       \n\
							 pos.x = pos.x*2.+1.;       \n\
							 pos.y = pos.y*2.-1.;       \n\
						}            \n\
						else {          \n\
							 pos.z = 5.;       \n\
							 pos.x = pos.x*2.-1.;       \n\
							 pos.y = pos.y*2.-1.;       \n\
						}               \n\
					} \n\
					vec3 dir;               \n\
					if(pos.z == 1.) {        \n\
						dir.x = -pos.x;                        \n\
						dir.y = pos.y;                        \n\
						dir.z = 1.;                        \n\
					}                        \n\
					else if(pos.z == 2.) {        \n\
						dir.x = -1.;                        \n\
						dir.y = pos.y;                        \n\
						dir.z = -pos.x;                        \n\
					}                        \n\
					else if(pos.z == 3.) {        \n\
						dir.x = -pos.x;                        \n\
						dir.y = 1.;                        \n\
						dir.z = -pos.y;                        \n\
					}                        \n\
					else if(pos.z == 4.) {        \n\
						dir.x = pos.x;                        \n\
						dir.y = pos.y;                        \n\
						dir.z = -1.;                        \n\
					}                        \n\
					else if(pos.z == 5.) {        \n\
						dir.x = 1.;                        \n\
						dir.y = pos.y;                        \n\
						dir.z = pos.x;                        \n\
					}                        \n\
					else {                    \n\
						dir.x = pos.x;                        \n\
						dir.y = -1.;                        \n\
						dir.z = -pos.y;                        \n\
					}                        \n\
					color = getCubeLod(cubeSampler, 1./256., dir, int(pos.z), int(pos.w));                      \n\
					/*if(texcoord.x == 0. || texcoord.y == 0.) {      \n\
						color = vec4(1.,0.,0.,1.);      \n\
					}               \n\
					else if(texcoord.x == 1./2./1024. || texcoord.y == 1./2./512.) {     \n\
						color = vec4(1.,1.,0.,1.);      \n\
					}                       \n\
					else if(texcoord.x == 1.-1./2./1024. || texcoord.y == 1.-1./2./512.) {     \n\
						color = vec4(0.,1.,1.,1.);      \n\
					}                       \n\
					else if(texcoord.x == 1. || texcoord.y == 1.) {     \n\
						color = vec4(0.,1.,0.,1.);      \n\
					}                       \n\
					else {                  \n\
						color = vec4(0.,0.,0.,1.);      \n\
					}*/               \n\
					gl_FragColor = color;                           \n\
				}                                                   \n\
				");
                }

                pWebGLRenderer.bindWebGLTexture(eTarget, null);

                return true;
            };

            // destroyResource(): boolean {
            //  super.destroyResource();
            //  this._pWebGLTexture = null;
            //  this.destroy();
            //  return true;
            // }
            WebGLTextureBuffer.prototype.destroy = function () {
                if (akra.bf.testAny(this._iFlags, 512 /* RENDERTARGET */)) {
                    // Delete all render targets that are not yet deleted via _clearSliceRTT because the rendertarget
                    // was deleted by the user.
                    var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                    for (var i = 0; i < this._pRTTList.length; i++) {
                        pWebGLRenderer.destroyRenderTarget(this._pRTTList[i]);
                    }
                }
            };

            WebGLTextureBuffer.prototype.unwrapFromCubeTexture = function (pCubeTex) {
                var pSource = this;
                var pWebGLRenderer = pSource.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                pWebGLRenderer._setViewport(null);

                pWebGLRenderer._setViewport(null);
                pWebGLRenderer._disableTextureUnitsFrom(0);
                pWebGLRenderer.activateWebGLTexture(33984 /* TEXTURE0 */);

                // Disable alpha, depth and scissor testing, disable blending,
                // and disable culling
                pWebGLRenderer.disable(2929 /* DEPTH_TEST */);
                pWebGLRenderer.disable(3089 /* SCISSOR_TEST */);
                pWebGLRenderer.disable(3042 /* BLEND */);
                pWebGLRenderer.disable(2884 /* CULL_FACE */);

                // Set up source texture
                pWebGLRenderer.bindWebGLTexture(pSource._getFaceTarget(), pSource._getWebGLTexture());
                var iOldMagFilter = pWebGLContext.getTexParameter(pSource._getFaceTarget(), 10240 /* TEXTURE_MAG_FILTER */), iOldMinFilter = pWebGLContext.getTexParameter(pSource._getFaceTarget(), 10241 /* TEXTURE_MIN_FILTER */), iOldWrapS = pWebGLContext.getTexParameter(pSource._getFaceTarget(), 10242 /* TEXTURE_WRAP_S */), iOldWrapT = pWebGLContext.getTexParameter(pSource._getFaceTarget(), 10243 /* TEXTURE_WRAP_T */);

                //if (isNull(pSrcBox)) {
                //    pSrcBox = pDestBox;
                //}
                // Set filtering modes depending on the dimensions and source
                //if (pSrcBox.getWidth() === pDestBox.getWidth() &&
                //    pSrcBox.getHeight() === pDestBox.getHeight() &&
                //    pSrcBox.getDepth() === pDestBox.getDepth()) {
                //    // Dimensions match -- use nearest filtering (fastest and pixel correct)
                //    pWebGLContext.texParameteri(pSource._getFaceTarget(), gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                //    pWebGLContext.texParameteri(pSource._getFaceTarget(), gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                //}
                //else {
                //    pWebGLContext.texParameteri(pSource._getFaceTarget(), gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                //    pWebGLContext.texParameteri(pSource._getFaceTarget(), gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                //}
                // Clamp to edge (fastest)
                pWebGLContext.texParameteri(pSource._getFaceTarget(), 10242 /* TEXTURE_WRAP_S */, 33071 /* CLAMP_TO_EDGE */);
                pWebGLContext.texParameteri(pSource._getFaceTarget(), 10243 /* TEXTURE_WRAP_T */, 33071 /* CLAMP_TO_EDGE */);

                //Store old binding so it can be restored later
                var pOldFramebuffer = pWebGLRenderer.getParameter(36006 /* FRAMEBUFFER_BINDING */);
                var pFramebuffer = pWebGLRenderer.createWebGLFramebuffer();

                pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pFramebuffer);

                var pTempWebGLTexture = this._getWebGLTexture();

                // If target format not directly supported, create intermediate texture
                //var iGLTempFormat: int = webgl.getClosestWebGLInternalFormat(webgl.getSupportedAlternative(eFormat));
                //pWebGLRenderer.bindWebGLTexture(gl.TEXTURE_CUBE_MAP, pCubeTex.getWebGLTexture());
                // Allocate temporary texture of the size of the destination area
                //pWebGLContext.texImage2D(gl.TEXTURE_2D, 0, iGLTempFormat,
                //    /*math.ceilingPowerOfTwo*/(pDestBox.getWidth()),
                //    /*math.ceilingPowerOfTwo*/(pDestBox.getHeight()),
                //    0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                pWebGLContext.framebufferTexture2D(36160 /* FRAMEBUFFER */, 36064 /* COLOR_ATTACHMENT0 */, 3553 /* TEXTURE_2D */, pTempWebGLTexture, 0);

                // Set viewport to size of destination slice
                pWebGLContext.viewport(0, 0, this.getWidth(), this.getHeight());

                //Get WebGL program
                var pWebGLShaderProgram = this.getManager().getShaderProgramPool().findResource("WEBgl.unwrap_cube_texture");
                pWebGLRenderer.disableAllWebGLVertexAttribs();
                pWebGLRenderer.useWebGLProgram(pWebGLShaderProgram.getWebGLProgram());

                var iPosAttrIndex = 0;
                var iTexAttrIndex = 0;

                iPosAttrIndex = pWebGLShaderProgram.getWebGLAttributeLocation("POSITION");
                iTexAttrIndex = pWebGLShaderProgram.getWebGLAttributeLocation("TEXCOORD");

                pWebGLContext.enableVertexAttribArray(iPosAttrIndex);
                pWebGLContext.enableVertexAttribArray(iTexAttrIndex);

                var pSquareVertices = SQUARE_VERTICES;
                var pTexCoords = TEXCOORDS;

                var pPositionBuffer = pWebGLRenderer.createWebGLBuffer();
                var pTexCoordsBuffer = pWebGLRenderer.createWebGLBuffer();

                pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, pPositionBuffer);
                pWebGLContext.bufferData(34962 /* ARRAY_BUFFER */, pSquareVertices, 35040 /* STREAM_DRAW */);
                pWebGLContext.vertexAttribPointer(iPosAttrIndex, 2, 5126 /* FLOAT */, false, 0, 0);

                pWebGLShaderProgram.setInt("cubeSampler", 0);

                //pWebGLShaderProgram.setInt("src_components_num", pixelUtil.getComponentCount(pSource.getFormat()));
                //pWebGLShaderProgram.setInt("dst_width", pDestBox.getWidth());
                //pWebGLShaderProgram.setInt("dst_height", pDestBox.getHeight());
                /// Calculate source texture coordinates
                var u1 = 0.;
                var v1 = 0.;
                var u2 = 1.;
                var v2 = 1.;

                /// Calculate source slice for this destination slice
                var w = 0.5;

                pTexCoords[0] = 0.;
                pTexCoords[1] = 1.;
                pTexCoords[2] = w;

                pTexCoords[3] = 1.;
                pTexCoords[4] = 1.;
                pTexCoords[5] = w;

                pTexCoords[6] = 0.;
                pTexCoords[7] = 0.;
                pTexCoords[8] = w;

                pTexCoords[9] = 1.;
                pTexCoords[10] = 0.;
                pTexCoords[11] = w;

                /// Finally we're ready to rumble
                pWebGLRenderer.bindWebGLTexture(34067 /* TEXTURE_CUBE_MAP */, pCubeTex.getWebGLTexture());

                pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, pTexCoordsBuffer);
                pWebGLContext.bufferData(34962 /* ARRAY_BUFFER */, pTexCoords, 35040 /* STREAM_DRAW */);
                pWebGLContext.vertexAttribPointer(iTexAttrIndex, 3, 5126 /* FLOAT */, false, 0, 0);

                pWebGLContext.drawArrays(5 /* TRIANGLE_STRIP */, 0, 4);

                if (akra.bf.testAny(this._iFlags, 256 /* AUTOMIPMAP */) && !this._bSoftwareMipmap && (this._iLevel === 0)) {
                    pWebGLContext.generateMipmap(this._eFaceTarget);
                }

                pWebGLContext.disableVertexAttribArray(iPosAttrIndex);
                pWebGLContext.disableVertexAttribArray(iTexAttrIndex);

                pWebGLRenderer.deleteWebGLBuffer(pPositionBuffer);
                pWebGLRenderer.deleteWebGLBuffer(pTexCoordsBuffer);

                pWebGLRenderer.bindWebGLTexture(34067 /* TEXTURE_CUBE_MAP */, null);

                // Reset source texture to sane state
                pWebGLRenderer.bindWebGLTexture(pSource._getFaceTarget(), pSource._getWebGLTexture());
                pWebGLContext.texParameteri(pSource._getFaceTarget(), 10241 /* TEXTURE_MIN_FILTER */, iOldMinFilter);
                pWebGLContext.texParameteri(pSource._getFaceTarget(), 10240 /* TEXTURE_MAG_FILTER */, iOldMagFilter);
                pWebGLContext.texParameteri(pSource._getFaceTarget(), 10242 /* TEXTURE_WRAP_S */, iOldWrapS);
                pWebGLContext.texParameteri(pSource._getFaceTarget(), 10243 /* TEXTURE_WRAP_T */, iOldWrapT);
                pWebGLRenderer.bindWebGLTexture(pSource._getFaceTarget(), null);

                // Detach texture from temporary framebuffer
                pWebGLContext.framebufferRenderbuffer(36160 /* FRAMEBUFFER */, 36064 /* COLOR_ATTACHMENT0 */, 36161 /* RENDERBUFFER */, null);

                // Restore old framebuffer
                pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pOldFramebuffer);
                pWebGLRenderer.deleteWebGLFramebuffer(pFramebuffer);

                return true;
            };

            //upload(download) data to(from) videocard.
            WebGLTextureBuffer.prototype.upload = function (pData, pDestBox) {
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);

                var pDataBox = null;

                if (akra.pixelUtil.isCompressed(pData.format)) {
                    if (pData.format !== this._eFormat || !pData.isConsecutive()) {
                        akra.logger.critical("Compressed images must be consecutive, in the source format");
                    }

                    var iWebGLFormat = webgl.getClosestWebGLInternalFormat(this._eFormat);

                    // Data must be consecutive and at beginning of buffer as PixelStorei not allowed
                    // for compressed formats
                    if (pDestBox.left === 0 && pDestBox.top === 0) {
                        pWebGLContext.compressedTexImage2D(this._eFaceTarget, this._iLevel, iWebGLFormat, pDestBox.getWidth(), pDestBox.getHeight(), 0, pData.data);
                    } else {
                        pWebGLContext.compressedTexSubImage2D(this._eFaceTarget, this._iLevel, pDestBox.left, pDestBox.top, pDestBox.getWidth(), pDestBox.getHeight(), iWebGLFormat, pData.data);
                    }
                } else if (this._bSoftwareMipmap) {
                    if (pData.getWidth() !== pData.rowPitch || pData.getHeight() * pData.getWidth() !== pData.slicePitch) {
                        pDataBox = this._pBuffer.getSubBox(pDestBox, akra.pixelUtil.PixelBox.temp());
                        pDataBox.setConsecutive();
                        akra.pixelUtil.bulkPixelConversion(pData, pDataBox);
                    } else {
                        pDataBox = pData;
                    }

                    pWebGLRenderer.pixelStorei(3317 /* UNPACK_ALIGNMENT */, 1);
                    this.buildMipmaps(pDataBox);
                } else {
                    if (pData.getWidth() !== pData.rowPitch || pData.getHeight() * pData.getWidth() !== pData.slicePitch) {
                        pDataBox = this._pBuffer.getSubBox(pDestBox, akra.pixelUtil.PixelBox.temp());
                        pDataBox.setConsecutive();
                        akra.pixelUtil.bulkPixelConversion(pData, pDataBox);
                    } else {
                        pDataBox = pData;
                    }

                    if ((pData.getWidth() * akra.pixelUtil.getNumElemBytes(pData.format)) & 3) {
                        // Standard alignment of 4 is not right
                        pWebGLRenderer.pixelStorei(3317 /* UNPACK_ALIGNMENT */, 1);
                    }
                    if (pDestBox.left === 0 && pDestBox.top === 0 && pDestBox.getWidth() >= this.getWidth() && pDestBox.getHeight() >= this.getHeight()) {
                        pWebGLContext.texImage2D(this._eFaceTarget, this._iLevel, webgl.getWebGLFormat(pData.format), pDestBox.getWidth(), pDestBox.getHeight(), 0, webgl.getWebGLFormat(pData.format), webgl.getWebGLDataType(pData.format), !akra.pixelUtil.isFloatingPoint(pData.format) ? pDataBox.data : new Float32Array(pDataBox.data.buffer, pDataBox.data.byteOffset, pDataBox.data.byteLength / Float32Array.BYTES_PER_ELEMENT));
                    } else {
                        pWebGLContext.texSubImage2D(this._eFaceTarget, this._iLevel, pDestBox.left, pDestBox.top, pDestBox.getWidth(), pDestBox.getHeight(), webgl.getWebGLFormat(pData.format), webgl.getWebGLDataType(pData.format), pDataBox.data);
                    }
                }

                if (akra.bf.testAny(this._iFlags, 256 /* AUTOMIPMAP */) && !this._bSoftwareMipmap && (this._iLevel === 0)) {
                    pWebGLContext.generateMipmap(this._eFaceTarget);
                }

                pWebGLRenderer.pixelStorei(3317 /* UNPACK_ALIGNMENT */, 4);

                pWebGLRenderer.bindWebGLTexture(this._eTarget, null);

                this.notifyAltered();
            };

            WebGLTextureBuffer.prototype.download = function (pData) {
                akra.logger.assert(!((pData.right > this._iWidth) || (pData.bottom > this._iHeight) || (pData.front != 0) || (pData.back != 1)), "Invalid box " + pData.toString());

                var pSrcBox = null;
                var pWebGLTexture = this._pWebGLTexture;
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                if (!webgl.checkFBOAttachmentFormat(this.getFormat())) {
                    akra.logger.critical("Read from texture this format not support(" + this.getFormat() + ")");
                }

                if (!webgl.checkReadPixelFormat(this.getFormat())) {
                    akra.logger.assert(this.getFormat() === 46 /* DEPTH32 */ || this.getFormat() === 24 /* FLOAT32_RGB */ || this.getFormat() === 25 /* FLOAT32_RGBA */, "TODO: downloading for all formats");

                    var eFormat = this.getFormat();
                    var pDestBox = akra.geometry.Box.temp(0, 0, 0, pData.getWidth() * akra.pixelUtil.getComponentCount(this.getFormat()), pData.getHeight(), pData.getDepth());

                    if (this.getFormat() === 46 /* DEPTH32 */) {
                        eFormat = 29 /* FLOAT32_DEPTH */;
                    }

                    // мы не можем читать из данного формата напрямую, поэтому необходимо перерендерить эту текстура в RGB/RGBA 8.
                    var pProgram = this.getManager().getShaderProgramPool().findResource(this.getFormat() === 46 /* DEPTH32 */ ? "WEBgl.decode_depth32_texture" : "WEBgl.decode_float32_texture");

                    pWebGLTexture = WebGLTextureBuffer.copyTex2DImageByProgram(pProgram, pDestBox, 28 /* R8G8B8A8 */, this, pData);

                    if (pData.format === eFormat) {
                        pSrcBox = pData;
                    } else {
                        pSrcBox = new akra.pixelUtil.PixelBox(pData, eFormat, new Uint8Array(akra.pixelUtil.getMemorySize(pData.getWidth() * akra.pixelUtil.getComponentCount(this.getFormat()), pData.getHeight(), pData.getDepth(), 28 /* R8G8B8A8 */)));
                    }

                    var pOldFramebuffer = pWebGLRenderer.getParameter(36006 /* FRAMEBUFFER_BINDING */);
                    var pFrameBuffer = pWebGLRenderer.createWebGLFramebuffer();

                    pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pFrameBuffer);
                    pWebGLContext.framebufferTexture2D(36160 /* FRAMEBUFFER */, 36064 /* COLOR_ATTACHMENT0 */, 3553 /* TEXTURE_2D */, pWebGLTexture, 0);
                    pWebGLContext.readPixels(0, 0, pDestBox.getWidth(), pDestBox.getHeight(), 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */, pSrcBox.data);
                    pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pOldFramebuffer);
                    pWebGLRenderer.deleteWebGLFramebuffer(pFrameBuffer);
                    pWebGLRenderer.deleteWebGLTexture(pWebGLTexture);

                    if (pSrcBox != pData) {
                        console.log("download. convertion....");
                        akra.pixelUtil.bulkPixelConversion(pSrcBox, pData);
                    }

                    return;
                }

                if (webgl.checkReadPixelFormat(pData.format)) {
                    pSrcBox = pData;
                } else {
                    pSrcBox = new akra.pixelUtil.PixelBox(pData, 28 /* BYTE_RGBA */, new Uint8Array(akra.pixelUtil.getMemorySize(pData.getWidth(), pData.getHeight(), pData.getDepth(), 28 /* BYTE_RGBA */)));
                }

                var pOldFramebuffer = pWebGLRenderer.getParameter(36006 /* FRAMEBUFFER_BINDING */);
                var pFrameBuffer = pWebGLRenderer.createWebGLFramebuffer();

                pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pFrameBuffer);

                var eFormat = webgl.getWebGLFormat(pSrcBox.format);
                var eType = webgl.getWebGLDataType(pSrcBox.format);

                pWebGLContext.framebufferTexture2D(36160 /* FRAMEBUFFER */, 36064 /* COLOR_ATTACHMENT0 */, this._eFaceTarget, pWebGLTexture, this._iLevel);
                pWebGLContext.readPixels(pSrcBox.left, pSrcBox.top, pSrcBox.getWidth(), pSrcBox.getHeight(), eFormat, eType, pSrcBox.data);

                if (!webgl.checkReadPixelFormat(pData.format)) {
                    console.log("download. convertion....");
                    akra.pixelUtil.bulkPixelConversion(pSrcBox, pData);
                }

                //дективировать его
                pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pOldFramebuffer);
                pWebGLRenderer.deleteWebGLFramebuffer(pFrameBuffer);
                // if(data.getWidth() != getWidth() ||
                //     data.getHeight() != getHeight() ||
                //     data.getDepth() != getDepth())
                //     OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS, "only download of entire buffer is supported by GL",
                //         "GLTextureBuffer::download");
                // glBindTexture( mTarget, mTextureID );
                // if(PixelUtil::isCompressed(data.format))
                // {
                //     if(data.format != mFormat || !data.isConsecutive())
                //         OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS,
                //         "Compressed images must be consecutive, in the source format",
                //         "GLTextureBuffer::download");
                //     // Data must be consecutive and at beginning of buffer as PixelStorei not allowed
                //     // for compressed formate
                //     glGetCompressedTexImageNV(mFaceTarget, mLevel, data.data);
                // }
                // else
                // {
                //     if((data.getWidth()*PixelUtil::getNumElemBytes(data.format)) & 3) {
                //         // Standard alignment of 4 is not right
                //         glPixelStorei(gl.PACK_ALIGNMENT, 1);
                //     }
                //     // We can only get the entire texture
                //     glGetTexImageNV(mFaceTarget, mLevel,
                //         GLES2PixelUtil::getGLOriginFormat(data.format), GLES2PixelUtil::getGLOriginDataType(data.format),
                //         data.data);
                //     // Restore defaults
                //     glPixelStorei(gl.PACK_ALIGNMENT, 4);
                // }
                //logger.critical("Downloading texture buffers is not supported by OpenGL ES");
            };

            WebGLTextureBuffer.prototype.buildMipmaps = function (pData) {
                var iWidth = 0;
                var iHeight = 0;
                var iLogW = 0;
                var iLogH = 0;
                var iLevel = 0;
                var pScaled = new akra.pixelUtil.PixelBox();

                pScaled.data = pData.data;
                pScaled.left = pData.left;
                pScaled.right = pData.right;
                pScaled.top = pData.top;
                pScaled.bottom = pData.bottom;
                pScaled.front = pData.front;
                pScaled.back = pData.back;

                iWidth = pData.getWidth();
                iHeight = pData.getHeight();

                iLogW = computeLog(iWidth);
                iLogH = computeLog(iHeight);
                iLevel = (iLogW > iLogH ? iLogW : iLogH);

                var mip = 0;
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                for (mip = 0; mip <= iLevel; mip++) {
                    var iWebGLFormat = webgl.getWebGLFormat(pScaled.format);
                    var iWebGLDataType = webgl.getWebGLDataType(pScaled.format);

                    pWebGLContext.texImage2D(this._eFaceTarget, mip, iWebGLFormat, iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, pScaled.data);

                    if (mip !== 0) {
                        pScaled.data = null;
                    }

                    if (iWidth > 1) {
                        iWidth = iWidth / 2;
                    }

                    if (iHeight > 1) {
                        iHeight = iHeight / 2;
                    }

                    var iSizeInBytes = akra.pixelUtil.getMemorySize(iWidth, iHeight, 1, pData.format);
                    pScaled = new akra.pixelUtil.PixelBox(iWidth, iHeight, 1, pData.format);
                    pScaled.data = new Uint8Array(iSizeInBytes);
                    pData.scale(pScaled, 1 /* LINEAR */);
                }

                // Delete the scaled data for the last level
                if (iLevel > 0) {
                    pScaled.data = null;
                }
            };

            WebGLTextureBuffer.prototype._bindToFramebuffer = function (iAttachment, iZOffset) {
                akra.logger.assert(iZOffset < this._iDepth);
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                pWebGLContext.framebufferTexture2D(36160 /* FRAMEBUFFER */, iAttachment, this._eFaceTarget, this._pWebGLTexture, this._iLevel);
            };

            WebGLTextureBuffer.prototype._copyFromFramebuffer = function (iZOffset) {
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);
                pWebGLContext.copyTexSubImage2D(this._eFaceTarget, this._iLevel, 0, 0, 0, 0, this._iWidth, this._iHeight);
                pWebGLRenderer.bindWebGLTexture(this._eTarget, null);
            };

            WebGLTextureBuffer.prototype._getTarget = function () {
                return this._eTarget;
            };

            WebGLTextureBuffer.prototype._getWebGLTexture = function () {
                return this._pWebGLTexture;
            };

            WebGLTextureBuffer.prototype._getFaceTarget = function () {
                return this._eFaceTarget;
            };

            WebGLTextureBuffer.prototype.blit = function (pSource, pSrcBox, pDestBox) {
                if (arguments.length === 1) {
                    return this.blit(pSource, new akra.geometry.Box(0, 0, 0, pSource.getWidth(), pSource.getHeight(), pSource.getDepth()), new akra.geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth));
                } else {
                    var pSourceTexture = pSource;

                    // TODO: Check for FBO support first
                    // Destination texture must be 2D or Cube
                    // Source texture must be 2D
                    if (!akra.bf.testAny(pSourceTexture.getFlags(), 512 /* RENDERTARGET */) && pSourceTexture._getTarget() === 3553 /* TEXTURE_2D */) {
                        return this.blitFromTexture(pSourceTexture, pSrcBox, pDestBox);
                    } else {
                        return _super.prototype.blit.call(this, pSource, pSrcBox, pDestBox);
                    }
                }
            };

            WebGLTextureBuffer.copyTex2DImageByProgram = function (pProgram, pDestBox, eFormat, pSource, pSrcBox) {
                if (typeof pSrcBox === "undefined") { pSrcBox = null; }
                var pWebGLRenderer = pSource.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                pWebGLRenderer._disableTextureUnitsFrom(0);
                pWebGLRenderer.activateWebGLTexture(33984 /* TEXTURE0 */);

                // Disable alpha, depth and scissor testing, disable blending,
                // and disable culling
                pWebGLRenderer.disable(2929 /* DEPTH_TEST */);
                pWebGLRenderer.disable(3089 /* SCISSOR_TEST */);
                pWebGLRenderer.disable(3042 /* BLEND */);
                pWebGLRenderer.disable(2884 /* CULL_FACE */);

                // Set up source texture
                pWebGLRenderer.bindWebGLTexture(pSource._getFaceTarget(), pSource._getWebGLTexture());
                var iOldMagFilter = pWebGLContext.getTexParameter(pSource._getFaceTarget(), 10240 /* TEXTURE_MAG_FILTER */), iOldMinFilter = pWebGLContext.getTexParameter(pSource._getFaceTarget(), 10241 /* TEXTURE_MIN_FILTER */), iOldWrapS = pWebGLContext.getTexParameter(pSource._getFaceTarget(), 10242 /* TEXTURE_WRAP_S */), iOldWrapT = pWebGLContext.getTexParameter(pSource._getFaceTarget(), 10243 /* TEXTURE_WRAP_T */);

                if (akra.isNull(pSrcBox)) {
                    pSrcBox = pDestBox;
                }

                // Set filtering modes depending on the dimensions and source
                if (pSrcBox.getWidth() === pDestBox.getWidth() && pSrcBox.getHeight() === pDestBox.getHeight() && pSrcBox.getDepth() === pDestBox.getDepth()) {
                    // Dimensions match -- use nearest filtering (fastest and pixel correct)
                    pWebGLContext.texParameteri(pSource._getFaceTarget(), 10241 /* TEXTURE_MIN_FILTER */, 9728 /* NEAREST */);
                    pWebGLContext.texParameteri(pSource._getFaceTarget(), 10240 /* TEXTURE_MAG_FILTER */, 9728 /* NEAREST */);
                } else {
                    pWebGLContext.texParameteri(pSource._getFaceTarget(), 10241 /* TEXTURE_MIN_FILTER */, 9729 /* LINEAR */);
                    pWebGLContext.texParameteri(pSource._getFaceTarget(), 10240 /* TEXTURE_MAG_FILTER */, 9729 /* LINEAR */);
                }

                // Clamp to edge (fastest)
                pWebGLContext.texParameteri(pSource._getFaceTarget(), 10242 /* TEXTURE_WRAP_S */, 33071 /* CLAMP_TO_EDGE */);
                pWebGLContext.texParameteri(pSource._getFaceTarget(), 10243 /* TEXTURE_WRAP_T */, 33071 /* CLAMP_TO_EDGE */);

                //Store old binding so it can be restored later
                var pOldFramebuffer = pWebGLRenderer.getParameter(36006 /* FRAMEBUFFER_BINDING */);
                var pFramebuffer = pWebGLRenderer.createWebGLFramebuffer();

                pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pFramebuffer);

                var pTempWebGLTexture = null;

                // If target format not directly supported, create intermediate texture
                var iGLTempFormat = webgl.getClosestWebGLInternalFormat(webgl.getSupportedAlternative(eFormat));

                pTempWebGLTexture = pWebGLRenderer.createWebGLTexture();
                pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, pTempWebGLTexture);

                // Allocate temporary texture of the size of the destination area
                pWebGLContext.texImage2D(3553 /* TEXTURE_2D */, 0, iGLTempFormat, (pDestBox.getWidth()), (pDestBox.getHeight()), 0, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */, null);

                pWebGLContext.framebufferTexture2D(36160 /* FRAMEBUFFER */, 36064 /* COLOR_ATTACHMENT0 */, 3553 /* TEXTURE_2D */, pTempWebGLTexture, 0);

                // Set viewport to size of destination slice
                pWebGLContext.viewport(0, 0, pDestBox.getWidth(), pDestBox.getHeight());

                //Get WebGL program
                var pWebGLShaderProgram = pProgram;
                pWebGLRenderer.disableAllWebGLVertexAttribs();
                pWebGLRenderer.useWebGLProgram(pWebGLShaderProgram.getWebGLProgram());

                var iPosAttrIndex = 0;
                var iTexAttrIndex = 0;

                iPosAttrIndex = pWebGLShaderProgram.getWebGLAttributeLocation("POSITION");
                iTexAttrIndex = pWebGLShaderProgram.getWebGLAttributeLocation("TEXCOORD");

                pWebGLContext.enableVertexAttribArray(iPosAttrIndex);
                pWebGLContext.enableVertexAttribArray(iTexAttrIndex);

                var pSquareVertices = SQUARE_VERTICES;
                var pTexCoords = TEXCOORDS;

                var pPositionBuffer = pWebGLRenderer.createWebGLBuffer();
                var pTexCoordsBuffer = pWebGLRenderer.createWebGLBuffer();

                pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, pPositionBuffer);
                pWebGLContext.bufferData(34962 /* ARRAY_BUFFER */, pSquareVertices, 35040 /* STREAM_DRAW */);
                pWebGLContext.vertexAttribPointer(iPosAttrIndex, 2, 5126 /* FLOAT */, false, 0, 0);

                pWebGLShaderProgram.setInt("uSampler", 0);
                pWebGLShaderProgram.setInt("src_components_num", akra.pixelUtil.getComponentCount(pSource.getFormat()));
                pWebGLShaderProgram.setInt("dst_width", pDestBox.getWidth());
                pWebGLShaderProgram.setInt("dst_height", pDestBox.getHeight());

                // LOG("dest size: ", pDestBox.width, "x", pDestBox.height, "cn: ", pixelUtil.getComponentCount(pSource.format));
                // Process each destination slice
                var iSlice = 0;
                for (iSlice = pDestBox.front; iSlice < pDestBox.back; ++iSlice) {
                    /// Calculate source texture coordinates
                    var u1 = pSrcBox.left / pSource.getWidth();
                    var v1 = pSrcBox.top / pSource.getHeight();
                    var u2 = pSrcBox.right / pSource.getWidth();
                    var v2 = pSrcBox.bottom / pSource.getHeight();

                    /// Calculate source slice for this destination slice
                    var w = (iSlice - pDestBox.front) / pDestBox.getDepth();

                    /// Get slice # in source
                    w = w * pSrcBox.getDepth() + pSrcBox.front;

                    /// Normalise to texture coordinate in 0.0 .. 1.0
                    w = (w + 0.5) / pSource.getDepth();

                    pTexCoords[0] = u1;
                    pTexCoords[1] = v1;
                    pTexCoords[2] = w;

                    pTexCoords[3] = u2;
                    pTexCoords[4] = v1;
                    pTexCoords[5] = w;

                    pTexCoords[6] = u2;
                    pTexCoords[7] = v2;
                    pTexCoords[8] = w;

                    pTexCoords[9] = u1;
                    pTexCoords[10] = v2;
                    pTexCoords[11] = w;

                    /// Finally we're ready to rumble
                    pWebGLRenderer.bindWebGLTexture(pSource._getFaceTarget(), pSource._getWebGLTexture());

                    pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, pTexCoordsBuffer);
                    pWebGLContext.bufferData(34962 /* ARRAY_BUFFER */, pTexCoords, 35040 /* STREAM_DRAW */);
                    pWebGLContext.vertexAttribPointer(iTexAttrIndex, 3, 5126 /* FLOAT */, false, 0, 0);

                    pWebGLContext.drawArrays(5 /* TRIANGLE_STRIP */, 0, 4);
                }

                pWebGLContext.disableVertexAttribArray(iPosAttrIndex);
                pWebGLContext.disableVertexAttribArray(iTexAttrIndex);

                pWebGLRenderer.deleteWebGLBuffer(pPositionBuffer);
                pWebGLRenderer.deleteWebGLBuffer(pTexCoordsBuffer);

                // Reset source texture to sane state
                pWebGLRenderer.bindWebGLTexture(pSource._getFaceTarget(), pSource._getWebGLTexture());
                pWebGLContext.texParameteri(pSource._getFaceTarget(), 10241 /* TEXTURE_MIN_FILTER */, iOldMinFilter);
                pWebGLContext.texParameteri(pSource._getFaceTarget(), 10240 /* TEXTURE_MAG_FILTER */, iOldMagFilter);
                pWebGLContext.texParameteri(pSource._getFaceTarget(), 10242 /* TEXTURE_WRAP_S */, iOldWrapS);
                pWebGLContext.texParameteri(pSource._getFaceTarget(), 10243 /* TEXTURE_WRAP_T */, iOldWrapT);
                pWebGLRenderer.bindWebGLTexture(pSource._getFaceTarget(), null);

                // Detach texture from temporary framebuffer
                pWebGLContext.framebufferRenderbuffer(36160 /* FRAMEBUFFER */, 36064 /* COLOR_ATTACHMENT0 */, 36161 /* RENDERBUFFER */, null);

                // Restore old framebuffer
                pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pOldFramebuffer);
                pWebGLRenderer.deleteWebGLFramebuffer(pFramebuffer);

                return pTempWebGLTexture;
            };

            //-----------------------------------------------------------------------------
            // Very fast texture-to-texture blitter and hardware bi/trilinear scaling implementation using FBO
            // Destination texture must be 1D, 2D, 3D, or Cube
            // Source texture must be 1D, 2D or 3D
            // Supports compressed formats as both source and destination format, it will use the hardware DXT compressor
            // if available.
            WebGLTextureBuffer.prototype.blitFromTexture = function (pSource, pSrcBox, pDestBox) {
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                if (this.getFormat() === pSource.getFormat() && webgl.checkCopyTexImage(this.getFormat()) && this._pBuffer.contains(pDestBox) && pSrcBox.getWidth() === pDestBox.getWidth() && pSrcBox.getHeight() === pDestBox.getHeight() && pSrcBox.getDepth() === pDestBox.getDepth()) {
                    var pOldFramebuffer = pWebGLRenderer.getParameter(36006 /* FRAMEBUFFER_BINDING */);
                    var pFramebuffer = pWebGLRenderer.createWebGLFramebuffer();

                    pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pFramebuffer);

                    pWebGLContext.framebufferTexture2D(36160 /* FRAMEBUFFER */, 36064 /* COLOR_ATTACHMENT0 */, pSource._getTarget(), pSource._getWebGLTexture(), 0);

                    pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);

                    if (pDestBox.getWidth() === this.getWidth() && pDestBox.getHeight() === this.getHeight()) {
                        pWebGLContext.copyTexImage2D(this._eFaceTarget, this._iLevel, webgl.getWebGLFormat(this._eFormat), pSrcBox.left, pSrcBox.top, pSrcBox.getWidth(), pSrcBox.getHeight(), 0);
                    } else {
                        pWebGLContext.copyTexSubImage2D(this._eFaceTarget, this._iLevel, pDestBox.left, pDestBox.top, pSrcBox.left, pSrcBox.top, pSrcBox.getWidth(), pSrcBox.getHeight());
                    }

                    pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pOldFramebuffer);
                    pWebGLRenderer.bindWebGLTexture(this._eTarget, null);
                    pWebGLRenderer.deleteWebGLFramebuffer(pFramebuffer);

                    this.notifyAltered();

                    return true;
                }
                pWebGLRenderer._disableTextureUnitsFrom(0);
                pWebGLRenderer.activateWebGLTexture(33984 /* TEXTURE0 */);

                // Disable alpha, depth and scissor testing, disable blending,
                // and disable culling
                pWebGLRenderer.disable(2929 /* DEPTH_TEST */);
                pWebGLRenderer.disable(3089 /* SCISSOR_TEST */);
                pWebGLRenderer.disable(3042 /* BLEND */);
                pWebGLRenderer.disable(2884 /* CULL_FACE */);

                // Set up source texture
                pWebGLRenderer.bindWebGLTexture(pSource._getTarget(), pSource._getWebGLTexture());
                var iOldMagFilter = pWebGLContext.getTexParameter(pSource._getFaceTarget(), 10240 /* TEXTURE_MAG_FILTER */), iOldMinFilter = pWebGLContext.getTexParameter(pSource._getFaceTarget(), 10241 /* TEXTURE_MIN_FILTER */), iOldWrapS = pWebGLContext.getTexParameter(pSource._getFaceTarget(), 10242 /* TEXTURE_WRAP_S */), iOldWrapT = pWebGLContext.getTexParameter(pSource._getFaceTarget(), 10243 /* TEXTURE_WRAP_T */);

                // Set filtering modes depending on the dimensions and source
                if (pSrcBox.getWidth() === pDestBox.getWidth() && pSrcBox.getHeight() === pDestBox.getHeight() && pSrcBox.getDepth() === pDestBox.getDepth()) {
                    // Dimensions match -- use nearest filtering (fastest and pixel correct)
                    pWebGLContext.texParameteri(pSource._getTarget(), 10241 /* TEXTURE_MIN_FILTER */, 9728 /* NEAREST */);
                    pWebGLContext.texParameteri(pSource._getTarget(), 10240 /* TEXTURE_MAG_FILTER */, 9728 /* NEAREST */);
                } else {
                    // Dimensions don't match -- use bi or trilinear filtering depending on the
                    // source texture.
                    if (akra.bf.testAny(pSource.getFlags(), 256 /* AUTOMIPMAP */)) {
                        // Automatic mipmaps, we can safely use trilinear filter which
                        // brings greatly improved quality for minimisation.
                        pWebGLContext.texParameteri(pSource._getTarget(), 10241 /* TEXTURE_MIN_FILTER */, 9987 /* LINEAR_MIPMAP_LINEAR */);
                        pWebGLContext.texParameteri(pSource._getTarget(), 10240 /* TEXTURE_MAG_FILTER */, 9729 /* LINEAR */);
                    } else {
                        // Manual mipmaps, stay safe with bilinear filtering so that no
                        // intermipmap leakage occurs.
                        pWebGLContext.texParameteri(pSource._getTarget(), 10241 /* TEXTURE_MIN_FILTER */, 9729 /* LINEAR */);
                        pWebGLContext.texParameteri(pSource._getTarget(), 10240 /* TEXTURE_MAG_FILTER */, 9729 /* LINEAR */);
                    }
                }

                // Clamp to edge (fastest)
                pWebGLContext.texParameteri(pSource._getTarget(), 10242 /* TEXTURE_WRAP_S */, 33071 /* CLAMP_TO_EDGE */);
                pWebGLContext.texParameteri(pSource._getTarget(), 10243 /* TEXTURE_WRAP_T */, 33071 /* CLAMP_TO_EDGE */);

                //Store old binding so it can be restored later
                var pOldFramebuffer = pWebGLRenderer.getParameter(36006 /* FRAMEBUFFER_BINDING */);

                var pFramebuffer = pWebGLRenderer.createWebGLFramebuffer();

                pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pFramebuffer);

                var pTempWebGLTexture = null;

                if (!webgl.checkFBOAttachmentFormat(this._eFormat) || pSource._getWebGLTexture() === this._getWebGLTexture()) {
                    // If target format not directly supported, create intermediate texture
                    var iGLTempFormat = webgl.getClosestWebGLInternalFormat(webgl.getSupportedAlternative(this._eFormat));

                    pTempWebGLTexture = pWebGLRenderer.createWebGLTexture();
                    pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, pTempWebGLTexture);

                    // Allocate temporary texture of the size of the destination area
                    pWebGLContext.texImage2D(3553 /* TEXTURE_2D */, 0, iGLTempFormat, akra.math.ceilingPowerOfTwo(pDestBox.getWidth()), akra.math.ceilingPowerOfTwo(pDestBox.getHeight()), 0, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */, null);

                    pWebGLContext.framebufferTexture2D(36160 /* FRAMEBUFFER */, 36064 /* COLOR_ATTACHMENT0 */, 3553 /* TEXTURE_2D */, pTempWebGLTexture, 0);

                    // Set viewport to size of destination slice
                    pWebGLContext.viewport(0, 0, pDestBox.getWidth(), pDestBox.getHeight());
                } else {
                    // We are going to bind directly, so set viewport to size and position of destination slice
                    pWebGLContext.viewport(pDestBox.left, pDestBox.top, pDestBox.getWidth(), pDestBox.getHeight());
                }

                //Get WebGL program
                var pWebGLShaderProgram = this.getManager().getShaderProgramPool().findResource("WEBgl.blit_texture_buffer");
                pWebGLRenderer.disableAllWebGLVertexAttribs();
                pWebGLRenderer.useWebGLProgram(pWebGLShaderProgram.getWebGLProgram());

                var iPosAttrIndex = 0;
                var iTexAttrIndex = 0;

                iPosAttrIndex = pWebGLShaderProgram.getWebGLAttributeLocation("POSITION");
                iTexAttrIndex = pWebGLShaderProgram.getWebGLAttributeLocation("TEXCOORD");

                pWebGLContext.enableVertexAttribArray(iPosAttrIndex);
                pWebGLContext.enableVertexAttribArray(iTexAttrIndex);

                var pSquareVertices = SQUARE_VERTICES;
                var pTexCoords = TEXCOORDS;

                var pPositionBuffer = pWebGLRenderer.createWebGLBuffer();
                var pTexCoordsBuffer = pWebGLRenderer.createWebGLBuffer();

                pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, pPositionBuffer);
                pWebGLContext.bufferData(34962 /* ARRAY_BUFFER */, pSquareVertices, 35040 /* STREAM_DRAW */);
                pWebGLContext.vertexAttribPointer(iPosAttrIndex, 2, 5126 /* FLOAT */, false, 0, 0);

                pWebGLShaderProgram.setInt("uSampler", 0);

                // Process each destination slice
                var iSlice = 0;
                for (iSlice = pDestBox.front; iSlice < pDestBox.back; ++iSlice) {
                    if (akra.isNull(pTempWebGLTexture)) {
                        // Bind directly
                        this._bindToFramebuffer(36064 /* COLOR_ATTACHMENT0 */, iSlice);
                    }

                    /// Calculate source texture coordinates
                    var u1 = pSrcBox.left / pSource.getWidth();
                    var v1 = pSrcBox.top / pSource.getHeight();
                    var u2 = pSrcBox.right / pSource.getWidth();
                    var v2 = pSrcBox.bottom / pSource.getHeight();

                    /// Calculate source slice for this destination slice
                    var w = (iSlice - pDestBox.front) / pDestBox.getDepth();

                    /// Get slice # in source
                    w = w * pSrcBox.getDepth() + pSrcBox.front;

                    /// Normalise to texture coordinate in 0.0 .. 1.0
                    w = (w + 0.5) / pSource.getDepth();

                    pTexCoords[0] = u1;
                    pTexCoords[1] = v1;
                    pTexCoords[2] = w;

                    pTexCoords[3] = u2;
                    pTexCoords[4] = v1;
                    pTexCoords[5] = w;

                    pTexCoords[6] = u2;
                    pTexCoords[7] = v2;
                    pTexCoords[8] = w;

                    pTexCoords[9] = u1;
                    pTexCoords[10] = v2;
                    pTexCoords[11] = w;

                    /// Finally we're ready to rumble
                    pWebGLRenderer.bindWebGLTexture(pSource._getTarget(), pSource._getWebGLTexture());

                    // pWebGLContext.enable(pSource._getTarget());
                    pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, pTexCoordsBuffer);
                    pWebGLContext.bufferData(34962 /* ARRAY_BUFFER */, pTexCoords, 35040 /* STREAM_DRAW */);
                    pWebGLContext.vertexAttribPointer(iTexAttrIndex, 3, 5126 /* FLOAT */, false, 0, 0);

                    pWebGLContext.drawArrays(5 /* TRIANGLE_STRIP */, 0, 4);

                    // pWebGLContext.disable(pSource._getTarget());
                    if (!akra.isNull(pTempWebGLTexture)) {
                        if (pSource === this) {
                            //set width, height and _pWebGLTexture
                            pWebGLRenderer.deleteWebGLTexture(this._pWebGLTexture);

                            this._pWebGLTexture = pTempWebGLTexture;
                            this._iWidth = akra.math.ceilingPowerOfTwo(pDestBox.getWidth());
                            this._iHeight = akra.math.ceilingPowerOfTwo(pDestBox.getHeight());
                        } else {
                            // Copy temporary texture
                            pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);

                            switch (this._eTarget) {
                                case 3553 /* TEXTURE_2D */:
                                case 34067 /* TEXTURE_CUBE_MAP */:
                                    pWebGLContext.copyTexSubImage2D(this._eFaceTarget, this._iLevel, pDestBox.left, pDestBox.top, 0, 0, pDestBox.getWidth(), pDestBox.getHeight());
                                    break;
                            }
                        }
                    }
                }

                pWebGLContext.disableVertexAttribArray(iPosAttrIndex);
                pWebGLContext.disableVertexAttribArray(iTexAttrIndex);

                pWebGLRenderer.deleteWebGLBuffer(pPositionBuffer);
                pWebGLRenderer.deleteWebGLBuffer(pTexCoordsBuffer);

                // Finish up
                if (!akra.isNull(pTempWebGLTexture)) {
                    // Generate mipmaps
                    if (akra.bf.testAny(this._iFlags, 256 /* AUTOMIPMAP */)) {
                        pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);
                        pWebGLContext.generateMipmap(this._eTarget);
                    }
                }

                // Reset source texture to sane state
                pWebGLRenderer.bindWebGLTexture(pSource._getTarget(), pSource._getWebGLTexture());
                pWebGLContext.texParameteri(pSource._getTarget(), 10241 /* TEXTURE_MIN_FILTER */, iOldMinFilter);
                pWebGLContext.texParameteri(pSource._getTarget(), 10240 /* TEXTURE_MAG_FILTER */, iOldMagFilter);
                pWebGLContext.texParameteri(pSource._getTarget(), 10242 /* TEXTURE_WRAP_S */, iOldWrapS);
                pWebGLContext.texParameteri(pSource._getTarget(), 10243 /* TEXTURE_WRAP_T */, iOldWrapT);
                pWebGLRenderer.bindWebGLTexture(pSource._getTarget(), null);

                // Detach texture from temporary framebuffer
                pWebGLContext.framebufferRenderbuffer(36160 /* FRAMEBUFFER */, 36064 /* COLOR_ATTACHMENT0 */, 36161 /* RENDERBUFFER */, null);

                // Restore old framebuffer
                pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pOldFramebuffer);
                if (pSource !== this) {
                    pWebGLRenderer.deleteWebGLTexture(pTempWebGLTexture);
                }
                pWebGLRenderer.deleteWebGLFramebuffer(pFramebuffer);

                pTempWebGLTexture = null;
                this.notifyAltered();

                return true;
            };

            WebGLTextureBuffer.prototype.blitFromMemory = function () {
                if (arguments.length === 1) {
                    return _super.prototype.blitFromMemory.call(this, arguments[0]);
                }

                // Fall back to normal GLHardwarePixelBuffer::blitFromMemory in case
                // - FBO is not supported
                // - Either source or target is luminance due doesn't looks like supported by hardware
                // - the source dimensions match the destination ones, in which case no scaling is needed
                // TODO: Check that extension is NOT available
                var pSourceOrigin = arguments[0];
                var pDestBox = arguments[1];

                if (akra.pixelUtil.isLuminance(pSourceOrigin.format) || akra.pixelUtil.isLuminance(this._eFormat) || (pSourceOrigin.getWidth() === pDestBox.getWidth() && pSourceOrigin.getHeight() === pDestBox.getHeight() && pSourceOrigin.getDepth() === pDestBox.getDepth())) {
                    return _super.prototype.blitFromMemory.call(this, pSourceOrigin, pDestBox);
                }

                if (!this._pBuffer.contains(pDestBox)) {
                    akra.logger.critical("Destination box out of range");
                }

                var pSource;

                // First, convert the srcbox to a OpenGL compatible pixel format
                if (webgl.getWebGLFormat(pSourceOrigin.format) === 0) {
                    // Convert to buffer internal format
                    var iSizeInBytes = akra.pixelUtil.getMemorySize(pSourceOrigin.getWidth(), pSourceOrigin.getHeight(), pSourceOrigin.getDepth(), this._eFormat);
                    pSource = new akra.pixelUtil.PixelBox(pSourceOrigin.getWidth(), pSourceOrigin.getHeight(), pSourceOrigin.getDepth(), this._eFormat, new Uint8Array(iSizeInBytes));

                    akra.pixelUtil.bulkPixelConversion(pSourceOrigin, pSource);
                } else {
                    // No conversion needed
                    pSource = pSourceOrigin;
                }

                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                // Create temporary texture to store source data
                var pTempWebGLTexture = null;
                var eTarget = 3553 /* TEXTURE_2D */;
                var iWidth = akra.math.ceilingPowerOfTwo(pSource.getWidth());
                var iHeight = akra.math.ceilingPowerOfTwo(pSource.getHeight());
                var iWebGLFormat = webgl.getClosestWebGLInternalFormat(pSource.format);
                var iWebGLDataType = webgl.getWebGLDataType(pSource.format);

                pTempWebGLTexture = pWebGLRenderer.createWebGLTexture();

                if (akra.isNull(pTempWebGLTexture)) {
                    akra.logger.error("Can not create WebGL texture");
                    return false;
                }

                pWebGLRenderer.bindWebGLTexture(eTarget, pTempWebGLTexture);
                pWebGLContext.texImage2D(eTarget, 0, iWebGLFormat, iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, null);
                pWebGLRenderer.bindWebGLTexture(eTarget, null);

                var pTextureBufferPool = this.getManager().getTextureBufferPool();
                var pTempTexBuffer = pTextureBufferPool.createResource(".temp");

                // var pTempTexBuffer: WebGLTextureBuffer = <WebGLTextureBuffer>pTextureBufferPool.findResource(".temp");
                // if(isNull(pTextureBufferPool)){
                //  pTempTexBuffer = <WebGLTextureBuffer>pTextureBufferPool.createResource(".temp");
                // }
                pTempTexBuffer.create(eTarget, pTempWebGLTexture, iWidth, iHeight, iWebGLFormat, pSource.format, 0, 0, 256 /* AUTOMIPMAP */ | 1 /* STATIC */, false);

                // Upload data to 0,0,0 in temporary texture
                var pTempBoxTarget = new akra.geometry.Box(0, 0, 0, pSource.getWidth(), pSource.getHeight(), pSource.getDepth());
                pTempTexBuffer.upload(pSource, pTempBoxTarget);

                //Blit
                this.blitFromTexture(pTempTexBuffer, pTempBoxTarget, pDestBox);

                //Delete temp data
                pTempTexBuffer.release();
                pTextureBufferPool.destroyResource(pTempTexBuffer);

                pWebGLRenderer.deleteWebGLTexture(pTempWebGLTexture);
                pTempWebGLTexture = null;
                pTempBoxTarget = null;

                return true;
            };

            WebGLTextureBuffer.prototype.getRenderTarget = function (iZOffest) {
                if (typeof iZOffest === "undefined") { iZOffest = 0; }
                akra.logger.assert(akra.bf.testAny(this._iFlags, 512 /* RENDERTARGET */));
                akra.logger.assert(iZOffest < this._iDepth, "iZOffest: " + iZOffest + ", iDepth: " + this._iDepth);
                return this._pRTTList[iZOffest];
            };

            WebGLTextureBuffer.prototype.resize = function (iWidth, iHeight) {
                if (typeof iHeight === "undefined") { iHeight = iWidth; }
                if (arguments.length === 1) {
                    akra.logger.critical("resize with one parametr not available for WebGLTextureBuffer");
                    return false;
                }
                var pSrcBox = akra.geometry.Box.temp(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
                var pDestBox = akra.geometry.Box.temp(0, 0, 0, iWidth, iHeight, this._iDepth);

                return this.blitFromTexture(this, pSrcBox, pDestBox);
            };
            return WebGLTextureBuffer;
        })(webgl.WebGLPixelBuffer);
        webgl.WebGLTextureBuffer = WebGLTextureBuffer;
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
/// <reference path="../idl/IRenderer.ts" />
/// <reference path="../idl/IResourcePool.ts" />
/// <reference path="../idl/IColor.ts" />
/// <reference path="../idl/IPixelBuffer.ts" />
var akra;
(function (akra) {
    /// <reference path="../pool/resources/Texture.ts" />
    /// <reference path="../math/math.ts" />
    /// <reference path="webgl.ts" />
    /// <reference path="WebGLTextureBuffer.ts" />
    (function (webgl) {
        var WebGLInternalTexture = (function (_super) {
            __extends(WebGLInternalTexture, _super);
            function WebGLInternalTexture() {
                _super.call(this);
                this._pSurfaceList = null;
                this._pWebGLTexture = null;
            }
            WebGLInternalTexture.prototype.getWebGLTexture = function () {
                return this._pWebGLTexture;
            };

            WebGLInternalTexture.prototype._getWebGLTextureTarget = function () {
                switch (this._eTextureType) {
                    case 3553 /* TEXTURE_2D */:
                        return 3553 /* TEXTURE_2D */;
                    case 34067 /* TEXTURE_CUBE_MAP */:
                        return 34067 /* TEXTURE_CUBE_MAP */;
                    default:
                        return 0;
                }
            };

            WebGLInternalTexture.prototype._getWebGLTextureParameter = function (eParam) {
                switch (eParam) {
                    case 10240 /* MAG_FILTER */:
                        return 10240 /* TEXTURE_MAG_FILTER */;
                    case 10241 /* MIN_FILTER */:
                        return 10241 /* TEXTURE_MIN_FILTER */;
                    case 10242 /* WRAP_S */:
                        return 10242 /* TEXTURE_WRAP_S */;
                    case 10243 /* WRAP_T */:
                        return 10243 /* TEXTURE_WRAP_T */;
                    default:
                        return 0;
                }
            };

            WebGLInternalTexture.prototype._getWebGLTextureParameterValue = function (eValue) {
                switch (eValue) {
                    case 9728 /* NEAREST */:
                        return 9728 /* NEAREST */;
                    case 9729 /* LINEAR */:
                        return 9729 /* LINEAR */;
                    case 9984 /* NEAREST_MIPMAP_NEAREST */:
                        return 9984 /* NEAREST_MIPMAP_NEAREST */;
                    case 9985 /* LINEAR_MIPMAP_NEAREST */:
                        return 9985 /* LINEAR_MIPMAP_NEAREST */;
                    case 9986 /* NEAREST_MIPMAP_LINEAR */:
                        return 9986 /* NEAREST_MIPMAP_LINEAR */;
                    case 9987 /* LINEAR_MIPMAP_LINEAR */:
                        return 9987 /* LINEAR_MIPMAP_LINEAR */;

                    case 10497 /* REPEAT */:
                        return 10497 /* REPEAT */;
                    case 33071 /* CLAMP_TO_EDGE */:
                        return 33071 /* CLAMP_TO_EDGE */;
                    case 33648 /* MIRRORED_REPEAT */:
                        return 33648 /* MIRRORED_REPEAT */;
                    default:
                        return 0;
                }
            };

            WebGLInternalTexture.prototype._getAkraTextureParameterValue = function (iWebGLValue) {
                switch (iWebGLValue) {
                    case 9728 /* NEAREST */:
                        return 9728 /* NEAREST */;
                    case 9729 /* LINEAR */:
                        return 9729 /* LINEAR */;
                    case 9984 /* NEAREST_MIPMAP_NEAREST */:
                        return 9984 /* NEAREST_MIPMAP_NEAREST */;
                    case 9985 /* LINEAR_MIPMAP_NEAREST */:
                        return 9985 /* LINEAR_MIPMAP_NEAREST */;
                    case 9986 /* NEAREST_MIPMAP_LINEAR */:
                        return 9986 /* NEAREST_MIPMAP_LINEAR */;
                    case 9987 /* LINEAR_MIPMAP_LINEAR */:
                        return 9987 /* LINEAR_MIPMAP_LINEAR */;

                    case 10497 /* REPEAT */:
                        return 10497 /* REPEAT */;
                    case 33071 /* CLAMP_TO_EDGE */:
                        return 33071 /* CLAMP_TO_EDGE */;
                    case 33648 /* MIRRORED_REPEAT */:
                        return 33648 /* MIRRORED_REPEAT */;
                    default:
                        return 0;
                }
            };

            WebGLInternalTexture.prototype.reset = function (iWidth, iHeight) {
                if (typeof iWidth === "undefined") { iWidth = this._iWidth; }
                if (typeof iHeight === "undefined") { iHeight = iWidth; }
                _super.prototype.reset.call(this, iWidth, iHeight);

                for (var i = 0; i < this._pSurfaceList.length; i++) {
                    this._pSurfaceList[i].reset(iWidth, iHeight);
                }
            };

            WebGLInternalTexture.prototype._setFilterInternalTexture = function (eParam, eValue) {
                if (!this.isValid()) {
                    return false;
                }

                var iWebGLTarget = this._getWebGLTextureTarget();
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);
                pWebGLContext.texParameteri(iWebGLTarget, this._getWebGLTextureParameter(eParam), this._getWebGLTextureParameterValue(eValue));

                // var e = pWebGLContext.getError();if (e){LOG(this.findResourceName(), "filter: ", eParam, "value: ", eValue, "error: ", e)};
                return true;
            };
            WebGLInternalTexture.prototype._setWrapModeInternalTexture = function (eParam, eValue) {
                if (!this.isValid()) {
                    return false;
                }

                var iWebGLTarget = this._getWebGLTextureTarget();
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);
                pWebGLContext.texParameteri(iWebGLTarget, this._getWebGLTextureParameter(eParam), this._getWebGLTextureParameterValue(eValue));
                return true;
            };

            WebGLInternalTexture.prototype._getFilterInternalTexture = function (eParam) {
                if (!this.isValid()) {
                    return 0;
                }
                var iWebGLTarget = this._getWebGLTextureTarget();
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);
                return this._getAkraTextureParameterValue(pWebGLContext.getTexParameter(iWebGLTarget, this._getWebGLTextureParameter(eParam)));
            };

            WebGLInternalTexture.prototype._createInternalTextureImpl = function (cFillColor) {
                if (typeof cFillColor === "undefined") { cFillColor = null; }
                if (!akra.isNull(cFillColor)) {
                    akra.logger.warn("Texture can create with filled only by default(black) color");
                    //TODO: must implement filling by color
                }

                var pWebGLRenderer = this.getManager().getEngine().getRenderer();

                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                if (this._eTextureType == 3553 /* TEXTURE_2D */) {
                    if (this._iWidth > webgl.maxTextureSize) {
                        akra.logger.warn("Заданная ширина не поддерживается(" + this._iWidth + ")");
                        this._iWidth = webgl.maxTextureSize;
                    }
                    if (this._iHeight > webgl.maxTextureSize) {
                        akra.logger.warn("Заданная высота не поддерживается(" + this._iHeight + ")");
                        this._iHeight = webgl.maxTextureSize;
                    }
                } else if (this._eTextureType == 34067 /* TEXTURE_CUBE_MAP */) {
                    if (this._iWidth > webgl.maxCubeMapTextureSize) {
                        akra.logger.warn("Заданная ширина не поддерживается(" + this._iWidth + ")");
                        this._iWidth = webgl.maxCubeMapTextureSize;
                    }
                    if (this._iHeight > webgl.maxCubeMapTextureSize) {
                        akra.logger.warn("Заданная высота не поддерживается(" + this._iHeight + ")");
                        this._iHeight = webgl.maxCubeMapTextureSize;
                    }
                }

                if (this._iWidth == 0) {
                    akra.logger.warn("Заданная ширина не поддерживается(" + this._iWidth + ")");
                    this._iWidth = 1;
                }
                if (this._iHeight == 0) {
                    akra.logger.warn("Заданная высота не поддерживается(" + this._iHeight + ")");
                    this._iHeight = 1;
                }
                if (this._iDepth != 1) {
                    this._iDepth = 1;
                    akra.logger.warn("Трехмерные текстуры не поддерживаются, сброс глубины в 1");
                }
                if (this._nMipLevels != 0 && !webgl.hasExtension(webgl.EXT_TEXTURE_NPOT_2D_MIPMAP) && (!akra.math.isPowerOfTwo(this._iDepth) || !akra.math.isPowerOfTwo(this._iHeight) || !akra.math.isPowerOfTwo(this._iWidth))) {
                    akra.logger.warn("Мип мапы у текстуры не стпени двойки не поддерживаются, сброс мипмапов в 0");
                    this._nMipLevels = 0;
                    this._iFlags = akra.bf.clearAll(this._iFlags, 256 /* AUTOMIPMAP */);
                }

                if (!webgl.isWebGLFormatSupport(this._eFormat)) {
                    akra.logger.warn("Данный тип текстуры не поддерживается: ", this._eFormat);
                    this._eFormat = 13 /* A8B8G8R8 */;
                }

                if (this._nMipLevels != 0 && this._nMipLevels !== akra.pool.resources.Img.getMaxMipmaps(this._iWidth, this._iHeight, this._iDepth, this._eFormat)) {
                    akra.logger.warn("Нехватает мипмапов, сброс в 0");
                    this._nMipLevels = 0;
                }

                // Convert to nearest power-of-two size if required
                //this._iWidth = math.ceilingPowerOfTwo(this._iWidth);
                //this._iHeight = math.ceilingPowerOfTwo(this._iHeight);
                //this._iDepth = math.ceilingPowerOfTwo(this._iDepth);
                var iWebGLTarget = this._getWebGLTextureTarget();

                this._pWebGLTexture = pWebGLRenderer.createWebGLTexture();

                pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);

                this._isMipmapsHardwareGenerated = pWebGLRenderer.hasCapability(akra.ERenderCapabilities.AUTOMIPMAP);

                // Set some misc default parameters, these can of course be changed later
                var eMinFiler = this.getFilter(10241 /* MIN_FILTER */);
                var eMagFiler = this.getFilter(10240 /* MAG_FILTER */);

                if ((eMinFiler >= 9984 /* NEAREST_MIPMAP_NEAREST */ && eMinFiler <= 9987 /* LINEAR_MIPMAP_LINEAR */) && this._nMipLevels < 2) {
                    eMinFiler = 9729 /* LINEAR */;
                }

                if ((eMagFiler >= 9984 /* NEAREST_MIPMAP_NEAREST */ && eMagFiler <= 9987 /* LINEAR_MIPMAP_LINEAR */) && this._nMipLevels < 2) {
                    eMagFiler = 9729 /* LINEAR */;
                }

                // LOG("e: ", pWebGLContext.getError(), this.findResourceName(), "n mipmaps: ", this._nMipLevels, "size (x, y):", this._iWidth, this._iHeight, "min filer > ", "(0x", eMinFiler.toString(16), ")");
                this.setFilter(10241 /* MIN_FILTER */, eMinFiler);
                this.setFilter(10240 /* MAG_FILTER */, eMagFiler);
                this.setWrapMode(10242 /* WRAP_S */, this.getWrapMode(10242 /* WRAP_S */));
                this.setWrapMode(10243 /* WRAP_T */, this.getWrapMode(10243 /* WRAP_T */));

                pWebGLContext.texParameteri(iWebGLTarget, this._getWebGLTextureParameter(10241 /* MIN_FILTER */), eMinFiler);
                pWebGLContext.texParameteri(iWebGLTarget, this._getWebGLTextureParameter(10240 /* MAG_FILTER */), eMagFiler);
                pWebGLContext.texParameteri(iWebGLTarget, this._getWebGLTextureParameter(10242 /* WRAP_S */), this.getWrapMode(10242 /* WRAP_S */));
                pWebGLContext.texParameteri(iWebGLTarget, this._getWebGLTextureParameter(10243 /* WRAP_T */), this.getWrapMode(10243 /* WRAP_T */));

                var iWebGLFormat = webgl.getWebGLFormat(this._eFormat);
                var iWebGLDataType = webgl.getWebGLDataType(this._eFormat);
                var iWidth = this._iWidth;
                var iHeight = this._iHeight;
                var iDepth = this._iDepth;

                if (akra.pixelUtil.isCompressed(this._eFormat)) {
                    // Compressed formats
                    var iSize = akra.pixelUtil.getMemorySize(iWidth, iHeight, iDepth, this._eFormat);

                    // Provide temporary buffer filled with zeroes as glCompressedTexImageXD does not
                    // accept a 0 pointer like normal glTexImageXD
                    // Run through this process for every mipmap to pregenerate mipmap pyramid
                    var pTmpData = new Uint8Array(iSize);
                    var pEmptyData;
                    var mip = 0;

                    for (mip = 0; mip <= this._nMipLevels; mip++) {
                        iSize = akra.pixelUtil.getMemorySize(iWidth, iHeight, iDepth, this._eFormat);

                        //console.log(iSize,iWidth, iHeight, iDepth, this._eFormat);
                        pEmptyData = pTmpData.subarray(0, iSize);
                        switch (this._eTextureType) {
                            case 3553 /* TEXTURE_2D */:
                                //debug.log(gl.TEXTURE_2D, mip, EPixelFormats[this._eFormat] + " (" + iWebGLFormat + ")",
                                //	iWidth, iHeight, 0, null);
                                pWebGLContext.compressedTexImage2D(3553 /* TEXTURE_2D */, mip, iWebGLFormat, iWidth, iHeight, 0, pEmptyData);
                                break;
                            case 34067 /* TEXTURE_CUBE_MAP */:
                                var iFace = 0;
                                for (iFace = 0; iFace < 6; iFace++) {
                                    pWebGLContext.compressedTexImage2D(34069 /* TEXTURE_CUBE_MAP_POSITIVE_X */ + iFace, mip, iWebGLFormat, iWidth, iHeight, 0, pEmptyData);
                                }
                                break;
                            default:
                                break;
                        }
                        ;
                        if (iWidth > 1)
                            iWidth = iWidth / 2;
                        if (iHeight > 1)
                            iHeight = iHeight / 2;
                        if (iDepth > 1)
                            iDepth = iDepth / 2;
                    }
                    pTmpData = null;
                    pEmptyData = null;
                } else {
                    var mip = 0;

                    for (mip = 0; mip <= this._nMipLevels; mip++) {
                        switch (this._eTextureType) {
                            case 3553 /* TEXTURE_2D */:
                                //debug.log(gl.TEXTURE_2D, mip, EPixelFormats[this._eFormat] + " (" + iWebGLFormat + ")",
                                //	iWidth, iHeight, 0, EPixelFormats[this._eFormat] + " (" + iWebGLFormat + ")", EPixelComponentTypes[pixelUtil.getComponentType(this._eFormat)] + " (" + iWebGLDataType+ ")", null);
                                pWebGLContext.texImage2D(3553 /* TEXTURE_2D */, mip, iWebGLFormat, iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, null);
                                break;
                            case 34067 /* TEXTURE_CUBE_MAP */:
                                var iFace = 0;
                                for (iFace = 0; iFace < 6; iFace++) {
                                    pWebGLContext.texImage2D(34069 /* TEXTURE_CUBE_MAP_POSITIVE_X */ + iFace, mip, iWebGLFormat, iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, null);
                                }
                                break;
                            default:
                                break;
                        }

                        if (iWidth > 1)
                            iWidth = iWidth >>> 1;
                        if (iHeight > 1)
                            iHeight = iHeight >>> 1;
                        if (iDepth > 1)
                            iDepth = iDepth >>> 1;
                    }
                }

                this._createSurfaceList();
                pWebGLRenderer.bindWebGLTexture(iWebGLTarget, null);

                return true;
            };

            WebGLInternalTexture.prototype.freeInternalTextureImpl = function () {
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                pWebGLRenderer.deleteWebGLTexture(this._pWebGLTexture);
                this._pWebGLTexture = null;

                for (var i = 0; i < this._pSurfaceList.length; i++) {
                    this._pSurfaceList[i].release();
                }

                this._pSurfaceList = null;

                return true;
            };

            WebGLInternalTexture.prototype._createSurfaceList = function () {
                this._pSurfaceList = new Array();

                // For all faces and mipmaps, store surfaces as IPixelBuffer
                var bWantGeneratedMips = akra.bf.testAny(this._iFlags, 256 /* AUTOMIPMAP */);

                // Do mipmapping in software? (uses GLU) For some cards, this is still needed. Of course,
                // only when mipmap generation is desired.
                var bDoSoftware = bWantGeneratedMips && !this._isMipmapsHardwareGenerated && this._nMipLevels !== 0;

                var iFace = 0;
                var mip = 0;
                var pTextureBufferPool = this.getManager().getTextureBufferPool();
                var sResourceName = this.findResourceName();

                for (iFace = 0; iFace < this.getNumFaces(); iFace++) {
                    var iWidth = this._iWidth;
                    var iHeight = this._iHeight;

                    for (mip = 0; mip <= this._nMipLevels; mip++) {
                        var pBuf = pTextureBufferPool.createResource(sResourceName + "_" + iFace + "_" + mip);

                        pBuf.create(this._getWebGLTextureTarget(), this._pWebGLTexture, iWidth, iHeight, webgl.getClosestWebGLInternalFormat(this._eFormat), webgl.getWebGLDataType(this._eFormat), iFace, mip, this._iFlags, bDoSoftware && mip === 0);

                        this._pSurfaceList.push(pBuf);

                        //check error
                        if (pBuf.getWidth() === 0 || pBuf.getHeight() === 0 || pBuf.getDepth() === 0) {
                            akra.logger.critical("Zero sized texture surface on texture " + sResourceName + " face " + iFace + " mipmap " + mip + ". The GL driver probably refused to create the texture.");
                        }
                    }
                }
            };

            WebGLInternalTexture.prototype.getBuffer = function (iFace, iMipmap) {
                if (typeof iFace === "undefined") { iFace = 0; }
                if (typeof iMipmap === "undefined") { iMipmap = 0; }
                if (iFace >= this.getNumFaces()) {
                    akra.logger.critical("Face index out of range", iFace, this.getNumFaces());
                }

                if (iMipmap > this._nMipLevels) {
                    akra.logger.critical("Mipmap index out of range", iMipmap, this._nMipLevels);
                }

                var idx = iFace * (this._nMipLevels + 1) + iMipmap;
                akra.logger.assert(idx < this._pSurfaceList.length, "smth " + this._pSurfaceList.length + " , " + iFace + " , " + this._nMipLevels + " , " + iMipmap);

                return this._pSurfaceList[idx];
            };

            WebGLInternalTexture.prototype.createRenderTexture = function () {
                // Create the GL texture
                // This already does everything necessary
                return this.createInternalTexture();
            };
            return WebGLInternalTexture;
        })(akra.pool.resources.Texture);
        webgl.WebGLInternalTexture = WebGLInternalTexture;
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    /// <reference path="../render/Viewport.ts" />
    /// <reference path="WebGLRenderer.ts" />
    /// <reference path="WebGLInternalTexture.ts" />
    /// <reference path="../math/Vec2.ts" />
    (function (webgl) {
        var Vec2 = akra.math.Vec2;

        var sFloatToVec4Func = "\
			vec4 floatToVec4(float value){						\n\
				float data = value;								\n\
				vec4 result = vec4(0.);							\n\
																\n\
				if(data == 0.){									\n\
					float signedZeroTest = 1./value;			\n\
					if(signedZeroTest < 0.){					\n\
						result.x = 128.;						\n\
					}											\n\
					return result/255.;							\n\
				}												\n\
																\n\
				if(data < 0.){									\n\
					result.x=128.;								\n\
					data = -data;								\n\
				}												\n\
																\n\
				float power = 0.;								\n\
				bool isFinish = false;							\n\
																\n\
				for(int i = 0; i < 128; i++) {					\n\
				  if(isFinish){									\n\
					break;										\n\
				  }												\n\
																\n\
				  if(data >= 2.) {								\n\
					if(!isFinish){								\n\
					  data = data * 0.5;						\n\
					  power += 1.;								\n\
					  if (power == 127.) {						\n\
						isFinish = true;						\n\
					  }											\n\
					}											\n\
				  }												\n\
				  else if(data < 1.) {							\n\
					if(!isFinish){								\n\
					  data = data * 2.;							\n\
					  power -= 1.;								\n\
					  if (power == -126.) {						\n\
						isFinish = true;						\n\
					  }											\n\
					}											\n\
				  }												\n\
				  else {										\n\
					isFinish = true;							\n\
				  }												\n\
				}												\n\
																\n\
				if(power == -126. && data < 1.){				\n\
					power = 0.;									\n\
				}												\n\
				else{											\n\
					power = power+127.;							\n\
					data = data - 1.;							\n\
				}												\n\
																\n\
				result.x+=floor(power/2.);						\n\
				result.y = mod(power,2.)*128.;					\n\
																\n\
				data *= 128.;									\n\
																\n\
				result.y += floor(data);						\n\
																\n\
				data -= floor(data);							\n\
				data *= 256.;									\n\
																\n\
				result.z = floor(data);							\n\
																\n\
				data -= floor(data);							\n\
				data *= 256.;									\n\
																\n\
				result.w = floor(data);							\n\
																\n\
				return result/255.;								\n\
			}													\n";

        var sPixelCode = "										\n\
				precision highp float;								\n\
				varying vec2 texPosition;							\n\
																	\n\
				uniform sampler2D srcTexture;						\n\
				uniform vec2 halfSrcTexureStep;						\n\
				uniform int selector;								\n\
																	\n\
				" + sFloatToVec4Func + "							\n\
																	\n\
				void main(void) {  									\n\
					if(selector == 0){								\n\
						float depth_NW = texture2D(srcTexture, texPosition + vec2(-halfSrcTexureStep.x, halfSrcTexureStep.y)).x;	\n\
						float depth_NE = texture2D(srcTexture, texPosition + vec2(halfSrcTexureStep.x, halfSrcTexureStep.y)).x;		\n\
						float depth_SW = texture2D(srcTexture, texPosition + vec2(-halfSrcTexureStep.x, -halfSrcTexureStep.y)).x;	\n\
						float depth_SE = texture2D(srcTexture, texPosition + vec2(halfSrcTexureStep.x, -halfSrcTexureStep.y)).x;	\n\
																																	\n\
						float fMaxDepth = -1.;														\n\
						float fMinDepth = min(depth_NW, min(depth_NE, min(depth_SW, depth_SE)));	\n\
																									\n\
						if(depth_NW != 1.){ //clear Depth value										\n\
							fMaxDepth = max(fMaxDepth, depth_NW);									\n\
						}																			\n\
						if(depth_NE != 1.){ //clear Depth value										\n\
							fMaxDepth = max(fMaxDepth, depth_NE);									\n\
						}																			\n\
						if(depth_SW != 1.){ //clear Depth value										\n\
							fMaxDepth = max(fMaxDepth, depth_SW);									\n\
						}																			\n\
						if(depth_SE != 1.){ //clear Depth value										\n\
							fMaxDepth = max(fMaxDepth, depth_SE);									\n\
						}																			\n\
																									\n\
						if(fMaxDepth == -1.){														\n\
							fMaxDepth = 1.;															\n\
						}																			\n\
																									\n\
						gl_FragColor = vec4(fMaxDepth, fMinDepth, 0., 1.);							\n\
					}																				\n\
					else if(selector == 1){															\n\
						vec2 depth_NW = texture2D(srcTexture, texPosition + vec2(-halfSrcTexureStep.x, halfSrcTexureStep.y)).xy;	\n\
						vec2 depth_NE = texture2D(srcTexture, texPosition + vec2(halfSrcTexureStep.x, halfSrcTexureStep.y)).xy;		\n\
						vec2 depth_SW = texture2D(srcTexture, texPosition + vec2(-halfSrcTexureStep.x, -halfSrcTexureStep.y)).xy;	\n\
						vec2 depth_SE = texture2D(srcTexture, texPosition + vec2(halfSrcTexureStep.x, -halfSrcTexureStep.y)).xy;	\n\
																																	\n\
						//x - max depth 																							\n\
						//y - min depth 																							\n\
																																	\n\
						float fMaxDepth = -1.;																						\n\
						float fMinDepth = min(depth_NW.y, min(depth_NE.y, min(depth_SW.y, depth_SE.y)));							\n\
																																	\n\
						if(depth_NW.x != 1.){ //clear Depth value																	\n\
							fMaxDepth = max(fMaxDepth, depth_NW.x);																	\n\
						}																											\n\
						if(depth_NE.x != 1.){ //clear Depth value																	\n\
							fMaxDepth = max(fMaxDepth, depth_NE.x);																	\n\
						}																											\n\
						if(depth_SW.x != 1.){ //clear Depth value																	\n\
							fMaxDepth = max(fMaxDepth, depth_SW.x);																	\n\
						}																											\n\
						if(depth_SE.x != 1.){ //clear Depth value																	\n\
							fMaxDepth = max(fMaxDepth, depth_SE.x);																	\n\
						}																											\n\
																																	\n\
						if(fMaxDepth == -1.){																						\n\
							fMaxDepth = 1.;																							\n\
						}																											\n\
																																	\n\
						gl_FragColor = vec4(fMaxDepth, fMinDepth, 0., 1.);															\n\
					}																												\n\
					else{																											\n\
						// 1x1 float texture with depth to two point with decomposed float 											\n\
						vec2 depth = texture2D(srcTexture, vec2(0.5, 0.5)).xy;														\n\
						if(texPosition.x < 0.5){																					\n\
							//first pixel																							\n\
							vec4 value = floatToVec4(depth.x);																		\n\
							gl_FragColor = vec4(value.w, value.b, value.g, value.r);												\n\
						}																											\n\
						else{																										\n\
							//second pixel																							\n\
							vec4 value = floatToVec4(depth.y);																		\n\
							gl_FragColor = vec4(value.w, value.b, value.g, value.r);												\n\
						}																											\n\
					}																												\n\
				}                                   																				\n\
				";

        var sVertexCode = "																						\n\
				attribute vec2 POSITION;																			\n\
																													\n\
				varying vec2 texPosition;																			\n\
																													\n\
				void main(void){																					\n\
					texPosition = (POSITION + 1.)/2.;																\n\
					gl_Position = vec4(POSITION, 0., 1.);															\n\
				}																									\n\
				";

        var pF32ScreenCoords = new Float32Array([-1, -1, -1, 1, 1, -1, 1, 1]);
        var pU8Destination = new Uint8Array(8);
        var pF32Destination = new Float32Array(pU8Destination.buffer);

        function getDepthRange(pDepthTexture) {
            var pEngine = pDepthTexture.getEngine();
            var pResourceManager = pEngine.getResourceManager();
            var pWebGLRenderer = pEngine.getRenderer();
            var pWebGLContext = pWebGLRenderer.getWebGLContext();

            var pWebGLDepthTexture = pDepthTexture.getWebGLTexture();

            var pWebGLProgram = pResourceManager.getShaderProgramPool().findResource(".WEBGL_depth_range");

            if (akra.isNull(pWebGLProgram)) {
                pWebGLProgram = pResourceManager.getShaderProgramPool().createResource(".WEBGL_depth_range");

                pWebGLProgram.create(sVertexCode, sPixelCode);
            }

            var pOldFrameBuffer = pWebGLRenderer.getParameter(36006 /* FRAMEBUFFER_BINDING */);

            var pWebGLFramebuffer = pWebGLRenderer.createWebGLFramebuffer();

            pWebGLRenderer.disableAllWebGLVertexAttribs();

            pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pWebGLFramebuffer);
            pWebGLRenderer.useWebGLProgram(pWebGLProgram.getWebGLProgram());

            pWebGLRenderer.disable(2929 /* DEPTH_TEST */);
            pWebGLRenderer.disable(3089 /* SCISSOR_TEST */);
            pWebGLRenderer.disable(3042 /* BLEND */);
            pWebGLRenderer.disable(2884 /* CULL_FACE */);

            var iPositionAttribLocation = pWebGLProgram.getWebGLAttributeLocation("POSITION");

            pWebGLContext.enableVertexAttribArray(iPositionAttribLocation);

            var pPositionBuffer = pWebGLContext.createBuffer();
            pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, pPositionBuffer);
            pWebGLContext.bufferData(34962 /* ARRAY_BUFFER */, pF32ScreenCoords, 35044 /* STATIC_DRAW */);
            pWebGLContext.vertexAttribPointer(iPositionAttribLocation, 2, 5126 /* FLOAT */, false, 0, 0);

            var iSrcTextureSizeX = pDepthTexture.getWidth();
            var iSrcTextureSizeY = pDepthTexture.getHeight();

            var pWebGLTexture1 = pWebGLContext.createTexture();
            var pWebGLTexture2 = pWebGLContext.createTexture();

            var pWebGLRenderTexture = pWebGLTexture1;
            var pWebGLSrcTexture = pWebGLDepthTexture;

            var iSelector = 0;

            var iRenderTextureSizeX = 0;
            var iRenderTextureSizeY = 0;

            if (iSrcTextureSizeX == 1 && iSrcTextureSizeY == 1) {
                iSelector = 2;

                iRenderTextureSizeX = 2;
                iRenderTextureSizeY = 1;

                pWebGLRenderer.activateWebGLTexture(33984 /* TEXTURE0 */);
                pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, pWebGLRenderTexture);

                pWebGLContext.texImage2D(3553 /* TEXTURE_2D */, 0, 6408 /* RGBA */, 2, 1, 0, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */, null);
            } else {
                iSelector = 0;

                iRenderTextureSizeX = akra.math.pow(2, akra.math.floor(akra.math.log(iSrcTextureSizeX) / akra.math.log(2)));
                iRenderTextureSizeY = akra.math.pow(2, akra.math.floor(akra.math.log(iSrcTextureSizeY) / akra.math.log(2)));

                if (iRenderTextureSizeX == iSrcTextureSizeX) {
                    iRenderTextureSizeX = iSrcTextureSizeX / 2;
                }
                if (iRenderTextureSizeY == iSrcTextureSizeY) {
                    iRenderTextureSizeY = iSrcTextureSizeY / 2;
                }

                if (iRenderTextureSizeX > iRenderTextureSizeY) {
                    iRenderTextureSizeY = iRenderTextureSizeX;
                } else {
                    iRenderTextureSizeX = iRenderTextureSizeY;
                }

                pWebGLRenderer.activateWebGLTexture(33984 /* TEXTURE0 */);
                pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, pWebGLRenderTexture);

                pWebGLContext.texImage2D(3553 /* TEXTURE_2D */, 0, 6408 /* RGBA */, iRenderTextureSizeX, iRenderTextureSizeY, 0, 6408 /* RGBA */, 5126 /* FLOAT */, null);
            }

            do {
                pWebGLRenderer.activateWebGLTexture(33985 /* TEXTURE1 */);
                pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, pWebGLRenderTexture);
                pWebGLContext.texParameteri(3553 /* TEXTURE_2D */, 10242 /* TEXTURE_WRAP_S */, 33071 /* CLAMP_TO_EDGE */);
                pWebGLContext.texParameteri(3553 /* TEXTURE_2D */, 10243 /* TEXTURE_WRAP_T */, 33071 /* CLAMP_TO_EDGE */);
                pWebGLContext.texParameteri(3553 /* TEXTURE_2D */, 10241 /* TEXTURE_MIN_FILTER */, 9728 /* NEAREST */);
                pWebGLContext.texParameteri(3553 /* TEXTURE_2D */, 10240 /* TEXTURE_MAG_FILTER */, 9728 /* NEAREST */);

                pWebGLContext.framebufferTexture2D(36160 /* FRAMEBUFFER */, 36064 /* COLOR_ATTACHMENT0 */, 3553 /* TEXTURE_2D */, pWebGLRenderTexture, 0);

                pWebGLRenderer.activateWebGLTexture(33984 /* TEXTURE0 */);
                pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, pWebGLSrcTexture);

                pWebGLProgram.setInt("selector", iSelector);
                pWebGLProgram.setInt("srcTexture", 0);
                pWebGLProgram.setVec2("halfSrcTexureStep", Vec2.temp(0.5 / iSrcTextureSizeX, 0.5 / iSrcTextureSizeY));

                pWebGLContext.viewport(0, 0, iRenderTextureSizeX, iRenderTextureSizeY);

                pWebGLContext.drawArrays(5 /* TRIANGLE_STRIP */, 0, 4);

                if (iSelector == 2) {
                    break;
                }

                iSelector = 1;

                if (iRenderTextureSizeX === 1 && iRenderTextureSizeY === 1) {
                    iSelector = 2;

                    iRenderTextureSizeX = 2;
                    iRenderTextureSizeY = 1;

                    pWebGLSrcTexture = pWebGLRenderTexture;

                    pWebGLRenderTexture = (pWebGLRenderTexture === pWebGLTexture1) ? pWebGLTexture2 : pWebGLTexture1;

                    pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, pWebGLRenderTexture);

                    pWebGLContext.texImage2D(3553 /* TEXTURE_2D */, 0, 6408 /* RGBA */, iRenderTextureSizeX, iRenderTextureSizeY, 0, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */, null);
                } else {
                    iSrcTextureSizeX = iRenderTextureSizeX;
                    iSrcTextureSizeY = iRenderTextureSizeY;

                    iRenderTextureSizeX = iSrcTextureSizeX / 2;
                    iRenderTextureSizeY = iSrcTextureSizeY / 2;

                    pWebGLSrcTexture = pWebGLRenderTexture;

                    pWebGLRenderTexture = (pWebGLRenderTexture === pWebGLTexture1) ? pWebGLTexture2 : pWebGLTexture1;

                    pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, pWebGLRenderTexture);

                    pWebGLContext.texImage2D(3553 /* TEXTURE_2D */, 0, 6408 /* RGBA */, iRenderTextureSizeX, iRenderTextureSizeY, 0, 6408 /* RGBA */, 5126 /* FLOAT */, null);
                }
            } while(1);

            pWebGLContext.readPixels(0, 0, 2, 1, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */, pU8Destination);

            pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pOldFrameBuffer);
            pWebGLRenderer.deleteWebGLFramebuffer(pWebGLFramebuffer);

            pWebGLContext.disableVertexAttribArray(iPositionAttribLocation);
            pWebGLContext.deleteBuffer(pPositionBuffer);
            pWebGLContext.deleteTexture(pWebGLTexture1);
            pWebGLContext.deleteTexture(pWebGLTexture2);

            pWebGLRenderer.enable(2929 /* DEPTH_TEST */);

            // pWebGLContext.disable(gl.SCISSOR_TEST);
            // pWebGLContext.disable(gl.BLEND);
            // pWebGLContext.disable(gl.CULL_FACE);
            pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, null);
            pWebGLRenderer._setViewport(null);

            // console.log("depth range:", pF32Destination[1], pF32Destination[0]);
            return { min: pF32Destination[1], max: pF32Destination[0] };
        }
        webgl.getDepthRange = getDepthRange;
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
/// <reference path="IDisplayList.ts" />
/// <reference path="ICamera.ts" />
/// <reference path="IObjectArray.ts" />
/// <reference path="ILightPoint.ts" />
/// <reference path="IOcTree.ts" />
/// <reference path="ISceneObject.ts" />
/// <reference path="IRect3d.ts" />
/// <reference path="IObjectList.ts" />
/// <reference path="IDisplayList.ts" />
/// <reference path="IRect3d.ts" />
/// <reference path="IOcTreeNode.ts" />
/// <reference path="ISceneObject.ts" />
/// <reference path="IVec3.ts" />
/// <reference path="../idl/ISceneObject.ts" />
/// <reference path="../idl/IControllable.ts" />
var akra;
(function (akra) {
    /// <reference path="../idl/IRenderableObject.ts" />
    /// <reference path="../geometry/Rect3d.ts" />
    /// <reference path="../events.ts" />
    /// <reference path="SceneNode.ts" />
    (function (scene) {
        var ESceneObjectFlags;
        (function (ESceneObjectFlags) {
            ESceneObjectFlags[ESceneObjectFlags["k_NewLocalBounds"] = 0] = "k_NewLocalBounds";
            ESceneObjectFlags[ESceneObjectFlags["k_NewWorldBounds"] = 1] = "k_NewWorldBounds";
        })(ESceneObjectFlags || (ESceneObjectFlags = {}));
        ;

        var EObjectViewModes;
        (function (EObjectViewModes) {
            EObjectViewModes[EObjectViewModes["k_Shadows"] = 0x01] = "k_Shadows";
            EObjectViewModes[EObjectViewModes["k_Billboard"] = 0x02] = "k_Billboard";
        })(EObjectViewModes || (EObjectViewModes = {}));

        var SceneObject = (function (_super) {
            __extends(SceneObject, _super);
            function SceneObject(pScene, eType) {
                if (typeof eType === "undefined") { eType = 64 /* SCENE_OBJECT */; }
                _super.call(this, pScene, eType);
                this._iObjectFlags = 0;
                this._iViewModes = 0;
                this._pLocalBounds = new akra.geometry.Rect3d();
                this._pWorldBounds = new akra.geometry.Rect3d();
                //user event handing
                this._iUserEvents = 1023 /* ANY */;
            }
            SceneObject.prototype.setupSignals = function () {
                this.worldBoundsUpdated = this.worldBoundsUpdated || new akra.Signal(this, 0 /* UNICAST */);

                this.worldBoundsUpdated.setForerunner(this._setWorldBoundsUpdated);

                this.click = this.click || new akra.Signal(this);

                this.mousemove = this.mousemove || new akra.Signal(this);
                this.mousedown = this.mousedown || new akra.Signal(this);
                this.mouseup = this.mouseup || new akra.Signal(this);
                this.mouseover = this.mouseover || new akra.Signal(this);
                this.mouseout = this.mouseout || new akra.Signal(this);
                this.mousewheel = this.mousewheel || new akra.Signal(this);

                this.dragstart = this.dragstart || new akra.Signal(this);
                this.dragstop = this.dragstop || new akra.Signal(this);
                this.dragging = this.dragging || new akra.Signal(this);

                _super.prototype.setupSignals.call(this);
            };

            SceneObject.prototype.enableSupportForUserEvent = function (iType) {
                //get events that have not yet been activated
                var iNotActivate = (this._iUserEvents ^ 0x7fffffff) & iType;

                this._iUserEvents = akra.bf.setAll(this._iUserEvents, iNotActivate);

                return iNotActivate;
            };

            SceneObject.prototype.isUserEventSupported = function (eType) {
                return akra.bf.testAny(this._iUserEvents, eType);
            };

            SceneObject.prototype.getTotalRenderable = function () {
                return 0;
            };

            SceneObject.prototype.getWorldBounds = function () {
                return this._pWorldBounds;
            };

            SceneObject.prototype.getLocalBounds = function () {
                return this._pLocalBounds;
            };

            SceneObject.prototype.accessLocalBounds = function () {
                this._iObjectFlags = akra.bf.setBit(this._iObjectFlags, 0 /* k_NewLocalBounds */);
                return this._pLocalBounds;
            };

            SceneObject.prototype.getShadow = function () {
                return (this._iViewModes & 1 /* k_Shadows */) != 0;
            };

            SceneObject.prototype.setShadow = function (bValue) {
                this._iViewModes = bValue ? akra.bf.setAll(this._iViewModes, 1 /* k_Shadows */) : akra.bf.clearAll(this._iViewModes, 1 /* k_Shadows */);

                for (var i = 0; i < this.getTotalRenderable(); i++) {
                    this.getRenderable(i).setShadow(bValue);
                }
            };

            SceneObject.prototype.setBillboard = function (bValue) {
                this._iViewModes = bValue ? akra.bf.setAll(this._iViewModes, 2 /* k_Billboard */) : akra.bf.clearAll(this._iViewModes, 2 /* k_Billboard */);
            };

            SceneObject.prototype.getBillboard = function () {
                return (this._iViewModes & 2 /* k_Billboard */) != 0;
            };

            SceneObject.prototype.isBillboard = function () {
                return this.getBillboard();
            };

            SceneObject.prototype.getRenderable = function (i) {
                return null;
            };

            SceneObject.prototype.getRenderID = function (i) {
                var pComposer = this.getScene().getManager().getEngine().getComposer();

                if (akra.isDef(i)) {
                    return pComposer._calcRenderID(this, this.getRenderable(i));
                }

                return pComposer._calcRenderID(this, null);
            };

            SceneObject.prototype.isWorldBoundsNew = function () {
                return akra.bf.testBit(this._iObjectFlags, 0 /* k_NewLocalBounds */);
            };

            SceneObject.prototype.prepareForUpdate = function () {
                _super.prototype.prepareForUpdate.call(this);

                this._iObjectFlags = akra.bf.clearAll(this._iObjectFlags, akra.bf.flag(0 /* k_NewLocalBounds */) | akra.bf.flag(1 /* k_NewWorldBounds */));
            };

            SceneObject.prototype.update = function () {
                //если, обновится мировая матрица узла, то и AABB обновится
                _super.prototype.update.call(this);

                // do we need to update our local matrix?
                // derived classes update the local matrix
                // then call this base function to complete
                // the update
                return this.recalcWorldBounds();
            };

            SceneObject.prototype.recalcWorldBounds = function () {
                // nodes only get their bounds updated
                // as nessesary
                if ((akra.bf.testBit(this._iObjectFlags, 0 /* k_NewLocalBounds */) || this.isWorldMatrixNew())) {
                    // transform our local rectangle
                    // by the current world matrix
                    this._pWorldBounds.set(this._pLocalBounds);

                    // make sure we have some degree of thickness
                    if (true) {
                        this._pWorldBounds.x1 = akra.math.max(this._pWorldBounds.x1, this._pWorldBounds.x0 + 0.01);
                        this._pWorldBounds.y1 = akra.math.max(this._pWorldBounds.y1, this._pWorldBounds.y0 + 0.01);
                        this._pWorldBounds.z1 = akra.math.max(this._pWorldBounds.z1, this._pWorldBounds.z0 + 0.01);
                    }

                    this._pWorldBounds.transform(this.getWorldMatrix());
                    this.worldBoundsUpdated.emit();

                    return true;
                }

                return false;
            };

            SceneObject.prototype._setWorldBoundsUpdated = function () {
                // set the flag that our bounding box has changed
                return akra.bf.setBit(this._iObjectFlags, 1 /* k_NewWorldBounds */);
            };

            SceneObject.prototype.getObjectFlags = function () {
                return this._iObjectFlags;
            };

            SceneObject.prototype.prepareForRender = function (pViewport) {
            };

            SceneObject.prototype.toString = function (isRecursive, iDepth) {
                if (typeof isRecursive === "undefined") { isRecursive = false; }
                if (typeof iDepth === "undefined") { iDepth = 0; }
                if (akra.config.DEBUG) {
                    if (!isRecursive) {
                        return "<scene_object" + (this._sName ? " " + this._sName : "") + ">";
                    }

                    return _super.prototype.toString.call(this, isRecursive, iDepth);
                }

                return null;
            };

            SceneObject.isSceneObject = function (pEntity) {
                return !akra.isNull(pEntity) && pEntity.getType() >= 64 /* SCENE_OBJECT */ && pEntity.getType() < 128 /* OBJECTS_LIMIT */;
            };
            return SceneObject;
        })(scene.SceneNode);
        scene.SceneObject = SceneObject;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
/// <reference path="../idl/ISkeleton.ts" />
/// <reference path="../idl/INode.ts" />
/// <reference path="../idl/IVertexData.ts" />
/// <reference path="../idl/IRenderDataCollection.ts" />
/// <reference path="../idl/IMesh.ts" />
/// <reference path="../idl/IMat4.ts" />
/// <reference path="../idl/ISceneNode.ts" />
var akra;
(function (akra) {
    (function (model) {
        var VE = akra.data.VertexElement;
        var Mat4 = akra.math.Mat4;
        var DeclUsages = akra.data.Usages;

        var Skin = (function () {
            function Skin(pMesh) {
                this.guid = akra.guid();
                this._pSkeleton = null;
                // name of bones/nodes
                this._pNodeNames = null;
                //bind matrix from collada
                this._m4fBindMatrix = new Mat4(1);
                //BONE_MATRIX = WORLD_MATRIX x OFFSET_MATRIX
                this._pBoneTransformMatrices = null;
                /**
                * Common buffer for all transform matrices.
                * _pBoneOffsetMatrixBuffer = [_pBoneTransformMatrices[0], ..., _pBoneTransformMatrices[N]]
                */
                this._pBoneOffsetMatrixBuffer = null;
                // bone offset matrices from collada
                this._pBoneOffsetMatrices = null;
                /**
                * Pointers to nodes, that affect to this skin.
                */
                this._pAffectingNodes = null;
                /**
                * Format:
                * BONE_INF_COUNT - number of bones, that influence to the vertex.
                * BONE_INF_LOC - address of influence, pointer to InfData structire list.
                * ..., [BONE_INF_COUNT: float, BONE_INF_LOC: float], ...
                *
                */
                this._pInfMetaData = null;
                /**
                * Format:
                * BONE_INF_DATA - bone matrix address, pointer to BONE_MATRIX list
                * BONE_WEIGHT - bone weight
                * ..., [BONE_INF_DATA: float, BONE_WEIGHT: float], ...
                */
                this._pInfData = null;
                /**
                * Format:
                * ..., [BONE_MATRIX: matrix4], ...
                */
                this._pBoneTransformMatrixData = null;
                this._pWeights = null;
                /**
                * Links to VertexData, that contain meta from this skin.
                */
                this._pTiedData = [];
                akra.debug.assert(akra.isDefAndNotNull(pMesh), "you must specify mesh for skin");

                this.setupSignals();
                this._pMesh = pMesh;
            }
            Skin.prototype.setupSignals = function () {
                this.transformed = this.transformed || new akra.Signal(this);
            };

            Skin.prototype.getData = function () {
                return this._pMesh.getData();
            };

            Skin.prototype.getTotalBones = function () {
                return this._pNodeNames.length;
            };

            Skin.prototype.getBoneName = function (iBone) {
                akra.debug.assert(iBone >= 0 && iBone < this._pNodeNames.length, "invalid bone index");
                return this._pNodeNames[iBone];
            };

            Skin.prototype.getBoneIndex = function (sBone) {
                return this._pNodeNames.indexOf(sBone);
            };

            Skin.prototype.getSkeleton = function () {
                return this._pSkeleton;
            };

            Skin.prototype.setBindMatrix = function (m4fMatrix) {
                this._m4fBindMatrix.set(m4fMatrix);
            };

            Skin.prototype.getBindMatrix = function () {
                return this._m4fBindMatrix;
            };

            /**
            * Get scene node that are affected by this skin.
            * Nodes are arranged in the order they are located in video memory.
            * @param iNode Node index.
            */
            Skin.prototype.getAffectedNode = function (iNode) {
                akra.debug.assert(!akra.isNull(this._pSkeleton), "nodes not exists");
                return this._pAffectingNodes[iNode];
            };

            Skin.prototype.getBoneOffsetMatrix = function (bone) {
                var pBoneNames = this._pNodeNames;

                if (akra.isNumber(bone)) {
                    return this._pBoneOffsetMatrices[bone];
                }

                for (var i = 0; i < pBoneNames.length; i++) {
                    if (pBoneNames[i] === bone) {
                        return this._pBoneOffsetMatrices[i];
                    }
                }

                return null;
            };

            Skin.prototype.setSkeleton = function (pSkeleton) {
                if (akra.isNull(pSkeleton) || pSkeleton.getTotalBones() < this.getTotalBones()) {
                    akra.debug.warn("number of bones in skeleton (" + pSkeleton.getTotalBones() + ") less then number of bones in skin (" + this.getTotalBones() + ").");
                    return false;
                }

                for (var i = 0, nMatrices = this.getTotalBones(); i < nMatrices; i++) {
                    this._pAffectingNodes[i] = pSkeleton.findJoint(this._pNodeNames[i]);
                    akra.debug.assert(!akra.isNull(this._pAffectingNodes[i]), "joint<" + this._pNodeNames[i] + "> must exists...");
                }

                this._pSkeleton = pSkeleton;

                this.transformed.emit();
                return true;
            };

            Skin.prototype.attachToScene = function (pRootNode) {
                for (var i = 0, nMatrices = this.getTotalBones(); i < nMatrices; i++) {
                    this._pAffectingNodes[i] = pRootNode.findEntity(this._pNodeNames[i]);
                    akra.debug.assert(akra.isDefAndNotNull(this._pAffectingNodes[i]), "node<" + this._pNodeNames[i] + "> must exists...");
                }

                this.transformed.emit();
                return true;
            };

            Skin.prototype.setBoneNames = function (pNames) {
                if (akra.isNull(pNames)) {
                    return false;
                }

                akra.debug.assert(akra.isNull(this._pNodeNames), "you try redefine e existing node names...");

                this._pNodeNames = pNames;
                this._pAffectingNodes = new Array(pNames.length);

                return true;
            };

            Skin.prototype.setBoneOffsetMatrices = function (pMatrices) {
                var pMatrixNames = this._pNodeNames;

                akra.debug.assert(akra.isDefAndNotNull(pMatrices) && akra.isDefAndNotNull(pMatrixNames) && pMatrixNames.length === pMatrices.length, "number of matrix names must equal matrices data length:\n" + pMatrixNames.length + " / " + pMatrices.length);

                var nMatrices = pMatrixNames.length;
                var pData = this.getData();
                var pMatrixData = new Float32Array(nMatrices * 16);

                //FIXME: правильно положить матрицы...
                this._pBoneOffsetMatrices = pMatrices;
                this._pBoneTransformMatrixData = pData._allocateData([VE.float4x4("BONE_MATRIX")], pMatrixData);
                this._pBoneTransformMatrices = new Array(nMatrices);

                for (var i = 0; i < nMatrices; i++) {
                    this._pBoneTransformMatrices[i] = new Mat4(pMatrixData.subarray(i * 16, (i + 1) * 16), true);
                }

                this._pBoneOffsetMatrixBuffer = pMatrixData;
            };

            Skin.prototype.setWeights = function (pWeights) {
                this._pWeights = pWeights;
                return true;
            };

            Skin.prototype.getInfluenceMetaData = function () {
                return this._pInfMetaData;
            };

            Skin.prototype.getInfluences = function () {
                return this._pInfData;
            };

            Skin.prototype.setInfluences = function (pInfluencesCount, pInfluences) {
                akra.debug.assert(this._pInfMetaData == null && this._pInfData == null, "vertex weights already setuped.");
                akra.debug.assert(!akra.isNull(this._pWeights), "you must set weight data before setup influences");

                var pData = this.getData();
                var pInfluencesMeta = new Float32Array(pInfluencesCount.length * 2);
                var pWeights = this._pWeights;

                var iInfLoc = 0;
                var iTransformLoc = 0;

                //получаем копию массива влияний
                pInfluences = new Float32Array(pInfluences);

                //вычисляем адресса матриц транфсормации и весов
                iTransformLoc = this._pBoneTransformMatrixData.getByteOffset() / 4 /* BYTES_PER_FLOAT */;

                for (var i = 0, n = pInfluences.length; i < n; i += 2) {
                    pInfluences[i] = pInfluences[i] * 16 + iTransformLoc;
                    pInfluences[i + 1] = pWeights[pInfluences[i + 1]];
                }

                //запоминаем модифицированную информацию о влияниях
                this._pInfData = pData._allocateData([
                    VE.float('BONE_INF_DATA'),
                    VE.float('BONE_WEIGHT')
                ], pInfluences);

                iInfLoc = this._pInfData.getByteOffset() / 4 /* BYTES_PER_FLOAT */;

                for (var i = 0, j = 0, n = iInfLoc; i < pInfluencesMeta.length; i += 2) {
                    var iCount = pInfluencesCount[j++];
                    pInfluencesMeta[i] = iCount; /*число влияний на вершину*/
                    pInfluencesMeta[i + 1] = n; /*адрес начала информации о влияниях */

                    //(пары индекс коэф. веса и индекс матрицы)
                    n += 2 * iCount;
                }

                //influences meta: разметка влияний
                this._pInfMetaData = pData._allocateData([
                    VE.float('BONE_INF_COUNT'),
                    VE.float('BONE_INF_LOC')
                ], pInfluencesMeta);

                return this._pInfMetaData !== null && this._pInfData !== null;
            };

            Skin.prototype.setVertexWeights = function (pInfluencesCount, pInfluences, pWeights) {
                akra.debug.assert(arguments.length > 1, 'you must specify all parameters');

                //загружаем веса
                if (pWeights) {
                    this.setWeights(pWeights);
                }

                return this.setInfluences(pInfluencesCount, pInfluences);
            };

            Skin.prototype.applyBoneMatrices = function (bForce) {
                if (typeof bForce === "undefined") { bForce = false; }
                var pData;
                var bResult;
                var pNode;
                var isUpdated = false;

                for (var i = 0, nMatrices = this.getTotalBones(); i < nMatrices; ++i) {
                    pNode = this._pAffectingNodes[i];

                    if (pNode && (pNode.isWorldMatrixNew() || bForce)) {
                        pNode.getWorldMatrix().multiply(this._pBoneOffsetMatrices[i], this._pBoneTransformMatrices[i]);
                        isUpdated = true;
                    }
                }

                if (isUpdated) {
                    this.transformed.emit();
                    pData = this._pBoneOffsetMatrixBuffer;
                    return this._pBoneTransformMatrixData.setData(pData, 0, pData.byteLength);
                }

                return false;
            };

            Skin.prototype.isReady = function () {
                return !(akra.isNull(this._pInfMetaData) || akra.isNull(this._pInfData) || akra.isNull(this._pWeights) || akra.isNull(this._pBoneOffsetMatrixBuffer) || akra.isNull(this._pBoneOffsetMatrices) || akra.isNull(this._pNodeNames) || akra.isNull(this._m4fBindMatrix));
            };

            Skin.prototype.getBoneTransforms = function () {
                return this._pBoneTransformMatrixData;
            };

            Skin.prototype.isAffect = function (pData) {
                if (akra.isDefAndNotNull(pData)) {
                    for (var i = 0; i < this._pTiedData.length; i++) {
                        if (this._pTiedData[i] === pData) {
                            return true;
                        }
                    }
                }

                return false;
            };

            //for MeshSubset
            Skin.prototype._attach = function (pData) {
                akra.debug.assert(pData.getStride() === 16, "you cannot add skin to mesh with POSITION: {x, y, z}" + "\nyou need POSITION: {x, y, z, w}");

                //adding BLENDMETA usage to [{X, Y, Z}, T_END] ==> [{X, Y, Z, BLENDMETA}];
                pData.getVertexDeclaration().append(VE.float(DeclUsages.BLENDMETA, 12));

                this._pTiedData.push(pData);
            };
            return Skin;
        })();
        model.Skin = Skin;

        function createSkin(pMesh) {
            return new Skin(pMesh);
        }
        model.createSkin = createSkin;
    })(akra.model || (akra.model = {}));
    var model = akra.model;
})(akra || (akra = {}));
/// <reference path="../idl/IMesh.ts" />
/// <reference path="../idl/IReferenceCounter.ts" />
/// <reference path="../idl/ISkeleton.ts" />
/// <reference path="../idl/IRect3d.ts" />
/// <reference path="../idl/ISphere.ts" />
/// <reference path="../idl/IEngine.ts" />
/// <reference path="../idl/IMaterial.ts" />
/// <reference path="../idl/IVertexData.ts" />
/// <reference path="../idl/IMeshSubset.ts" />
/// <reference path="../idl/ISkin.ts" />
/// <reference path="../idl/IRenderDataCollection.ts" />
/// <reference path="../idl/ISceneNode.ts" />
/// <reference path="../idl/ISceneModel.ts" />
var akra;
(function (akra) {
    /// <reference path="Skin.ts" />
    /// <reference path="MeshSubset.ts" />
    /// <reference path="../material/materials.ts" />
    /// <reference path="../util/ReferenceCounter.ts" />
    /// <reference path="../events.ts" />
    /// <reference path="../guid.ts" />
    (function (model) {
        var DeclUsages = akra.data.Usages;

        var ShadowedSignal = (function (_super) {
            __extends(ShadowedSignal, _super);
            function ShadowedSignal(pViewport) {
                _super.call(this, pViewport, 0 /* UNICAST */);
            }
            ShadowedSignal.prototype.emit = function (pSubMesh, bShadow) {
                var pMesh = this.getSender();

                pMesh._setShadow(bShadow);

                //debug.log("Mesh(" + pMesh.getName() + ")::ShadowSignal()", ", shadow = " + bShadow);
                if (!bShadow) {
                    for (var i = 0; i < pMesh.getLength(); ++i) {
                        if (pMesh.getSubset(i).getShadow()) {
                            pMesh._setShadow(true);
                            break;
                        }
                    }
                }

                _super.prototype.emit.call(this, pSubMesh, bShadow);
            };
            return ShadowedSignal;
        })(akra.Signal);

        var Mesh = (function (_super) {
            __extends(Mesh, _super);
            function Mesh(pEngine, eOptions, sName, pDataBuffer) {
                _super.call(this);
                this.guid = akra.guid();
                this._pBuffer = null;
                this._eOptions = 0;
                this._pBoundingBox = new akra.geometry.Rect3d();
                this._pBoundingSphere = new akra.geometry.Sphere();
                this._pSubMeshes = [];
                this._bShadow = true;
                this._bBoundgingBoxChanged = false;
                this._bBoundingSphereChanged = false;
                this._bGeometryChanged = false;
                this.setupSignals();

                this._sName = sName || null;
                this._pEngine = pEngine;
                this.setup(sName, eOptions, pDataBuffer);
            }
            Mesh.prototype.setupSignals = function () {
                this.shadowed = this.shadowed || new ShadowedSignal(this);
            };

            Mesh.prototype.isGeometryChanged = function () {
                return this._bGeometryChanged;
            };

            Mesh.prototype.getLength = function () {
                return this._pSubMeshes.length;
            };

            Mesh.prototype.getName = function () {
                return this._sName;
            };

            Mesh.prototype.getData = function () {
                return this._pBuffer;
            };

            Mesh.prototype.getBoundingBox = function () {
                if (this._bBoundgingBoxChanged) {
                    akra.logger.assert(this.calculateBoundingBox(), "could not compute bounding box for mesh");
                }

                return this._pBoundingBox;
            };

            Mesh.prototype.getBoundingSphere = function () {
                if (this._bBoundingSphereChanged) {
                    akra.logger.assert(this.calculateBoundingSphere(), "could not compute bounding sphere for mesh");
                }

                return this._pBoundingSphere;
            };

            Mesh.prototype.getShadow = function () {
                return this._bShadow;
            };

            Mesh.prototype.setShadow = function (bValue) {
                for (var i = 0; i < this._pSubMeshes.length; ++i) {
                    this._pSubMeshes[i].setShadow(bValue);
                }
            };

            Mesh.prototype.getOptions = function () {
                return this._eOptions;
            };

            Mesh.prototype.getEngine = function () {
                return this._pEngine;
            };

            Mesh.prototype.isReadyForRender = function () {
                for (var i = 0; i < this._pSubMeshes.length; ++i) {
                    if (this._pSubMeshes[i].isReadyForRender()) {
                        return true;
                    }
                }

                return false;
            };

            Mesh.prototype.setup = function (sName, eOptions, pDataCollection) {
                akra.debug.assert(this._pBuffer === null, "mesh already setuped.");

                if (akra.isNull(pDataCollection)) {
                    this._pBuffer = this._pEngine.createRenderDataCollection(eOptions);
                } else {
                    akra.debug.assert(pDataCollection.getEngine() === this.getEngine(), "you can not use a buffer with a different context");

                    this._pBuffer = pDataCollection;
                    eOptions |= pDataCollection.getOptions();
                }

                this._pBuffer.addRef();
                this._eOptions = eOptions || 0;
                this._sName = sName || akra.config.unknown.name;

                return true;
            };

            Mesh.prototype.createSubset = function (sName, ePrimType, eOptions) {
                if (typeof eOptions === "undefined") { eOptions = 0; }
                var pData;

                //TODO: modify options and create options for data factory.
                pData = this._pBuffer.getEmptyRenderData(ePrimType, eOptions);
                pData.addRef();

                if (akra.isNull(pData)) {
                    return null;
                }

                return this.appendSubset(sName, pData);
            };

            Mesh.prototype.appendSubset = function (sName, pData) {
                akra.debug.assert(pData.getBuffer() === this._pBuffer, "invalid data used");

                var pSubMesh = new model.MeshSubset(this, pData, sName);
                this._pSubMeshes.push(pSubMesh);

                pSubMesh.shadowed.connect(this.shadowed);
                pSubMesh.transformed.connect(this, this._notifyGeometryChanged);

                this._notifyGeometryChanged();

                return pSubMesh;
            };

            // mark, that mesh geometry changed
            Mesh.prototype._notifyGeometryChanged = function () {
                this._bBoundgingBoxChanged = true;
                this._bBoundingSphereChanged = true;
                this._bGeometryChanged = true;
            };

            Mesh.prototype.freeSubset = function (sName) {
                akra.debug.error("Метод freeSubset не реализован");
                return false;
            };

            Mesh.prototype.destroy = function () {
                this._pSubMeshes = null;
                this._pBuffer.destroy();
            };

            Mesh.prototype.getSubset = function (n) {
                if (akra.isInt(arguments[0])) {
                    return this._pSubMeshes[arguments[0]] || null;
                } else {
                    for (var i = 0; i < this.getLength(); ++i) {
                        if (this._pSubMeshes[i].getName() == arguments[0]) {
                            return this._pSubMeshes[i];
                        }
                    }
                }

                return null;
            };

            Mesh.prototype.setSkin = function (pSkin) {
                for (var i = 0; i < this.getLength(); ++i) {
                    this._pSubMeshes[i].setSkin(pSkin);
                }
            };

            Mesh.prototype.createSkin = function () {
                var pSkin = model.createSkin(this);
                return pSkin;
            };

            Mesh.prototype.clone = function (iCloneOptions) {
                var pClone = null;
                var pRenderData;
                var pSubMesh;

                if (iCloneOptions & 1 /* SHARED_GEOMETRY */) {
                    pClone = this.getEngine().createMesh(this.getName(), this.getOptions(), this.getData());

                    for (var i = 0; i < this.getLength(); ++i) {
                        pRenderData = this._pSubMeshes[i].getData();
                        pRenderData.addRef();
                        pClone.appendSubset(this._pSubMeshes[i].getName(), pRenderData);
                        pClone.getSubset(i).getMaterial().name = this._pSubMeshes[i].getMaterial().name;
                    }
                    //trace('created clone', pClone);
                } else {
                    //TODO: clone mesh data.
                }

                if (iCloneOptions & 0 /* GEOMETRY_ONLY */) {
                    return pClone;
                } else {
                    //TODO: clone mesh shading
                }

                return pClone;
            };

            Mesh.prototype.isSkinned = function () {
                for (var i = 0; i < this._pSubMeshes.length; ++i) {
                    if (this._pSubMeshes[i].isSkinned()) {
                        return true;
                    }
                }

                return false;
            };

            Mesh.prototype._createAndShowSubBoundingBox = function () {
                /*
                for (var i = 0; i < this.getLength(); i++) {
                var pSubMesh: model.MeshSubset = <model.MeshSubset>this.getSubset(i);
                if (pSubMesh.createBoundingBox()) {
                if (!pSubMesh._showBoundingBox()) {
                debug.error("could not show sub bounding box");
                }
                }
                else {
                debug.error("could not create sub bounding box.");
                }
                }
                */
            };

            Mesh.prototype._createAndShowSubBoundingSphere = function () {
                /*
                for (var i = 0; i < this.getLength(); i++) {
                var pSubMesh: model.MeshSubset = <model.MeshSubset>this.getSubset(i);
                pSubMesh.createBoundingSphere();
                pSubMesh._showBoundingSphere();
                }
                */
            };

            Mesh.prototype.calculateBoundingBox = function () {
                var pSubsets = this._pSubMeshes;
                var pBB = this._pBoundingBox.set(pSubsets[0].getBoundingBox());

                for (var i = 1; i < pSubsets.length; ++i) {
                    var pSubset = pSubsets[i];
                    var pLocalBB = pSubset.getBoundingBox();

                    pBB.x0 = akra.math.min(pBB.x0, pLocalBB.x0);
                    pBB.x1 = akra.math.max(pBB.x1, pLocalBB.x1);

                    pBB.y0 = akra.math.min(pBB.y0, pLocalBB.y0);
                    pBB.y1 = akra.math.max(pBB.y1, pLocalBB.y1);

                    pBB.z0 = akra.math.min(pBB.z0, pLocalBB.z0);
                    pBB.z1 = akra.math.max(pBB.z1, pLocalBB.z1);
                }

                //debug.log("Mesh(" + this.getName() + ")::calculateBoundingBox()");
                this._bBoundgingBoxChanged = false;

                return true;
            };

            Mesh.prototype._showBoundingBox = function () {
                if (akra.config.DEBUG)
                    return false;

                /*
                var pSubMesh: IMeshSubset;
                var pMaterial: IMaterial;
                var iData: int;
                var pPoints: float[], pIndexes: uint[];
                
                if (isNull(this._pBoundingBox)) {
                if (!this.createBoundingBox()) {
                return false;
                }
                }
                
                pPoints = new Array();
                pIndexes = new Array();
                
                geometry.computeDataForCascadeBoundingBox(this._pBoundingBox, pPoints, pIndexes, 0.1);
                
                pSubMesh = this.getSubset(".BoundingBox");
                
                if (!pSubMesh) {
                pSubMesh = this.createSubset(".BoundingBox", EPrimitiveTypes.LINELIST, EHardwareBufferFlags.STATIC);
                
                if (isNull(pSubMesh)) {
                debug.error("could not create bounding box subset...");
                return false;
                }
                
                iData = pSubMesh.getData().allocateData([VE.float3(DeclUsages.POSITION)], new Float32Array(pPoints));
                
                pSubMesh.getData().allocateIndex([VE.float(DeclUsages.INDEX0)], new Float32Array(pIndexes));
                
                pSubMesh.getData().index(iData, DeclUsages.INDEX0);
                
                pMaterial = pSubMesh.getMaterial();
                pMaterial.emissive = new Color(1.0, 1.0, 1.0, 1.0);
                pMaterial.diffuse = new Color(1.0, 1.0, 1.0, 1.0);
                pMaterial.ambient = new Color(1.0, 1.0, 1.0, 1.0);
                pMaterial.specular = new Color(1.0, 1.0, 1.0, 1.0);
                
                pSubMesh.getEffect().addComponent("akra.system.mesh_texture");
                pSubMesh.setShadow(false);
                }
                else {
                pSubMesh.getData()._getData(DeclUsages.POSITION).setData(new Float32Array(pPoints), DeclUsages.POSITION);
                }
                
                pSubMesh.getData().setRenderable(pSubMesh.getData().getIndexSet(), true);
                return true;
                */
                return false;
            };
            Mesh.prototype._hideBoundingBox = function () {
                if (akra.config.DEBUG)
                    return false;

                /*
                var pSubMesh: IMeshSubset = this.getSubset(".BoundingBox");
                
                if (!pSubMesh) {
                return false;
                }
                
                //TODO: hide bounding box!!
                pSubMesh.getData().setRenderable(pSubMesh.getData().getIndexSet(), false);
                return true;
                */
                return false;
            };
            Mesh.prototype._isBoundingBoxVisible = function () {
                if (akra.config.DEBUG)
                    return false;

                /*
                var pSubMesh: IMeshSubset = this.getSubset(".BoundingBox");
                
                if (!pSubMesh) {
                return false;
                }
                
                return pSubMesh.getData().isRenderable(pSubMesh.getData().getIndexSet());
                */
                return false;
            };

            Mesh.prototype.calculateBoundingSphere = function () {
                var pSubsets = this._pSubMeshes;
                var pSphere = this._pBoundingSphere;

                for (var i = 0; i < pSubsets.length; ++i) {
                    var pSubset = pSubsets[i];
                    var pLocalSphere = pSubset.getBoundingSphere();

                    if (pSubset.isSkinned()) {
                        pLocalSphere.transform(pSubset.getSkin().getBindMatrix());
                        pLocalSphere.transform(pSubset.getSkin().getBoneOffsetMatrix(pSubset.getSkin().getSkeleton().getRoot().getBoneName()));
                    }

                    if (i == 0) {
                        pSphere.set(pLocalSphere);
                        continue;
                    }

                    akra.geometry.computeGeneralizingSphere(pSphere, pLocalSphere);
                }

                //debug.log("Mesh(" + this.getName() + ")::calculateBoundingSphere()");
                this._bBoundingSphereChanged = false;

                return true;

                var pVertexData;
                var pSubMesh;
                var pNewBoundingSphere, pTempBoundingSphere;
                var i;

                pNewBoundingSphere = new akra.geometry.Sphere();
                pTempBoundingSphere = new akra.geometry.Sphere();

                pSubMesh = this.getSubset(0);
                pVertexData = pSubMesh.getData()._getData(DeclUsages.POSITION);

                if (!pVertexData) {
                    return false;
                }

                if (akra.geometry.computeBoundingSphere(pVertexData, pNewBoundingSphere) == false) {
                    return false;
                }

                if (pSubMesh.isSkinned()) {
                    pNewBoundingSphere.transform(pSubMesh.getSkin().getBindMatrix());
                    pNewBoundingSphere.transform(pSubMesh.getSkin().getBoneOffsetMatrix(pSubMesh.getSkin().getSkeleton().getRoot().getBoneName()));
                }

                for (i = 1; i < this.getLength(); i++) {
                    pSubMesh = this.getSubset(i);
                    pVertexData = pSubMesh.getData()._getData(DeclUsages.POSITION);

                    if (akra.isNull(pVertexData))
                        return false;

                    if (akra.geometry.computeBoundingSphere(pVertexData, pTempBoundingSphere) == false)
                        return false;

                    if (pSubMesh.isSkinned()) {
                        pTempBoundingSphere.transform(pSubMesh.getSkin().getBindMatrix());
                        pTempBoundingSphere.transform(pSubMesh.getSkin().getBoneOffsetMatrix(pSubMesh.getSkin().getSkeleton().getRoot().getBoneName()));
                        // trace(pTempBoundingSphere.fRadius, '<<<');
                    }

                    akra.geometry.computeGeneralizingSphere(pNewBoundingSphere, pTempBoundingSphere);
                }

                this._pBoundingSphere = pNewBoundingSphere;

                return true;
            };

            Mesh.prototype.deleteBoundingSphere = function () {
                this._pBoundingSphere = null;
                return true;
            };

            Mesh.prototype._showBoundingSphere = function () {
                if (akra.config.DEBUG)
                    return false;

                /*
                var pSubMesh: IMeshSubset, pMaterial: IMaterial;
                var iData: int;
                var pPoints: float[], pIndexes: uint[];
                
                if (!this._pBoundingSphere) {
                if (!this.createBoundingSphere()) {
                return false;
                }
                }
                
                pPoints = new Array();
                pIndexes = new Array();
                
                geometry.computeDataForCascadeBoundingSphere(this._pBoundingSphere, pPoints, pIndexes);
                
                pSubMesh = this.getSubset(".BoundingSphere");
                
                if (!pSubMesh) {
                pSubMesh = this.createSubset(".BoundingSphere", EPrimitiveTypes.LINELIST, EHardwareBufferFlags.STATIC);
                
                if (isNull(pSubMesh))
                return false;
                
                iData = pSubMesh.getData().allocateData(
                [VE.float3(DeclUsages.POSITION)],
                new Float32Array(pPoints));
                
                pSubMesh.getData().allocateIndex([VE.float(DeclUsages.INDEX0)], new Float32Array(pIndexes));
                pSubMesh.getData().index(iData, DeclUsages.INDEX0);
                
                pMaterial = pSubMesh.getMaterial();
                pMaterial.emissive = new Color(1.0, 1.0, 1.0, 1.0);
                pMaterial.diffuse = new Color(1.0, 1.0, 1.0, 1.0);
                pMaterial.ambient = new Color(1.0, 1.0, 1.0, 1.0);
                pMaterial.specular = new Color(1.0, 1.0, 1.0, 1.0);
                
                pSubMesh.getEffect().addComponent("akra.system.mesh_texture");
                pSubMesh.setShadow(false);
                }
                else {
                pSubMesh.getData()._getData(DeclUsages.POSITION).setData(new Float32Array(pPoints), DeclUsages.POSITION);
                }
                
                pSubMesh.getData().setRenderable(pSubMesh.getData().getIndexSet(), true);
                
                return true;
                */
                return false;
            };

            Mesh.prototype._hideBoundingSphere = function () {
                if (akra.config.DEBUG)
                    return false;

                //var pSubMesh: IMeshSubset;
                //pSubMesh = this.getSubset(".BoundingSphere");
                //if (!pSubMesh) {
                //	return false;
                //}
                //pSubMesh.getData().setRenderable(pSubMesh.getData().getIndexSet(), false);
                //return true;
                return false;
            };

            Mesh.prototype._isBoundingSphereVisible = function () {
                //var pSubMesh: IMeshSubset = this.getSubset(".BoundingSphere");
                //if (!pSubMesh) {
                //	return false;
                //}
                //return pSubMesh.getData().isRenderable(pSubMesh.getData().getIndexSet());
                return false;
            };

            Mesh.prototype.update = function () {
                var isOk = false;

                this._bGeometryChanged = false;

                for (var i = 0; i < this._pSubMeshes.length; ++i) {
                    isOk = this._pSubMeshes[i].update() ? true : isOk;
                }

                return isOk;
            };

            Mesh.prototype._setShadow = function (bValue) {
                this._bShadow = bValue;
            };

            Mesh.ShadowedSignal = ShadowedSignal;
            return Mesh;
        })(akra.util.ReferenceCounter);

        function createMesh(pEngine, sName, eOptions, pDataBuffer) {
            if (typeof sName === "undefined") { sName = null; }
            if (typeof eOptions === "undefined") { eOptions = 0; }
            if (typeof pDataBuffer === "undefined") { pDataBuffer = null; }
            return new Mesh(pEngine, eOptions, sName, pDataBuffer);
        }
        model.createMesh = createMesh;
    })(akra.model || (akra.model = {}));
    var model = akra.model;
})(akra || (akra = {}));
/// <reference path="../idl/ISceneModel.ts" />
/// <reference path="../idl/IMesh.ts" />
/// <reference path="../idl/IMeshSubset.ts" />
var akra;
(function (akra) {
    /// <reference path="../model/Mesh.ts" />
    /// <reference path="SceneObject.ts" />
    (function (scene) {
        var SceneModel = (function (_super) {
            __extends(SceneModel, _super);
            function SceneModel(pScene) {
                _super.call(this, pScene, 65 /* MODEL */);
                this._pMesh = null;
                this._bShow = true;
            }
            SceneModel.prototype.getVisible = function () {
                return this._bShow;
            };

            SceneModel.prototype.setVisible = function (bValue) {
                this._bShow = bValue;
            };

            SceneModel.prototype.getMesh = function () {
                return this._pMesh;
            };

            SceneModel.prototype.setMesh = function (pMesh) {
                if (!akra.isNull(this._pMesh)) {
                    this.accessLocalBounds().set(0.01, 0.01, 0.01);
                    this.getScene().postUpdate.disconnect(this._pMesh, this._pMesh.update);

                    //this._pMesh.disconnect(this.scene, SIGNAL(postUpdate), SLOT(update));
                    this._pMesh = null;
                }

                if (!akra.isNull(pMesh)) {
                    this.accessLocalBounds().set(pMesh.getBoundingBox());
                    this._pMesh = pMesh;

                    //FIXME: event handing used out of object, bad practice..
                    this.getScene().postUpdate.connect(this._pMesh, this._pMesh.update);
                }
            };

            SceneModel.prototype.getTotalRenderable = function () {
                return akra.isNull(this._pMesh) || !this._bShow ? 0 : this._pMesh.getLength();
            };

            SceneModel.prototype.getRenderable = function (i) {
                if (typeof i === "undefined") { i = 0; }
                if (akra.isNull(this._pMesh)) {
                    akra.logger.warn(this);
                }
                return this._pMesh.getSubset(i);
            };

            SceneModel.prototype.getShadow = function () {
                return this._pMesh.getShadow();
            };

            SceneModel.prototype.setShadow = function (bValue) {
                this._pMesh.setShadow(bValue);
            };

            SceneModel.prototype.isVisible = function () {
                return this._bShow;
            };

            SceneModel.prototype.toString = function (isRecursive, iDepth) {
                if (typeof isRecursive === "undefined") { isRecursive = false; }
                if (typeof iDepth === "undefined") { iDepth = 0; }
                if (akra.config.DEBUG) {
                    if (!isRecursive) {
                        var sData = "<model" + (this.getName() ? " " + this.getName() : "") + "(" + (akra.isNull(this._pMesh) ? 0 : this._pMesh.getLength()) + ")" + '>';

                        if (!akra.isNull(this._pMesh)) {
                            sData += "( " + this._pMesh.getName() + " )";
                        }

                        return sData;
                    }

                    return _super.prototype.toString.call(this, isRecursive, iDepth);
                }

                return null;
            };

            SceneModel.prototype.recalcWorldBounds = function () {
                if (this._pMesh.isGeometryChanged()) {
                    // Mesh::isGeometryChanged() can be TRUE only for Skinned meshes.
                    // bounding boxes for skinned meshes always calculated in World Space,
                    // because, skin depends of skeleton, skeletom is part of scene.
                    this._pWorldBounds.set(this._pMesh.getBoundingBox());
                    this.worldBoundsUpdated.emit();

                    return true;
                }

                if (!this._pMesh.isSkinned()) {
                    return _super.prototype.recalcWorldBounds.call(this);
                }

                return false;
            };

            SceneModel.isModel = function (pEntity) {
                return !akra.isNull(pEntity) && pEntity.getType() === 65 /* MODEL */;
            };
            return SceneModel;
        })(scene.SceneObject);
        scene.SceneModel = SceneModel;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
/// <reference path="../idl/IScene3d.ts" />
/// <reference path="../idl/ISceneObject.ts" />
/// <reference path="../idl/IDisplayList.ts" />
/// <reference path="../idl/ICamera.ts" />
var akra;
(function (akra) {
    /// <reference path="../util/ObjectArray.ts" />
    /// <reference path="../debug.ts" />
    /// <reference path="../events.ts" />
    /// <reference path="../guid.ts" />
    /// <reference path="SceneObject.ts" />
    (function (scene) {
        var DisplayList = (function () {
            //setName(sName: string): void { this._sName = sName; }
            function DisplayList(sName) {
                this.guid = akra.guid();
                this._pScene = null;
                this._sName = "";
                this.setupSignals();

                this._sName = sName;
            }
            DisplayList.prototype.getName = function () {
                return this._sName;
            };

            DisplayList.prototype.setupSignals = function () {
            };

            DisplayList.prototype._onNodeAttachment = function (pScene, pNode) {
                this.attachObject(pNode);
            };

            DisplayList.prototype._onNodeDetachment = function (pScene, pNode) {
                this.detachObject(pNode);
            };

            DisplayList.prototype.attachObject = function (pNode) {
                akra.debug.error("pure virtual method DisplayList::attachObject()");
            };

            DisplayList.prototype.detachObject = function (pNode) {
                akra.debug.error("pure virtual method DisplayList::detachObject()");
            };

            DisplayList.prototype._setup = function (pScene) {
                var _this = this;
                if (akra.isDefAndNotNull(this._pScene)) {
                    akra.logger.critical("list movement from scene to another scene temprary unsupported!");
                }

                this._pScene = pScene;

                pScene.nodeAttachment.connect(this, this._onNodeAttachment);
                pScene.nodeDetachment.connect(this, this._onNodeDetachment);

                //register all exists nodes
                pScene.getRootNode().explore(function (pEntity) {
                    _this._onNodeAttachment(pScene, pEntity);
                    return true;
                });
            };

            DisplayList.prototype._findObjects = function (pCamera, pResultArray, bQuickSearch) {
                if (typeof bQuickSearch === "undefined") { bQuickSearch = false; }
                akra.debug.error("pure virtual method");
                return null;
            };
            return DisplayList;
        })();
        scene.DisplayList = DisplayList;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
/// <reference path="../idl/IObjectList.ts" />
/// <reference path="../logger.ts" />
/// <reference path="ObjectArray.ts" />
var akra;
(function (akra) {
    (function (util) {
        var ObjectList = (function () {
            function ObjectList(pData) {
                this._pHead = null;
                this._pTail = null;
                this._pCurrent = null;
                this._iLength = 0;
                this._bLock = false;
                if (arguments.length) {
                    this.fromArray(pData);
                }
            }
            ObjectList.prototype.getLength = function () {
                return this._iLength;
            };

            ObjectList.prototype.getFirst = function () {
                this._pCurrent = this._pHead;
                return (akra.isDefAndNotNull(this._pCurrent)) ? this._pCurrent.data : null;
            };

            ObjectList.prototype.getLast = function () {
                this._pCurrent = this._pTail;
                return (akra.isDefAndNotNull(this._pCurrent)) ? this._pCurrent.data : null;
            };

            ObjectList.prototype.getCurrent = function () {
                return (akra.isDefAndNotNull(this._pCurrent)) ? this._pCurrent.data : null;
            };

            ObjectList.prototype.lock = function () {
                this._bLock = true;
            };

            ObjectList.prototype.unlock = function () {
                this._bLock = false;
            };

            ObjectList.prototype.isLocked = function () {
                return this._bLock;
            };

            ObjectList.prototype.value = function (n) {
                return this.find(n).data;
            };

            ObjectList.prototype.indexOf = function (pData, iFrom) {
                if (typeof iFrom === "undefined") { iFrom = 0; }
                var pItem = this.find(iFrom);

                for (var i = iFrom; i < this._iLength; i++) {
                    if (pItem.data === pData) {
                        return i;
                    }
                    pItem = pItem.next;
                }
                return -1;
            };

            ObjectList.prototype.mid = function (iPos, iSize) {
                if (typeof iPos === "undefined") { iPos = 0; }
                if (typeof iSize === "undefined") { iSize = this._iLength; }
                iSize = Math.min(this._iLength - iPos, iSize);

                if (iPos > this._iLength - 1) {
                    return null;
                }

                var pNewList = new ObjectList();
                var pItem = this.find(iPos);

                for (var i = 0; i < iSize; ++i) {
                    pNewList.push(pItem.data);
                    pItem = pItem.next;
                }

                return pNewList;
            };

            ObjectList.prototype.slice = function (iStart, iEnd) {
                if (typeof iStart === "undefined") { iStart = 0; }
                if (typeof iEnd === "undefined") { iEnd = Math.max(this._iLength - iStart, 0); }
                return this.mid(iStart, iEnd - iStart);
            };

            ObjectList.prototype.move = function (iFrom, iTo) {
                return this.insert(iTo - 1, this.takeAt(iFrom));
            };

            ObjectList.prototype.replace = function (iPos, pData) {
                akra.debug.assert(!this.isLocked());
                this.find(iPos).data = pData;
                return this;
            };

            ObjectList.prototype.erase = function (begin, end) {
                if (arguments.length < 2) {
                    this.takeAt(arguments[0]);
                } else {
                    end = Math.min(end, this._iLength);
                    for (var i = begin; i < end; i++) {
                        this.takeAt(i);
                    }
                }
                return this;
            };

            ObjectList.prototype.contains = function (pData) {
                return (this.indexOf(pData) >= 0);
            };

            ObjectList.prototype.removeAt = function (n) {
                this.takeAt(n);
            };

            ObjectList.prototype.removeOne = function (pData) {
                this.removeAt(this.indexOf(pData));
            };

            ObjectList.prototype.removeAll = function (pData) {
                var i;
                var n = this.getLength();

                while ((i = this.indexOf(pData)) >= 0) {
                    this.removeAt(i);
                    i--;
                }

                return n;
            };

            ObjectList.prototype.swap = function (i, j) {
                akra.debug.assert(!this.isLocked());

                i = Math.min(i, this._iLength - 1);
                j = Math.min(j, this._iLength - 1);

                if (i != j) {
                    var pItem1 = this.find(i);
                    var pItem2 = this.find(j);

                    var pTmp = pItem1.data;

                    pItem1.data = pItem2.data;
                    pItem2.data = pTmp;
                }

                return this;
            };

            ObjectList.prototype.add = function (pList) {
                pList.seek(0);

                //FIXME: what's this mean?
                if (pList.getLength() > 1) {
                    this.push(pList.getFirst());
                }

                for (var i = 1; i < pList.getLength(); i++) {
                    this.push(pList.next());
                }

                return this;
            };

            ObjectList.prototype.seek = function (n) {
                if (typeof n === "undefined") { n = 0; }
                var pElement;

                n = Math.min(n, this._iLength - 1);

                if (n > this._iLength / 2) {
                    pElement = this._pTail;

                    for (var m = this._iLength - 1 - n; m > 0; --m) {
                        pElement = pElement.prev;
                    }
                } else {
                    pElement = this._pHead;

                    for (var i = 0; i < n; ++i) {
                        pElement = pElement.next;
                    }
                }

                this._pCurrent = pElement;

                return this;
            };

            ObjectList.prototype.next = function () {
                return (akra.isDefAndNotNull(this._pCurrent) && akra.isDefAndNotNull(this._pCurrent.next)) ? (this._pCurrent = this._pCurrent.next).data : null;
            };

            ObjectList.prototype.prev = function () {
                return (akra.isDefAndNotNull(this._pCurrent) && akra.isDefAndNotNull(this._pCurrent.prev)) ? (this._pCurrent = this._pCurrent.prev).data : null;
            };

            ObjectList.prototype.push = function (pElement) {
                return this.insert(this._iLength, pElement);
            };

            ObjectList.prototype.takeAt = function (n) {
                akra.debug.assert(!this.isLocked(), "list locked.");

                if (n < 0) {
                    return null;
                }

                return this.pullElement(this.find(n));
            };

            ObjectList.prototype.pullElement = function (pItem) {
                if (akra.isNull(pItem)) {
                    //this case theoretically cannot happen, but ....
                    return null;
                }

                if (akra.isNull(pItem.prev)) {
                    this._pHead = pItem.next;
                } else {
                    pItem.prev.next = pItem.next;
                }

                if (akra.isNull(pItem.next)) {
                    this._pTail = pItem.prev;
                } else {
                    pItem.next.prev = pItem.prev;
                }

                this._iLength--;

                if (akra.isNull(pItem.next)) {
                    this._pCurrent = this._pTail;
                } else {
                    this._pCurrent = pItem.next;
                }

                return this.releaseItem(pItem);
            };

            ObjectList.prototype.takeFirst = function () {
                return this.takeAt(0);
            };

            ObjectList.prototype.takeLast = function () {
                return this.takeAt(this._iLength - 1);
            };

            ObjectList.prototype.takeCurrent = function (isPrev) {
                if (typeof isPrev === "undefined") { isPrev = false; }
                return this.pullElement(this._pCurrent);
            };

            ObjectList.prototype.pop = function () {
                return this.takeAt(this._iLength - 1);
            };

            ObjectList.prototype.prepend = function (pElement) {
                return this.insert(0, pElement);
            };

            ObjectList.prototype.find = function (n) {
                if (n < this._iLength) {
                    this.seek(n);
                    return this._pCurrent;
                }

                return null;
            };

            ObjectList.prototype.releaseItem = function (pItem) {
                var pData = pItem.data;

                pItem.next = null;
                pItem.prev = null;
                pItem.data = null;

                ObjectList._pool.push(pItem);

                return pData;
            };

            ObjectList.prototype.createItem = function () {
                if (ObjectList._pool.getLength() === 0) {
                    return { next: null, prev: null, data: null };
                }
                return ObjectList._pool.pop();
            };

            ObjectList.prototype.fromArray = function (elements, iOffset, iSize) {
                if (typeof iOffset === "undefined") { iOffset = 0; }
                if (typeof iSize === "undefined") { iSize = elements.length; }
                iOffset = Math.min(iOffset, this._iLength);

                for (var i = 0; i < iSize; i++) {
                    this.insert(iOffset + i, elements[i]);
                }

                return this;
            };

            ObjectList.prototype.insert = function (n, pData) {
                akra.debug.assert(!this.isLocked());

                var pNew = this.createItem();
                var pItem;

                n = Math.min(n, this._iLength);
                pNew.data = pData;

                pItem = this.find(n - 1);

                if (pItem == null) {
                    this._pHead = pNew;
                } else {
                    if (pItem.next == null) {
                        this._pTail = pNew;
                    } else {
                        pNew.next = pItem.next;
                        pItem.next.prev = pNew;
                    }

                    pItem.next = pNew;
                    pNew.prev = pItem;
                }

                this._iLength++;
                this._pCurrent = pNew;

                return this;
            };

            ObjectList.prototype.isEqual = function (pList) {
                if (this._iLength == pList.getLength()) {
                    if (this === pList) {
                        return true;
                    }

                    var l1 = this.getFirst();
                    var l2 = pList.getFirst();

                    for (var i = 0; i < this._iLength; ++i) {
                        if (l1 !== l2) {
                            return false;
                        }

                        l1 = this.next();
                        l2 = pList.next();
                    }

                    return true;
                }

                return false;
            };

            ObjectList.prototype.clear = function () {
                akra.debug.assert(!this.isLocked());

                var pPrev;
                var pNext;

                this._pCurrent = this._pHead;

                for (var i = 0; i < this._iLength; ++i) {
                    pPrev = this._pCurrent;
                    pNext = this._pCurrent = this._pCurrent.next;

                    this.releaseItem(pPrev);
                }

                this._pHead = this._pCurrent = this._pTail = null;
                this._iLength = 0;

                return this;
            };

            ObjectList.prototype.forEach = function (fn) {
                var pItem = this._pHead;
                var n = 0;
                do {
                    if (fn(pItem.data, n++) === false) {
                        return;
                    }
                } while((pItem = pItem.next));
            };

            ObjectList._pool = new util.ObjectArray();
            return ObjectList;
        })();
        util.ObjectList = ObjectList;
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
/// <reference path="../idl/IOcTreeNode.ts" />
/// <reference path="../idl/IRect3d.ts" />
/// <reference path="../idl/IVec3.ts" />
var akra;
(function (akra) {
    /// <reference path="../debug.ts" />
    /// <reference path="../guid.ts" />
    /// <reference path="../geometry/Rect3d.ts" />
    /// <reference path="../util/ObjectList.ts" />
    (function (scene) {
        /** OcTreeNode class represent node of OcTree */
        var OcTreeNode = (function () {
            //index - is xyz where x-left = 0, x-right = 1 etc.
            function OcTreeNode(pTree) {
                this.guid = akra.guid();
                /** Level of node */
                this.level = 0;
                /** Byte x-coord of node */
                //x: int = 0;
                /** Byte y-coord of node */
                //y: int = 0;
                /** Byte z-coord of node */
                //z: int = 0;
                /** Index in array of nodes in tree */
                this.index = 0;
                /** Link to previous node in tree */
                this.rearNodeLink = null;
                this.membersList = new akra.util.ObjectList();
                this.worldBounds = new akra.geometry.Rect3d();

                this.childrenList = new Array(8);
                for (var i = 0; i < 8; i++) {
                    this.childrenList[i] = new akra.util.ObjectList();
                }

                this.tree = pTree;
            }
            /**
            * Add object in this node
            */
            OcTreeNode.prototype.addMember = function (pObject) {
                this.membersList.push(pObject);
                pObject.worldBoundsUpdated.connect(this, this.OcTreeObjectMoved, 0 /* UNICAST */);
                //this.connect(pObject, SIGNAL(worldBoundsUpdated), SLOT(OcTreeObjectMoved), EEventTypes.UNICAST);
            };

            /**
            * Remove member object from node and release node if there are not members in it
            */
            OcTreeNode.prototype.removeMember = function (pObject) {
                var i = this.membersList.indexOf(pObject);

                // console.log('position in list ------------>',i);
                // make sure this is one of ours
                akra.debug.assert(i >= 0, "error removing member cannot find member");

                if (i >= 0) {
                    this.membersList.takeAt(i);
                    pObject.worldBoundsUpdated.disconnect(this, this.OcTreeObjectMoved, 0 /* UNICAST */);
                    //this.disconnect(pObject, SIGNAL(worldBoundsUpdated), SLOT(OcTreeObjectMoved), EEventTypes.UNICAST);
                }

                if (this.membersList.getLength() === 0) {
                    this.tree.deleteNodeFromTree(this);
                }
            };

            OcTreeNode.prototype.toString = function () {
                var sStr = "guid: " + this.guid.toString() + "\n";
                sStr += "level: " + this.level.toString() + "\n";
                sStr += "index: " + this.index.toString() + "\n";
                sStr += "world bounds: " + this.worldBounds.toString() + "\n";
                return sStr;
            };

            OcTreeNode.prototype.OcTreeObjectMoved = function (pObject) {
                // console.warn('object moving');
                var pNode = this.tree.findTreeNode(pObject);

                //if (pNode === null) {
                //	logger.log(pObject);
                //}
                if (pNode !== this) {
                    this.removeMember(pObject);
                    pNode.addMember(pObject);
                }
            };
            return OcTreeNode;
        })();
        scene.OcTreeNode = OcTreeNode;

        var OcTreeRootNode = (function (_super) {
            __extends(OcTreeRootNode, _super);
            function OcTreeRootNode(pTree) {
                _super.call(this, pTree);

                var iTmp = (1 << this.tree.getDepth());

                this._pBasicWorldBounds = new akra.geometry.Rect3d(0, iTmp, 0, iTmp, 0, iTmp);
                this._pBasicWorldBounds.divSelf(this.tree.getWorldScale());
                this._pBasicWorldBounds.subSelf(this.tree.getWorldOffset());

                this.worldBounds.set(this._pBasicWorldBounds);
            }
            OcTreeRootNode.prototype.addMember = function (pMember) {
                _super.prototype.addMember.call(this, pMember);

                //обновляем границы нода, критично, в том случае если объект выходит за границы нода, так как иначе отсекаться будет неправильно
                this._updateNodeBoundingBox();
            };

            OcTreeRootNode.prototype.removeMember = function (pObject) {
                var i = this.membersList.indexOf(pObject);

                // make sure this is one of ours
                akra.debug.assert(i >= 0, "error removing member cannot find member");

                if (i >= 0) {
                    this.membersList.takeAt(i);
                    pObject.worldBoundsUpdated.disconnect(this, this.OcTreeObjectMoved, 0 /* UNICAST */);
                    //this.disconnect(pObject, SIGNAL(worldBoundsUpdated), SLOT(OcTreeObjectMoved), EEventTypes.UNICAST);
                }

                //обновляем границы нода, критично, в том случае если объект выходит за границы нода, так как иначе отсекаться будет неправильно
                this._updateNodeBoundingBox();
            };

            OcTreeRootNode.prototype._updateNodeBoundingBox = function () {
                var pNodeWorldBounds = this.worldBounds;
                pNodeWorldBounds.set(this._pBasicWorldBounds);

                var pObject = this.membersList.getFirst();
                while (akra.isDefAndNotNull(pObject)) {
                    pNodeWorldBounds.unionRect(pObject.getWorldBounds());

                    pObject = this.membersList.next();
                }
            };
            return OcTreeRootNode;
        })(OcTreeNode);
        scene.OcTreeRootNode = OcTreeRootNode;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
/// <reference path="../idl/IOcTree.ts" />
/// <reference path="../idl/IFrustum.ts" />
/// <reference path="../idl/IRect3d.ts" />
var akra;
(function (akra) {
    /// <reference path="../common.ts" />
    /// <reference path="../math/Vec3.ts" />
    /// <reference path="../geometry/classify/classify.ts" />
    /// <reference path="../geometry/intersect/intersect.ts" />
    /// <reference path="DisplayList.ts" />
    /// <reference path="OcTreeNode.ts" />
    (function (scene) {
        var Vec3 = akra.math.Vec3;

        var EOcTreeConstants;
        (function (EOcTreeConstants) {
            EOcTreeConstants[EOcTreeConstants["k_MinimumTreeDepth"] = 0] = "k_MinimumTreeDepth";
            EOcTreeConstants[EOcTreeConstants["k_MaximumTreeDepth"] = 10] = "k_MaximumTreeDepth";
        })(EOcTreeConstants || (EOcTreeConstants = {}));

        var OcTree = (function (_super) {
            __extends(OcTree, _super);
            /**
            * Список байтовых ректов ректа камеры для тестов объектов.
            */
            //protected _pTestLocalRect: IOcTreeRect[] = null;
            function OcTree() {
                _super.call(this, "OcTree");
                /** List of OcTreeNodes on each level */
                //protected _ppLevelNodes: IOcTreeNode[][] = null;
                /** First node in list of all nodes */
                //protected _pFirstNode: IOcTreeNode = null;
                this._pHead = null;
                /** Size of world bounding box */
                this._v3fWorldExtents = new Vec3();
                /** Negate min point of bounding box */
                this._v3fWorldScale = new Vec3();
                /** Value of relation between (1024,1024,1024) and bounding box size */
                this._v3fWorldOffset = new Vec3();
                /** Maximum depth of tree. Value set when you call OcTree::create() */
                this._iDepth = 0;
                //protected _iSize: int = 0;//2^iDepth;
                /**
                * Список свободных узлов(объектов OcTreeNode).
                * Необходимо для экономии ресурсов памяти и чтобы не делать лишних delete
                */
                this._pFreeNodePool = null;
            }
            OcTree.prototype.getDepth = function () {
                return this._iDepth;
            };

            OcTree.prototype.getWorldScale = function () {
                return this._v3fWorldScale;
            };

            OcTree.prototype.getWorldOffset = function () {
                return this._v3fWorldOffset;
            };

            /**
            * Create
            */
            OcTree.prototype.create = function (pWorldBoundingBox, iDepth, nNodes) {
                if (typeof nNodes === "undefined") { nNodes = 64; }
                var v3fTemp = Vec3.temp();
                var i = 0;

                akra.debug.assert(!this.isReady(), "the Oc tree has already been created");
                akra.debug.assert(iDepth >= 0 /* k_MinimumTreeDepth */ && iDepth <= 10 /* k_MaximumTreeDepth */, "invalid tree depth");

                this._iDepth = iDepth;

                this._v3fWorldExtents.set(pWorldBoundingBox.size(v3fTemp));

                this._v3fWorldOffset.set(pWorldBoundingBox.minPoint(v3fTemp).negate());

                var iSize = 1 << iDepth;

                this._v3fWorldScale.x = iSize / this._v3fWorldExtents.x;
                this._v3fWorldScale.y = iSize / this._v3fWorldExtents.y;
                this._v3fWorldScale.z = iSize / this._v3fWorldExtents.z;

                // allocate the nodes
                // this._ppLevelNodes = new Array(iDepth);
                // for (i = 0; i < iDepth; ++i) {
                //     this._ppLevelNodes[i] = new Array();
                // }
                // this._pTestLocalRect = new Array(iDepth);
                // for (i = 0; i < iDepth; ++i) {
                //     this._pTestLocalRect[i] = new OcTreeRect;
                // }
                this._pHead = new scene.OcTreeRootNode(this);
                this._pHead.level = 0;

                this._pFreeNodePool = new Array();

                for (i = 0; i < nNodes; ++i) {
                    this._pFreeNodePool.push(new scene.OcTreeNode(this));
                }
            };

            /**
            * is any levels of tree are availeable(some object in a tree)
            */
            OcTree.prototype.isReady = function () {
                if (this._iDepth > 0) {
                    return true;
                } else {
                    return false;
                }
            };

            /**
            * find node
            */
            OcTree.prototype.findTreeNode = function (pObject) {
                var pRect = pObject.getWorldBounds();
                var iX0 = pRect.x0, iX1 = pRect.x1, iY0 = pRect.y0, iY1 = pRect.y1, iZ0 = pRect.z0, iZ1 = pRect.z1;

                var v3fWorldOffset = this._v3fWorldOffset;
                var v3fWorldScale = this._v3fWorldScale;

                iX0 += v3fWorldOffset.x;
                iX1 += v3fWorldOffset.x;
                iY0 += v3fWorldOffset.y;
                iY1 += v3fWorldOffset.y;
                iZ0 += v3fWorldOffset.z;
                iZ1 += v3fWorldOffset.z;

                iX0 *= v3fWorldScale.x;
                iX1 *= v3fWorldScale.x;
                iY0 *= v3fWorldScale.y;
                iY1 *= v3fWorldScale.y;
                iZ0 *= v3fWorldScale.z;
                iZ1 *= v3fWorldScale.z;

                //round it
                iX0 = akra.math.floor(iX0);
                iX1 = akra.math.ceil(iX1);
                iY0 = akra.math.floor(iY0);
                iY1 = akra.math.ceil(iY1);
                iZ0 = akra.math.floor(iZ0);
                iZ1 = akra.math.ceil(iZ1);

                iX1 = (iX1 === iX0) ? iX0 + 1 : iX1;
                iY1 = (iY1 === iY0) ? iY0 + 1 : iY1;
                iZ1 = (iZ1 === iZ0) ? iZ0 + 1 : iZ1;

                //var iMax1: int = 1 << this._iDepth - 2;
                //var iMax2: int = 1 << this._iDepth - 1;
                //iX0 = math.clamp(iX0, 0, iMax1);
                //iY0 = math.clamp(iY0, 0, iMax1);
                //iZ0 = math.clamp(iZ0, 0, iMax1);
                //iX1 = math.clamp(iX1, iX0 + 1, iMax2);
                //iY1 = math.clamp(iY1, iY0 + 1, iMax2);
                //iZ1 = math.clamp(iZ1, iZ0 + 1, iMax2);
                // LOG(pRect.toString());
                // if(pRect.x0 == 128 && pRect.x1 == 160 && pRect.y0 == 480 && pRect.y1 == 512){
                //     console.error(iX0, iX1, iY0, iY1, iZ0, iZ1);
                // }
                var pNode = this.findTreeNodeByRect(iX0, iX1, iY0, iY1, iZ0, iZ1);

                //if (pNode == null) {
                //	console.log(pNode);
                //}
                return pNode;
            };

            /**
            * Find tree node by Rect
            */
            OcTree.prototype.findTreeNodeByRect = function (iX0, iX1, iY0, iY1, iZ0, iZ1) {
                var nMax = (1 << this._iDepth);

                if (iX0 < 0 || iX1 > nMax || iY0 < 0 || iY1 > nMax || iZ0 < 0 || iZ1 > nMax) {
                    return this._pHead;
                }

                var iDepth = this._iDepth;
                var iLevel;

                ///////////////////////////
                iLevel = this._findNodeLevel(iX0, iX1, iY0, iY1, iZ0, iZ1);

                // console.warn(iLevel);
                ///////////////////////////
                if (iLevel === 0) {
                    return this._pHead;
                }

                var iComposedIndex;
                var iShift = iDepth - iLevel;
                iComposedIndex = (iX0 >> (iDepth - iLevel)) << (2 * iDepth + iShift);

                // console.log(iComposedIndex);
                iComposedIndex += (iY0 >> (iDepth - iLevel)) << (iDepth + iShift);

                // console.log(iComposedIndex);
                iComposedIndex += (iZ0 >> (iDepth - iLevel)) << (iShift);

                var iWay;

                var pParentNode, pNode;
                pParentNode = this._pHead;
                pNode = null;

                var iX, iY, iZ;

                var i = 0;
                while (i < iLevel) {
                    iX = (iX0 >> (iDepth - i - 1)) & 1;
                    iY = (iY0 >> (iDepth - i - 1)) & 1;
                    iZ = (iZ0 >> (iDepth - i - 1)) & 1;

                    iWay = 4 * iX + 2 * iY + iZ;

                    var pNodeList = pParentNode.childrenList[iWay];

                    if (pNodeList.getLength() === 0) {
                        pNode = this.getAndSetFreeNode(iLevel, iComposedIndex, pParentNode);
                        pNodeList.push(pNode);
                        return pNode;
                    }

                    var iPosition = 0;
                    var pTestNode = pNodeList.getFirst();

                    var iTestMask = (iDepth >= i + 2) ? 1 << (iDepth - i - 2) : 0;

                    var iMask = (iTestMask << (2 * iDepth)) + (iTestMask << iDepth) + iTestMask;

                    var pParentNodeOld = pParentNode;

                    while (akra.isDefAndNotNull(pTestNode)) {
                        var iTestNodeIndex = pTestNode.index;

                        var iResult1 = iTestNodeIndex & iMask;
                        var iResult2 = iComposedIndex & iMask;

                        if (iResult1 === iResult2) {
                            if (pTestNode.level === iLevel && iTestNodeIndex == iComposedIndex) {
                                return pTestNode;
                            } else if (pTestNode.level < iLevel && this._parentTest(pTestNode.level, iTestNodeIndex, iComposedIndex)) {
                                pParentNode = pTestNode;
                                i = pTestNode.level;
                                break;
                            } else if (pTestNode.level > iLevel && this._parentTest(iLevel, iComposedIndex, iTestNodeIndex)) {
                                //alert("" + <string><any>pTestNode.level + "  " + <string><any>iLevel);
                                if (pNode === null) {
                                    pNode = this.getAndSetFreeNode(iLevel, iComposedIndex, pParentNode);
                                    pParentNode.childrenList[iWay].push(pNode);
                                    i = iLevel;
                                }

                                var iShift = iDepth - i - 1;

                                iX = (iTestNodeIndex >> (2 * iDepth + iShift)) & 1;
                                iY = (iTestNodeIndex >> (iDepth + iShift)) & 1;
                                iZ = (iTestNodeIndex >> iShift) & 1;

                                var iTestWay = 4 * iX + 2 * iY + iZ;

                                pNode.childrenList[iTestWay].push(pTestNode);
                                pTestNode.rearNodeLink = pNode;

                                pNodeList.takeAt(iPosition);
                                if (iPosition === 0) {
                                    pNodeList.seek(0);
                                    pTestNode = pNodeList.getFirst();
                                    continue;
                                }
                                pNodeList.seek(iPosition - 1);
                                iPosition--;
                            }
                        }

                        pTestNode = pNodeList.next();
                        iPosition++;
                    }

                    if (pNode === null && pParentNodeOld === pParentNode) {
                        pNode = this.getAndSetFreeNode(iLevel, iComposedIndex, pParentNode);
                        pParentNode.childrenList[iWay].push(pNode);
                        break;
                    }
                }

                return pNode;
            };

            OcTree.prototype._parentTest = function (iLevel, iParentIndex, iChildIndex) {
                var iDepth = this._iDepth;

                var iTmp = (1 << iDepth) - (1 << (iDepth - iLevel));
                var iMask = (iTmp << (2 * iDepth)) + (iTmp << iDepth) + iTmp;

                if ((iParentIndex & iMask) == (iChildIndex & iMask)) {
                    return true;
                }
                return false;
            };

            OcTree.prototype._findNodeLevel = function (iX0, iX1, iY0, iY1, iZ0, iZ1) {
                var iLengthX = iX1 - iX0;
                var iLengthY = iY1 - iY0;
                var iLengthZ = iZ1 - iZ0;

                var iLength = akra.math.max(iLengthX, akra.math.max(iLengthY, iLengthZ));

                //maximum possible level
                var iLevel = this._iDepth - akra.math.floor(akra.math.log(iLength) / akra.math.LN2);

                while (iLevel > 0) {
                    var iPitch = 1 << (this._iDepth - iLevel);
                    var iTest1, iTest2;

                    //first test for x then for y and z
                    var i;
                    for (i = 0; i < 3; i++) {
                        iTest1 = akra.math.floor(arguments[2 * i] / iPitch);
                        iTest2 = akra.math.floor(arguments[2 * i + 1] / iPitch);

                        if (iTest1 != iTest2) {
                            if ((iTest1 + 1) == iTest2) {
                                if ((arguments[2 * i + 1] % iPitch) != 0) {
                                    break;
                                }
                            } else {
                                break;
                            }
                        }
                    }
                    if (i != 3) {
                        iLevel--;
                    } else {
                        break;
                    }
                }
                return iLevel;
            };

            /**
            * Get free node.
            * Get it from _pFreeNodePull or create new OcTreeNode if it`s empty and set his data.
            */
            OcTree.prototype.getAndSetFreeNode = function (iLevel, iComposedIndex, pParentNode) {
                var pNode = this._pFreeNodePool.pop();
                if (!akra.isDefAndNotNull(pNode)) {
                    pNode = new scene.OcTreeNode(this);
                }

                var iDepth = this._iDepth;
                var iMask = (1 << this._iDepth) - 1;
                var iIndexX = (iComposedIndex >> (2 * iDepth)) & iMask;
                var iIndexY = (iComposedIndex >> (iDepth)) & iMask;
                var iIndexZ = iComposedIndex & iMask;
                var iSize = 1 << (this._iDepth - iLevel);

                pNode.level = iLevel;

                // pNode.x = iX;
                // pNode.y = iY;
                // pNode.z = iZ;
                pNode.index = iComposedIndex;
                pNode.rearNodeLink = pParentNode;
                pNode.worldBounds.set(iIndexX, iIndexX + iSize, iIndexY, iIndexY + iSize, iIndexZ, iIndexZ + iSize);
                pNode.worldBounds.divSelf(this._v3fWorldScale);
                pNode.worldBounds.subSelf(this._v3fWorldOffset);

                return pNode;
            };

            /**
            * Delete node from tree
            */
            OcTree.prototype.deleteNodeFromTree = function (pNode) {
                var pParentNode = pNode.rearNodeLink;

                akra.debug.assert(pNode.membersList.getLength() == 0, "list members of node don't empty");

                var iDepth = this._iDepth;
                var iParentLevel = pParentNode.level;
                var iIndex = pNode.index;
                var iShift = iDepth - iParentLevel - 1;

                var iX = (iIndex >> (2 * iDepth + iShift)) & 1;
                var iY = (iIndex >> (iDepth + iShift)) & 1;
                var iZ = (iIndex >> iShift) & 1;

                var iWay = 4 * iX + 2 * iY + iZ;

                var pParentBranch = pParentNode.childrenList[iWay];

                //console.log('iWay ------------>', iWay);
                var iNode = pParentBranch.indexOf(pNode);

                akra.debug.assert(iNode != -1, "can't remove node from parent, node not found");

                //deleting node from parent list
                pParentBranch.takeAt(iNode);

                for (var i = 0; i < 8; i++) {
                    var pChildrens = pNode.childrenList[i];
                    while (pChildrens.getLength() > 0) {
                        var pChildNode = pChildrens.pop();
                        pChildNode.rearNodeLink = pParentNode;
                        pParentBranch.push(pChildNode);
                    }
                }

                pNode.level = 0;
                pNode.rearNodeLink = null;
                pNode.worldBounds.clear();

                this._pFreeNodePool.push(pNode);
            };

            OcTree.prototype._findObjects = function (pCamera, pResultArray, bFastSearch) {
                //while we ignore second parametr
                //don't have normal implementation
                if (typeof pResultArray === "undefined") { pResultArray = new akra.util.ObjectArray(); }
                if (typeof bFastSearch === "undefined") { bFastSearch = false; }
                pResultArray.clear();

                if (!akra.isDef(pCamera.getFrustum())) {
                    this._buildSearchResultsByRect(pCamera.getSearchRect(), this._pHead, pResultArray);
                } else {
                    this._buildSearchResultsByRectAndFrustum(pCamera.getSearchRect(), pCamera.getFrustum(), this._pHead, pResultArray);
                }

                return pResultArray;
            };

            OcTree.prototype._buildSearchResultsByRect = function (pSearchRect, pNode, pResultList) {
                var pNodeRect = pNode.worldBounds;

                var kResult = akra.geometry.classify.rect3d(pSearchRect, pNodeRect);

                if (kResult == 3 /* B_CONTAINS_A */ || kResult == 4 /* INTERSECTING */) {
                    //надо проводить дополнительные тесты
                    var pMemberList = pNode.membersList;
                    var pObject = pMemberList.getFirst();
                    while (akra.isDefAndNotNull(pObject)) {
                        if (akra.geometry.intersect.rect3dRect3d(pSearchRect, pObject.getWorldBounds())) {
                            pResultList.push(pObject);
                        }
                        pObject = pMemberList.next();
                    }

                    for (var i = 0; i < 8; i++) {
                        var pChildrenList = pNode.childrenList[i];
                        var pChildNode = pChildrenList.getFirst();

                        while (akra.isDefAndNotNull(pChildNode)) {
                            this._buildSearchResultsByRect(pSearchRect, pChildNode, pResultList);
                            pChildNode = pChildrenList.next();
                        }
                    }
                } else if (kResult != 0 /* NO_RELATION */) {
                    //объект полностью попал
                    this._includeAllTreeSubbranch(pNode, pResultList);
                }
            };

            OcTree.prototype._buildSearchResultsByRectAndFrustum = function (pSearchRect, pFrustum, pNode, pResultList) {
                var pNodeRect = pNode.worldBounds;

                //var pChildRect: IRect3d;
                if (akra.geometry.intersect.rect3dRect3d(pSearchRect, pNodeRect)) {
                    var kTestResult = akra.geometry.classify.frustumRect3d(pFrustum, pNodeRect);
                    if (kTestResult == 2 /* A_CONTAINS_B */) {
                        //объект полностью попал
                        this._includeAllTreeSubbranch(pNode, pResultList);
                    } else if (kTestResult == 4 /* INTERSECTING */) {
                        //объект попал частично
                        var pMemberList = pNode.membersList;
                        var pObject = pMemberList.getFirst();
                        while (akra.isDefAndNotNull(pObject)) {
                            if (pFrustum.testRect(pObject.getWorldBounds())) {
                                pResultList.push(pObject);
                            }
                            pObject = pMemberList.next();
                        }

                        for (var i = 0; i < 8; i++) {
                            //TODO: test by child rect
                            var pChildrenList = pNode.childrenList[i];
                            var pChildNode = pChildrenList.getFirst();
                            while (akra.isDefAndNotNull(pChildNode)) {
                                this._buildSearchResultsByRectAndFrustum(pSearchRect, pFrustum, pChildNode, pResultList);
                                pChildNode = pChildrenList.next();
                            }
                        }
                    }
                }
            };

            OcTree.prototype._includeAllTreeSubbranch = function (pNode, pResultList) {
                //console.warn("----------------> including all subbranch <------------------");
                var pMemberList = pNode.membersList;
                var pObject = pMemberList.getFirst();

                while (akra.isDefAndNotNull(pObject)) {
                    pResultList.push(pObject);
                    pObject = pMemberList.next();
                }

                for (var i = 0; i < 8; i++) {
                    var pChildrenList = pNode.childrenList[i];
                    var pChildNode = pChildrenList.getFirst();

                    while (akra.isDefAndNotNull(pChildNode)) {
                        this._includeAllTreeSubbranch(pChildNode, pResultList);
                        pChildNode = pChildrenList.next();
                    }
                }
            };

            OcTree.prototype.attachObject = function (pNode) {
                if (scene.SceneObject.isSceneObject(pNode)) {
                    var pOcTreeNode = this.findTreeNode(pNode);
                    pOcTreeNode.addMember(pNode);
                }
            };

            OcTree.prototype.detachObject = function (pNode) {
                if (scene.SceneObject.isSceneObject(pNode)) {
                    var pOcTreeNode = this.findTreeNode(pNode);
                    pOcTreeNode.removeMember(pNode);
                }
            };

            OcTree.prototype._toSimpleObject = function (pNode) {
                if (typeof pNode === "undefined") { pNode = this._pHead; }
                var pResult = {};
                pResult.members = [];
                pResult.childrens = new Array(8);
                for (var i = 0; i < 8; i++) {
                    pResult.childrens[i] = [];
                }
                pResult.level = pNode.level;
                pResult.index = pNode.index;
                pResult.worldBounds = pNode.worldBounds.toString();

                var pMemberList = pNode.membersList;
                var pObject = pMemberList.getFirst();
                while (akra.isDefAndNotNull(pObject)) {
                    pResult.members.push(pObject.getWorldBounds().toString());
                    pObject = pMemberList.next();
                }

                for (var i = 0; i < 8; i++) {
                    var pList = pNode.childrenList[i];
                    var pChildNode = pList.getFirst();

                    while (akra.isDefAndNotNull(pChildNode)) {
                        pResult.childrens[i].push(this._toSimpleObject(pChildNode));
                        pChildNode = pList.next();
                    }
                }

                return pResult;
            };
            return OcTree;
        })(scene.DisplayList);
        scene.OcTree = OcTree;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
/// <reference path="../../idl/ILightPoint.ts" />
/// <reference path="../SceneObject.ts" />
/// <reference path="../../math/math.ts" />
var akra;
(function (akra) {
    (function (scene) {
        (function (light) {
            var ELightPointFlags;
            (function (ELightPointFlags) {
                ELightPointFlags[ELightPointFlags["k_NewRestrictedLocalBounds"] = 0] = "k_NewRestrictedLocalBounds";
                ELightPointFlags[ELightPointFlags["k_NewWorldBounds"] = 1] = "k_NewWorldBounds";
            })(ELightPointFlags || (ELightPointFlags = {}));
            ;

            var LightPoint = (function (_super) {
                __extends(LightPoint, _super);
                function LightPoint(pScene, eType) {
                    if (typeof eType === "undefined") { eType = 0 /* UNKNOWN */; }
                    _super.call(this, pScene, 37 /* LIGHT */);
                    this._isShadowCaster = false;
                    this._isEnabled = true;
                    this._iMaxShadowResolution = 256;
                    //optimized camera frustum for better shadow casting
                    this._pOptimizedCameraFrustum = new akra.geometry.Frustum();
                    this._pRestrictedLocalBounds = null;
                    this._isRestricted = false;
                    this._iLightPointFlags = 0;

                    this._eLightType = eType;
                }
                LightPoint.prototype.getParams = function () {
                    // return this._pLightParameters;
                    return null;
                };

                LightPoint.prototype.getLightType = function () {
                    return this._eLightType;
                };

                LightPoint.prototype.getOptimizedCameraFrustum = function () {
                    return this._pOptimizedCameraFrustum;
                };

                LightPoint.prototype.isEnabled = function () {
                    return this._isEnabled;
                };

                LightPoint.prototype.setEnabled = function (bValue) {
                    this._isEnabled = bValue;
                };

                LightPoint.prototype.isShadowCaster = function () {
                    return this._isShadowCaster;
                };

                LightPoint.prototype.setShadowCaster = function (bValue) {
                    this._isShadowCaster = bValue;
                };

                LightPoint.prototype.getLightingDistance = function () {
                    return -1.;
                };

                LightPoint.prototype.setLightingDistance = function (fDistance) {
                };

                LightPoint.prototype.isRestricted = function () {
                    return this._isRestricted;
                };

                LightPoint.prototype.setRestrictedLocalBounds = function (pBox) {
                    this.restrictLight(true, pBox);
                };

                LightPoint.prototype.getRestrictedLocalBounds = function () {
                    return this._pRestrictedLocalBounds;
                };

                LightPoint.prototype.create = function (isShadowCaster, iMaxShadowResolution) {
                    if (typeof isShadowCaster === "undefined") { isShadowCaster = true; }
                    if (typeof iMaxShadowResolution === "undefined") { iMaxShadowResolution = 256; }
                    var isOk = _super.prototype.create.call(this);
                    var pRenderer = this.getScene().getManager().getEngine().getRenderer();

                    //our shadows use shadow maps, but without depth textures we can't rendr shadows
                    if (!pRenderer.hasCapability(akra.ERenderCapabilities.RTT_SEPARATE_DEPTHBUFFER) || !akra.config.render.shadows.enabled) {
                        isShadowCaster = false;
                        iMaxShadowResolution = 0;
                    }

                    //есть тени от источника или нет
                    this._isShadowCaster = isShadowCaster;

                    //мкасимальный размер shadow текстуры
                    this._iMaxShadowResolution = iMaxShadowResolution;

                    return isOk;
                };

                LightPoint.prototype.restrictLight = function (bEnable, pBox) {
                    this._isRestricted = bEnable;

                    if (bEnable) {
                        if (akra.isNull(this._pRestrictedLocalBounds)) {
                            this._pRestrictedLocalBounds = new akra.geometry.Rect3d(-1, 1, -1, 1, -1, 1);
                        }

                        if (akra.isDef(pBox)) {
                            this._pRestrictedLocalBounds.set(pBox);
                        }

                        this._iLightPointFlags = akra.bf.setBit(this._iLightPointFlags, 0 /* k_NewRestrictedLocalBounds */);
                    }
                };

                LightPoint.prototype.prepareForUpdate = function () {
                    _super.prototype.prepareForUpdate.call(this);

                    this._iLightPointFlags = akra.bf.clearAll(this._iLightPointFlags, akra.bf.flag(0 /* k_NewRestrictedLocalBounds */));
                };

                LightPoint.prototype._prepareForLighting = function (pCamera) {
                    akra.debug.warn("pure virtual method");
                    return false;
                };

                LightPoint.prototype._calculateShadows = function () {
                    akra.debug.critical("NOT IMPLEMENTED!");
                };

                LightPoint.isLightPoint = function (pNode) {
                    return pNode.getType() === 37 /* LIGHT */;
                };
                return LightPoint;
            })(scene.SceneNode);
            light.LightPoint = LightPoint;
        })(scene.light || (scene.light = {}));
        var light = scene.light;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
/// <reference path="../idl/ILightGraph.ts" />
/// <reference path="../util/ObjectList.ts" />
/// <reference path="../common.ts" />
var akra;
(function (akra) {
    /// <reference path="light/LightPoint.ts" />
    /// <reference path="DisplayList.ts" />
    (function (scene) {
        var LightPoint = scene.light.LightPoint;

        var LightGraph = (function (_super) {
            __extends(LightGraph, _super);
            function LightGraph() {
                _super.call(this, "LightGraph");
                this._pLightPoints = new akra.util.ObjectList();
            }
            LightGraph.prototype._findObjects = function (pCamera, pResultArray, bFastSearch) {
                if (typeof pResultArray === "undefined") { pResultArray = null; }
                if (typeof bFastSearch === "undefined") { bFastSearch = false; }
                if (akra.isNull(pResultArray)) {
                    pResultArray = new akra.util.ObjectArray();
                }

                //while we ignore second parametr
                //don't have normal implementation
                pResultArray.clear();

                var pList = this._pLightPoints;

                var pLightPoint = pList.getFirst();

                while (akra.isDefAndNotNull(pLightPoint)) {
                    if (pLightPoint._prepareForLighting(pCamera)) {
                        // LOG("light point added");
                        pResultArray.push(pLightPoint);
                    }

                    pLightPoint = pList.next();
                }

                return pResultArray;
            };

            LightGraph.prototype.attachObject = function (pNode) {
                if (LightPoint.isLightPoint(pNode)) {
                    this._pLightPoints.push(pNode);
                }
            };

            LightGraph.prototype.detachObject = function (pNode) {
                if (LightPoint.isLightPoint(pNode)) {
                    var iPosition = this._pLightPoints.indexOf(pNode);
                    if (iPosition != -1) {
                        this._pLightPoints.takeAt(iPosition);
                    } else {
                        akra.debug.assert(false, "cannot find light point");
                    }
                }
            };
            return LightGraph;
        })(scene.DisplayList);
        scene.LightGraph = LightGraph;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
/// <reference path="../idl/ISprite.ts" />
/// <reference path="../idl/ISpriteManager.ts" />
var akra;
(function (akra) {
    /// <reference path="SceneObject.ts" />
    /// <reference path="../render/RenderableObject.ts" />
    (function (scene) {
        var VE = akra.data.VertexElement;

        var SpriteManager = (function () {
            function SpriteManager(pEngine) {
                this._pSprites = [];
                this._pDataFactory = pEngine.createRenderDataCollection(4 /* READABLE */);
            }
            SpriteManager.prototype._allocateSprite = function (pSprite) {
                var pDataSubset = this._pDataFactory.getEmptyRenderData(5 /* TRIANGLESTRIP */, 0);

                this._pSprites.push(pSprite);

                return pDataSubset;
            };
            return SpriteManager;
        })();
        scene.SpriteManager = SpriteManager;

        var Sprite = (function (_super) {
            __extends(Sprite, _super);
            function Sprite(pScene) {
                _super.call(this, pScene, 71 /* SPRITE */);

                var pEngine = pScene.getManager().getEngine();
                var pRsmgr = pEngine.getResourceManager();
                var pManager = pEngine.getSpriteManager();
                var pRenderer = pEngine.getRenderer();
                var pRenderable = new akra.render.RenderableObject(3 /* SPRITE */);

                pRenderable._setup(pRenderer);

                var iGuid = this.guid;
                var pRenderMethod = pRenderable.getRenderMethod();
                var pEffect = pRenderMethod.getEffect();

                pEffect.addComponent("akra.system.mesh_texture");

                pRenderable.getTechnique().setMethod(pRenderMethod);

                this._pManager = pManager;
                this._pRenderable = pRenderable;

                this.create(2, 2);
            }
            Sprite.prototype.getTotalRenderable = function () {
                return 1;
            };

            Sprite.prototype.getSpriteManager = function () {
                return this._pManager;
            };

            Sprite.prototype.create = function (fSizeX, fSizeY) {
                if (typeof fSizeX === "undefined") { fSizeX = 2; }
                if (typeof fSizeY === "undefined") { fSizeY = 2; }
                _super.prototype.create.call(this);

                //4 vertex * (4 coords + 3 texcoords)
                var pGeometry = new Float32Array(4 * 4);
                var pTexCoords = new Float32Array(4 * 3);
                var pNormals = new Float32Array([0., 0., 1., 0.]);

                for (var i = 0; i < 4; i++) {
                    //-1, -1, -1, 1, 1, -1, 1, 1
                    //0, 0, 0, 1, 1, 0, 1, 1
                    var signX = akra.math.floor(i / 2) * 2 - 1;
                    var signY = (i % 2) * 2 - 1;

                    pGeometry[4 * i] = signX * fSizeX / 2;
                    pGeometry[4 * i + 1] = signY * fSizeY / 2;
                    pGeometry[4 * i + 2] = 0;
                    pGeometry[4 * i + 3] = 0;

                    pTexCoords[3 * i + 0] = (signX + 1) / 2;
                    pTexCoords[3 * i + 1] = (signY + 1) / 2;
                    pTexCoords[3 * i + 2] = 0;
                }

                var fMaxSize = (fSizeX > fSizeY) ? fSizeX : fSizeY;

                this.accessLocalBounds().set(fMaxSize, fMaxSize, fMaxSize);

                var pData = this.getSpriteManager()._allocateSprite(this);

                pData.allocateData([VE.float4("POSITION")], pGeometry);
                pData.allocateData([VE.float3("TEXCOORD0")], pTexCoords);
                pData.allocateData([VE.float4("NORMAL")], pNormals);
                pData.allocateIndex([VE.float('INDEX0')], new Float32Array([0, 1, 2, 3]));
                pData.allocateIndex([VE.float('INDEX1')], new Float32Array([0, 1, 2, 3]));
                pData.allocateIndex([VE.float('INDEX2')], new Float32Array([0, 0, 0, 0]));
                pData.index('POSITION', 'INDEX0');
                pData.index('TEXCOORD0', 'INDEX1');
                pData.index('NORMAL', 'INDEX2');

                this._pRenderable._setRenderData(pData);

                return true;
            };

            Sprite.prototype.setTexture = function (pTex) {
                var pSurfaceMaterial = this._pRenderable.getSurfaceMaterial();
                pSurfaceMaterial.setTexture(3 /* EMISSIVE */, pTex, 0);

                pSurfaceMaterial.getMaterial().emissive.set(0.);
                pSurfaceMaterial.getMaterial().diffuse.set(0.);
                pSurfaceMaterial.getMaterial().ambient.set(0.);
                pSurfaceMaterial.getMaterial().specular.set(0.);

                this._pRenderable.wireframe(true);
            };

            Sprite.prototype.getRenderable = function () {
                return this._pRenderable;
            };
            return Sprite;
        })(scene.SceneObject);
        scene.Sprite = Sprite;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
/// <reference path="../../idl/IModelEntry.ts" />
/// <reference path="../SceneNode.ts" />
var akra;
(function (akra) {
    (function (scene) {
        (function (objects) {
            var ModelEntry = (function (_super) {
                __extends(ModelEntry, _super);
                function ModelEntry(pScene, pModel) {
                    _super.call(this, pScene, 6 /* MODEL_ENTRY */);
                    this._pModelResource = null;

                    this._pModelResource = pModel;
                }
                ModelEntry.prototype.getResource = function () {
                    return this._pModelResource;
                };

                ModelEntry.isModelEntry = function (pEntity) {
                    return !akra.isNull(pEntity) && pEntity.getType() === 6 /* MODEL_ENTRY */;
                };
                return ModelEntry;
            })(scene.SceneNode);
            objects.ModelEntry = ModelEntry;
        })(scene.objects || (scene.objects = {}));
        var objects = scene.objects;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
/// <reference path="../../idl/IScene3d.ts" />
/// <reference path="../../idl/ICamera.ts" />
/// <reference path="../../idl/IDisplayList.ts" />
/// <reference path="../../idl/IViewport.ts" />
/// <reference path="../../idl/IObjectArray.ts" />
var akra;
(function (akra) {
    (function (scene) {
        /// <reference path="../../geometry/Frustum.ts" />
        /// <reference path="../../common.ts" />
        /// <reference path="../../math/math.ts" />
        /// <reference path="../../util/ObjectArray.ts" />
        /// <reference path="../SceneObject.ts" />
        (function (objects) {
            var Mat4 = akra.math.Mat4;

            var Vec3 = akra.math.Vec3;
            var Vec4 = akra.math.Vec4;

            var __13 = akra.math.__13;
            var __23 = akra.math.__23;
            var __33 = akra.math.__33;

            var ECameraFlags;
            (function (ECameraFlags) {
                ECameraFlags[ECameraFlags["k_NewProjectionMatrix"] = 0] = "k_NewProjectionMatrix";
                ECameraFlags[ECameraFlags["k_NewProjectionParams"] = 1] = "k_NewProjectionParams";
            })(ECameraFlags || (ECameraFlags = {}));

            var DLTechnique = (function () {
                function DLTechnique(pList, pCamera) {
                    this._pPrevResult = null;
                    this.list = pList;
                    this.camera = pCamera;
                }
                DLTechnique.prototype.findObjects = function (pResultArray, bQuickSearch) {
                    if (typeof bQuickSearch === "undefined") { bQuickSearch = false; }
                    var pResult = this.list._findObjects(this.camera, pResultArray, bQuickSearch && akra.isDefAndNotNull(this._pPrevResult));

                    if (akra.isNull(this._pPrevResult)) {
                        this._pPrevResult = pResult;
                    }

                    return this._pPrevResult;
                };
                return DLTechnique;
            })();
            objects.DLTechnique = DLTechnique;

            var Camera = (function (_super) {
                __extends(Camera, _super);
                function Camera(pScene, eType) {
                    if (typeof eType === "undefined") { eType = 4 /* CAMERA */; }
                    _super.call(this, pScene, eType);
                    /** camera type */
                    this._eCameraType = 0 /* PERSPECTIVE */;
                    /** camera options */
                    this._iCameraOptions = 0;
                    /** update projection bit flag */
                    this._iUpdateProjectionFlags = 0;
                    /**
                    * View matrix
                    */
                    this._m4fView = new Mat4;
                    /** internal, un-biased projection matrix */
                    this._m4fProj = new Mat4;
                    /** internal, un-biased projection+view matrix */
                    this._m4fProjView = new Mat4;
                    /**
                    * Biased for use during current render stage
                    * @deprecated
                    */
                    //protected _m4fRenderStageProj: IMat4 = new Mat4;
                    /**
                    * @deprecated
                    */
                    //protected _m4fRenderStageProjView: IMat4 = new Mat4;
                    /** Search rect for scene culling */
                    this._pSearchRect = new akra.geometry.Rect3d();
                    /** Position */
                    this._v3fTargetPos = new Vec3;
                    /** Attributes for projection matrix */
                    this._fFOV = akra.math.PI / 3.;
                    this._fAspect = 4. / 3.;
                    this._fNearPlane = 0.1;
                    this._fFarPlane = 500.;
                    this._fWidth = 0.;
                    this._fHeight = 0.;
                    this._fMinX = 0.;
                    this._fMaxX = 0.;
                    this._fMinY = 0.;
                    this._fMaxY = 0.;
                    this._pFrustum = new akra.geometry.Frustum;
                    this._pLastViewport = null;
                    this._pDLTechniques = [];
                    this._pDLResultStorage = [];
                }
                Camera.prototype.setupSignals = function () {
                    this.preRenderScene = this.preRenderScene || new akra.Signal(this);
                    this.postRenderScene = this.postRenderScene || new akra.Signal(this);

                    _super.prototype.setupSignals.call(this);
                };

                Camera.prototype.getViewMatrix = function () {
                    return this._m4fView;
                };

                Camera.prototype.getProjectionMatrix = function () {
                    return this._m4fProj;
                };

                Camera.prototype.getProjViewMatrix = function () {
                    return this._m4fProjView;
                };

                Camera.prototype.getTargetPos = function () {
                    return this._v3fTargetPos;
                };

                Camera.prototype.getViewDistance = function () {
                    return this._fFarPlane - this._fNearPlane;
                };

                Camera.prototype.getSearchRect = function () {
                    return this._pSearchRect;
                };

                Camera.prototype.getFrustum = function () {
                    return this._pFrustum;
                };

                Camera.prototype.getFOV = function () {
                    return this._fFOV;
                };

                Camera.prototype.setFOV = function (fFOV) {
                    this._fFOV = fFOV;
                    this._iUpdateProjectionFlags = akra.bf.setBit(this._iUpdateProjectionFlags, 1 /* k_NewProjectionParams */);
                };

                Camera.prototype.getAspect = function () {
                    return this._fAspect;
                };

                Camera.prototype.setAspect = function (fAspect) {
                    this._fAspect = fAspect;
                    this._iUpdateProjectionFlags = akra.bf.setBit(this._iUpdateProjectionFlags, 1 /* k_NewProjectionParams */);
                };

                Camera.prototype.getNearPlane = function () {
                    return this._fNearPlane;
                };

                Camera.prototype.setNearPlane = function (fNearPlane) {
                    this._fNearPlane = fNearPlane;
                    this._iUpdateProjectionFlags = akra.bf.setBit(this._iUpdateProjectionFlags, 1 /* k_NewProjectionParams */);
                };

                Camera.prototype.getFarPlane = function () {
                    return this._fFarPlane;
                };

                Camera.prototype.setFarPlane = function (fFarPlane) {
                    this._fFarPlane = fFarPlane;
                    this._iUpdateProjectionFlags = akra.bf.setBit(this._iUpdateProjectionFlags, 1 /* k_NewProjectionParams */);
                };

                Camera.prototype.create = function () {
                    var isOK = _super.prototype.create.call(this);

                    if (isOK) {
                        this._v3fTargetPos.set(this._m4fLocalMatrix.data[__13], this._m4fLocalMatrix.data[__23], this._m4fLocalMatrix.data[__33]);
                        this._v3fTargetPos.negate();

                        this.recalcProjMatrix();
                        this.recalcMatrices();

                        var pScene = this._pScene;

                        pScene.displayListAdded.connect(this, this._addDisplayList);
                        pScene.displayListRemoved.connect(this, this._removeDisplayList);

                        for (var i = 0; i < pScene.getTotalDL(); ++i) {
                            var pList = pScene.getDisplayList(i);

                            if (!akra.isNull(pList)) {
                                this._addDisplayList(pScene, pList, i);
                            }
                        }
                    }

                    return isOK;
                };

                Camera.prototype.isProjParamsNew = function () {
                    return akra.bf.testBit(this._iUpdateProjectionFlags, 1 /* k_NewProjectionParams */);
                };

                Camera.prototype.recalcProjMatrix = function () {
                    switch (this._eCameraType) {
                        case 0 /* PERSPECTIVE */:
                            Mat4.perspective(this._fFOV, this._fAspect, this._fNearPlane, this._fFarPlane, this._m4fProj);
                            break;
                        case 1 /* ORTHO */:
                            Mat4.orthogonalProjection(this._fWidth, this._fHeight, this._fNearPlane, this._fFarPlane, this._m4fProj);
                            break;
                        case 2 /* OFFSET_ORTHO */:
                            Mat4.orthogonalProjectionAsymmetric(this._fMinX, this._fMaxX, this._fMinY, this._fMaxY, this._fNearPlane, this._fFarPlane, this._m4fProj);
                            break;
                    }
                    this._iUpdateProjectionFlags = akra.bf.setBit(this._iUpdateProjectionFlags, 0 /* k_NewProjectionMatrix */);

                    this._iUpdateProjectionFlags = akra.bf.clearBit(this._iUpdateProjectionFlags, 1 /* k_NewProjectionParams */);
                };

                Camera.prototype.prepareForUpdate = function () {
                    _super.prototype.prepareForUpdate.call(this);
                    //reset culling cache for all display lists
                    // for (var i: int = 0; i < this._pDLTechniques.length; ++ i) {
                    // 	if (this._pDLTechniques[i] != null) {
                    // 		this._pDLTechniques.reset();
                    // 	}
                    // }
                };

                Camera.prototype.display = function (iList) {
                    if (typeof iList === "undefined") { iList = /*DL_DEFAULT*/ 0; }
                    var pObjects = this._pDLTechniques[iList].findObjects(this._pDLResultStorage[iList], !this.isUpdated());

                    return pObjects;
                };

                Camera.prototype._getLastResults = function (iList) {
                    if (typeof iList === "undefined") { iList = 0; }
                    return this._pDLResultStorage[iList] || null;
                };

                Camera.prototype.setParameter = function (eParam, pValue) {
                    if (eParam === 1 /* CONST_ASPECT */ && pValue) {
                        this._iCameraOptions = akra.bf.setAll(this._iCameraOptions, eParam);
                    }
                };

                Camera.prototype.isConstantAspect = function () {
                    return akra.bf.testAny(this._iCameraOptions, 1 /* CONST_ASPECT */);
                };

                Camera.prototype.setProjParams = function (fFOV, fAspect, fNearPlane, fFarPlane) {
                    // Set attributes for the projection matrix
                    this._fFOV = fFOV;
                    this._fAspect = fAspect;
                    this._fNearPlane = fNearPlane;
                    this._fFarPlane = fFarPlane;
                    this._eCameraType = 0 /* PERSPECTIVE */;

                    // create the regular projection matrix
                    Mat4.perspective(fFOV, fAspect, fNearPlane, fFarPlane, this._m4fProj);

                    // create a unit-space matrix
                    // for sky box geometry.
                    // this ensures that the
                    // near and far plane enclose
                    // the unit space around the camera
                    // Mat4.perspective(fFOV, fAspect, 0.01, 2.0, this._m4fUnitProj);
                    this._iUpdateProjectionFlags = akra.bf.setBit(this._iUpdateProjectionFlags, 0 /* k_NewProjectionMatrix */);
                };

                Camera.prototype.setOrthoParams = function (fWidth, fHeight, fNearPlane, fFarPlane) {
                    this._fWidth = fWidth;
                    this._fHeight = fHeight;
                    this._fNearPlane = fNearPlane;
                    this._fFarPlane = fFarPlane;
                    this._eCameraType = 1 /* ORTHO */;

                    // create the regular projection matrix
                    Mat4.orthogonalProjection(fWidth, fHeight, fNearPlane, fFarPlane, this._m4fProj);

                    // create a unit-space matrix
                    // for sky box geometry.
                    // this ensures that the
                    // near and far plane enclose
                    // the unit space around the camera
                    // Mat4.matrixOrthoRH(fWidth, fHeight, 0.01, 2.0, this._m4fUnitProj);
                    this._iUpdateProjectionFlags = akra.bf.setBit(this._iUpdateProjectionFlags, 0 /* k_NewProjectionMatrix */);
                };

                Camera.prototype.setOffsetOrthoParams = function (fMinX, fMaxX, fMinY, fMaxY, fNearPlane, fFarPlane) {
                    this._fMinX = fMinX;
                    this._fMaxX = fMaxX;
                    this._fMinY = fMinY;
                    this._fMaxY = fMaxY;
                    this._fNearPlane = fNearPlane;
                    this._fFarPlane = fFarPlane;
                    this._eCameraType = 2 /* OFFSET_ORTHO */;

                    // create the regular projection matrix
                    Mat4.orthogonalProjectionAsymmetric(fMinX, fMaxX, fMinY, fMaxY, fNearPlane, fFarPlane, this._m4fProj);

                    // create a unit-space matrix
                    // for sky box geometry.
                    // this ensures that the
                    // near and far plane enclose
                    // the unit space around the camera
                    // Mat4.orthogonalProjectionorthogonalProjectionAsymmetric(fMinX, fMaxX, fMinY, fMaxY,
                    //                             0.01, 2.0, this._m4fUnitProj);
                    this._iUpdateProjectionFlags = akra.bf.setBit(this._iUpdateProjectionFlags, 0 /* k_NewProjectionMatrix */);
                };

                Camera.prototype.recalcMatrices = function () {
                    this._v3fTargetPos.set(this._m4fLocalMatrix.data[__13], this._m4fLocalMatrix.data[__23], this._m4fLocalMatrix.data[__33]);

                    this._v3fTargetPos.negate();

                    // the camera view matrix is the
                    // inverse of the world matrix
                    this._m4fView.set(this.getInverseWorldMatrix());
                    // sky boxes use the inverse
                    // world matrix of the camera (the
                    // camera view matrix) without
                    // any translation information.
                    //this.m4fSkyBox.set(this.m4fView);
                    // this.m4fSkyBox.data[__14] = 0.0;
                    // this.m4fSkyBox.data[__24] = 0.0;
                    // this.m4fSkyBox.data[__34] = 0.0;
                    // this is combined with the unit
                    // space projection matrix to form
                    // the sky box viewing matrix
                    //this.m4fSkyBox.multiply(this.m4fUnitProj, this.m4fSkyBox);
                    // billboard objects use our world matrix
                    // without translation
                    // this.m4fBillboard.set(this.worldMatrix());
                    // this.m4fBillboard.data[__14] = 0.0;
                    // this.m4fBillboard.data[__24] = 0.0;
                    // this.m4fBillboard.data[__34] = 0.0;
                };

                Camera.prototype.update = function () {
                    var isUpdated = _super.prototype.update.call(this);

                    if (this.isProjParamsNew()) {
                        this.recalcProjMatrix();
                    }

                    if (this.isWorldMatrixNew() || akra.bf.testBit(this._iUpdateProjectionFlags, 0 /* k_NewProjectionMatrix */)) {
                        this._pFrustum.extractFromMatrix(this._m4fProj, this._m4fWorldMatrix, this._pSearchRect);

                        // this._m4fRenderStageProj.set(this._m4fProj);
                        if (this.isWorldMatrixNew()) {
                            this.recalcMatrices();
                        }

                        // our projView matrix is the projection
                        //matrix multiplied by the inverse of our world matrix
                        this._m4fProj.multiply(this._m4fView, this._m4fProjView);
                        isUpdated = true;

                        this._iUpdateProjectionFlags = akra.bf.clearBit(this._iUpdateProjectionFlags, 0 /* k_NewProjectionMatrix */);
                    }

                    return isUpdated;
                };

                // applyRenderStageBias(iStage: int): void {
                //    	var fZ_bias = iStage > 1 ? 0.001 : 0.0;
                //     this._m4fRenderStageProj.set(this._m4fProj);
                //     this._m4fRenderStageProjView.set(this._m4fProjView);
                //     this._m4fRenderStageProj[__34] -= fZ_bias;
                //     this._m4fRenderStageProjView[__34] -= fZ_bias;
                //    }
                Camera.prototype._renderScene = function (pViewport) {
                    //update the pixel display ratio
                    // if (this._eCameraType == ECameraTypes.PERSPECTIVE) {
                    // 	mPixelDisplayRatio = (2. * math.tan(this._fFOV * 0.5)) / pViewport.actualHeight;
                    // }
                    // else {
                    // 	mPixelDisplayRatio = (mTop - mBottom) / vp->getActualHeight();
                    // }
                    //notify prerender scene
                    this.preRenderScene.emit();

                    pViewport.update();

                    //notify postrender scene
                    this.postRenderScene.emit();
                };

                Camera.prototype._keepLastViewport = function (pViewport) {
                    this._pLastViewport = pViewport;
                };
                Camera.prototype._getLastViewport = function () {
                    return this._pLastViewport;
                };
                Camera.prototype._getNumRenderedFaces = function () {
                    return 0;
                };
                Camera.prototype._notifyRenderedFaces = function (nFaces) {
                };

                Camera.prototype.isActive = function () {
                    return this._pLastViewport && this._pLastViewport.getCamera() === this;
                };

                Camera.prototype.toString = function (isRecursive, iDepth) {
                    if (typeof isRecursive === "undefined") { isRecursive = false; }
                    if (typeof iDepth === "undefined") { iDepth = 0; }
                    if (!isRecursive) {
                        return "<camera" + (this._sName ? " " + this._sName : "") + ">" + " height: " + this.getWorldPosition().y;
                    }

                    return _super.prototype.toString.call(this, isRecursive, iDepth);
                };

                Camera.prototype.projectPoint = function (v3fPoint, v3fDestination) {
                    if (!akra.isDef(v3fDestination)) {
                        v3fDestination = v3fPoint;
                    }

                    var m4fView = this.getViewMatrix();
                    var m4fProj = this.getProjectionMatrix();

                    var v4fTmp = Vec4.temp(v3fPoint, 1.);

                    v4fTmp = m4fProj.multiplyVec4(m4fView.multiplyVec4(v4fTmp));

                    if (v4fTmp.w <= 0.) {
                        return null;
                    }

                    v3fDestination.set((v4fTmp.scale(1. / v4fTmp.w)).clone("xyz"));

                    var fX = akra.math.abs(v3fDestination.x);
                    var fY = akra.math.abs(v3fDestination.y);
                    var fZ = akra.math.abs(v3fDestination.z);

                    if (fX > 1 || fY > 1 || fZ > 1) {
                        return null;
                    }

                    return v3fDestination;
                };

                Camera.prototype.getDepthRange = function () {
                    var pDepthRange = this._pLastViewport.getDepthRange();

                    var zNear = this._m4fProj.unprojZ(pDepthRange.min);
                    var zFar = this._m4fProj.unprojZ(pDepthRange.max);

                    return { min: zNear, max: zFar };
                };

                Camera.prototype._addDisplayList = function (pScene, pList, index) {
                    this._pDLTechniques[index] = new DLTechnique(pList, this);
                    this._pDLResultStorage[index] = new akra.util.ObjectArray();
                };

                Camera.prototype._removeDisplayList = function (pScene, pList, index) {
                    this._pDLTechniques[index] = null;
                    this._pDLResultStorage[index] = null;
                };

                Camera.isCamera = function (pNode) {
                    return pNode.getType() >= 4 /* CAMERA */ && pNode.getType() <= 5 /* SHADOW_CASTER */;
                };
                return Camera;
            })(scene.SceneNode);
            objects.Camera = Camera;
        })(scene.objects || (scene.objects = {}));
        var objects = scene.objects;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
/// <reference path="../idl/IRenderData.ts" />
/// <reference path="../idl/IVertexData.ts" />
/// <reference path="../idl/IVertexElement.ts" />
/// <reference path="../idl/IBufferMap.ts" />
/// <reference path="../idl/IBufferData.ts" />
/// <reference path="../idl/IRenderDataCollection.ts" />
/// <reference path="../idl/IMap.ts" />
var akra;
(function (akra) {
    /// <reference path="../bf/bf.ts" />
    /// <reference path="VertexDeclaration.ts" />
    /// <reference path="../util/ReferenceCounter.ts" />
    /// <reference path="../debug.ts" />
    /// <reference path="../guid.ts" />
    /// <reference path="../config/config.ts" />
    (function (_data) {
        var RenderData = (function (_super) {
            __extends(RenderData, _super);
            function RenderData(pCollection) {
                if (typeof pCollection === "undefined") { pCollection = null; }
                _super.call(this);
                /**
                * Options.
                */
                this._eOptions = 0;
                /**
                * Buffer, that create this class.
                */
                this._pBuffer = null;
                /**
                * ID of this data.
                */
                this._iId = -1;
                /**
                * Buffer with indices.
                * If the data is the simplest mesh, with no more
                * than one index, the type will be IndexBuffer,
                * otherwise VertexBuffer.
                */
                this._pIndexBuffer = null;
                /**
                * Buffer with attributes.
                */
                this._pAttribBuffer = null;
                /**
                * VextexTextureBuffer with attributes
                */
                this._pAttribVideoBuffer = null;
                /**
                * Data with indices.
                * If _pIndexBuffer has type IndexBuffer, indices data
                * has type IndexData, otherwise VertexData.
                */
                this._pIndexData = null;
                /**
                * Data with attributes.
                */
                this._pAttribData = null;
                /**
                * Buffer map for current index set.
                */
                this._pMap = null;
                /**
                * Buffer maps of all index sets.
                */
                this._pIndicesArray = [];
                /**
                * Current index set.
                */
                this._iIndexSet = 0;
                this._iRenderable = 1;
                this._pComposer = null;
                this._pBuffer = pCollection;
                this._pComposer = pCollection.getEngine().getComposer();
            }
            RenderData.prototype.getBuffer = function () {
                return this._pBuffer;
            };

            RenderData.prototype._getAttribBuffer = function (eType) {
                return eType === 0 /* STATIC */ ? this._pAttribBuffer : this._pAttribVideoBuffer;
            };

            RenderData.prototype.getCurrentIndexSet = function () {
                return this._pIndicesArray[this._iIndexSet];
            };

            RenderData.prototype.allocateData = function (pDecl, pData, hasIndex) {
                if (typeof hasIndex === "undefined") { hasIndex = true; }
                var pDataDecl = _data.VertexDeclaration.normalize(pDecl);
                var eType = 1 /* INDEXED */;

                if (!hasIndex || this.useSingleIndex()) {
                    eType = 3 /* DIRECT */;
                } else if (this.useAdvancedIndex()) {
                    eType = 2 /* I2I */;
                }

                return this._allocateData(pDataDecl, pData, eType);
            };

            /**
            * Remove data from this render data.
            */
            RenderData.prototype.releaseData = function (iDataLocation) {
                //TODO: release data.
            };

            RenderData.prototype.allocateAttribute = function (pDecl, pData, eType, bSilent) {
                if (typeof eType === "undefined") { eType = 0 /* STATIC */; }
                if (typeof bSilent === "undefined") { bSilent = false; }
                var pAttrDecl = _data.VertexDeclaration.normalize(pDecl);
                var pIndexData = this._pIndexData;
                var pAttribData = this._pAttribData;
                var pAttribBuffer = eType === 0 /* STATIC */ ? this._pAttribBuffer : this._pAttribVideoBuffer;
                var pBuffer = this._pBuffer;

                if (!pAttribData || eType === 1 /* DYNAMIC */) {
                    if (!pAttribBuffer) {
                        if (eType === 0 /* STATIC */) {
                            pAttribBuffer = pBuffer.getEngine().getResourceManager().createVertexBuffer('render_data_attrs_' + akra.guid());
                            pAttribBuffer.create(pData.byteLength, 8 /* BACKUP_COPY */);
                            this._pAttribBuffer = pAttribBuffer;
                        } else {
                            pAttribBuffer = pBuffer.getEngine().getResourceManager().createVideoBuffer('render_data_dynamic_attrs_' + akra.guid());
                            pAttribBuffer.create(pData.byteLength, 8 /* BACKUP_COPY */);
                            this._pAttribVideoBuffer = pAttribBuffer;
                        }
                    }

                    this._pAttribData = pAttribBuffer.allocateData(pAttrDecl, pData);
                    this._pIndicesArray[this._iIndexSet].pAttribData = this._pAttribData;

                    if (!bSilent) {
                        this._pMap.flow(this._pAttribData);
                    }

                    return this._pAttribData !== null;
                }

                if (!pAttribData.extend(pAttrDecl, pData)) {
                    akra.logger.log('invalid data for allocation:', arguments);
                    akra.logger.warn('cannot allocate attribute in data subset..');
                    return false;
                }

                return true;
            };

            RenderData.prototype.allocateIndex = function (pDecl, pData) {
                var pAttrDecl = _data.VertexDeclaration.normalize(pDecl);

                if (this.useAdvancedIndex()) {
                    return this._allocateAdvancedIndex(pAttrDecl, pData);
                }

                akra.logger.assert(!this.useSingleIndex() || akra.isNull(pAttrDecl) || pAttrDecl.getLength() === 1, "Index declaration(VertexDeclaration) will be ignored when SINGLE_INDEX mode used for render data");

                return this._allocateIndex(pAttrDecl, pData);
            };

            RenderData.prototype.getAdvancedIndexData = function (sSemantics) {
                return this._getData(sSemantics, true);
            };

            /**
            * Add new set of indices.
            */
            RenderData.prototype.addIndexSet = function (usePreviousDataSet, ePrimType, sName) {
                // if (this._pIndexData === null) {
                //     return false;
                // }
                if (typeof usePreviousDataSet === "undefined") { usePreviousDataSet = true; }
                if (typeof ePrimType === "undefined") { ePrimType = 4 /* TRIANGLELIST */; }
                if (typeof sName === "undefined") { sName = null; }
                if (usePreviousDataSet) {
                    this._pMap = this._pMap.clone(false);

                    if (!this._pMap) {
                        akra.debug.warn("could not clone buffer map");
                        return -1;
                    }
                } else {
                    this._pMap = this._pBuffer.getEngine().createBufferMap();
                    this._pAttribData = null;
                }

                this._pMap.setPrimType(ePrimType);
                this._pIndexData = null;
                this._iIndexSet = this._pIndicesArray.length;
                this._pIndicesArray.push({
                    pMap: this._pMap,
                    pIndexData: this._pIndexData,
                    pAttribData: this._pAttribData,
                    sName: sName,
                    pI2IDataCache: null,
                    pAdditionCache: null
                });

                return this._iIndexSet;
            };

            RenderData.prototype.getNumIndexSet = function () {
                return this._pIndicesArray.length;
            };

            RenderData.prototype.getIndexSetName = function (iSet) {
                if (typeof iSet === "undefined") { iSet = this._iIndexSet; }
                return this._pIndicesArray[iSet].sName;
            };

            RenderData.prototype.selectIndexSet = function (a) {
                var iSet = -1;

                if (akra.isString(arguments[0])) {
                    iSet = this.findIndexSet(arguments[0]);

                    if (iSet < 0) {
                        return false;
                    }
                } else {
                    iSet = arguments[0];
                }

                var pIndexSet = this._pIndicesArray[iSet];

                if (pIndexSet) {
                    this._pMap = pIndexSet.pMap;
                    this._pIndexData = pIndexSet.pIndexData;
                    this._pAttribData = pIndexSet.pAttribData;
                    this._iIndexSet = iSet;
                    return true;
                }

                return false;
            };

            RenderData.prototype.findIndexSet = function (sName) {
                for (var i = 0; i < this._pIndicesArray.length; ++i) {
                    if (this._pIndicesArray[i].sName === sName) {
                        return i;
                    }
                }

                return -1;
            };

            /**
            * Get number of current index set.
            */
            RenderData.prototype.getIndexSet = function () {
                return this._iIndexSet;
            };

            RenderData.prototype.hasAttributes = function () {
                return !akra.isNull(this._pAttribData);
            };

            /**
            * Specifies uses advanced index.
            */
            RenderData.prototype.useAdvancedIndex = function () {
                return (this._eOptions & 65536 /* ADVANCED_INDEX */) != 0;
            };

            RenderData.prototype.useSingleIndex = function () {
                return (this._eOptions & 131072 /* SINGLE_INDEX */) != 0;
            };

            RenderData.prototype.useMultiIndex = function () {
                return (this._eOptions & 131072 /* SINGLE_INDEX */) == 0;
            };

            RenderData.prototype.setRenderable = function (iIndexSet, bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                if (arguments.length < 2) {
                    //mark all render data as renderable or not
                    if (arguments[0]) {
                        this._eOptions = akra.bf.setAll(this._eOptions, 262144 /* RENDERABLE */);
                    } else {
                        this._eOptions = akra.bf.clearAll(this._eOptions, 262144 /* RENDERABLE */);
                    }
                }

                //mark index set is renderable or not
                this._iRenderable = akra.bf.setBit(this._iRenderable, iIndexSet, bValue);
            };

            RenderData.prototype.isRenderable = function (iIndexSet) {
                if (arguments.length > 0) {
                    //is this index set renderable ?
                    return akra.bf.testBit(this._iRenderable, iIndexSet);
                }

                //is this data renderable ?
                return this._eOptions & 262144 /* RENDERABLE */ ? true : false;
            };

            /**
            * Check whether the semantics used in this data set.
            */
            RenderData.prototype.hasSemantics = function (sSemantics, bSearchComplete) {
                if (typeof bSearchComplete === "undefined") { bSearchComplete = true; }
                return this._getFlow(sSemantics, bSearchComplete) !== null;
            };

            RenderData.prototype.getDataLocation = function (sSemantics) {
                var pData = this._getData(sSemantics);

                return pData ? pData.getByteOffset() : -1;
            };

            /**
            * Get indices that uses in current index set.
            */
            RenderData.prototype.getIndices = function () {
                return this._pIndexData;
            };

            RenderData.prototype.getIndexFor = function (sSemantics) {
                var pFlow = this._getFlow(sSemantics);

                if (!akra.isNull(pFlow.mapper)) {
                    return pFlow.mapper.data.getTypedData(pFlow.mapper.semantics);
                }

                return null;
            };

            RenderData.prototype.getInitialIndexFor = function (sSemantics) {
                var pFlow = this._getFlow(sSemantics);

                if (!akra.isNull(pFlow.mapper)) {
                    return null;
                }

                var pIndices = pFlow.mapper.data.getTypedData(pFlow.mapper.semantics);
                var pData = pFlow.data.getTypedData(sSemantics);
                var iStride = pFlow.data.getStride();
                var iAddition = pFlow.data.getByteOffset();

                for (var i = 0; i < pIndices.length; i++) {
                    pIndices[i] = (pIndices[i] * 4 /* BYTES_PER_FLOAT */ - iAddition) / iStride;
                }

                return pIndices;
            };

            /**
            * Get number of primitives for rendering.
            */
            RenderData.prototype.getPrimitiveCount = function () {
                return this._pMap.getPrimCount();
            };

            RenderData.prototype.getPrimitiveType = function () {
                return this._pMap.getPrimType();
            };

            RenderData.prototype.index = function (data, sSemantics, useSame, iBeginWith, bForceUsage) {
                if (typeof useSame === "undefined") { useSame = false; }
                if (typeof iBeginWith === "undefined") { iBeginWith = 0; }
                if (typeof bForceUsage === "undefined") { bForceUsage = false; }
                var iData = akra.isNumber(arguments[0]) ? arguments[0] : 0;
                var iFlow = -1;
                var iAddition, iRealAddition, iPrevAddition;
                var pFlow;
                var pData, pRealData;
                var pFloat32Array;
                var iIndexOffset;
                var pIndexData = this._pIndexData;
                var sData;
                var iStride;
                var iTypeSize = 4 /* BYTES_PER_FLOAT */;

                if (this.useSingleIndex()) {
                    pIndexData = this._pAttribData;
                }

                if (this.useAdvancedIndex()) {
                    pRealData = this._getData(arguments[0]);
                    iAddition = pRealData.getByteOffset();
                    iStride = pRealData.getStride();

                    //индекс, который подал юзер
                    pData = this._getData(sSemantics, true);

                    pData.applyModifier(sSemantics, function (pTypedData) {
                        for (var i = 0; i < pTypedData.length; i++) {
                            pTypedData[i] = (pTypedData[i] * iStride + iAddition) / iTypeSize;
                        }
                    });

                    iData = pData.getByteOffset();
                    sSemantics = "INDEX_" + sSemantics;
                } else if (akra.isString(arguments[0])) {
                    //if (arguments[0] === "BARYCENTRIC") {
                    //	debugger;
                    //}
                    if (arguments[0] === "TEXCOORD") {
                        iData = this.getDataLocation("TEXCOORD0");
                        pFlow = this._getFlow("TEXCOORD0", false);
                    } else {
                        iData = this.getDataLocation(arguments[0]);
                        pFlow = this._getFlow(arguments[0], false);
                    }

                    akra.debug.assert(iData >= 0, "cannot find data with semantics: " + arguments[0]);
                }

                if (!pFlow) {
                    pFlow = this._getFlow(iData);
                }

                if (pFlow === null) {
                    //поищем эти данные в общем буфере
                    pData = this.getBuffer().getData(iData);

                    if (akra.isNull(pData)) {
                        akra.debug.warn("Could not find data flow <" + iData + "> int buffer map: " + this._pMap.toString(true));
                        return false;
                    }

                    //все ок, данные найдены, зарегистрируем их у себя в мапе
                    akra.logger.assert(this._addData(pData) !== -1, "could not add automatcly add data to map");
                    pFlow = this._getFlow(iData);
                }

                iFlow = pFlow.flow;
                iIndexOffset = pIndexData.getVertexDeclaration().findElement(sSemantics).offset;
                pFloat32Array = pIndexData.getTypedData(sSemantics);
                iAddition = iData;

                if (!pFloat32Array) {
                    akra.debug.log(pIndexData.toString());
                    akra.debug.error("RenderData.index() fail! Couldn`t find indeces");
                    return false;
                }

                iStride = pFlow.data.getStride();

                if (this.getCurrentIndexSet().pAdditionCache[iIndexOffset] !== iAddition && !bForceUsage) {
                    if (!useSame) {
                        iPrevAddition = this.getCurrentIndexSet().pAdditionCache[iIndexOffset] || 0;
                        iRealAddition = iAddition - iPrevAddition;

                        for (var i = 0; i < pFloat32Array.length; i++) {
                            pFloat32Array[i] = (pFloat32Array[i] * iStride + iRealAddition) / iTypeSize;
                        }
                    } else {
                        iRealAddition = iAddition;
                        for (var i = 0; i < pFloat32Array.length; i++) {
                            pFloat32Array[i] = (iBeginWith + iRealAddition) / iTypeSize;
                        }
                    }

                    //remeber addition, that we added to index.
                    this.getCurrentIndexSet().pAdditionCache[iIndexOffset] = iAddition;

                    if (!pIndexData.setData(pFloat32Array, sSemantics)) {
                        akra.debug.error("RenderData.index() fail! Couldn`t update indeces");
                        return false;
                    }
                }

                return this._pMap.mapping(iFlow, pIndexData, sSemantics);
            };

            /*Setup.*/
            RenderData.prototype._setup = function (pCollection, iId, ePrimType, eOptions) {
                if (typeof ePrimType === "undefined") { ePrimType = 4 /* TRIANGLELIST */; }
                if (typeof eOptions === "undefined") { eOptions = 0; }
                if (this._pBuffer === null && arguments.length < 2) {
                    return false;
                }

                this.setRenderable(true);

                this._eOptions |= eOptions;
                this._pBuffer = pCollection;
                this._iId = iId;

                //setup buffer map
                this._pMap = pCollection.getEngine().createBufferMap();
                this._pMap.setPrimType(ePrimType);

                //setup default index set
                this._pIndicesArray.push({
                    sName: ".main",
                    pMap: this._pMap,
                    pIndexData: null,
                    pAttribData: null,
                    pI2IDataCache: {},
                    pAdditionCache: null
                });

                //debug.assert(this.useSingleIndex() === false, "single indexed data not implimented");
                return true;
            };

            RenderData.prototype._allocateData = function (pDataDecl, pData, eType) {
                if (eType === 3 /* DIRECT */) {
                    return this.allocateAttribute(pDataDecl, pData) ? 0 : -1;
                }

                var iFlow;
                var pVertexData = this._pBuffer._allocateData(pDataDecl, pData);
                var iOffset = pVertexData.getByteOffset();

                iFlow = this._addData(pVertexData, undefined, eType);

                if (iFlow < 0) {
                    akra.logger.log("invalid data", pDataDecl, pData);
                    akra.debug.error("cannot allocate data for submesh");
                    return -1;
                }

                return iOffset;
            };

            /**
            * Add vertex data to this render data.
            */
            RenderData.prototype._addData = function (pVertexData, iFlow, eType) {
                if (typeof eType === "undefined") { eType = 3 /* DIRECT */; }
                if ((arguments.length < 3 && this.useAdvancedIndex()) || arguments[2] === 2 /* I2I */) {
                    return this._registerData(pVertexData);
                }

                return (!akra.isDef(iFlow) ? this._pMap.flow(pVertexData) : this._pMap.flow(iFlow, pVertexData));
            };

            RenderData.prototype._getComposer = function () {
                return null;
            };

            /**
            * Register data in this render.
            * Necessary for index to index mode, when data realy
            * not using in this render data for building final buffer map.
            */
            RenderData.prototype._registerData = function (pVertexData) {
                'use strict';
                var iOffset = pVertexData.getByteOffset();
                var pDataDecl = pVertexData.getVertexDeclaration();

                for (var i = 0; i < pDataDecl.getLength(); i++) {
                    this.getCurrentIndexSet().pI2IDataCache[pDataDecl.element(i).usage] = iOffset;
                }

                return 0;
            };

            RenderData.prototype._allocateAdvancedIndex = function (pAttrDecl, pData) {
                var pDecl = _data.VertexDeclaration.normalize(pAttrDecl);
                var nCount = pData.byteLength / pDecl.stride;

                //TODO: remove index dublicates
                var iIndLoc = this._allocateData(pAttrDecl, pData, 1 /* INDEXED */);
                var pI2IData = new Float32Array(nCount);
                var pI2IDecl = [];

                for (var i = 0; i < pDecl.getLength(); i++) {
                    pI2IDecl.push(_data.VertexElement.float('INDEX_' + pDecl.element(i).usage, 0));
                }

                for (var i = 0; i < pI2IData.length; i++) {
                    pI2IData[i] = i;
                }

                if (!this._allocateIndex(pI2IDecl, pI2IData)) {
                    this.releaseData(iIndLoc);
                    pI2IData = null;
                    pI2IDecl = null;
                    akra.logger.warn('cannot allocate index for index in render data subset');
                    return false;
                }

                return true;
            };

            RenderData.prototype._createIndex = function (pAttrDecl, pData) {
                'use strict';

                if (this.useMultiIndex()) {
                    //MULTIPLE INDEXES
                    if (!this._pIndexBuffer) {
                        this._pIndexBuffer = this._pBuffer.getEngine().getResourceManager().createVertexBuffer('subset_' + akra.guid());
                        this._pIndexBuffer.create((pData.byteLength), 8 /* BACKUP_COPY */);
                    }

                    this._pIndexData = this._pIndexBuffer.allocateData(pAttrDecl, pData);
                } else {
                    akra.debug.assert(akra.isNull(pAttrDecl) || pAttrDecl.getLength() === 1, "Index declaration(VertexDeclaration) will be ignored when SINGLE_INDEX mode used for render data");
                    akra.logger.assert(pData instanceof Uint16Array || pData instanceof Uint32Array, "Indexes must be packed to Uint[16, 32]Array");

                    //SINGLE INDEX
                    if (!this._pIndexBuffer) {
                        this._pIndexBuffer = this._pBuffer.getEngine().getResourceManager().createIndexBuffer('subset_' + akra.guid());
                        this._pIndexBuffer.create((pData.byteLength), 8 /* BACKUP_COPY */ | 1 /* STATIC */);
                    }

                    var eDataType = 5123 /* UNSIGNED_SHORT */;

                    if (pData instanceof Uint32Array) {
                        eDataType = 5125 /* UNSIGNED_INT */;
                    }

                    this._pIndexData = this._pIndexBuffer.allocateData(this._pMap.getPrimType(), eDataType, pData);

                    this._pMap.setIndex(this._pIndexData);
                }

                this.getCurrentIndexSet().pIndexData = this._pIndexData;
                this.getCurrentIndexSet().pAdditionCache = {};
                return this._pIndexData !== null;
            };

            RenderData.prototype._allocateIndex = function (pDecl, pData) {
                'use strict';

                var pAttrDecl = _data.VertexDeclaration.normalize(pDecl);

                var pIndexData = this._pIndexData;
                var pIndexBuffer = this._pIndexBuffer;
                var pBuffer = this._pBuffer;

                if (akra.config.DEBUG && !akra.isNull(pDecl)) {
                    for (var i = 0; i < pAttrDecl.getLength(); i++) {
                        if (pAttrDecl.element(i).type !== 5126 /* FLOAT */) {
                            return false;
                        }
                    }
                }

                if (!this._pIndexData) {
                    return this._createIndex(pAttrDecl, pData);
                } else {
                    akra.logger.assert(!this.useSingleIndex(), "Multiple indexes not allowed for SINGLE_INDEX'ed render data.");
                }

                if (!this._pIndexData.extend(pAttrDecl, pData)) {
                    akra.logger.log('invalid data for allocation:', arguments);
                    akra.logger.warn('cannot allocate index in data subset..');
                    return false;
                }

                return true;
            };

            RenderData.prototype._setIndexLength = function (iLength) {
                var bResult = this._pIndexData.resize(iLength);

                if (bResult) {
                    this._pMap._setLengthForce(iLength);
                }

                return bResult;
            };

            RenderData.prototype._getFlow = function (a, b) {
                if (typeof arguments[0] === 'string') {
                    return this._pMap.getFlow(arguments[0], arguments[1]);
                }

                for (var i = 0, n = this._pMap.getLimit(); i < n; ++i) {
                    var pFlow = this._pMap.getFlow(i, false);

                    if (pFlow.data && pFlow.data.getByteOffset() === arguments[0]) {
                        return pFlow;
                    }
                }

                return null;
            };

            RenderData.prototype._getData = function (a, b) {
                var pFlow;

                if (this.useAdvancedIndex() && arguments.length < 2) {
                    if (typeof arguments[0] === 'string') {
                        return this._getData(this.getCurrentIndexSet().pI2IDataCache[arguments[0]]);
                    }

                    return this._pBuffer.getData(arguments[0]);
                }

                if (typeof arguments[0] === 'string') {
                    for (var i = 0, n = this._pMap.getLimit(); i < n; ++i) {
                        pFlow = this._pMap.getFlow(i, false);
                        if (pFlow.data != null && pFlow.data.hasSemantics(arguments[0])) {
                            return pFlow.data;
                        }
                    }

                    return null;
                }

                pFlow = this._getFlow(arguments[0]);
                return pFlow === null ? null : pFlow.data;
            };

            /**
            * Draw this data.
            */
            RenderData.prototype._draw = function (pTechnique, pViewport, pRenderable, pSceneObject) {
                for (var i = 0; i < this._pIndicesArray.length; i++) {
                    if (this.isRenderable(i)) {
                        //this._pIndicesArray[i].pMap._draw();
                        this._pComposer.applyBufferMap(this._pIndicesArray[i].pMap);
                        pTechnique._renderTechnique(pViewport, pRenderable, pSceneObject);
                    }
                }
            };

            //applyMe(): boolean;
            RenderData.prototype.toString = function () {
                var s;
                s = "\nRENDER DATA SUBSET: #" + this._iId + "\n";
                s += "        ATTRIBUTES: " + (this._pAttribData ? "TRUE" : "FALSE") + "\n";
                s += "----------------------------------------------------------------\n";
                s += this._pMap.toString();

                return s;
            };
            return RenderData;
        })(akra.util.ReferenceCounter);
        _data.RenderData = RenderData;
    })(akra.data || (akra.data = {}));
    var data = akra.data;
})(akra || (akra = {}));
/// <reference path="../idl/IRenderDataCollection.ts" />
/// <reference path="../idl/IHardwareBuffer.ts" />
var akra;
(function (akra) {
    /// <reference path="RenderData.ts" />
    /// <reference path="VertexDeclaration.ts" />
    (function (data) {
        var RenderDataCollection = (function (_super) {
            __extends(RenderDataCollection, _super);
            function RenderDataCollection(pEngine, eOptions) {
                if (typeof eOptions === "undefined") { eOptions = 0; }
                _super.call(this);
                this._pDataBuffer = null;
                this._pEngine = null;
                this._eDataOptions = 0;
                this._pDataArray = [];
                this._pEngine = pEngine;
                this.setup(eOptions);
            }
            RenderDataCollection.prototype.getBuffer = function () {
                return this._pDataBuffer;
            };

            RenderDataCollection.prototype.getLength = function () {
                return this._pDataArray.length;
            };

            RenderDataCollection.prototype.getByteLength = function () {
                return this._pDataBuffer.getByteLength();
            };

            RenderDataCollection.prototype.clone = function (pSrc) {
                akra.logger.critical("TODO: RenderDataCollection::clone();");

                return false;
            };

            RenderDataCollection.prototype.getEngine = function () {
                return this._pEngine;
            };

            RenderDataCollection.prototype.getOptions = function () {
                return this._eDataOptions;
            };

            RenderDataCollection.prototype.getData = function (a) {
                var pBuffer = this._pDataBuffer;
                var pData;
                var n;

                if (!akra.isNull(pBuffer)) {
                    n = this._pDataBuffer.getLength();

                    if (akra.isString(arguments[0])) {
                        for (var i = 0; i < n; i++) {
                            pData = pBuffer.getVertexData(i);
                            if (pData.hasSemantics(arguments[0])) {
                                return pData;
                            }
                        }
                    } else {
                        for (var i = 0; i < n; i++) {
                            pData = pBuffer.getVertexData(i);
                            if (pData.getByteOffset() === arguments[0]) {
                                return pData;
                            }
                        }
                    }
                }

                return null;
            };

            RenderDataCollection.prototype._allocateData = function (pDecl, pData) {
                if (!this._pDataBuffer) {
                    this.createDataBuffer();
                }

                var pVertexDecl = data.VertexDeclaration.normalize(pDecl);
                var pVertexData;

                if ((arguments.length < 2) || akra.isNumber(arguments[1]) || akra.isNull(arguments[1])) {
                    pVertexData = this._pDataBuffer.getEmptyVertexData(pData || 1, pVertexDecl);
                } else {
                    pVertexData = this._pDataBuffer.allocateData(pVertexDecl, pData);
                }

                akra.debug.assert(pVertexData !== null, "cannot allocate data:\n" + pVertexDecl.toString());

                return pVertexData;
            };

            RenderDataCollection.prototype.allocateData = function (pDecl, pData, isCommon) {
                if (typeof isCommon === "undefined") { isCommon = true; }
                var pVertexData;
                var pDataDecl = data.VertexDeclaration.normalize(pDecl);

                if (akra.config.DEBUG) {
                    for (var i = 0; i < pDataDecl.getLength(); i++) {
                        if (this.getData(pDataDecl.element(i).usage) !== null && pDataDecl.element(i).count !== 0) {
                            akra.logger.warn("data buffer already contains data with similar vertex decloration <" + pDataDecl.element(i).usage + ">.");
                        }
                    }
                }

                pVertexData = this._allocateData(pDataDecl, pData);

                if (isCommon) {
                    for (var i = 0; i < this._pDataArray.length; ++i) {
                        this._pDataArray[i]._addData(pVertexData);
                    }
                }

                return pVertexData.getByteOffset();
            };

            RenderDataCollection.prototype.getDataLocation = function (sSemantics) {
                if (this._pDataBuffer) {
                    var pData;

                    for (var i = 0, n = this._pDataBuffer.getLength(); i < n; i++) {
                        pData = this._pDataBuffer.getVertexData(i);
                        if (pData.hasSemantics(sSemantics)) {
                            return pData.getByteOffset();
                        }
                    }
                }

                return -1;
            };

            RenderDataCollection.prototype.createDataBuffer = function () {
                //TODO: add support for eOptions
                var iVbOption = 0;
                var eOptions = this._eDataOptions;

                if (eOptions & akra.ERenderDataBufferOptions.VB_READABLE) {
                    iVbOption = akra.ERenderDataBufferOptions.VB_READABLE;
                }

                //trace('creating new video buffer for render data buffer ...');
                this._pDataBuffer = this._pEngine.getResourceManager().createVideoBuffer("render_data_buffer" + "_" + akra.guid());
                this._pDataBuffer.create(0, iVbOption);
                this._pDataBuffer.addRef();
                return this._pDataBuffer !== null;
            };

            RenderDataCollection.prototype.getRenderData = function (iSubset) {
                return this._pDataArray[iSubset];
            };

            RenderDataCollection.prototype.getEmptyRenderData = function (ePrimType, eOptions) {
                if (typeof eOptions === "undefined") { eOptions = 0; }
                var iSubsetId = this._pDataArray.length;
                var pDataset = new data.RenderData(this);

                eOptions |= this._eDataOptions;

                if (!pDataset._setup(this, iSubsetId, ePrimType, eOptions)) {
                    akra.debug.error("cannot setup submesh...");
                }

                this._pDataArray.push(pDataset);

                return pDataset;
            };

            RenderDataCollection.prototype._draw = function (iSubset) {
                // if (arguments.length > 0) {
                //     this._pDataArray[iSubset]._draw();
                // }
                // for (var i: int = 0; i < this._pDataArray.length; i++) {
                //     this._pDataArray[i]._draw();
                // }
                akra.logger.critical("TODO");
            };

            RenderDataCollection.prototype.destroy = function () {
                this._pDataArray = null;

                if (this._pDataBuffer) {
                    // this._pDataBuffer.release();
                    this._pDataBuffer.destroy();
                    this._pDataBuffer = null;
                }

                this._pEngine = null;
                this._eDataOptions = 0;
            };

            RenderDataCollection.prototype.setup = function (eOptions) {
                if (typeof eOptions === "undefined") { eOptions = 0; }
                this._eDataOptions = eOptions;
            };
            return RenderDataCollection;
        })(akra.util.ReferenceCounter);
        data.RenderDataCollection = RenderDataCollection;

        function createRenderDataCollection(pEngine, eOptions) {
            if (typeof eOptions === "undefined") { eOptions = 0; }
            return new RenderDataCollection(pEngine, eOptions);
        }
        data.createRenderDataCollection = createRenderDataCollection;
    })(akra.data || (akra.data = {}));
    var data = akra.data;
})(akra || (akra = {}));
/// <reference path="IEventProvider.ts" />
/// <reference path="IMap.ts" />
var akra;
(function (akra) {
    (function (ERPCPacketTypes) {
        ERPCPacketTypes[ERPCPacketTypes["FAILURE"] = 0] = "FAILURE";
        ERPCPacketTypes[ERPCPacketTypes["REQUEST"] = 1] = "REQUEST";
        ERPCPacketTypes[ERPCPacketTypes["RESPONSE"] = 2] = "RESPONSE";
    })(akra.ERPCPacketTypes || (akra.ERPCPacketTypes = {}));
    var ERPCPacketTypes = akra.ERPCPacketTypes;

    (function (ERPCErrorCodes) {
        ERPCErrorCodes[ERPCErrorCodes["STACK_SIZE_EXCEEDED"] = 0] = "STACK_SIZE_EXCEEDED";
        ERPCErrorCodes[ERPCErrorCodes["CALLBACK_LIFETIME_EXPIRED"] = 1] = "CALLBACK_LIFETIME_EXPIRED";
    })(akra.ERPCErrorCodes || (akra.ERPCErrorCodes = {}));
    var ERPCErrorCodes = akra.ERPCErrorCodes;

    (function (ERpcStates) {
        //not connected
        ERpcStates[ERpcStates["k_Deteached"] = 0] = "k_Deteached";

        //connected, and connection must be established
        ERpcStates[ERpcStates["k_Joined"] = 1] = "k_Joined";

        //must be closed
        ERpcStates[ERpcStates["k_Closing"] = 2] = "k_Closing";
    })(akra.ERpcStates || (akra.ERpcStates = {}));
    var ERpcStates = akra.ERpcStates;
})(akra || (akra = {}));
/// <reference path="IEventProvider.ts" />
var akra;
(function (akra) {
    (function (EPipeTypes) {
        EPipeTypes[EPipeTypes["UNKNOWN"] = 0] = "UNKNOWN";

        EPipeTypes[EPipeTypes["WEBSOCKET"] = 1] = "WEBSOCKET";
        EPipeTypes[EPipeTypes["WEBWORKER"] = 2] = "WEBWORKER";
    })(akra.EPipeTypes || (akra.EPipeTypes = {}));
    var EPipeTypes = akra.EPipeTypes;

    (function (EPipeDataTypes) {
        EPipeDataTypes[EPipeDataTypes["BINARY"] = 0] = "BINARY";
        EPipeDataTypes[EPipeDataTypes["STRING"] = 1] = "STRING";
    })(akra.EPipeDataTypes || (akra.EPipeDataTypes = {}));
    var EPipeDataTypes = akra.EPipeDataTypes;
})(akra || (akra = {}));
/// <reference path="../idl/IPipe.ts" />
var akra;
(function (akra) {
    /// <reference path="../logger.ts" />
    /// <reference path="../debug.ts" />
    /// <reference path="../config/config.ts" />
    /// <reference path="../uri/uri.ts" />
    /// <reference path="../path/path.ts" />
    /// <reference path="../events.ts" />
    /// <reference path="../guid.ts" />
    (function (net) {
        /** @const */
        var WEBSOCKET_PORT = akra.config.net.port;

        var Pipe = (function () {
            function Pipe(sAddr) {
                if (typeof sAddr === "undefined") { sAddr = null; }
                this.guid = akra.guid();
                this._pAddr = null;
                this._nMesg = 0;
                this._eType = 0 /* UNKNOWN */;
                this._pConnect = null;
                this._bSetupComplete = false;
                this.setupSignals();

                if (!akra.isNull(sAddr)) {
                    this.open(sAddr);
                }
            }
            Pipe.prototype.setupSignals = function () {
                this.opened = this.opened || new akra.Signal(this);
                this.closed = this.closed || new akra.Signal(this);
                this.error = this.error || new akra.Signal(this);
                this.message = this.message || new akra.Signal(this);
            };

            Pipe.prototype.getURI = function () {
                return akra.uri.parse(this._pAddr.toString());
            };

            Pipe.prototype.open = function (sAddr) {
                if (typeof sAddr === "undefined") { sAddr = null; }
                var pAddr;
                var eType;
                var pSocket = null;
                var pWorker = null;
                var pPipe = this;

                if (!akra.isNull(sAddr)) {
                    pAddr = akra.uri.parse(sAddr);
                } else {
                    if (this.isCreated()) {
                        this.close();
                    }

                    pAddr = this.getURI();
                }

                // pipe to websocket
                if (pAddr.getProtocol().toLowerCase() === "ws") {
                    //unknown port
                    if (!(pAddr.getPort() > 0)) {
                        pAddr.setPort(WEBSOCKET_PORT);
                    }

                    //websocket unsupported
                    if (!akra.isDefAndNotNull(WebSocket)) {
                        akra.logger.error("Your browser does not support websocket api.");
                        return false;
                    }

                    pSocket = new WebSocket(pAddr.toString());

                    pSocket.binaryType = "arraybuffer";
                    eType = 1 /* WEBSOCKET */;
                } else if (akra.path.parse(pAddr.getPath()).getExt().toLowerCase() === "js") {
                    if (!akra.isDefAndNotNull(Worker)) {
                        akra.logger.error("Your browser does not support webworker api.");
                        return false;
                    }

                    pWorker = new Worker(pAddr.toString());
                    eType = 2 /* WEBWORKER */;
                } else {
                    akra.logger.error("Pipe supported only websockets/webworkers.");
                    return false;
                }

                this._pConnect = (pWorker || pSocket);
                this._pAddr = pAddr;
                this._eType = eType;

                if (akra.isDefAndNotNull(window)) {
                    window.onunload = function () {
                        pPipe.close();
                    };
                }

                if (!akra.isNull(this._pConnect)) {
                    this.setupConnect();

                    return true;
                }

                return false;
            };

            Pipe.prototype.setupConnect = function () {
                var pConnect = this._pConnect;
                var pPipe = this;
                var pAddr = this._pAddr;

                if (this._bSetupComplete) {
                    return;
                }

                pConnect.onmessage = function (pMessage) {
                    if (akra.isArrayBuffer(pMessage.data)) {
                        pPipe.message.emit(pMessage.data, 0 /* BINARY */);
                    } else {
                        pPipe.message.emit(pMessage.data, 1 /* STRING */);
                    }
                };

                pConnect.onopen = function (pEvent) {
                    akra.logger.log("created connect to: " + pAddr.toString());

                    pPipe.opened.emit(pEvent);
                };

                pConnect.onerror = function (pErr) {
                    akra.debug.warn("pipe error detected: " + pErr.message);
                    pPipe.error.emit(pErr);
                };

                pConnect.onclose = function (pEvent) {
                    akra.logger.log("connection to " + pAddr.toString() + " closed");
                    akra.debug.log("Close event:", pEvent);
                    pPipe.closed.emit(pEvent);
                };

                this._bSetupComplete = true;
            };

            Pipe.prototype.close = function () {
                var pSocket;
                var pWorker;
                if (this.isOpened()) {
                    switch (this._eType) {
                        case 1 /* WEBSOCKET */:
                            pSocket = this._pConnect;
                            pSocket.onmessage = null;
                            pSocket.onerror = null;
                            pSocket.onopen = null;
                            pSocket.close();
                            break;
                        case 2 /* WEBWORKER */:
                            pWorker = this._pConnect;
                            pWorker.terminate();
                    }
                }

                this._pConnect = null;
                this._bSetupComplete = false;
            };

            Pipe.prototype.write = function (pValue) {
                var pSocket;
                var pWorker;

                if (this.isOpened()) {
                    this._nMesg++;

                    switch (this._eType) {
                        case 1 /* WEBSOCKET */:
                            pSocket = this._pConnect;

                            if (akra.isObject(pValue)) {
                                pValue = JSON.stringify(pValue);
                            }

                            pSocket.send(pValue);

                            return true;

                        case 2 /* WEBWORKER */:
                            pWorker = this._pConnect;

                            if (akra.isDef(pValue.byteLength)) {
                                pWorker.postMessage(pValue, [pValue]);
                            } else {
                                pWorker.postMessage(pValue);
                            }

                            return true;
                    }
                }

                return false;
            };

            Pipe.prototype.isClosed = function () {
                switch (this._eType) {
                    case 1 /* WEBSOCKET */:
                        return akra.isNull(this._pConnect) || (this._pConnect.readyState === WebSocket.CLOSED);
                }

                return akra.isNull(this._pConnect);
            };

            Pipe.prototype.isOpened = function () {
                switch (this._eType) {
                    case 1 /* WEBSOCKET */:
                        return !akra.isNull(this._pConnect) && this._pConnect.readyState === WebSocket.OPEN;
                }

                return !akra.isNull(this._pConnect);
            };

            Pipe.prototype.isCreated = function () {
                return !akra.isNull(this._pConnect);
            };
            return Pipe;
        })();
        net.Pipe = Pipe;
    })(akra.net || (akra.net = {}));
    var net = akra.net;
})(akra || (akra = {}));
/// <reference path="../idl/IObjectSortCollection.ts" />
/// <reference path="../logger.ts" />
var akra;
(function (akra) {
    (function (util) {
        var ObjectSortCollection = (function () {
            function ObjectSortCollection(iSize) {
                this._iSize = 0;
                this._iCursor = 0;
                this._pElements = null;
                this._fnCollectionIndex = null;
                this._iCursorElementIndex = 0xFFFFFFFF;
                this._iStartElementIndex = 0xFFFFFFFF;
                this._iLastElementIndex = 0xFFFFFFFF;
                this._iSize = iSize;
                this._pElements = new Array(iSize);
                this._iCursor = -1;

                for (var i = 0; i < iSize; i++) {
                    this._pElements[i] = null;
                }
            }
            ObjectSortCollection.prototype.push = function (pElement) {
                if (this._iCursor === this._iSize - 1) {
                    this._iCursor = -1;
                }

                this._iCursor++;

                this._pElements[this._iCursor] = pElement;

                this._iCursorElementIndex = this._fnCollectionIndex.call(null, this._pElements[this._iCursor]);

                if (this._iCursor === 0) {
                    this._iStartElementIndex = this._fnCollectionIndex.call(null, this._pElements[0]);
                } else if (this._iCursor === this._iSize - 1) {
                    this._iLastElementIndex = this._fnCollectionIndex.call(null, this._pElements[this._iSize - 1]);
                }
            };

            ObjectSortCollection.prototype.findElement = function (iCollectionIndex) {
                if (this._iStartElementIndex === 0xFFFFFFFF || this._iCursorElementIndex === 0xFFFFFFFF || iCollectionIndex > this._iCursorElementIndex) {
                    return null;
                }

                if (iCollectionIndex >= this._iStartElementIndex) {
                    return this._pElements[iCollectionIndex - this._iStartElementIndex];
                } else if (iCollectionIndex <= this._iLastElementIndex) {
                    return this._pElements[this._iSize - 1 - (this._iLastElementIndex - iCollectionIndex)];
                }

                return null;
            };

            ObjectSortCollection.prototype.takeElement = function (iCollectionIndex) {
                if (this._iStartElementIndex === 0xFFFFFFFF || this._iCursorElementIndex === 0xFFFFFFFF || iCollectionIndex > this._iCursorElementIndex) {
                    akra.logger.log("i must not be here 1");
                    return null;
                }

                var iResultIndex = -1;

                if (iCollectionIndex >= this._iStartElementIndex) {
                    iResultIndex = iCollectionIndex - this._iStartElementIndex;
                } else if (iCollectionIndex <= this._iLastElementIndex) {
                    iResultIndex = this._iSize - 1 - (this._iLastElementIndex - iCollectionIndex);
                }

                if (iResultIndex >= 0) {
                    var pResult = this._pElements[iResultIndex];
                    this._pElements[iResultIndex] = null;
                    return pResult;
                } else {
                    //LOG("i must not be here 2");
                    return null;
                }
            };

            ObjectSortCollection.prototype.getElementAt = function (iIndex) {
                return this._pElements[iIndex];
            };

            ObjectSortCollection.prototype.setElementAt = function (iIndex, pValue) {
                this._pElements[iIndex] = pValue;
            };

            ObjectSortCollection.prototype.removeElementAt = function (iIndex) {
                this._pElements[iIndex] = null;
            };

            ObjectSortCollection.prototype.clear = function () {
                this._iCursor = -1;

                for (var i = 0; i < this._iSize - 1; i++) {
                    this._pElements[i] = null;
                }
            };

            ObjectSortCollection.prototype.setCollectionFuncion = function (fnCollection) {
                this._fnCollectionIndex = fnCollection;
            };
            return ObjectSortCollection;
        })();
        util.ObjectSortCollection = ObjectSortCollection;
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
/// <reference path="../idl/IRPC.ts" />
var akra;
(function (akra) {
    /// <reference path="../logger.ts" />
    /// <reference path="../debug.ts" />
    /// <reference path="../config/config.ts" />
    /// <reference path="../uri/uri.ts" />
    /// <reference path="../path/path.ts" />
    /// <reference path="../events.ts" />
    /// <reference path="../guid.ts" />
    /// <reference path="../time.ts" />
    /// <reference path="Pipe.ts" />
    /// <reference path="../util/ObjectArray.ts" />
    /// <reference path="../util/ObjectList.ts" />
    /// <reference path="../util/ObjectSortCollection.ts" />
    (function (net) {
        var ObjectList = akra.util.ObjectList;
        var ObjectArray = akra.util.ObjectArray;
        var ObjectSortCollection = akra.util.ObjectSortCollection;

        var OPTIONS = akra.config.rpc;

        function hasLimitedDeferredCalls(pRpc) {
            return (pRpc.getOptions().deferredCallsLimit >= 0);
        }

        function hasReconnect(pRpc) {
            return (pRpc.getOptions().reconnectTimeout > 0);
        }

        function hasSystemRoutine(pRpc) {
            return (pRpc.getOptions().systemRoutineInterval > 0);
        }
        function hasCallbackLifetime(pRpc) {
            return (pRpc.getOptions().callbackLifetime > 0);
        }

        function hasGroupCalls(pRpc) {
            return (pRpc.getOptions().callsFrequency > 0);
        }

        function hasCallbacksCountLimit(pRpc) {
            return (pRpc.getOptions().maxCallbacksCount > 0);
        }

        var RPC = (function () {
            function RPC(pAddr, pOption) {
                if (typeof pAddr === "undefined") { pAddr = null; }
                if (typeof pOption === "undefined") { pOption = {}; }
                this.guid = akra.guid();
                this._pPipe = null;
                this._iGroupID = -1;
                this._pGroupCalls = null;
                //стек вызововы, которые были отложены
                this._pDefferedRequests = new ObjectList();
                //стек вызовов, ожидающих результата
                //type: ObjectList<IRPCCallback>
                this._pCallbacksList = null;
                this._pCallbacksCollection = null;
                //число совершенных вызовов
                this._nCalls = 0;
                this._pRemoteAPI = {};
                this._eState = 0 /* k_Deteached */;
                //rejoin timer
                this._iReconnect = -1;
                //timer for system routine
                this._iSystemRoutine = -1;
                this._iGroupCallRoutine = -1;
                this.setupSignals();

                for (var i in OPTIONS) {
                    if (!akra.isDef(pOption[i])) {
                        pOption[i] = OPTIONS[i];
                    }
                }

                this._pOption = pOption;

                if (!akra.isDefAndNotNull(pOption.procMap)) {
                    pOption.procMap = {};
                }

                pOption.procMap[pOption.procListName] = {
                    lifeTime: -1,
                    priority: 10
                };

                if (hasCallbacksCountLimit(this)) {
                    this._pCallbacksCollection = new ObjectSortCollection(this._pOption.maxCallbacksCount);
                    this._pCallbacksCollection.setCollectionFuncion(function (pCallback) {
                        return akra.isNull(pCallback) ? -1 : pCallback.n;
                    });
                } else {
                    this._pCallbacksList = new ObjectList();
                }
                pAddr = pAddr || pOption.addr;

                if (akra.isDefAndNotNull(pAddr)) {
                    this.join(pAddr);
                }
            }
            RPC.prototype.getRemote = function () {
                return this._pRemoteAPI;
            };
            RPC.prototype.getOptions = function () {
                return this._pOption;
            };
            RPC.prototype.getGroup = function () {
                return !akra.isNull(this._pGroupCalls) ? this._iGroupID : -1;
            };

            RPC.prototype.setupSignals = function () {
                this.joined = this.joined || new akra.Signal(this);
                this.error = this.error || new akra.Signal(this);
            };

            RPC.prototype.join = function (sAddr) {
                var _this = this;
                if (typeof sAddr === "undefined") { sAddr = null; }
                var pPipe = this._pPipe;
                var pDeffered = this._pDefferedRequests;

                if (akra.isNull(pPipe)) {
                    pPipe = new net.Pipe();

                    pPipe.message.connect(function (pPipe, pMessage, eType) {
                        // LOG(pMessage);
                        if (eType !== 0 /* BINARY */) {
                            _this.parse(JSON.parse(pMessage));
                        } else {
                            _this.parseBinary(new Uint8Array(pMessage));
                        }
                    });

                    pPipe.opened.connect(function (pPipe, pEvent) {
                        _this._startRoutines();

                        //if we have unhandled call in deffered...
                        if (pDeffered.getLength()) {
                            pDeffered.seek(0);

                            while (pDeffered.getLength() > 0) {
                                pPipe.write(pDeffered.getCurrent());
                                _this._releaseRequest(pDeffered.takeCurrent());
                            }

                            akra.debug.assert(pDeffered.getLength() === 0, "something going wrong. length is: " + pDeffered.getLength());
                        }

                        var pRPC = _this;

                        _this.proc(_this.getOptions().procListName, function (pError, pList) {
                            if (!akra.isNull(pError)) {
                                akra.logger.critical("could not get proc. list");
                            }

                            //TODO: FIX akra. prefix...
                            if (!akra.isNull(pList) && akra.isArray(pList)) {
                                for (var i = 0; i < pList.length; ++i) {
                                    (function (sMethod) {
                                        pRPC.getOptions().procMap[sMethod] = pRPC.getOptions().procMap[sMethod] || {
                                            lifeTime: -1,
                                            priority: 0
                                        };

                                        pRPC.getRemote()[sMethod] = function () {
                                            var pArguments = [sMethod];

                                            for (var j = 0; j < arguments.length; ++j) {
                                                pArguments.push(arguments[j]);
                                            }

                                            return pRPC.proc.apply(pRPC, pArguments);
                                        };
                                    })(String(pList[i]));
                                }
                                // logger.log("rpc options: ", pRPC.options);
                            }

                            pRPC.joined.emit();
                        });
                    });

                    pPipe.error.connect(function (pPipe, pError) {
                        akra.debug.error("pipe error occured...");
                        _this.error.emit(pError);
                        //pRPC.rejoin();
                    });

                    pPipe.closed.connect(function (pPipe, pEvent) {
                        _this._stopRoutines();
                        _this.rejoin();
                    });
                }

                pPipe.open(sAddr);

                this._pPipe = pPipe;
                this._eState = 1 /* k_Joined */;
            };

            RPC.prototype.rejoin = function () {
                var pRPC = this;

                clearTimeout(this._iReconnect);

                //rejoin not needed, because pipe already connected
                if (this._pPipe.isOpened()) {
                    this._eState = 1 /* k_Joined */;
                    return;
                }

                //rejoin not needed, because we want close connection
                if (this._eState == 2 /* k_Closing */) {
                    this._eState = 0 /* k_Deteached */;
                    return;
                }

                if (this._pPipe.isClosed()) {
                    //callbacks that will not be called, because connection was lost
                    this.freeCallbacks();

                    if (hasReconnect(this)) {
                        this._iReconnect = setTimeout(function () {
                            pRPC.join();
                        }, this.getOptions().reconnectTimeout);
                    }
                }
            };

            RPC.prototype.parse = function (pRes) {
                if (!akra.isDef(pRes.n)) {
                    //logger.log(pRes);
                    akra.logger.warn("message droped, because seriial not recognized.");
                }

                this.response(pRes.n, pRes.type, pRes.res);
            };

            RPC.prototype.parseBinary = function (pBuffer) {
                var iHeaderByteLength = 12;
                var pHeader = new Uint32Array(pBuffer.buffer, pBuffer.byteOffset, iHeaderByteLength / 4);

                var nMsg = pHeader[0];
                var eType = pHeader[1];
                var iByteLength = pHeader[2];

                var pResult = pBuffer.subarray(iHeaderByteLength, iHeaderByteLength + iByteLength);

                this.response(nMsg, eType, pResult);

                var iPacketByteLength = iHeaderByteLength + iByteLength;

                if (pBuffer.byteLength > iPacketByteLength) {
                    // console.log("group message detected >> ");
                    this.parseBinary(pBuffer.subarray(iPacketByteLength));
                }
            };

            RPC.prototype.response = function (nSerial, eType, pResult) {
                if (eType === 2 /* RESPONSE */) {
                    var fn = null;
                    var pCallback = null;

                    // WARNING("---------------->",nSerial,"<-----------------");
                    // LOG(pStack.length);
                    if (hasCallbacksCountLimit(this)) {
                        var pCollection = this._pCallbacksCollection;
                        pCallback = pCollection.takeElement(nSerial);
                        if (!akra.isNull(pCallback)) {
                            fn = pCallback.fn;
                            this._releaseCallback(pCallback);

                            if (!akra.isNull(fn)) {
                                fn(null, pResult);
                            }
                            return;
                        }
                    } else {
                        var pStack = this._pCallbacksList;
                        pCallback = pStack.getLast();
                        if (!akra.isNull(pCallback)) {
                            do {
                                // LOG("#n: ", nSerial, " result: ", pResult);
                                if (pCallback.n === nSerial) {
                                    fn = pCallback.fn;
                                    this._releaseCallback(pStack.takeCurrent());

                                    if (!akra.isNull(fn)) {
                                        fn(null, pResult);
                                    }
                                    return;
                                }
                            } while(pCallback = pStack.prev());
                        }
                    }
                    // WARNING("package droped, invalid serial: " + nSerial);
                } else if (eType === 1 /* REQUEST */) {
                    akra.logger.error("TODO: REQUEST package type temprary unsupported.");
                } else if (eType === 0 /* FAILURE */) {
                    akra.logger.error("detected FAILURE on " + nSerial + " package");
                    akra.logger.log(pResult);
                } else {
                    akra.logger.error("unsupported response type detected: " + eType);
                }
            };

            RPC.prototype.freeRequests = function () {
                var pStack = this._pDefferedRequests;
                var pReq = pStack.getFirst();

                if (pReq) {
                    do {
                        this._releaseRequest(pReq);
                    } while(pReq = pStack.next());

                    pStack.clear();
                }
            };

            RPC.prototype.freeCallbacks = function () {
                if (hasCallbacksCountLimit(this)) {
                    this._pCallbacksCollection.clear();
                } else {
                    var pStack = this._pCallbacksList;
                    var pCallback = pStack.getFirst();

                    if (pCallback) {
                        do {
                            this._releaseCallback(pCallback);
                        } while(pCallback = pStack.next());

                        pStack.clear();
                    }
                }
            };

            RPC.prototype.free = function () {
                this.freeRequests();
                this.freeCallbacks();
            };

            RPC.prototype.detach = function () {
                this._eState = 2 /* k_Closing */;

                if (!akra.isNull(this._pPipe) && this._pPipe.isOpened()) {
                    this._pPipe.close();
                }

                this.free();
            };

            RPC.prototype.findLifeTimeFor = function (sProc) {
                var pProcOpt = this._pOption.procMap[sProc];

                if (pProcOpt) {
                    var iProcLt = pProcOpt.lifeTime;

                    if (iProcLt >= 0)
                        return iProcLt;
                }

                return this._pOption.callbackLifetime;
            };

            RPC.prototype.findPriorityFor = function (sProc) {
                var pProcOpt = this._pOption.procMap[sProc];

                if (pProcOpt) {
                    var iProcPr = pProcOpt.priority || 0;

                    return iProcPr;
                }

                return 0;
            };

            RPC.prototype.setProcedureOption = function (sProc, sOpt, pValue) {
                var pOptions = this.getOptions().procMap[sProc];

                if (!pOptions) {
                    pOptions = this.getOptions().procMap[sProc] = {
                        lifeTime: -1
                    };
                }

                pOptions[sOpt] = pValue;
            };

            RPC.prototype.proc = function () {
                var argv = [];
                for (var _i = 0; _i < (arguments.length - 0); _i++) {
                    argv[_i] = arguments[_i + 0];
                }
                var iRPCCallback = arguments.length - 1;
                var fnCallback = akra.isFunction(arguments[iRPCCallback]) ? arguments[iRPCCallback] : null;
                var nArg = arguments.length - (fnCallback ? 2 : 1);
                var pArgv = new Array(nArg);
                var pPipe = this._pPipe;
                var pCallback = null;

                for (var i = 0; i < nArg; ++i) {
                    pArgv[i] = arguments[i + 1];
                }

                var pProc = this._createRequest();

                pProc.n = this._nCalls++;
                pProc.type = 1 /* REQUEST */;
                pProc.proc = String(arguments[0]);
                pProc.argv = pArgv;
                pProc.next = null;
                pProc.lt = this.findLifeTimeFor(pProc.proc);
                pProc.pr = this.findPriorityFor(pProc.proc);

                pCallback = this._createCallback();
                pCallback.n = pProc.n;
                pCallback.fn = fnCallback;
                pCallback.timestamp = akra.time();

                if (akra.config.DEBUG) {
                    pCallback.procInfo = pProc.proc + "(" + pArgv.join(',') + ")";
                }

                if (akra.isNull(pPipe) || !pPipe.isOpened()) {
                    if (!hasLimitedDeferredCalls(this) || this._pDefferedRequests.getLength() <= this.getOptions().deferredCallsLimit) {
                        this._pDefferedRequests.push(pProc);

                        if (hasCallbacksCountLimit(this)) {
                            this._pCallbacksCollection.push(pCallback);
                        } else {
                            this._pCallbacksList.push(pCallback);
                        }
                    } else {
                        pCallback.fn(RPC.ERRORS.STACK_SIZE_EXCEEDED);
                        akra.logger.log(RPC.ERRORS.STACK_SIZE_EXCEEDED);

                        this._releaseCallback(pCallback);
                        this._releaseRequest(pProc);
                    }

                    return false;
                }

                if (hasCallbacksCountLimit(this)) {
                    this._pCallbacksCollection.push(pCallback);
                } else {
                    this._pCallbacksList.push(pCallback);
                }

                return this.callProc(pProc);
            };

            RPC.prototype.callProc = function (pProc) {
                var pPipe = this._pPipe;
                var bResult = false;

                if (hasGroupCalls(this)) {
                    if (akra.isNull(this._pGroupCalls)) {
                        this._pGroupCalls = pProc;
                        this._iGroupID++;
                    } else {
                        pProc.next = this._pGroupCalls;
                        this._pGroupCalls = pProc;
                    }

                    return true;
                } else {
                    bResult = pPipe.write(pProc);
                    this._releaseRequest(pProc);
                }

                return bResult;
            };

            RPC.prototype._systemRoutine = function () {
                this._removeExpiredCallbacks();
            };

            RPC.prototype._startRoutines = function () {
                var pRPC = this;

                if (hasSystemRoutine(this)) {
                    this._iSystemRoutine = setInterval(function () {
                        pRPC._systemRoutine();
                    }, this.getOptions().systemRoutineInterval);
                }

                if (hasGroupCalls(this)) {
                    this._iGroupCallRoutine = setInterval(function () {
                        pRPC.groupCall();
                    }, this.getOptions().callsFrequency);
                }
            };

            RPC.prototype._stopRoutines = function () {
                clearInterval(this._iSystemRoutine);
                this._systemRoutine();

                clearInterval(this._iGroupCallRoutine);
                //TODO: remove calls from group call, if RPC finally detached!
            };

            RPC.prototype.groupCall = function () {
                var pReq = this._pGroupCalls;

                if (akra.isNull(pReq)) {
                    return;
                }

                this._pPipe.write(pReq);

                return this.dropGroupCall();
            };

            RPC.prototype.dropGroupCall = function () {
                var pReq = this._pGroupCalls;

                for (; ;) {
                    var pNext = pReq.next;
                    this._releaseRequest(pReq);

                    if (!pNext) {
                        break;
                    }

                    pReq = pNext;
                }

                this._pGroupCalls = null;
                return this._iGroupID;
            };

            RPC.prototype._removeExpiredCallbacks = function () {
                var pCallback = null;
                var iNow = akra.time();
                var fn = null;
                var sInfo = null;

                if (hasCallbacksCountLimit(this)) {
                    //				 for(var i: uint = 0; i < this.options.maxCallbacksCount; i++){
                    //					 pCallback = <IRPCCallback>this._pCallbacksCollection.getElementAt(i);
                    //					 if (!isNull(pCallback) && HAS_CALLBACK_LIFETIME(this) && (iNow - pCallback.timestamp) >= this.options.callbackLifetime) {
                    //						 fn = pCallback.fn;
                    // #ifdef DEBUG
                    //						 sInfo = pCallback.procInfo;
                    // #endif
                    //						 this._releaseCallback(pCallback);
                    //						 this._pCallbacksCollection.removeElementAt(i);
                    //						 if (!isNull(fn)) {
                    //							 // logger.log("procedure info: ", sInfo);
                    //							 fn(RPC.ERRORS.CALLBACK_LIFETIME_EXPIRED, null);
                    //						 }
                    //					 }
                    //				 }
                } else {
                    var pCallbacks = this._pCallbacksList;
                    pCallback = pCallbacks.getFirst();
                    while (!akra.isNull(pCallback)) {
                        if (hasCallbackLifetime(this) && (iNow - pCallback.timestamp) >= this.getOptions().callbackLifetime) {
                            fn = pCallback.fn;
                            if (akra.config.DEBUG) {
                                sInfo = pCallback.procInfo;
                            }
                            this._releaseCallback(pCallbacks.takeCurrent());

                            pCallback = pCallbacks.getCurrent();

                            if (!akra.isNull(fn)) {
                                // logger.log("procedure info: ", sInfo);
                                fn(RPC.ERRORS.CALLBACK_LIFETIME_EXPIRED, null);
                            }
                        } else {
                            pCallback = pCallbacks.next();
                        }
                    }
                }
            };

            RPC.prototype._releaseRequest = function (pReq) {
                pReq.n = 0;
                pReq.proc = null;
                pReq.argv = null;
                pReq.next = null;
                pReq.lt = 0;
                pReq.pr = 0;

                RPC.requestPool.push(pReq);
            };

            RPC.prototype._createRequest = function () {
                if (RPC.requestPool.getLength() == 0) {
                    // LOG("allocated rpc request");
                    return { n: 0, type: 1 /* REQUEST */, proc: null, argv: null, next: null, lt: 0, pr: 0 };
                }

                return RPC.requestPool.pop();
            };

            RPC.prototype._releaseCallback = function (pCallback) {
                pCallback.n = 0;
                pCallback.fn = null;
                pCallback.timestamp = 0;
                pCallback.procInfo = null;

                RPC.callbackPool.push(pCallback);
            };

            RPC.prototype._createCallback = function () {
                if (RPC.callbackPool.getLength() == 0) {
                    // LOG("allocated callback");
                    return { n: 0, fn: null, timestamp: 0, procInfo: null };
                }

                return RPC.callbackPool.pop();
            };

            RPC.requestPool = new ObjectArray();
            RPC.callbackPool = new ObjectArray();

            RPC.ERRORS = {
                STACK_SIZE_EXCEEDED: {
                    name: "RPC err.",
                    message: "stack size exceeded",
                    code: 0 /* STACK_SIZE_EXCEEDED */
                },
                CALLBACK_LIFETIME_EXPIRED: {
                    name: "RPC err.",
                    message: "procedure life time expired",
                    code: 1 /* CALLBACK_LIFETIME_EXPIRED */
                }
            };
            return RPC;
        })();

        function createRpc(addr, opt) {
            if (arguments.length === 1) {
                if (akra.isString(addr)) {
                    return new RPC(addr);
                }

                return new RPC(null, arguments[0]);
            }

            return new RPC(addr, opt);
        }
        net.createRpc = createRpc;
    })(akra.net || (akra.net = {}));
    var net = akra.net;
})(akra || (akra = {}));
/// <reference path="../idl/IMegaTexture.ts" />
/// <reference path="../idl/IViewport.ts" />
/// <reference path="../idl/IRenderPass.ts" />
/// <reference path="../idl/IRPC.ts" />
var akra;
(function (akra) {
    /// <reference path="../net/RPC.ts" />
    /// <reference path="../math/math.ts" />
    /// <reference path="../pool/resources/Texture.ts" />
    /// <reference path="../pixelUtil/PixelBox.ts" />
    /// <reference path="../events.ts" />
    (function (terrain) {
        var Vec2 = akra.math.Vec2;

        var Vec4 = akra.math.Vec4;

        var MegaTexture = (function () {
            function MegaTexture(pEngine) {
                this.guid = akra.guid();
                this._pEngine = null;
                // private _pDevice = null;
                this._pObject = null;
                this._pWorldExtents = null;
                //Координаты камеры на объекте
                this._v2fCameraCoord = new Vec2(0, 0);
                //Путь откуда запрашиваются куски текстуры
                this._sSurfaceTextures = "";
                //Маскимальный размер стороны текстуры
                this._v2iOriginalTextreMaxSize = new Vec2(1024 * 32.);
                this._v2iOriginalTextreMinSize = new Vec2(1024 * 4.);
                this._v2iTextureLevelSize = new Vec2(1024);
                this._iMinLevel = 0;
                this._iMaxLevel = 0;
                //Тип хранимых тектсур
                this._eTextureFormat = 10 /* BYTE_RGB */;
                //Размер блока текстуры(минимальный размер выгружаемого куска текстуры)
                this._iBlockSize = 32;
                this._iBufferWidth = 0;
                this._iBufferHeight = 0;
                this._pTextures = null;
                this._pTextureForSwap = null;
                //Карта с разметкой буфера, чтобы знать какой части буффер уже отсылалось задание на заполнение
                this._pSectorLoadInfo = null;
                this._pXY = null;
                //Всякие темповые буферы
                this._pLoadInfoForSwap = null;
                this._pDefaultSectorLoadInfo = null;
                this._pRPC = null;
                this._fTexCourdXOld = 0xFFFFFFFF;
                this._fTexCourdYOld = 0xFFFFFFFF;
                this._nCountRender = 0;
                this._iSectorLifeTime = 60000;
                this._pSamplerUniforms = null;
                this._pLoadStatusUniforms = null;
                this._pTexcoordOffsetUniforms = null;
                this._bManualMinLevelLoad = false;
                this._bStreaming = false;
                this._tLastUpdateTime = 0;
                this._fThresHold = 0.1;
                this._bColored = false;
                this._iTryCount = 0;
                this._iTrafficCounter = 0;
                this._iResponseCount = 0;
                this._iQueryCount = 0;
                this._fnPRCCallBack = null;
                this.pDataList = new Array(8);
                this.setupSignals();
                this._pEngine = pEngine;
            }
            MegaTexture.prototype.setupSignals = function () {
                this.minLevelLoaded = this.minLevelLoaded || new akra.Signal(this);
            };

            MegaTexture.prototype.getManualMinLevelLoad = function () {
                return this._bManualMinLevelLoad;
            };

            MegaTexture.prototype.setManualMinLevelLoad = function (bManual) {
                this._bManualMinLevelLoad = bManual;
            };

            MegaTexture.prototype.init = function (pObject, sSurfaceTextures) {
                this._pObject = pObject;
                this._pWorldExtents = pObject.getLocalBounds();
                this._sSurfaceTextures = sSurfaceTextures;

                if (!this.checkTextureSizeSettings()) {
                    akra.logger.critical("Wrong texture size settings for MegaTexture");
                }

                var iCountTex = this._iMaxLevel - this._iMinLevel + 1;

                this._pTextures = new Array(iCountTex);
                this._pSectorLoadInfo = new Array(iCountTex);
                this._pXY = new Array(iCountTex);

                this._iBufferWidth = this._v2iTextureLevelSize.x * 1;
                this._iBufferHeight = this._v2iTextureLevelSize.y * 1;

                this._pLoadInfoForSwap = new Uint32Array(this._v2iTextureLevelSize.y * this._v2iTextureLevelSize.x / (this._iBlockSize * this._iBlockSize));
                this._pDefaultSectorLoadInfo = new Uint32Array(this._v2iTextureLevelSize.y * this._v2iTextureLevelSize.x / (this._iBlockSize * this._iBlockSize));

                for (var i = 0; i < this._pDefaultSectorLoadInfo.length; i++) {
                    this._pDefaultSectorLoadInfo[i] = 0;
                }

                this.setSectorLoadInfoToDefault(this._pLoadInfoForSwap);

                //Создаем куски мегатекстуры
                var pRmgr = this._pEngine.getResourceManager();

                this._pTextureForSwap = pRmgr.createTexture(".texture-for-mega-swap_" + akra.guid());
                this._pTextureForSwap.create(this._v2iTextureLevelSize.x, this._v2iTextureLevelSize.y, 1, null, akra.ETextureFlags.DYNAMIC, 0, 1, 3553 /* TEXTURE_2D */, this._eTextureFormat);
                this._pTextureForSwap.setWrapMode(10242 /* WRAP_S */, 33071 /* CLAMP_TO_EDGE */);
                this._pTextureForSwap.setWrapMode(10243 /* WRAP_T */, 33071 /* CLAMP_TO_EDGE */);

                for (var i = 0; i < this._pTextures.length; i++) {
                    this._pTextures[i] = pRmgr.createTexture(".texture-for-mega-" + i + "_" + akra.guid());
                    if (i === 0) {
                        this._pTextures[i].create(this._v2iOriginalTextreMinSize.x, this._v2iOriginalTextreMinSize.y, 1, null, akra.ETextureFlags.DYNAMIC, 0, 1, 3553 /* TEXTURE_2D */, 10 /* BYTE_RGB */);

                        this._pSectorLoadInfo[i] = new Uint32Array(this._v2iOriginalTextreMinSize.y * this._v2iOriginalTextreMinSize.x / (this._iBlockSize * this._iBlockSize));
                        this._pXY[i] = {
                            iX: 0, iY: 0,
                            iTexX: 0, iTexY: 0,
                            width: this._v2iOriginalTextreMinSize.x,
                            height: this._v2iOriginalTextreMinSize.y,
                            isUpdated: true, isLoaded: false
                        };
                    } else {
                        this._pTextures[i].create(this._v2iTextureLevelSize.x, this._v2iTextureLevelSize.y, 1, null, akra.ETextureFlags.DYNAMIC, 0, 1, 3553 /* TEXTURE_2D */, this._eTextureFormat);

                        this._pSectorLoadInfo[i] = new Uint32Array(this._v2iTextureLevelSize.y * this._v2iTextureLevelSize.x / (this._iBlockSize * this._iBlockSize));

                        this.setSectorLoadInfoToDefault(this._pSectorLoadInfo[i]);

                        this._pTextures[i].setWrapMode(10242 /* WRAP_S */, 33071 /* CLAMP_TO_EDGE */);
                        this._pTextures[i].setWrapMode(10243 /* WRAP_T */, 33071 /* CLAMP_TO_EDGE */);

                        this._pXY[i] = {
                            iX: 0, iY: 0,
                            iTexX: 0, iTexY: 0,
                            width: this._pTextures[i].getWidth(),
                            height: this._pTextures[i].getHeight(),
                            isUpdated: true, isLoaded: false };
                    }
                }

                this.createUniforms();

                this.testDataInit();

                this._pRPC = akra.net.createRpc();

                if (!this._bManualMinLevelLoad) {
                    this._pRPC.joined.connect(this, this.loadMinTextureLevel, 1 /* BROADCAST */);
                    this._pRPC.error.connect(this, this.rpcErrorOccured, 1 /* BROADCAST */);
                }

                this._pRPC.setProcedureOption("getMegaTexture", "lifeTime", 60000);
                this._pRPC.setProcedureOption("getMegaTexture", "priority", 1);

                this._pRPC.setProcedureOption("loadMegaTexture", "lifeTime", 60000);
                this._pRPC.setProcedureOption("loadMegaTexture", "priority", 1);
            };

            MegaTexture.prototype.enableStreaming = function (bEnable) {
                if (typeof bEnable === "undefined") { bEnable = true; }
                if (bEnable) {
                    this.connectToServer();
                } else {
                    this.disconnectFromServer();
                }
            };

            MegaTexture.prototype.connectToServer = function (sURL /*"ws://23.21.68.208:6112"*/ ) {
                if (typeof sURL === "undefined") { sURL = "ws://192.168.88.53:6112"; }
                this._pRPC.join(sURL);

                // this._pRPC.join("ws://localhost:6112");
                this._bStreaming = true;

                for (var i = 1; i < this._pSectorLoadInfo.length; i++) {
                    this.setSectorLoadInfoToDefault(this._pSectorLoadInfo[i]);
                }
            };

            MegaTexture.prototype.disconnectFromServer = function () {
                this._pRPC.detach();
                this._bStreaming = false;
            };

            MegaTexture.prototype.prepareForRender = function (pViewport) {
                if (!this._bStreaming) {
                    return;
                }

                if (!this._pXY[0].isLoaded) {
                    return;
                }

                var tCurrentTime = akra.time() >>> 0;

                if (tCurrentTime - this._tLastUpdateTime < 30) {
                    return;
                }

                this._tLastUpdateTime = tCurrentTime;

                var pCamera = pViewport.getCamera();
                var v4fCameraCoord = Vec4.temp(pCamera.getWorldPosition(), 1.);
                var m4fTransposeInverse = this._pObject.getInverseWorldMatrix();

                v4fCameraCoord = m4fTransposeInverse.multiplyVec4(v4fCameraCoord);

                //Вычисление текстурных координат над которыми находиться камера
                var fTexCourdX = (v4fCameraCoord.x - this._pWorldExtents.x0) / akra.math.abs(this._pWorldExtents.x1 - this._pWorldExtents.x0);
                var fTexCourdY = (v4fCameraCoord.y - this._pWorldExtents.y0) / akra.math.abs(this._pWorldExtents.y1 - this._pWorldExtents.y0);

                this._v2fCameraCoord.set(fTexCourdX, fTexCourdY);

                var iX = 0, iX1 = 0, iX2 = 0;
                var iY = 0, iY1 = 0, iY2 = 0;
                var iWidth = 0, iHeight = 0;

                //Нужно ли перекладвывать, отсавим на запас 8 блоков
                //Опираемся на текстуру самого хорошего разрешения
                //Координаты квадрата this._v2iTextureLevelSize.x Х this._v2iTextureLevelSize.y с центром в камере на текстуре самого большого разрешения.
                iX = akra.math.round(fTexCourdX * (this.getWidthOrig(this._pTextures.length - 1)) - this._v2iTextureLevelSize.x / 2);
                iY = akra.math.round(fTexCourdY * (this.getHeightOrig(this._pTextures.length - 1)) - this._v2iTextureLevelSize.y / 2);

                iWidth = this._v2iTextureLevelSize.x;
                iHeight = this._v2iTextureLevelSize.y;

                // Перемещаем данные из одного пиксель буффера в другой
                if ((this._fTexCourdXOld !== fTexCourdX || this._fTexCourdYOld !== fTexCourdY)) {
                    for (i = 1; i < this._pTextures.length; i++) {
                        // logger.log("Уровень", i)
                        //Вычисляем новые координаты буфера в текстуре
                        var iXnew = akra.math.round(fTexCourdX * this.getWidthOrig(i) - this._v2iTextureLevelSize.x / 2);
                        var iYnew = akra.math.round(fTexCourdY * this.getHeightOrig(i) - this._v2iTextureLevelSize.y / 2);

                        // iXnew -= (this._iBufferWidth - this._v2iTextureLevelSize.x) / 2;
                        // iYnew -= (this._iBufferHeight - this._v2iTextureLevelSize.y) / 2;
                        //Округлили на размер блока
                        iXnew = akra.math.round((iXnew / this._iBlockSize)) * this._iBlockSize;
                        iYnew = akra.math.round((iYnew / this._iBlockSize)) * this._iBlockSize;

                        //Копирование совпадающего куска
                        var iXOverlappingBlockInOldBuf = iXnew - this._pXY[i].iX;
                        var iYOverlappingBlockInOldBuf = iYnew - this._pXY[i].iY;
                        var iXOverlappingBlockInNewBuf = -iXOverlappingBlockInOldBuf;
                        var iYOverlappingBlockInNewBuf = -iYOverlappingBlockInOldBuf;

                        iXOverlappingBlockInOldBuf = akra.math.max(0, iXOverlappingBlockInOldBuf);
                        iYOverlappingBlockInOldBuf = akra.math.max(0, iYOverlappingBlockInOldBuf);
                        iXOverlappingBlockInNewBuf = akra.math.max(0, iXOverlappingBlockInNewBuf);
                        iYOverlappingBlockInNewBuf = akra.math.max(0, iYOverlappingBlockInNewBuf);

                        if (iXOverlappingBlockInOldBuf < this._iBufferWidth && iYOverlappingBlockInOldBuf < this._iBufferHeight && iXOverlappingBlockInNewBuf < this._iBufferWidth && iYOverlappingBlockInNewBuf < this._iBufferHeight) {
                            //произошло совпадение кусков
                            var iOverlappingBlockWidth = this._iBufferWidth - akra.math.abs(iXnew - this._pXY[i].iX);
                            var iOverlappingBlockHeight = this._iBufferHeight - akra.math.abs(iYnew - this._pXY[i].iY);

                            //копируем данные
                            var pSwapBuffer = this._pTextureForSwap.getBuffer(0, 0);
                            var pTextureBuffer = this._pTextures[i].getBuffer(0, 0);

                            var pTmpBox1 = akra.geometry.Box.temp(iXOverlappingBlockInNewBuf, iYOverlappingBlockInNewBuf, iOverlappingBlockWidth + iXOverlappingBlockInNewBuf, iOverlappingBlockHeight + iYOverlappingBlockInNewBuf);
                            var pTmpBox2 = akra.geometry.Box.temp(iXOverlappingBlockInOldBuf, iYOverlappingBlockInOldBuf, iOverlappingBlockWidth + iXOverlappingBlockInOldBuf, iOverlappingBlockHeight + iYOverlappingBlockInOldBuf);

                            var pTmpBox3 = akra.geometry.Box.temp(0, 0, this._v2iTextureLevelSize.x, this._v2iTextureLevelSize.y);

                            var pTempPixelBox = akra.pixelUtil.PixelBox.temp(pTmpBox3, this._eTextureFormat);
                            pTempPixelBox.data = null;

                            pSwapBuffer.blit(pTextureBuffer, pTmpBox2, pTmpBox2); /* Save overlapped data */

                            pTextureBuffer.blitFromMemory(pTempPixelBox, pTmpBox3); /* Clear texture */

                            pTextureBuffer.blit(pSwapBuffer, pTmpBox2, pTmpBox1); /* Put overlapperd data */

                            this.setSectorLoadInfoToDefault(this._pLoadInfoForSwap);

                            // logger.log(iXOverlappingBlockInOldBuf + " ---> " + iXOverlappingBlockInNewBuf,
                            // 	iYOverlappingBlockInOldBuf + " ---> " + iYOverlappingBlockInNewBuf);
                            this._setDataBetweenBufferMap(this._pLoadInfoForSwap, iXOverlappingBlockInNewBuf / this._iBlockSize, iYOverlappingBlockInNewBuf / this._iBlockSize, this._pSectorLoadInfo[i], iXOverlappingBlockInOldBuf / this._iBlockSize, iYOverlappingBlockInOldBuf / this._iBlockSize, iOverlappingBlockWidth / this._iBlockSize, iOverlappingBlockHeight / this._iBlockSize);

                            var s = this._pSectorLoadInfo[i];
                            this._pSectorLoadInfo[i] = this._pLoadInfoForSwap;
                            this._pLoadInfoForSwap = s;
                        } else {
                            var pTextureBuffer = this._pTextures[i].getBuffer(0, 0);
                            var pTmpBox3 = akra.geometry.Box.temp(0, 0, this._v2iTextureLevelSize.x, this._v2iTextureLevelSize.y);

                            var pTempPixelBox = akra.pixelUtil.PixelBox.temp(pTmpBox3, this._eTextureFormat);
                            pTempPixelBox.data = null;

                            pTextureBuffer.blitFromMemory(pTempPixelBox, pTmpBox3);

                            this.setSectorLoadInfoToDefault(this._pSectorLoadInfo[i]);
                        }

                        this._pXY[i].iX = iXnew;
                        this._pXY[i].iY = iYnew;
                    }
                }

                for (var i = 1; i < this._pTextures.length; i++) {
                    // for (var i: uint = this._pTextures.length - 1; i >= 1; i--) {
                    iX = akra.math.round(fTexCourdX * this.getWidthOrig(i) - this._v2iTextureLevelSize.x / 2);
                    iY = akra.math.round(fTexCourdY * this.getHeightOrig(i) - this._v2iTextureLevelSize.y / 2);

                    iX = akra.math.round((iX / this._iBlockSize)) * this._iBlockSize;
                    iY = akra.math.round((iY / this._iBlockSize)) * this._iBlockSize;

                    this._pXY[i].iTexX = iX / this.getWidthOrig(i);
                    this._pXY[i].iTexY = iY / this.getHeightOrig(i);

                    iWidth = this._v2iTextureLevelSize.x;
                    iHeight = this._v2iTextureLevelSize.y;

                    //На данный момент нужен кусок текстуры таких размеров iX1,iY1,iWidth,iHeight,
                    var iAreaX1 = iX;
                    var iAreaY1 = iY;
                    var iAreaX2 = iX + iWidth;
                    var iAreaY2 = iY + iHeight;

                    //Смотрим попадаем ли мы в текущий буфер
                    //Типа попали
                    //Значит нужно загрузить необходимые куски
                    //Обрезаемся чтобы не вылезти за пределы
                    // iX -= this._iBlockSize * 8;
                    // iY -= this._iBlockSize * 8;
                    // iWidth += this._iBlockSize * 16;
                    // iHeight += this._iBlockSize * 16;
                    iX1 = akra.math.clamp(iX, 0, this.getWidthOrig(i));
                    iY1 = akra.math.clamp(iY, 0, this.getHeightOrig(i));
                    iX2 = akra.math.clamp(iX + iWidth, 0, this.getWidthOrig(i));
                    iY2 = akra.math.clamp(iY + iHeight, 0, this.getHeightOrig(i));

                    var iAreaX1 = akra.math.clamp(iAreaX1, 0, this.getWidthOrig(i));
                    var iAreaY1 = akra.math.clamp(iAreaY1, 0, this.getHeightOrig(i));
                    var iAreaX2 = akra.math.clamp(iAreaX2, 0, this.getWidthOrig(i));
                    var iAreaY2 = akra.math.clamp(iAreaY2, 0, this.getHeightOrig(i));

                    if (this._pXY[i - 1].isLoaded) {
                        this.getDataFromServer(i, iX1, iY1, iX2 - iX1, iY2 - iY1, iAreaX1, iAreaY1, iAreaX2 - iAreaX1, iAreaY2 - iAreaY1);
                    } else {
                        this._pXY[i].isLoaded = false;
                    }
                    // this.getDataFromServer(i, iX1, iY1, iX2 - iX1, iY2 - iY1, /*Остальные область проверки*/iAreaX1,
                    //                        iAreaY1, iAreaX2 - iAreaX1, iAreaY2 - iAreaY1);
                }

                this._fTexCourdXOld = fTexCourdX;
                this._fTexCourdYOld = fTexCourdY;
            };

            MegaTexture.prototype.applyForRender = function (pRenderPass) {
                pRenderPass.setForeign("NUM_TOTAL_LEVELS", this._iMaxLevel - this._iMinLevel + 1);
                pRenderPass.setUniform("MIN_MEGATEXTURE_LEVEL", this._iMinLevel);
                pRenderPass.setUniform("threshold", this._fThresHold);
                pRenderPass.setUniform("bColored", this._bColored);

                for (var i = 0; i < this._pTextures.length; i++) {
                    this._pLoadStatusUniforms[i] = this._pXY[i].isLoaded ? 1 : 0;
                    this._pTexcoordOffsetUniforms[i].set(this._pXY[i].iTexX, this._pXY[i].iTexY);
                    this._pSamplerUniforms[i].texture = this._pTextures[i];
                }

                pRenderPass.setUniform("S_TERRAIN", this._pSamplerUniforms);
                pRenderPass.setUniform("TEXTURE_LOAD_STATUS", this._pLoadStatusUniforms);
                pRenderPass.setUniform("TEXTURE_LEVEL_OFFSET", this._pTexcoordOffsetUniforms);
            };

            MegaTexture.prototype.getWidthOrig = function (iLevel) {
                return this._v2iTextureLevelSize.x << (this._iMinLevel + iLevel);
            };

            MegaTexture.prototype.getHeightOrig = function (iLevel) {
                return this._v2iTextureLevelSize.y << (this._iMinLevel + iLevel);
            };

            MegaTexture.prototype.setMinLevelTexture = function (pImg) {
                this._pTextures[0].destroyResource();
                this._pTextures[0].loadImage(pImg);
                this._pXY[0].isLoaded = true;

                this.minLevelLoaded.emit();
            };

            MegaTexture.prototype.checkTextureSizeSettings = function () {
                var v2iCountTexMin = Vec2.temp();
                var v2iCountTexMax = Vec2.temp();

                v2iCountTexMin.x = akra.math.log2(this._v2iOriginalTextreMinSize.x / this._v2iTextureLevelSize.x);
                v2iCountTexMin.y = akra.math.log2(this._v2iOriginalTextreMinSize.y / this._v2iTextureLevelSize.y);

                v2iCountTexMax.x = akra.math.log2(this._v2iOriginalTextreMaxSize.x / this._v2iTextureLevelSize.x);
                v2iCountTexMax.y = akra.math.log2(this._v2iOriginalTextreMaxSize.y / this._v2iTextureLevelSize.y);

                if (v2iCountTexMin.x !== v2iCountTexMin.y || v2iCountTexMax.x !== v2iCountTexMax.y) {
                    return false;
                }

                if (v2iCountTexMax.x < v2iCountTexMin.x) {
                    return false;
                }

                this._iMinLevel = v2iCountTexMin.x;
                this._iMaxLevel = v2iCountTexMax.x;

                return true;
            };

            MegaTexture.prototype.createUniforms = function () {
                var iCountTex = this._iMaxLevel - this._iMinLevel + 1;

                this._pSamplerUniforms = new Array(iCountTex);
                this._pLoadStatusUniforms = new Array(iCountTex);
                this._pTexcoordOffsetUniforms = new Array(iCountTex);

                for (var i = 0; i < iCountTex; i++) {
                    this._pSamplerUniforms[i] = {
                        textureName: "",
                        texture: this._pTextures[i],
                        wrap_s: 33071 /* CLAMP_TO_EDGE */,
                        wrap_t: 33071 /* CLAMP_TO_EDGE */,
                        mag_filter: 9729 /* LINEAR */,
                        min_filter: 9729 /* LINEAR */
                    };

                    this._pLoadStatusUniforms[i] = 0;
                    this._pTexcoordOffsetUniforms[i] = new Vec2();
                }
            };

            MegaTexture.prototype.rpcErrorOccured = function (pRPC, pError) {
                this._pRPC.error.disconnect(this.rpcErrorOccured, 1 /* BROADCAST */);

                akra.logger.warn("Server for MeagTexture not response. Connection can not be established. Report us please.");
            };

            MegaTexture.prototype.loadMinTextureLevel = function () {
                var me = this;
                var sExt = "dds";

                this._pSectorLoadInfo[0][0] = akra.time() >>> 0;
                this._iTryCount++;

                if (this._iTryCount > 5) {
                    akra.logger.critical("Server for MegaTexture not response. Wait time out exceeded. Report us please.");
                }

                this._pRPC.proc('loadMegaTexture', me._sSurfaceTextures, sExt, me._v2iOriginalTextreMinSize.x, me._v2iOriginalTextreMinSize.x, function (pError, pData) {
                    if (me._pXY[0].isLoaded) {
                        return;
                    }

                    if (!akra.isNull(pError)) {
                        if (pError.code === 1 /* CALLBACK_LIFETIME_EXPIRED */) {
                            me.loadMinTextureLevel();
                        } else {
                            akra.logger.critical("Server for MegaTexture not response correctly. Report us please.");
                        }
                        return;
                    }

                    var pTempImg = me._pEngine.getResourceManager().getImagePool().findResource(".megatexture.temp_image");

                    if (akra.isNull(pTempImg)) {
                        pTempImg = me._pEngine.getResourceManager().getImagePool().createResource(".megatexture.temp_image");
                    }

                    pTempImg.load(pData, sExt, function (isLoaded) {
                        me._pTextures[0].destroyResource();
                        me._pTextures[0].loadImage(pTempImg);
                        me._pXY[0].isLoaded = true;
                        pTempImg.destroyResource();

                        me._pRPC.joined.disconnect(me.loadMinTextureLevel, 1 /* BROADCAST */);
                        me._pRPC.error.disconnect(me.rpcErrorOccured, 1 /* BROADCAST */);

                        me.minLevelLoaded.emit();
                    });
                });
                // this.getDataFromServer(0, 0, 0, this._v2iOriginalTextreMinSize.x, this._v2iOriginalTextreMinSize.y);
            };

            MegaTexture.prototype.getDataFromServer = function (iLevelTex, iOrigTexX, iOrigTexY, iWidth, iHeight, iAreaX, iAreaY, iAreaWidth, iAreaHeight) {
                var iBlockSize = this._iBlockSize;

                var iOrigTexEndX = akra.math.ceil((iOrigTexX + iWidth) / iBlockSize) * iBlockSize;
                var iOrigTexEndY = akra.math.ceil((iOrigTexY + iHeight) / iBlockSize) * iBlockSize;
                iOrigTexX = akra.math.max(0, iOrigTexX);
                iOrigTexY = akra.math.max(0, iOrigTexY);

                // iOrigTexX = math.floor(iOrigTexX / iBlockSize) * iBlockSize;
                // iOrigTexY = math.floor(iOrigTexY / iBlockSize) * iBlockSize;
                iOrigTexEndX = akra.math.min(iOrigTexEndX, this.getWidthOrig(iLevelTex));
                iOrigTexEndY = akra.math.min(iOrigTexEndY, this.getHeightOrig(iLevelTex));

                var iAreaEndX = iAreaX + iAreaWidth;
                var iAreaEndY = iAreaY + iAreaHeight;
                iAreaX = akra.math.max(0, iAreaX);
                iAreaY = akra.math.max(0, iAreaY);
                iAreaEndX = akra.math.min(iAreaEndX, this.getWidthOrig(iLevelTex));
                iAreaEndY = akra.math.min(iAreaEndY, this.getHeightOrig(iLevelTex));

                var isLoaded = true;
                var tCurrentTime = akra.time() >>> 0;

                for (var i = iOrigTexY; i < iOrigTexEndY; i += iBlockSize) {
                    for (var j = iOrigTexX; j < iOrigTexEndX; j += iBlockSize) {
                        var iSectorInfoCoord = (i - this._pXY[iLevelTex].iY) / iBlockSize * (this._pXY[iLevelTex].width / iBlockSize) + (j - this._pXY[iLevelTex].iX) / iBlockSize;

                        if (this._pSectorLoadInfo[iLevelTex][iSectorInfoCoord] !== 0xFFFFFFFF) {
                            isLoaded = false;
                        }

                        if (tCurrentTime - this._pSectorLoadInfo[iLevelTex][iSectorInfoCoord] < this._iSectorLifeTime) {
                            continue;
                        }
                        if (this._pSectorLoadInfo[iLevelTex][iSectorInfoCoord] === 0xFFFFFFFF) {
                            continue;
                        }

                        this._pSectorLoadInfo[iLevelTex][iSectorInfoCoord] = tCurrentTime;

                        var iLev = iLevelTex;
                        var iX = j, iY = i;

                        var iXBuf = j - this._pXY[iLevelTex].iX;
                        var iYBuf = i - this._pXY[iLevelTex].iY;

                        if (iXBuf < 0 || iXBuf > this._pXY[iLevelTex].width - iBlockSize || iYBuf < 0 || iYBuf > this._pXY[iLevelTex].height - iBlockSize) {
                            return;
                        }

                        this._iQueryCount++;

                        this.getDataByRPC(iLevelTex, j, i, iBlockSize);
                    }
                }
                this._pXY[iLevelTex].isLoaded = isLoaded;
            };

            MegaTexture.prototype._printTraffic = function () {
                akra.logger.log(this._iTrafficCounter / 1000000 + "Mb", this._iQueryCount + "/" + this._iResponseCount);
            };

            MegaTexture.prototype.getDataByRPC = function (iLev, iX, iY, iBlockSize) {
                if (!this._bStreaming) {
                    return;
                }

                var me = this;

                if (akra.isNull(this._fnPRCCallBack)) {
                    this._fnPRCCallBack = function (pError, pData) {
                        //var pError = null;
                        //var pData = this.pDataList[this._iMinLevel + iLev];
                        //var pTextureData = pData;
                        if (!akra.isNull(pError)) {
                            // debug_print(pError.message);
                            return;
                        }

                        me._iTrafficCounter += pData.length;
                        var pHeaderData = new Uint16Array(pData.buffer, pData.byteOffset, 4);
                        var pTextureData = pData.subarray(8);
                        var iLev = akra.math.log2(pHeaderData[0] / me._v2iTextureLevelSize.x) - me._iMinLevel;
                        var iBlockSize = pHeaderData[1];
                        var iX = pHeaderData[2];
                        var iY = pHeaderData[3];

                        var iXBuf = iX - me._pXY[iLev].iX;
                        var iYBuf = iY - me._pXY[iLev].iY;

                        if (iXBuf < 0 || iXBuf > me._pXY[iLev].width - iBlockSize || iYBuf < 0 || iYBuf > me._pXY[iLev].height - iBlockSize) {
                            return;
                        }

                        var iSectorInfoCoord = iYBuf / iBlockSize * (me._pXY[iLev].width / iBlockSize) + iXBuf / iBlockSize;

                        if (me._pSectorLoadInfo[iLev][iSectorInfoCoord] === 0xFFFFFFFF) {
                            return;
                        }

                        me._iResponseCount++;
                        me._pSectorLoadInfo[iLev][iSectorInfoCoord] = 0xFFFFFFFF;

                        var pTmpBox1 = akra.geometry.Box.temp(0, 0, iBlockSize, iBlockSize);
                        var pTmpBox2 = akra.geometry.Box.temp(iXBuf, iYBuf, iBlockSize + iXBuf, iBlockSize + iYBuf);

                        var pSourceBox = akra.pixelUtil.PixelBox.temp(pTmpBox1, me._eTextureFormat, pTextureData);

                        me._pTextures[iLev].getBuffer(0, 0).blitFromMemory(pSourceBox, pTmpBox2);
                        pSourceBox.data = null;
                    };
                }

                this._pRPC.proc('getMegaTexture', me._sSurfaceTextures, me.getWidthOrig(iLev), me.getHeightOrig(iLev), iX, iY, iBlockSize, iBlockSize, me._eTextureFormat, this._fnPRCCallBack);
            };

            MegaTexture.prototype.setDataT = function (pBuffer, iX, iY, iWidth, iHeight, pBufferIn, iInX, iInY, iInWidth, iInHeight, iBlockWidth, iBlockHeight, iComponents) {
                iBlockHeight = akra.math.max(0, iBlockHeight);
                iBlockWidth = akra.math.max(0, iBlockWidth);
                iBlockHeight = akra.math.min(iBlockHeight, iHeight - iY, iInHeight - iInY);
                iBlockWidth = akra.math.min(iBlockWidth, iWidth - iX, iInWidth - iInX);

                if (pBuffer.length < ((iY + iBlockHeight - 1) * iWidth + iX + iBlockWidth) * iComponents) {
                    akra.debug.error("Выход за предел массива 1");
                }
                if (pBufferIn.length < ((iInY + iBlockHeight - 1) * iInWidth + iInX + iBlockWidth) * iComponents) {
                    akra.debug.error("Выход за предел массива 2");
                }

                var iLenStr = iBlockWidth * iComponents;
                var iStartIn = 0;
                var iStartOut = 0;
                for (var i = 0; i < iBlockHeight; i++) {
                    iStartIn = ((iInY + i) * iInWidth + iInX) * iComponents;
                    iStartOut = ((iY + i) * iWidth + iX) * iComponents;

                    if (pBufferIn.BYTES_PER_ELEMENT == 8) {
                        pBuffer.set(new Float64Array(pBufferIn.buffer.slice(iStartIn * 8, (iStartIn + iLenStr) * 8)), iStartOut);
                    } else if (pBufferIn.BYTES_PER_ELEMENT == 4) {
                        pBuffer.set(new Uint32Array(pBufferIn.buffer.slice(iStartIn * 4, (iStartIn + iLenStr) * 4)), iStartOut);
                    } else if (pBufferIn.BYTES_PER_ELEMENT == 2) {
                        pBuffer.set(new Uint16Array(pBufferIn.buffer.slice(iStartIn * 2, (iStartIn + iLenStr) * 2)), iStartOut);
                    } else {
                        pBuffer.set(new Uint8Array(pBufferIn.buffer.slice(iStartIn, iStartIn + iLenStr)), iStartOut);
                    }
                }
            };

            MegaTexture.prototype._setDataBetweenBufferMap = function (pBuffer, iX, iY, pBufferIn, iInX, iInY, iBlockWidth, iBlockHeight) {
                var iInWidth = this._iBufferWidth / this._iBlockSize;
                var iInHeight = this._iBufferHeight / this._iBlockSize;
                var iComponents = 1;
                var iWidth = this._iBufferWidth / this._iBlockSize;
                var iHeight = this._iBufferHeight / this._iBlockSize;
                this.setDataT(pBuffer, iX, iY, iWidth, iHeight, pBufferIn, iInX, iInY, iInWidth, iInHeight, iBlockWidth, iBlockHeight, iComponents);
            };

            MegaTexture.prototype.setSectorLoadInfoToDefault = function (pBuffer) {
                pBuffer.set(this._pDefaultSectorLoadInfo, 0);
            };

            MegaTexture.prototype.testDataInit = function () {
                for (var i = 0; i < this.pDataList.length; i++) {
                    this.pDataList[i] = new Uint8Array(this._iBlockSize * this._iBlockSize * 3);

                    var iLev = i;
                    var pData = this.pDataList[i];

                    for (var k = 0; k < pData.length; k += 3) {
                        if (iLev === 0) {
                            pData[k] = 0;
                            pData[k + 1] = 255;
                            pData[k + 2] = 0;
                        } else if (iLev === 1) {
                            pData[k] = 255;
                            pData[k + 1] = 0;
                            pData[k + 2] = 0;
                        } else if (iLev === 2) {
                            pData[k] = 0;
                            pData[k + 1] = 0;
                            pData[k + 2] = 255;
                        } else if (iLev === 3) {
                            pData[k] = 255;
                            pData[k + 1] = 0;
                            pData[k + 2] = 255;
                        } else if (iLev === 4) {
                            pData[k] = 255;
                            pData[k + 1] = 255;
                            pData[k + 2] = 0;
                        } else if (iLev === 5) {
                            pData[k] = 0;
                            pData[k + 1] = 255;
                            pData[k + 2] = 255;
                        } else {
                            pData[k] = 170;
                            pData[k + 1] = 50;
                            pData[k + 2] = 170;
                        }
                    }
                }
            };
            return MegaTexture;
        })();
        terrain.MegaTexture = MegaTexture;
    })(akra.terrain || (akra.terrain = {}));
    var terrain = akra.terrain;
})(akra || (akra = {}));
/// <reference path="../idl/ITerrainSection.ts" />
var akra;
(function (akra) {
    /// <reference path="../scene/SceneObject.ts" />
    /// <reference path="../data/RenderData.ts" />
    /// <reference path="../render/RenderableObject.ts" />
    /// <reference path="Terrain.ts" />
    (function (terrain) {
        var VE = akra.data.VertexElement;
        var Vec2 = akra.math.Vec2;
        var Vec3 = akra.math.Vec3;

        var TerrainSection = (function (_super) {
            __extends(TerrainSection, _super);
            function TerrainSection(pScene, eType) {
                if (typeof eType === "undefined") { eType = 68 /* TERRAIN_SECTION */; }
                _super.call(this, pScene, eType);
                this._pTerrainSystem = null;
                this._iVertexID = 0;
                //Ее коорлинаты на карте высот
                this._iHeightMapX = 0;
                this._iHeightMapY = 0;
                //номер сектора по иксу и по игрику
                this._iSectorX = 0;
                this._iSectorY = 0;
                this._iSectorIndex = 0;
                //Ращмеры сетки вершин
                this._iXVerts = 0;
                this._iYVerts = 0;
                //Положение сетора в мире
                this._pWorldRect = new akra.geometry.Rect3d();
                this._pRenderableObject = null;
                this._pVertexDescription = null;
            }
            TerrainSection.prototype.getSectorX = function () {
                return this._iSectorX;
            };

            TerrainSection.prototype.getSectorY = function () {
                return this._iSectorY;
            };

            TerrainSection.prototype.getTerrainSystem = function () {
                return this._pTerrainSystem;
            };

            TerrainSection.prototype.getSectionIndex = function () {
                return this._iSectorIndex;
            };

            TerrainSection.prototype.getHeightX = function () {
                return akra.math.abs(this._pWorldRect.x1 - this._pWorldRect.x0);
            };

            TerrainSection.prototype.getHeightY = function () {
                return akra.math.abs(this._pWorldRect.y1 - this._pWorldRect.y0);
            };

            TerrainSection.prototype.getVertexDescription = function () {
                return this._pVertexDescription;
            };

            TerrainSection.prototype.getTotalRenderable = function () {
                return !akra.isNull(this._pRenderableObject) ? 1 : 0;
            };

            TerrainSection.prototype.getRenderable = function (i) {
                return this._pRenderableObject;
            };

            TerrainSection.prototype._internalCreate = function (pParentSystem, iSectorX, iSectorY, iHeightMapX, iHeightMapY, iXVerts, iYVerts, pWorldRect) {
                var bResult = false;

                this._pTerrainSystem = pParentSystem;
                this._iXVerts = iXVerts;
                this._iYVerts = iYVerts;
                this._iSectorX = iSectorX;
                this._iSectorY = iSectorY;
                this._iSectorIndex = (this._iSectorY * this._pTerrainSystem.getSectorCountX() + this._iSectorX);
                this._pWorldRect.x0 = pWorldRect.x0;
                this._pWorldRect.x1 = pWorldRect.x1;
                this._pWorldRect.y0 = pWorldRect.y0;

                //??
                this._pWorldRect.y1 = pWorldRect.y1;
                this._iHeightMapX = iHeightMapX;
                this._iHeightMapY = iHeightMapY;

                if (this.getTerrainSystem()._useVertexNormal()) {
                    this._pVertexDescription = [VE.float3(akra.data.Usages.POSITION), VE.float3(akra.data.Usages.NORMAL), VE.float2(akra.data.Usages.TEXCOORD)];
                } else {
                    this._pVertexDescription = [VE.float3(akra.data.Usages.POSITION), VE.float2(akra.data.Usages.TEXCOORD)];
                }

                bResult = this._createRenderDataForVertexAndIndex();
                bResult = bResult && this._buildVertexBuffer();
                bResult = bResult && this._buildIndexBuffer();

                // set the scene object bounds data
                this.accessLocalBounds().set(this._pWorldRect.x0, this._pWorldRect.x1, this._pWorldRect.y0, this._pWorldRect.y1, this._pWorldRect.z0, this._pWorldRect.z1);

                if (bResult) {
                    this.attachToParent(this._pTerrainSystem);
                    this.setInheritance(4 /* ALL */);

                    return true;
                } else {
                    return false;
                }
            };

            TerrainSection.prototype._createRenderable = function () {
                if (akra.isNull(this._pRenderableObject)) {
                    this._pRenderableObject = new akra.render.RenderableObject();
                    this._pRenderableObject._setup(this.getScene().getManager().getEngine().getRenderer());
                }
            };

            TerrainSection.prototype._createRenderDataForVertexAndIndex = function () {
                var pRenderable = this.getRenderable();

                if (akra.isNull(pRenderable)) {
                    return true;
                }

                akra.debug.assert(akra.isNull(pRenderable.getData()), "У терраин сектиона уже созданы данные");

                pRenderable._setRenderData(this.getTerrainSystem().getDataFactory().getEmptyRenderData(5 /* TRIANGLESTRIP */, 0));

                if (akra.isNull(pRenderable.getData())) {
                    return false;
                }

                return true;
            };

            TerrainSection.prototype._buildVertexBuffer = function () {
                this._pWorldRect.z0 = akra.MAX_FLOAT64;
                this._pWorldRect.z1 = akra.MIN_FLOAT64;

                if (!akra.isNull(this.getRenderable())) {
                    var nElementSize = 0;
                    if (this.getTerrainSystem()._useVertexNormal()) {
                        nElementSize = (3 + 3 + 2);
                    } else {
                        nElementSize = (3 + 2);
                    }

                    var pVerts = new Array(this._iXVerts * this._iYVerts * nElementSize);
                    var v3fNormal = new Vec3();

                    //размер ячейки сектора
                    var v2fCellSize = new Vec2();
                    v2fCellSize.set(this.getHeightX() / (this._iXVerts - 1), this.getHeightY() / (this._iYVerts - 1));

                    //Координаты вершина в секторе
                    var v2fVert = new Vec2();
                    v2fVert.set(0.0, 0.0);

                    for (var y = 0; y < this._iYVerts; ++y) {
                        v2fVert.set(this._pWorldRect.x0, y * v2fCellSize.y + this._pWorldRect.y0);

                        for (var x = 0; x < this._iXVerts; ++x) {
                            var fHeight = this.getTerrainSystem().readWorldHeight(this._iHeightMapX + x, this._iHeightMapY + y);

                            pVerts[((y * this._iXVerts) + x) * nElementSize + 0] = v2fVert.x;
                            pVerts[((y * this._iXVerts) + x) * nElementSize + 1] = v2fVert.y;
                            pVerts[((y * this._iXVerts) + x) * nElementSize + 2] = fHeight;

                            if (this.getTerrainSystem()._useVertexNormal()) {
                                this.getTerrainSystem().readWorldNormal(v3fNormal, this._iHeightMapX + x, this._iHeightMapY + y);

                                pVerts[((y * this._iXVerts) + x) * nElementSize + 3] = v3fNormal.x;
                                pVerts[((y * this._iXVerts) + x) * nElementSize + 4] = v3fNormal.y;
                                pVerts[((y * this._iXVerts) + x) * nElementSize + 5] = v3fNormal.z;

                                pVerts[((y * this._iXVerts) + x) * nElementSize + 6] = (this._iSectorX + x / (this._iXVerts - 1)) / this.getTerrainSystem().getSectorCountX();
                                pVerts[((y * this._iXVerts) + x) * nElementSize + 7] = (this._iSectorY + y / (this._iYVerts - 1)) / this.getTerrainSystem().getSectorCountY();
                            } else {
                                pVerts[((y * this._iXVerts) + x) * nElementSize + 3] = (this._iSectorX + x / (this._iXVerts - 1)) / this.getTerrainSystem().getSectorCountX();
                                pVerts[((y * this._iXVerts) + x) * nElementSize + 4] = (this._iSectorY + y / (this._iYVerts - 1)) / this.getTerrainSystem().getSectorCountY();
                            }

                            this._pWorldRect.z0 = akra.math.min(this._pWorldRect.z0, fHeight);
                            this._pWorldRect.z1 = akra.math.max(this._pWorldRect.z1, fHeight);

                            v2fVert.x += v2fCellSize.x;
                        }
                    }

                    this._iVertexID = this.getRenderable().getData().allocateData(this.getVertexDescription(), new Float32Array(pVerts));
                } else {
                    for (var y = 0; y < this._iYVerts; ++y) {
                        for (var x = 0; x < this._iXVerts; ++x) {
                            var fHeight = this.getTerrainSystem().readWorldHeight(this._iHeightMapX + x, this._iHeightMapY + y);

                            this._pWorldRect.z0 = akra.math.min(this._pWorldRect.z0, fHeight);
                            this._pWorldRect.z1 = akra.math.max(this._pWorldRect.z1, fHeight);
                        }
                    }
                }

                return true;
            };

            TerrainSection.prototype._buildIndexBuffer = function () {
                if (!akra.isNull(this.getRenderable())) {
                    var pIndexList = new Float32Array(TerrainSection.getCountIndexForStripGrid(this._iXVerts, this._iYVerts));

                    TerrainSection.createSingleStripGrid(pIndexList, this._iXVerts, this._iYVerts, 1, 1, this._iYVerts, 0);

                    this.getRenderable().getData().allocateIndex([VE.float(akra.data.Usages.INDEX0)], pIndexList);
                    this.getRenderable().getData().index(this._iVertexID, akra.data.Usages.INDEX0);
                }
                return true;
            };

            TerrainSection.createSingleStripGrid = function (pIndexValues, iXVerts, iYVerts, iXStep, iYStep, iSride, iFlags) {
                //TRIANGLESTRIP
                var iTotalStrips = iYVerts - 1;
                var iTotalIndexesPerStrip = iXVerts << 1;

                // the total number of indices is equal
                // to the number of strips times the
                // indices used per strip plus one
                // degenerate triangle between each strip
                //общее количество идексов равно количесву линий умноженному на колчесвто идексов в линии + вырожденный треуголник между полосами
                var iTotalIndexes = (iTotalStrips * iTotalIndexesPerStrip) + (iTotalStrips << 1) - 2;

                if (pIndexValues.length < iTotalIndexes) {
                    return 0;
                }

                var iIndex = 0;
                var iStartVert = 0;
                var iLineStep = iYStep * iSride;

                for (var j = 0; j < iTotalStrips; ++j) {
                    var k = 0;
                    var iVert = iStartVert;

                    for (k = 0; k < iXVerts; ++k) {
                        pIndexValues[iIndex++] = iVert;
                        pIndexValues[iIndex++] = iVert + iLineStep;
                        iVert += iXStep;
                    }
                    iStartVert += iLineStep;

                    if (j + 1 < iTotalStrips) {
                        // add a degenerate to attach to
                        // the next row
                        pIndexValues[iIndex++] = (iVert - iXStep) + iLineStep;
                        pIndexValues[iIndex++] = iStartVert;
                    }
                }

                // return
                return iTotalIndexes;
            };

            TerrainSection.getCountIndexForStripGrid = function (iXVerts, iYVerts) {
                //TRIANGLESTRIP
                var iTotalStrips = iYVerts - 1;
                var iTotalIndexesPerStrip = iXVerts << 1;
                var iTotalIndexes = (iTotalStrips * iTotalIndexesPerStrip) + (iTotalStrips << 1) - 2;
                return iTotalIndexes;
            };
            return TerrainSection;
        })(akra.scene.SceneObject);
        terrain.TerrainSection = TerrainSection;
    })(akra.terrain || (akra.terrain = {}));
    var terrain = akra.terrain;
})(akra || (akra = {}));
/// <reference path="../idl/ITerrain.ts" />
/// <reference path="../idl/IEffect.ts" />
/// <reference path="../idl/IRenderTechnique.ts" />
/// <reference path="../idl/IViewport.ts" />
var akra;
(function (akra) {
    /// <reference path="../pool/resources/Texture.ts" />
    /// <reference path="../data/RenderDataCollection.ts" />
    /// <reference path="../geometry/Rect3d.ts" />
    /// <reference path="../scene/SceneObject.ts" />
    /// <reference path="../render/Screen.ts" />
    /// <reference path="../config/config.ts" />
    /// <reference path="../math/math.ts" />
    /// <reference path="MegaTexture.ts" />
    /// <reference path="TerrainSection.ts" />
    (function (terrain) {
        var Vec2 = akra.math.Vec2;
        var Vec3 = akra.math.Vec3;
        var Vec4 = akra.math.Vec4;

        var Terrain = (function (_super) {
            __extends(Terrain, _super);
            function Terrain(pScene, eType) {
                if (typeof eType === "undefined") { eType = 66 /* TERRAIN */; }
                _super.call(this, pScene, eType);
                this._pEngine = null;
                // private _pDevice = null;
                this._pWorldExtents = new akra.geometry.Rect3d();
                this._v3fWorldSize = new Vec3();
                this._v3fMapScale = new Vec3();
                //массив подчиненный секций
                this._pSectorArray = null;
                this._pDataFactory = null;
                this._v2fSectorSize = new Vec2();
                //Таблица(карта высот)
                this._pHeightTable = null;
                this._pNormalMapTexture = null;
                this._pNormalMapImage = null;
                this._pBaseNormalTexture = null;
                this._pBaseNormalImage = null;
                this._pHeightMapTexture = null;
                this._pTempNormalColor = new akra.color.Color();
                //отоброжаемые куски текстуры
                this._pMegaTexures = null;
                this._bUseVertexNormal = false;
                this._pDefaultRenderMethod = null;
                this._pRenderMethod = null;
                this._pDefaultScreen = null;
                this._fMaxHeight = 0.;
                this._f2DDiagonal = 0.;
                this._isCreate = false;
                this._bManualMegaTextureInit = false;
                this._bShowMegaTexture = true;
                this._bMegaTextureCreated = false;
                this._sSurfaceTextures = "";
                this._pEngine = pScene.getManager().getEngine();
                this._pDataFactory = akra.data.createRenderDataCollection(this._pEngine, akra.ERenderDataBufferOptions.VB_READABLE);

                if (akra.config.terrain.useMegaTexture) {
                    this._pMegaTexures = new terrain.MegaTexture(this._pEngine);
                }
            }
            Terrain.prototype.getDataFactory = function () {
                return this._pDataFactory;
            };

            Terrain.prototype.getWorldExtents = function () {
                return this._pWorldExtents;
            };

            Terrain.prototype.getWorldSize = function () {
                return this._v3fWorldSize;
            };

            Terrain.prototype.getMapScale = function () {
                return this._v3fMapScale;
            };

            Terrain.prototype.getSectorCountX = function () {
                return this._iSectorCountX;
            };

            Terrain.prototype.getSectorCountY = function () {
                return this._iSectorCountY;
            };

            Terrain.prototype.getSectorSize = function () {
                return this._v2fSectorSize;
            };

            Terrain.prototype.getTableWidth = function () {
                return this._iTableWidth;
            };

            Terrain.prototype.getTableHeight = function () {
                return this._iTableHeight;
            };

            Terrain.prototype.getSectorShift = function () {
                return this._iSectorShift;
            };

            Terrain.prototype.getMaxHeight = function () {
                return this._fMaxHeight;
            };

            Terrain.prototype.getTerrain2DLength = function () {
                return this._f2DDiagonal;
            };

            Terrain.prototype.isCreate = function () {
                return this._isCreate;
            };

            Terrain.prototype.getMegaTexture = function () {
                return this._pMegaTexures;
            };

            Terrain.prototype.getManualMegaTextureInit = function () {
                return this._bManualMegaTextureInit;
            };

            Terrain.prototype.setManualMegaTextureInit = function (bManual) {
                this._bManualMegaTextureInit = bManual;
            };

            Terrain.prototype.getShowMegaTexture = function () {
                return this._bShowMegaTexture;
            };

            Terrain.prototype.setShowMegaTexture = function (bShow) {
                this._bShowMegaTexture = bShow;
            };

            Terrain.prototype._initSystemData = function () {
                var pEngine = this._pEngine, pRmgr = pEngine.getResourceManager();

                if (akra.isNull(this._pDefaultRenderMethod)) {
                    var pMethod = null, pEffect = null;

                    pMethod = pRmgr.getRenderMethodPool().findResource(".terrain_render");

                    if (!akra.isNull(pMethod)) {
                        this._pDefaultRenderMethod = pMethod;
                        return true;
                    }

                    pEffect = pRmgr.createEffect(".terrain_render");
                    pEffect.addComponent("akra.system.terrain");

                    pMethod = pRmgr.createRenderMethod(".terrain_render");
                    pMethod.setEffect(pEffect);
                    pMethod.setSurfaceMaterial(pRmgr.createSurfaceMaterial(".terrain_render"));
                    var pMat = pMethod.getSurfaceMaterial().getMaterial();
                    pMat.name = "terrain";

                    pMat.shininess = 30;
                    pMat.emissive.set(0);
                    pMat.specular.set(1);

                    this._pDefaultRenderMethod = pMethod;
                }

                if (akra.isNull(this._pDefaultScreen)) {
                    this._pDefaultScreen = new akra.render.Screen(pEngine.getRenderer());

                    var pMethod = null, pEffect = null;

                    pMethod = pRmgr.getRenderMethodPool().findResource(".terrain_generate_normal");

                    if (akra.isNull(pMethod)) {
                        pEffect = pRmgr.createEffect(".terrain_generate_normal");
                        pEffect.addComponent("akra.system.generateNormalMapByHeightMap");

                        pMethod = pRmgr.createRenderMethod(".terrain_generate_normal");
                        pMethod.setEffect(pEffect);
                    }

                    this._pDefaultScreen.addRenderMethod(pMethod, ".terrain_generate_normal");

                    this._pDefaultScreen.getTechnique(".terrain_generate_normal").render.connect(this, this._onGenerateNormalRender);
                }

                return true;
            };

            Terrain.prototype.init = function (pMaps, worldExtents, iShift, iShiftX, iShiftY, sSurfaceTextures, pRootNode) {
                if (typeof pRootNode === "undefined") { pRootNode = null; }
                if (!akra.isNull(pRootNode)) {
                    if (!this.attachToParent(pRootNode)) {
                        return false;
                    }
                }

                this._initSystemData();

                //Основные параметры
                this._iSectorShift = iShift;
                this._iSectorUnits = 1 << iShift;
                this._iSectorVerts = this._iSectorUnits + 1;

                this._pWorldExtents = new akra.geometry.Rect3d(worldExtents.x0, worldExtents.x1, worldExtents.y0, worldExtents.y1, worldExtents.z0, worldExtents.z1);
                this._pWorldExtents.normalize();
                this._v3fWorldSize = this._pWorldExtents.size(this._v3fWorldSize);

                //this._iTableWidth >> this._iSectorShift;
                this._iSectorCountX = 1 << iShiftX;

                //this._iTableHeight >> this._iSectorShift;
                this._iSectorCountY = 1 << iShiftY;

                this._iTableWidth = this._iSectorCountX * this._iSectorUnits + 1;
                this._iTableHeight = this._iSectorCountY * this._iSectorUnits + 1;

                this._v2fSectorSize.set(this._v3fWorldSize.x / this._iSectorCountX, this._v3fWorldSize.y / this._iSectorCountY);

                this._v3fMapScale.x = this._v3fWorldSize.x / this._iTableWidth;
                this._v3fMapScale.y = this._v3fWorldSize.y / this._iTableHeight;
                this._v3fMapScale.z = this._v3fWorldSize.z;

                // convert the height map to
                // data stored in local tables
                this._buildHeightAndNormalTables(pMaps.height, pMaps.normal);

                pMaps.height.destroyResource();
                pMaps.normal.destroyResource();

                if (!this._allocateSectors()) {
                    akra.debug.error("Can not alloacte terrain sections");
                    return false;
                }

                this.computeBoundingBox();

                if (akra.config.terrain.useMegaTexture) {
                    this._sSurfaceTextures = sSurfaceTextures;
                    if (!this._bManualMegaTextureInit) {
                        //Мегатекстурные параметры
                        this.initMegaTexture(sSurfaceTextures);
                    }
                }

                this._isCreate = true;

                return true;
            };

            Terrain.prototype.initMegaTexture = function (sSurfaceTextures) {
                if (typeof sSurfaceTextures === "undefined") { sSurfaceTextures = this._sSurfaceTextures; }
                if (akra.config.terrain.useMegaTexture) {
                    this._pMegaTexures.init(this, sSurfaceTextures);
                    this._bMegaTextureCreated = true;
                }
            };

            Terrain.prototype.findSection = function (iX, iY) {
                var pSection = null;

                if (iX >= 0 && iX < this._iSectorCountX && iY >= 0 && iY < this._iSectorCountY) {
                    pSection = this._pSectorArray[(iY * this._iSectorCountX) + iX];
                } else {
                    // if we had additional cRoamTerrain objects,
                    // we could reach out here to link with neighbors
                }

                return pSection;
            };

            Terrain.prototype._allocateSectors = function () {
                this._pSectorArray = new Array(this._iSectorCountX * this._iSectorCountY);

                for (var y = 0; y < this._iSectorCountY; ++y) {
                    for (var x = 0; x < this._iSectorCountX; ++x) {
                        var v2fSectorPos = new Vec2();
                        var r2fSectorRect = new akra.geometry.Rect2d();

                        v2fSectorPos.set(this._pWorldExtents.x0 + (x * this._v2fSectorSize.x), this._pWorldExtents.y0 + (y * this._v2fSectorSize.y));

                        r2fSectorRect.set(v2fSectorPos.x, v2fSectorPos.x + this._v2fSectorSize.x, v2fSectorPos.y, v2fSectorPos.y + this._v2fSectorSize.y);

                        var iXPixel = x << this._iSectorShift;
                        var iYPixel = y << this._iSectorShift;
                        var iIndex = (y * this._iSectorCountX) + x;

                        this._pSectorArray[iIndex] = this.getScene().createTerrainSection();
                        this._pSectorArray[iIndex]._createRenderable();

                        if (!this._pSectorArray[iIndex]._internalCreate(this, x, y, iXPixel, iYPixel, this._iSectorVerts, this._iSectorVerts, r2fSectorRect)) {
                            return false;
                        }
                    }
                }

                this._setRenderMethod(this._pDefaultRenderMethod);

                return true;
            };

            Terrain.prototype._setRenderMethod = function (pRenderMethod) {
                this._pRenderMethod = pRenderMethod;

                if (this._pRenderMethod) {
                    this._pRenderMethod.addRef();
                }

                var pSection = null;

                for (var i = 0; i < this._pSectorArray.length; i++) {
                    pSection = this._pSectorArray[i];

                    pSection.getRenderable().getTechnique().setMethod(this._pDefaultRenderMethod);
                    pSection.getRenderable().getTechnique().render.connect(this, this._onRender);
                }
            };

            Terrain.prototype._buildHeightAndNormalTables = function (pImageHightMap, pImageNormalMap) {
                var fHeight = 0;
                var iComponents = 4;
                this._pHeightTable = null;

                var iMaxY = this._iTableHeight;
                var iMaxX = this._iTableWidth;

                //var pColorData: Uint8Array = new Uint8Array(4 * iMaxY * iMaxX);
                this._pHeightTable = new Float32Array(iMaxX * iMaxY); /*float*/

                // first, build a table of heights
                if (pImageHightMap.isResourceLoaded()) {
                    if (pImageHightMap.getWidth() !== iMaxX && pImageHightMap.getHeight() !== iMaxY) {
                        akra.logger.warn("Размеры карты высот не совпадают с другими размерами. Нужно: " + iMaxX + "x" + iMaxY + ". Есть: " + pImageHightMap.getWidth() + "x" + pImageHightMap.getHeight());
                        return;
                    }

                    for (var iY = 0; iY < iMaxY; iY++) {
                        for (var iX = 0; iX < iMaxX; iX++) {
                            fHeight = pImageHightMap.getColorAt(this._pTempNormalColor, iX, iY).r;
                            fHeight = (fHeight * this._v3fMapScale.z) + this._pWorldExtents.z0;

                            this._pHeightTable[iY * iMaxX + iX] = fHeight;
                        }
                    }

                    if (this._useVertexNormal()) {
                        this.computeBaseNormal(pImageHightMap);
                    }
                } else {
                    akra.logger.warn("Height map not loaded");
                }

                if (pImageNormalMap.isResourceLoaded()) {
                    this._pNormalMapTexture = this._pEngine.getResourceManager().createTexture(".terrain-normal-texture" + this.guid);
                    this._pNormalMapTexture.loadImage(pImageNormalMap);
                    this._pNormalMapImage = pImageNormalMap;
                } else {
                    akra.logger.warn("Normal map not loaded");
                }
            };

            Terrain.prototype.readWorldHeight = function (iMapX, iMapY) {
                if (arguments.length === 2) {
                    var iFixedMapX = iMapX, iFixedMapY = iMapY;

                    if (iFixedMapX >= this._iTableWidth) {
                        iFixedMapX = this._iTableWidth - 1;
                    }
                    if (iFixedMapY >= this._iTableHeight) {
                        iFixedMapY = this._iTableHeight - 1;
                    }

                    return this._pHeightTable[(iFixedMapY * this._iTableWidth) + iFixedMapX];
                } else {
                    var iMapIndex = iMapX;
                    akra.logger.assert(iMapIndex < this._iTableWidth * this._iTableHeight, "invalid index");
                    return this._pHeightTable[iMapIndex];
                }
            };

            Terrain.prototype.readWorldNormal = function (v3fNormal, iMapX, iMapY) {
                if (iMapX >= this._pBaseNormalImage.getWidth()) {
                    iMapX = this._pBaseNormalImage.getWidth() - 1;
                }
                if (iMapY >= this._pBaseNormalImage.getHeight()) {
                    iMapY = this._pBaseNormalImage.getHeight() - 1;
                }

                this._pBaseNormalImage.getColorAt(this._pTempNormalColor, iMapX, iMapY);
                v3fNormal.set(this._pTempNormalColor.r, this._pTempNormalColor.g, this._pTempNormalColor.b);

                return v3fNormal;
            };

            Terrain.prototype.projectPoint = function (v3fCoord, v3fDestenation) {
                var v4fTerrainCoord = Vec4.temp(v3fCoord, 1.);

                v4fTerrainCoord = this.getInverseWorldMatrix().multiplyVec4(v4fTerrainCoord);

                if (v4fTerrainCoord.x < this.getWorldExtents().x0 || v4fTerrainCoord.x > this.getWorldExtents().x1 || v4fTerrainCoord.y < this.getWorldExtents().y0 || v4fTerrainCoord.y > this.getWorldExtents().y1) {
                    return false;
                }

                var iMapX = akra.math.floor((v4fTerrainCoord.x - this.getWorldExtents().x0) / this.getWorldExtents().sizeX() * this.getTableWidth());
                var iMapY = akra.math.floor((v4fTerrainCoord.y - this.getWorldExtents().y0) / this.getWorldExtents().sizeY() * this.getTableHeight());
                var fHeight = this.readWorldHeight(iMapX, iMapY);

                var v4fTempDestenation = Vec4.temp(v4fTerrainCoord.x, v4fTerrainCoord.y, fHeight, 1.);

                v4fTempDestenation = this.getWorldMatrix().multiplyVec4(v4fTempDestenation);
                v3fDestenation.set(v4fTempDestenation.x, v4fTempDestenation.y, v4fTempDestenation.z);

                return true;
            };

            /**
            * Подготовка терраина к рендерингу.
            */
            Terrain.prototype.prepareForRender = function (pViewport) {
                if (akra.config.terrain.useMegaTexture) {
                    if (this._bMegaTextureCreated && this._bShowMegaTexture) {
                        this._pMegaTexures.prepareForRender(pViewport);
                    }
                }
            };

            /**
            * Сброс параметров.
            */
            Terrain.prototype.reset = function () {
            };

            Terrain.prototype.computeBaseNormal = function (pImageHightMap) {
                var pRmgr = this._pEngine.getResourceManager();

                this._pHeightMapTexture = pRmgr.createTexture(".terrain-hight-texture" + this.guid);
                this._pHeightMapTexture.loadImage(pImageHightMap);

                this._pBaseNormalTexture = pRmgr.createTexture(".terrain-base-normal-texture" + this.guid);
                this._pBaseNormalTexture.create(pImageHightMap.getWidth(), pImageHightMap.getHeight(), 1, null, 512 /* RENDERTARGET */, 0, 0, 3553 /* TEXTURE_2D */, 28 /* R8G8B8A8 */);

                var pTarget = this._pBaseNormalTexture.getBuffer().getRenderTarget();
                pTarget.setAutoUpdated(false);

                var pViewport = pTarget.addViewport(new akra.render.Viewport(null, ".terrain_generate_normal"));
                pViewport.setDepthParams(false, false, 0);
                pViewport.setClearEveryFrame(false);

                pViewport.startFrame();
                pViewport.renderObject(this._pDefaultScreen);
                pViewport.endFrame();

                this._pBaseNormalImage = pRmgr.createImg(".terrain-base-normal-img" + this.guid);
                this._pBaseNormalTexture.convertToImage(this._pBaseNormalImage, false);
            };

            Terrain.prototype._tableIndex = function (iMapX, iMapY) {
                // clamp to the table dimensions
                if (iMapX >= this._iTableWidth) {
                    iMapX = this._iTableWidth - 1;
                }

                if (iMapY >= this._iTableHeight) {
                    iMapY = this._iTableHeight - 1;
                }

                return (iMapY * this._iTableWidth) + iMapX;
            };

            Terrain.prototype._useVertexNormal = function () {
                return this._bUseVertexNormal;
            };

            Terrain.prototype.computeBoundingBox = function () {
                var fX0, fY0, fZ0, fX1, fY1, fZ1;

                fX0 = fY0 = fZ0 = akra.MAX_FLOAT64;
                fX1 = fY1 = fZ1 = akra.MIN_FLOAT64;

                for (var i = 0; i < this._pSectorArray.length; i++) {
                    var pSectionBox = this._pSectorArray[i].getLocalBounds();

                    fX0 = akra.math.min(fX0, pSectionBox.x0);
                    fY0 = akra.math.min(fY0, pSectionBox.y0);
                    fZ0 = akra.math.min(fZ0, pSectionBox.z0);

                    fX1 = akra.math.max(fX1, pSectionBox.x1);
                    fY1 = akra.math.max(fY1, pSectionBox.y1);
                    fZ1 = akra.math.max(fZ1, pSectionBox.z1);
                }

                this.accessLocalBounds().set(fX0, fX1, fY0, fY1, fZ0, fZ1);

                this._fMaxHeight = fZ1 - fZ0;
                this._f2DDiagonal = akra.math.sqrt((fX1 - fX0) * (fX1 - fX0) + (fY1 - fY0) * (fY1 - fY0));
            };

            Terrain.prototype._onRender = function (pTechnique, iPass) {
                var pPass = pTechnique.getPass(iPass);

                pPass.setSamplerTexture("S_NORMAL_MAP", this._pNormalMapTexture);

                if (akra.config.terrain.useMegaTexture) {
                    if (this._bMegaTextureCreated && this._bShowMegaTexture) {
                        this._pMegaTexures.applyForRender(pPass);
                    } else {
                        pPass.setUniform("S_TERRAIN", null);
                        pPass.setForeign("NUM_TOTAL_LEVELS", 0);
                    }
                } else {
                    pPass.setForeign("NUM_TOTAL_LEVELS", 0);
                }
            };

            Terrain.prototype._onGenerateNormalRender = function (pTechnique, iPass) {
                var pPass = pTechnique.getPass(iPass);

                pPass.setSamplerTexture("HEIGHT_SAMPLER", this._pHeightMapTexture);
                pPass.setUniform("STEPS", Vec2.temp(1. / this._pHeightMapTexture.getWidth(), 1. / this._pHeightMapTexture.getHeight()));
                pPass.setUniform("SCALE", this._v3fMapScale.z);
                pPass.setUniform("CHANNEL", 0);
            };
            return Terrain;
        })(akra.scene.SceneObject);
        terrain.Terrain = Terrain;
    })(akra.terrain || (akra.terrain = {}));
    var terrain = akra.terrain;
})(akra || (akra = {}));
/// <reference path="../idl/ITriTreeNode.ts" />
var akra;
(function (akra) {
    (function (terrain) {
        var TriangleNodePool = (function () {
            function TriangleNodePool(iCount) {
                this._iNextTriNode = 0;
                this._iMaxCount = undefined;
                this._pPool = null;
                this._iMaxCount = iCount;
                this._pPool = new Array(iCount);

                for (var i = 0; i < this._iMaxCount; i++) {
                    this._pPool[i] = TriangleNodePool.createTriTreeNode();
                }
            }
            TriangleNodePool.prototype.getNextTriNode = function () {
                return this._iNextTriNode;
            };

            TriangleNodePool.prototype.setNextTriNode = function (iNextTriNode) {
                this._iNextTriNode = iNextTriNode;
            };

            TriangleNodePool.prototype.getMaxCount = function () {
                return this._iMaxCount;
            };

            TriangleNodePool.prototype.getPool = function () {
                return this._pPool;
            };

            TriangleNodePool.prototype.setPool = function (pPool) {
                this._pPool = pPool;
            };

            TriangleNodePool.prototype.request = function () {
                var pNode = null;

                if (this._iNextTriNode < this._iMaxCount) {
                    pNode = this._pPool[this._iNextTriNode];
                    pNode.baseNeighbor = null;
                    pNode.leftNeighbor = null;
                    pNode.rightNeighbor = null;
                    pNode.leftChild = null;
                    pNode.rightChild = null;
                    this._iNextTriNode++;
                }

                return pNode;
            };

            TriangleNodePool.prototype.reset = function () {
                this._iNextTriNode = 0;
            };

            TriangleNodePool.createTriTreeNode = function () {
                return {
                    baseNeighbor: null,
                    leftNeighbor: null,
                    rightNeighbor: null,
                    leftChild: null,
                    rightChild: null
                };
            };
            return TriangleNodePool;
        })();
        terrain.TriangleNodePool = TriangleNodePool;
    })(akra.terrain || (akra.terrain = {}));
    var terrain = akra.terrain;
})(akra || (akra = {}));
/// <reference path="../idl/ITerrainSectionROAM.ts" />
/// <reference path="TerrainROAM.ts" />
/// <reference path="TriangleNodePool.ts" />
var akra;
(function (akra) {
    (function (terrain) {
        var Vec2 = akra.math.Vec2;
        var Vec3 = akra.math.Vec3;

        var TerrainSectionROAM = (function (_super) {
            __extends(TerrainSectionROAM, _super);
            function TerrainSectionROAM(pScene, eType) {
                if (typeof eType === "undefined") { eType = 69 /* TERRAIN_SECTION_ROAM */; }
                _super.call(this, pScene, eType);
                this._pTerrainSystem = null;
                //два дерева треугольников
                this._pRootTriangleA = terrain.TriangleNodePool.createTriTreeNode();
                this._pRootTriangleB = terrain.TriangleNodePool.createTriTreeNode();
                //Урове5нь погрещности для двух деревьев
                this._pVarianceTreeA = null;
                this._pVarianceTreeB = null;
                //расстояние от камеры до углов секции
                this._v3fDistance0 = new Vec3();
                this._v3fDistance1 = new Vec3();
                this._v3fDistance2 = new Vec3();
                this._v3fDistance3 = new Vec3();
                this._leftNeighborOfA = null;
                this._rightNeighborOfA = null;
                this._leftNeighborOfB = null;
                this._rightNeighborOfB = null;
                this._iStartIndex = undefined;
                this._iTempTotalIndices = undefined;
                this._pTempIndexList = undefined;
                this._iMaxIndices = undefined;
            }
            TerrainSectionROAM.prototype.getTerrainSystem = function () {
                return this._pTerrainSystem;
            };

            TerrainSectionROAM.prototype.getTriangleA = function () {
                return this._pRootTriangleA;
            };

            TerrainSectionROAM.prototype.getTriangleB = function () {
                return this._pRootTriangleB;
            };

            TerrainSectionROAM.prototype.getQueueSortValue = function () {
                return this._fQueueSortValue;
            };

            TerrainSectionROAM.prototype._internalCreate = function (pParentSystem, iSectorX, iSectorY, iHeightMapX, iHeightMapY, iXVerts, iYVerts, pWorldRect, iStartIndex) {
                akra.debug.assert(arguments.length === 9, "Not valid arguments count.");

                var iVerts = akra.math.max(iXVerts, iYVerts);
                this._iStartIndex = iStartIndex;

                var bResult = _super.prototype._internalCreate.call(this, pParentSystem, iSectorX, iSectorY, iHeightMapX, iHeightMapY, iVerts, iVerts, pWorldRect);

                if (!this.getTerrainSystem().getUseTessellationThread()) {
                    this._initTessellationData();
                }

                return bResult;
            };

            TerrainSectionROAM.prototype._initTessellationData = function () {
                var iVerts = akra.math.max(this._iXVerts, this._iYVerts);
                this._iTotalDetailLevels = 2 * (akra.math.round(akra.math.log(iVerts - 1) / akra.math.LN2));
                this._iTotalVariances = 1 << this._iTotalDetailLevels;

                this._pVarianceTreeA = new Array(this._iTotalVariances);

                // this._pVarianceTreeA.set(0);
                this._pVarianceTreeB = new Array(this._iTotalVariances);

                for (var i = 0; i < this._iTotalVariances; i++) {
                    this._pVarianceTreeA[i] = 0;
                    this._pVarianceTreeB[i] = 0;
                }

                var pRoamTerrain = this.getTerrainSystem();
                var pNorthSection = pRoamTerrain.findSection(this._iSectorX, this._iSectorY - 1);
                var pSouthSection = pRoamTerrain.findSection(this._iSectorX, this._iSectorY + 1);
                var pEastSection = pRoamTerrain.findSection(this._iSectorX + 1, this._iSectorY);
                var pWestSection = pRoamTerrain.findSection(this._iSectorX - 1, this._iSectorY);

                if (pNorthSection) {
                    this._leftNeighborOfA = pNorthSection.getTriangleB();
                }

                if (pSouthSection) {
                    this._leftNeighborOfB = pSouthSection.getTriangleA();
                }

                if (pEastSection) {
                    this._rightNeighborOfB = pEastSection.getTriangleA();
                }

                if (pWestSection) {
                    this._rightNeighborOfA = pWestSection.getTriangleB();
                }

                // establish basic links
                this.reset();

                // build the variance trees
                this.computeVariance();
            };

            //private _v3fOldPosition:
            TerrainSectionROAM.prototype.prepareForRender = function (pViewport) {
                _super.prototype.prepareForRender.call(this, pViewport);

                var pCamera = pViewport.getCamera();

                if (!this.getTerrainSystem().resetWithCamera(pCamera)) {
                    return;
                }

                var v3fViewPoint = this.getTerrainSystem().getLocalCameraCoord();

                // compute view distance to our 4 corners
                var fHeight0 = this.getTerrainSystem().readWorldHeight(akra.math.ceil(this._iHeightMapX), akra.math.ceil(this._iHeightMapY));
                var fHeight1 = this.getTerrainSystem().readWorldHeight(akra.math.ceil(this._iHeightMapX), akra.math.ceil(this._iHeightMapY + this._iYVerts));
                var fHeight2 = this.getTerrainSystem().readWorldHeight(akra.math.ceil(this._iHeightMapX + this._iXVerts), akra.math.ceil(this._iHeightMapY + this._iYVerts));
                var fHeight3 = this.getTerrainSystem().readWorldHeight(akra.math.ceil(this._iHeightMapX + this._iXVerts), akra.math.ceil(this._iHeightMapY));

                this._v3fDistance0.set(v3fViewPoint.x - this._pWorldRect.x0, v3fViewPoint.y - this._pWorldRect.y0, v3fViewPoint.z - fHeight0);
                this._v3fDistance1.set(v3fViewPoint.x - this._pWorldRect.x0, v3fViewPoint.y - this._pWorldRect.y1, v3fViewPoint.z - fHeight1);
                this._v3fDistance2.set(v3fViewPoint.x - this._pWorldRect.x1, v3fViewPoint.y - this._pWorldRect.y1, v3fViewPoint.z - fHeight2);
                this._v3fDistance3.set(v3fViewPoint.x - this._pWorldRect.x1, v3fViewPoint.y - this._pWorldRect.y0, v3fViewPoint.z - fHeight3);

                this._fDistance0 = this._v3fDistance0.length();
                this._fDistance1 = this._v3fDistance1.length();
                this._fDistance2 = this._v3fDistance2.length();
                this._fDistance3 = this._v3fDistance3.length();

                // compute min distance as our sort value
                this._fQueueSortValue = akra.math.min(this._fDistance0, this._fDistance1);
                this._fQueueSortValue = akra.math.min(this._fQueueSortValue, this._fDistance2);
                this._fQueueSortValue = akra.math.min(this._fQueueSortValue, this._fDistance3);

                // submit to the tessellation queue of our parent
                this.getTerrainSystem().addToTessellationQueue(this);
            };

            TerrainSectionROAM.prototype.reset = function () {
                if (this.getTerrainSystem().getUseTessellationThread()) {
                    return;
                }

                this._pRootTriangleA.leftChild = null;
                this._pRootTriangleA.rightChild = null;
                this._pRootTriangleB.leftChild = null;
                this._pRootTriangleB.rightChild = null;

                this._pRootTriangleA.baseNeighbor = this._pRootTriangleB;
                this._pRootTriangleB.baseNeighbor = this._pRootTriangleA;

                // link to our neighbors
                this._pRootTriangleA.leftNeighbor = this._leftNeighborOfA;
                this._pRootTriangleA.rightNeighbor = this._rightNeighborOfA;
                this._pRootTriangleB.leftNeighbor = this._leftNeighborOfB;
                this._pRootTriangleB.rightNeighbor = this._rightNeighborOfB;
            };

            TerrainSectionROAM.prototype.tessellate = function (fScale, fLimit) {
                if (this.getTerrainSystem().getUseTessellationThread()) {
                    return;
                }

                var iIndex0 = this.getTerrainSystem()._tableIndex(this._iHeightMapX, this._iHeightMapY);
                var iIndex1 = this.getTerrainSystem()._tableIndex(this._iHeightMapX, this._iHeightMapY + this._iYVerts - 1);
                var iIndex2 = this.getTerrainSystem()._tableIndex(this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY + this._iYVerts - 1);
                var iIndex3 = this.getTerrainSystem()._tableIndex(this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY);

                var fHeight0 = this.getTerrainSystem().readWorldHeight(iIndex0);
                var fHeight1 = this.getTerrainSystem().readWorldHeight(iIndex1);
                var fHeight2 = this.getTerrainSystem().readWorldHeight(iIndex2);
                var fHeight3 = this.getTerrainSystem().readWorldHeight(iIndex3);

                this.recursiveTessellate(this._pRootTriangleA, this._iHeightMapX, this._iHeightMapY + this._iYVerts - 1, fHeight1, this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY + this._iYVerts - 1, fHeight2, this._iHeightMapX, this._iHeightMapY, fHeight0, this._pVarianceTreeA, 1);

                this.recursiveTessellate(this._pRootTriangleB, this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY, fHeight3, this._iHeightMapX, this._iHeightMapY, fHeight0, this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY + this._iYVerts - 1, fHeight2, this._pVarianceTreeB, 1);
            };

            TerrainSectionROAM.prototype.recursiveTessellate = function (pTri, iCornerAX, iCornerAY, fCornerAZ, iCornerBX, iCornerBY, fCornerBZ, iCornerCX, iCornerCY, fCornerCZ, pVTree, iIndex) {
                if ((iIndex << 1) + 1 > this._iTotalVariances) {
                    return;
                }

                var iMidpointX = (iCornerBX + iCornerCX) >> 1;
                var iMidpointY = (iCornerBY + iCornerCY) >> 1;

                if ((iMidpointX === iCornerBX || iMidpointX === iCornerCX) && (iMidpointY === iCornerBY || iMidpointY === iCornerCY)) {
                    return;
                }

                var fMidPointZ = (fCornerBZ + fCornerCZ) / 2;
                var fRealMidPointZ = this.getTerrainSystem().readWorldHeight(iMidpointX, iMidpointY);

                var v3fLoaclCameraCoord = this.getTerrainSystem().getLocalCameraCoord();
                var pTerrainExtents = this.getTerrainSystem().getWorldExtents();
                var iHeightMapWidth = this.getTerrainSystem().getTableWidth();
                var iHeightMapHeight = this.getTerrainSystem().getTableHeight();
                var fTerrainSizeZ = this.getTerrainSystem().getMaxHeight();
                var fTerrainDiagonal = this.getTerrainSystem().getTerrain2DLength();

                var fLocalMidX = pTerrainExtents.x0 + iMidpointX * pTerrainExtents.sizeX() / iHeightMapWidth;
                var fLocalMidY = pTerrainExtents.y0 + iMidpointY * pTerrainExtents.sizeY() / iHeightMapHeight;

                var fDistanceSquare = (v3fLoaclCameraCoord.x - fLocalMidX) * (v3fLoaclCameraCoord.x - fLocalMidX) + (v3fLoaclCameraCoord.y - fLocalMidY) * (v3fLoaclCameraCoord.y - fLocalMidY) + (v3fLoaclCameraCoord.z - fMidPointZ) * (v3fLoaclCameraCoord.z - fMidPointZ);

                // Если треугольник не поделен
                if (!pTri.leftChild) {
                    var fScale = this.getTerrainSystem().getTessellationScale();
                    var fLimit = this.getTerrainSystem().getTessellationLimit();

                    var fDistance = akra.math.sqrt(fDistanceSquare + 0.0001);
                    var fRatio = 0.;

                    fRatio = (pVTree[iIndex] / fTerrainSizeZ * fScale) / ((/*1 +*/ fDistance / fTerrainDiagonal) * fLimit);

                    if (fRatio > 1.) {
                        // subdivide this triangle
                        this.split(pTri);
                    }
                }

                // Если треугольник поделен, продолжаем
                if (pTri.leftChild) {
                    this.recursiveTessellate(pTri.leftChild, iMidpointX, iMidpointY, fRealMidPointZ, iCornerAX, iCornerAY, fCornerAZ, iCornerBX, iCornerBY, fCornerBZ, pVTree, iIndex << 1);

                    this.recursiveTessellate(pTri.rightChild, iMidpointX, iMidpointY, fRealMidPointZ, iCornerCX, iCornerCY, fCornerCZ, iCornerAX, iCornerAY, fCornerAZ, pVTree, (iIndex << 1) + 1);
                }
            };

            TerrainSectionROAM.prototype.split = function (pTri) {
                // Если разбит то смысла разбивать еще нет
                if (pTri.leftChild) {
                    return;
                }

                // If this triangle is not in a proper diamond, force split our base neighbor
                if (pTri.baseNeighbor && (pTri.baseNeighbor.baseNeighbor !== pTri)) {
                    this.split(pTri.baseNeighbor);
                }

                // Create children and link into mesh
                pTri.leftChild = this.getTerrainSystem().requestTriNode();
                pTri.rightChild = this.getTerrainSystem().requestTriNode();

                akra.debug.assert(pTri.leftChild != pTri, "recursive link");
                akra.debug.assert(pTri.rightChild != pTri, "recursive link");

                // Если не удалось выделить треугольник, то не разбиваем
                if ((!pTri.leftChild) || (!pTri.rightChild)) {
                    pTri.leftChild = null;
                    pTri.rightChild = null;
                    return;
                }

                // Fill in the information we can get from the parent (neighbor pointers)
                pTri.leftChild.baseNeighbor = pTri.leftNeighbor;
                pTri.leftChild.leftNeighbor = pTri.rightChild;

                pTri.rightChild.baseNeighbor = pTri.rightNeighbor;
                pTri.rightChild.rightNeighbor = pTri.leftChild;

                // Link our Left Neighbor to the new children
                if (pTri.leftNeighbor) {
                    if (pTri.leftNeighbor.baseNeighbor == pTri) {
                        pTri.leftNeighbor.baseNeighbor = pTri.leftChild;
                    } else if (pTri.leftNeighbor.leftNeighbor == pTri) {
                        pTri.leftNeighbor.leftNeighbor = pTri.leftChild;
                    } else if (pTri.leftNeighbor.rightNeighbor == pTri) {
                        pTri.leftNeighbor.rightNeighbor = pTri.leftChild;
                    } else {
                        console.log(pTri);
                        akra.logger.warn("Invalid Left Neighbor!");
                        akra.logger.critical("stop");
                        // debugger;
                    }
                }

                // Link our Right Neighbor to the new children
                if (pTri.rightNeighbor) {
                    if (pTri.rightNeighbor.baseNeighbor == pTri) {
                        pTri.rightNeighbor.baseNeighbor = pTri.rightChild;
                    } else if (pTri.rightNeighbor.rightNeighbor == pTri) {
                        pTri.rightNeighbor.rightNeighbor = pTri.rightChild;
                    } else if (pTri.rightNeighbor.leftNeighbor == pTri) {
                        pTri.rightNeighbor.leftNeighbor = pTri.rightChild;
                    } else {
                        akra.logger.warn("Invalid Right Neighbor!");
                    }
                }

                // Link our Base Neighbor to the new children
                if (pTri.baseNeighbor) {
                    if (pTri.baseNeighbor.leftChild) {
                        pTri.baseNeighbor.leftChild.rightNeighbor = pTri.rightChild;
                        pTri.baseNeighbor.rightChild.leftNeighbor = pTri.leftChild;
                        pTri.leftChild.rightNeighbor = pTri.baseNeighbor.rightChild;
                        pTri.rightChild.leftNeighbor = pTri.baseNeighbor.leftChild;
                    } else {
                        // Base Neighbor (in a diamond with us) was not split yet, so do that now.
                        this.split(pTri.baseNeighbor);
                    }
                } else {
                    // An edge triangle, trivial case.
                    pTri.leftChild.rightNeighbor = null;
                    pTri.rightChild.leftNeighbor = null;
                }
            };

            TerrainSectionROAM.prototype._createRenderDataForVertexAndIndex = function () {
                return true;
            };

            TerrainSectionROAM.prototype._buildIndexBuffer = function () {
                // this._iMaxIndices=a.TerrainROAM.MaxTriTreeNodes*3;
                this._iMaxIndices = this.getTerrainSystem().getMaxTriTreeNodes() * 3;
                return true;
            };

            TerrainSectionROAM.prototype._buildVertexBuffer = function () {
                this._pWorldRect.z0 = akra.MAX_FLOAT64;
                this._pWorldRect.z1 = akra.MIN_FLOAT64;

                var nElementSize = 0;
                if (this.getTerrainSystem()._useVertexNormal()) {
                    nElementSize = (3 + 3 + 2);
                } else {
                    nElementSize = (3 + 2);
                }

                var pVerts = this.getTerrainSystem().getVerts();

                var v3fNormal = new Vec3();

                // размер ячейки сектора
                var v2fCellSize = new Vec2();
                v2fCellSize.set(this.getHeightX() / (this._iXVerts - 1), this.getHeightY() / (this._iYVerts - 1)); /*размер сектора/количество ячеек в секторе*/

                //Координаты вершина в секторе
                var v2fVert = new Vec2();
                v2fVert.set(0.0, 0.0);

                for (var y = 0; y < this._iYVerts; ++y) {
                    v2fVert.set(this._pWorldRect.x0, y * v2fCellSize.y + this._pWorldRect.y0);

                    for (var x = 0; x < this._iXVerts; ++x) {
                        var fHeight = this.getTerrainSystem().readWorldHeight(this._iHeightMapX + x, this._iHeightMapY + y);

                        pVerts[((y * this._iXVerts) + x) * nElementSize + 0 + this._iStartIndex * nElementSize] = v2fVert.x;
                        pVerts[((y * this._iXVerts) + x) * nElementSize + 1 + this._iStartIndex * nElementSize] = v2fVert.y;
                        pVerts[((y * this._iXVerts) + x) * nElementSize + 2 + this._iStartIndex * nElementSize] = fHeight;

                        if (this.getTerrainSystem()._useVertexNormal()) {
                            this.getTerrainSystem().readWorldNormal(v3fNormal, this._iHeightMapX + x, this._iHeightMapY + y);

                            pVerts[((y * this._iXVerts) + x) * nElementSize + 3 + this._iStartIndex * nElementSize] = v3fNormal.x;
                            pVerts[((y * this._iXVerts) + x) * nElementSize + 4 + this._iStartIndex * nElementSize] = v3fNormal.y;
                            pVerts[((y * this._iXVerts) + x) * nElementSize + 5 + this._iStartIndex * nElementSize] = v3fNormal.z;

                            pVerts[((y * this._iXVerts) + x) * nElementSize + 6 + this._iStartIndex * nElementSize] = (this._iSectorX + x / (this._iXVerts - 1)) / this.getTerrainSystem().getSectorCountX();
                            pVerts[((y * this._iXVerts) + x) * nElementSize + 7 + this._iStartIndex * nElementSize] = (this._iSectorY + y / (this._iYVerts - 1)) / this.getTerrainSystem().getSectorCountY();
                        } else {
                            pVerts[((y * this._iXVerts) + x) * nElementSize + 3 + this._iStartIndex * nElementSize] = (this._iSectorX + x / (this._iXVerts - 1)) / this.getTerrainSystem().getSectorCountX();
                            pVerts[((y * this._iXVerts) + x) * nElementSize + 4 + this._iStartIndex * nElementSize] = (this._iSectorY + y / (this._iYVerts - 1)) / this.getTerrainSystem().getSectorCountY();
                        }

                        this._pWorldRect.z0 = akra.math.min(this._pWorldRect.z0, fHeight);
                        this._pWorldRect.z1 = akra.math.max(this._pWorldRect.z1, fHeight);

                        v2fVert.x += v2fCellSize.x;
                    }
                }

                return true;
            };

            TerrainSectionROAM.prototype.buildTriangleList = function () {
                if (this.getTerrainSystem().getUseTessellationThread()) {
                    return;
                }

                this._iTempTotalIndices = this.getTerrainSystem().getTotalIndex();

                this._pTempIndexList = this.getTerrainSystem().getIndex();
                this._iVertexID = this.getTerrainSystem().getVertexId();

                // add all the triangles to the roamTerrain
                // in root triangle A
                this.recursiveBuildTriangleList(this._pRootTriangleA, 0, this._iXVerts - 1, (this._iYVerts - 1) * this._iXVerts);

                // add all the triangles to the roamTerrain
                // in root triangle B
                this.recursiveBuildTriangleList(this._pRootTriangleB, (this._iYVerts * this._iXVerts) - 1, (this._iYVerts - 1) * this._iXVerts, this._iXVerts - 1);

                this.getTerrainSystem().setTotalIndex(this._iTempTotalIndices);

                this._iTempTotalIndices = undefined;
                this._iVertexID = undefined;
                this._pTempIndexList = null;
            };

            TerrainSectionROAM.prototype.recursiveBuildTriangleList = function (pTri, iPointBase, iPointLeft, iPointRight) {
                if (pTri.leftChild) {
                    if (!pTri.rightChild) {
                        akra.logger.warn("invalid triangle node");
                    }

                    var iPointMid = (iPointLeft + iPointRight) * 0.5;
                    this.recursiveBuildTriangleList(pTri.leftChild, iPointMid, iPointBase, iPointLeft);
                    this.recursiveBuildTriangleList(pTri.rightChild, iPointMid, iPointRight, iPointBase);
                } else if (this._iTempTotalIndices + 3 < this._iMaxIndices) {
                    var nElementSize = 0;
                    if (this.getTerrainSystem()._useVertexNormal()) {
                        nElementSize = (3 + 3 + 2);
                    } else {
                        nElementSize = (3 + 2);
                    }

                    // add the local triangle to the index list
                    this._pTempIndexList[this._iTempTotalIndices++] = ((iPointRight + this._iStartIndex) * nElementSize * 4 + this._iVertexID) / 4;
                    this._pTempIndexList[this._iTempTotalIndices++] = ((iPointLeft + this._iStartIndex) * nElementSize * 4 + this._iVertexID) / 4;
                    this._pTempIndexList[this._iTempTotalIndices++] = ((iPointBase + this._iStartIndex) * nElementSize * 4 + this._iVertexID) / 4;
                } else {
                    akra.debug.log("else", this._iTempTotalIndices, this._iMaxIndices);
                }
            };

            TerrainSectionROAM.prototype.computeVariance = function () {
                var iTableWidth = this.getTerrainSystem().getTableWidth();
                var iTableHeight = this.getTerrainSystem().getTableHeight();

                var iIndex0 = this.getTerrainSystem()._tableIndex(this._iHeightMapX, this._iHeightMapY);
                var iIndex1 = this.getTerrainSystem()._tableIndex(this._iHeightMapX, this._iHeightMapY + this._iYVerts - 1);
                var iIndex2 = this.getTerrainSystem()._tableIndex(this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY + this._iYVerts - 1);
                var iIndex3 = this.getTerrainSystem()._tableIndex(this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY);

                var fHeight0 = this.getTerrainSystem().readWorldHeight(iIndex0);
                var fHeight1 = this.getTerrainSystem().readWorldHeight(iIndex1);
                var fHeight2 = this.getTerrainSystem().readWorldHeight(iIndex2);
                var fHeight3 = this.getTerrainSystem().readWorldHeight(iIndex3);

                this.recursiveComputeVariance(this._iHeightMapX, this._iHeightMapY + this._iYVerts - 1, this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY + this._iYVerts - 1, this._iHeightMapX, this._iHeightMapY, fHeight1, fHeight2, fHeight0, this._pVarianceTreeA, 1);

                this.recursiveComputeVariance(this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY, this._iHeightMapX, this._iHeightMapY, this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY + this._iYVerts - 1, fHeight3, fHeight0, fHeight2, this._pVarianceTreeB, 1);
            };

            TerrainSectionROAM.prototype.recursiveComputeVariance = function (iCornerAX, iCornerAY, iCornerBX, iCornerBY, iCornerCX, iCornerCY, fHeightA, fHeightB, fHeightC, pVTree, iIndex) {
                if (iIndex < pVTree.length) {
                    var iMidpointX = (iCornerBX + iCornerCX) >> 1;
                    var iMidpointY = (iCornerBY + iCornerCY) >> 1;

                    if ((iMidpointX === iCornerBX || iMidpointX === iCornerCX) && (iMidpointY === iCornerBY || iMidpointY === iCornerCY)) {
                        return 0;
                    }

                    var fMidHeight = this.getTerrainSystem().readWorldHeight(iMidpointX, iMidpointY);
                    var fInterpolatedHeight = (fHeightB + fHeightC) * 0.5;
                    var fVariance = akra.math.abs(fMidHeight - fInterpolatedHeight);

                    // find the variance of our children
                    var fLeft = this.recursiveComputeVariance(iMidpointX, iMidpointY, iCornerAX, iCornerAY, iCornerBX, iCornerBY, fMidHeight, fHeightA, fHeightB, pVTree, iIndex << 1);

                    var fRight = this.recursiveComputeVariance(iMidpointX, iMidpointY, iCornerCX, iCornerCY, iCornerAX, iCornerAY, fMidHeight, fHeightC, fHeightA, pVTree, 1 + (iIndex << 1));

                    // local variance is the minimum of all three
                    fVariance = akra.math.max(fVariance, fLeft);
                    fVariance = akra.math.max(fVariance, fRight);

                    // store the variance as 1/(variance+1)
                    pVTree[iIndex] = fVariance;

                    // this.drawVariance(iIndex,
                    // 	this.getTerrainSystem()._tableIndex(iCornerAX, iCornerAY),
                    // 	this.getTerrainSystem()._tableIndex(iCornerBX, iCornerBY),
                    // 	this.getTerrainSystem()._tableIndex(iCornerCX, iCornerCY), pVTree);
                    return fVariance;
                }

                // return a value which will be ignored by the parent
                // (because the minimum function is used with this result)
                return 0;
            };

            TerrainSectionROAM.prototype.maxVariance = function () {
                var fVarianceMaxA = 0;
                var fVarianceMaxB = 0;
                for (var i = 0; i < this._pVarianceTreeA.length; i++) {
                    if (fVarianceMaxA < this._pVarianceTreeA[i]) {
                        fVarianceMaxA = this._pVarianceTreeA[i];
                    }

                    if (fVarianceMaxB < this._pVarianceTreeB[i]) {
                        fVarianceMaxB = this._pVarianceTreeB[i];
                    }
                }

                akra.logger.log("MAX ---> In A: " + fVarianceMaxA + ". In B: " + fVarianceMaxB);
            };

            TerrainSectionROAM.prototype.minVariance = function () {
                var fVarianceMaxA = 0xffffff;
                var fVarianceMaxB = 0xffffff;

                for (var i = 0; i < this._pVarianceTreeA.length; i++) {
                    if (fVarianceMaxA > this._pVarianceTreeA[i] && this._pVarianceTreeA[i] !== 0) {
                        fVarianceMaxA = this._pVarianceTreeA[i];
                    }

                    if (fVarianceMaxB > this._pVarianceTreeB[i] && this._pVarianceTreeB[i] !== 0) {
                        fVarianceMaxB = this._pVarianceTreeB[i];
                    }
                }

                akra.logger.log("MIN ---> In A: " + fVarianceMaxA + ". In B: " + fVarianceMaxB);
            };

            TerrainSectionROAM.prototype.drawVariance = function (iIndex, iCornerA, iCornerB, iCornerC, pVTree) {
                var iLevel = akra.math.floor(akra.math.log(iIndex) / akra.math.LN2);
                var iStart = 3;
                if (iLevel >= iStart && iLevel < iStart + 4) {
                    //#####################################################################################
                    //Получение канваса
                    var pCanvas = document.getElementById("canvasVariance" + (iLevel - iStart));
                    var p2D = pCanvas.getContext("2d");

                    // цвет фона
                    p2D.fillStyle = "rgb(0," + akra.math.floor(pVTree[iIndex]) + ",0)";

                    //#####################################################################################
                    //Рисование треугольников
                    //цвет линий
                    p2D.strokeStyle = "#f00";
                    p2D.lineWidth = 1;
                    p2D.beginPath();
                    var iTW = this.getTerrainSystem().getTableWidth();
                    var iTH = this.getTerrainSystem().getTableHeight();

                    var iXA = iCornerA % iTW;
                    var iYA = akra.math.floor(iCornerA / iTW);
                    var iXB = iCornerB % iTW;
                    var iYB = akra.math.floor(iCornerB / iTW);
                    var iXC = iCornerC % iTW;
                    var iYC = akra.math.floor(iCornerC / iTW);

                    var iXMid = akra.math.floor((iXA + iXB + iXC) / 3);
                    var iYMid = akra.math.floor((iYA + iYB + iYC) / 3);

                    p2D.arc(akra.math.floor(iXMid / iTW * pCanvas.width), akra.math.floor(iYMid / iTH * pCanvas.height), 1, 0, akra.math.PI * 2, false);
                    p2D.fill();
                }
            };
            return TerrainSectionROAM;
        })(terrain.TerrainSection);
        terrain.TerrainSectionROAM = TerrainSectionROAM;
    })(akra.terrain || (akra.terrain = {}));
    var terrain = akra.terrain;
})(akra || (akra = {}));
/// <reference path="../idl/ITerrainROAM.ts" />
var akra;
(function (akra) {
    /// <reference path="../scene/objects/Camera.ts" />
    /// <reference path="../conv/conv.ts" />
    /// <reference path="../config/config.ts" />
    /// <reference path="Terrain.ts" />
    /// <reference path="TerrainSectionROAM.ts" />
    /// <reference path="TriangleNodePool.ts" />
    /*
    #ifdef DEBUG
    
    //copy threads from sources to {data} folder and modify path to relative
    
    /// @TESSELLATION_THREAD: {data}/js/TessellationThread.t.js|src(inc/util/TessellationThread.t.js)|data_location({data},DATA)
    
    #define TessellationThread() Worker("@TESSELLATION_THREAD")
    
    #else
    
    //read threads data and insert to code
    /// @TESSELLATION_THREAD: |content(inc/util/TessellationThread.t.js)|minify()|stringify()
    
    #define TessellationThread() Worker(util.dataToURL("@TESSELLATION_THREAD", "application/javascript"))
    
    #endif
    */
    (function (terrain) {
        var Vec2 = akra.math.Vec2;
        var Vec3 = akra.math.Vec3;
        var Vec4 = akra.math.Vec4;

        var Mat4 = akra.math.Mat4;

        var VE = akra.data.VertexElement;

        var thread = akra.config.terrain.roam.tessellationThread;

        var sThread = thread.content;

        if (thread.format === "STRING") {
            //attachment contain inline thread file dataa
            sThread = akra.conv.toURL(thread.content, "application/javascript");
        } else {
            sThread = akra.config.data + sThread;
        }

        var TerrainROAM = (function (_super) {
            __extends(TerrainROAM, _super);
            function TerrainROAM(pScene, eType) {
                if (typeof eType === "undefined") { eType = 67 /* TERRAIN_ROAM */; }
                _super.call(this, pScene, eType);
                this._pRenderableObject = null;
                this._pRenderData = null;
                this._pDataIndex = null;
                this._pIndexList = null;
                this._pTessellationQueue = null;
                this._iTessellationQueueCount = 0;
                this._isRenderInThisFrame = false;
                this._iMaxTriTreeNodes = (1024 * 64 * 4);
                this._iTessellationQueueSize = 0;
                //массив подчиненный секций
                this._pSectorArray = null;
                this._fScale = 0.0;
                this._fLimit = 0.0;
                this._iTessellationQueueCountOld = 0;
                this._nCountRender = 0;
                this._m4fLastCameraMatrix = new Mat4();
                this._m4fLastTessellationMatrix = new Mat4();
                this._v3fLocalCameraCoord = new Vec3();
                this._isNeedReset = true;
                this._fLastTessellationTime = 0.;
                this._fTessellationSelfInterval = 1. / 25.;
                this._fTessellationThreadInterval = 1. / 60.;
                this._bUseTessellationThread = false;
                this._bIsInitTessellationSelfData = false;
                this._bIsInitTessellationThreadData = false;
                this._pTessellationThread = null;
                this._pTessellationTransferableData = null;
                this._pTmpTransferableArray = null;
                this._bIsReadyForTesseltion = false;
                this._pNodePool = null;
                // private _pTestTerrainInfo: util.TerrainInfo = null;
                this._fAvgTesselateCallsInSec = 0;
                this._iCurrentTesselateCount = 0;
                this._nSec = 0;
                this._fLastTimeStart = 0;
                this._pRenderData = this._pDataFactory.getEmptyRenderData(4 /* TRIANGLELIST */, akra.ERenderDataBufferOptions.RD_ADVANCED_INDEX);
                this._pRenderableObject = new akra.render.RenderableObject();
                this._pRenderableObject._setup(this._pEngine.getRenderer());
                this._pRenderableObject._setRenderData(this._pRenderData);

                if (akra.config.PROFILE_TESSEALLATION) {
                    this._fAvgTesselateCallsInSec = 0;
                    this._iCurrentTesselateCount = 0;
                    this._nSec = 0;
                    this._fLastTimeStart = 0;
                }

                this._pRenderableObject.beforeRender.connect(this, this._onBeforeRender);
            }
            TerrainROAM.prototype.getMaxTriTreeNodes = function () {
                return this._iMaxTriTreeNodes;
            };

            TerrainROAM.prototype.getVerts = function () {
                return this._pVerts;
            };

            TerrainROAM.prototype.getIndex = function () {
                return this._pIndexList;
            };

            TerrainROAM.prototype.getVertexId = function () {
                return this._iVertexID;
            };

            TerrainROAM.prototype.getTotalRenderable = function () {
                return !akra.isNull(this._pRenderableObject) ? 1 : 0;
            };

            TerrainROAM.prototype.getRenderable = function (i) {
                return this._pRenderableObject;
            };

            TerrainROAM.prototype.getLocalCameraCoord = function () {
                return this._v3fLocalCameraCoord;
            };

            TerrainROAM.prototype.getTessellationScale = function () {
                return this._fScale;
            };

            TerrainROAM.prototype.setTessellationScale = function (fScale) {
                this._fScale = fScale;
            };

            TerrainROAM.prototype.getTessellationLimit = function () {
                return this._fLimit;
            };

            TerrainROAM.prototype.setTessellationLimit = function (fLimit) {
                this._fLimit = fLimit;
            };

            TerrainROAM.prototype.getUseTessellationThread = function () {
                return this._bUseTessellationThread;
            };

            TerrainROAM.prototype.setUseTessellationThread = function (bUseThread) {
                this._bUseTessellationThread = bUseThread;

                if (this._isCreate) {
                    if (bUseThread && !this._bIsInitTessellationThreadData) {
                        this.initTessellationThreadData();
                    } else if (!bUseThread && !this._bIsInitTessellationSelfData) {
                        this.initTessellationSelfData();
                    }
                }

                if (akra.config.PROFILE_TESSEALLATION) {
                    this._fAvgTesselateCallsInSec = 0;
                    this._iCurrentTesselateCount = 0;
                    this._nSec = 0;
                    this._fLastTimeStart = 0;
                }
            };

            TerrainROAM.prototype.getTotalIndex = function () {
                return this._iTotalIndices;
            };

            TerrainROAM.prototype.setTotalIndex = function (iTotalIndices) {
                this._iTotalIndices = iTotalIndices;
            };

            TerrainROAM.prototype.init = function (pMaps, worldExtents, iShift, iShiftX, iShiftY, sSurfaceTextures, pRootNode) {
                if (typeof pRootNode === "undefined") { pRootNode = null; }
                var bResult = _super.prototype.init.call(this, pMaps, worldExtents, iShift, iShiftX, iShiftY, sSurfaceTextures, pRootNode);
                if (bResult) {
                    this._iTessellationQueueSize = this.getSectorCountX() * this.getSectorCountY();
                    this._pTessellationQueue = new Array(this._iTessellationQueueSize);
                    this._iTessellationQueueCount = 0;
                    this._iTotalIndicesMax = 0;

                    for (var i = 0; i < this._pTessellationQueue.length; i++) {
                        this._pTessellationQueue[i] = null;
                    }

                    this._pRenderableObject.getTechnique().setMethod(this._pDefaultRenderMethod);
                    this._pRenderableObject.getTechnique().render.connect(this, this._onRender);

                    if (!this._bUseTessellationThread) {
                        this._pNodePool = new terrain.TriangleNodePool(this._iMaxTriTreeNodes);
                    }

                    this._setTessellationParameters(10.0, 0.5);
                    this.reset();

                    if (this._bUseTessellationThread) {
                        this.initTessellationThreadData();
                    } else {
                        this._bIsInitTessellationSelfData = true;
                        this._bIsReadyForTesseltion = true;
                    }

                    this._isCreate = true;
                } else {
                    this._isCreate = false;
                }

                return bResult;
            };

            TerrainROAM.prototype.destroy = function () {
                delete this._pNodePool;
                delete this._pTessellationQueue;

                this._iTessellationQueueCount = 0;
                this._fScale = 0;
                this._fLimit = 0;
                //Terrain.prototype.destroy.call(this); с какого то хуя этого метода не оказалось
            };

            TerrainROAM.prototype.initTessellationSelfData = function () {
                this._bIsReadyForTesseltion = true;

                if (this._bIsInitTessellationSelfData) {
                    return;
                }

                this._pNodePool = new terrain.TriangleNodePool(this._iMaxTriTreeNodes);
                for (var i = 0; i < this._pSectorArray.length; i++) {
                    this._pSectorArray[i]._initTessellationData();
                }

                this._bIsInitTessellationSelfData = true;
            };

            TerrainROAM.prototype.initTessellationThreadData = function () {
                this._bIsReadyForTesseltion = false;

                if (this._bIsInitTessellationThreadData) {
                    return;
                }

                var me = this;
                var pThread = this._pTessellationThread = new Worker(sThread);

                pThread.onmessage = function (event) {
                    if (event.data === "ok") {
                        me.successThreadInit();
                    } else {
                        akra.logger.warn("Cannot inititalize tessellation thread. So we will tessellate terraint in main thread.");
                        me.setUseTessellationThread(false);
                        me.terminateTessellationThread();
                    }
                };

                pThread.onerror = function (event) {
                    akra.logger.warn("Error occured in tessellation thread. So we will tessellate terraint in main thread.");
                    akra.debug.log(event);
                    pThread.onmessage = null;
                    me.setUseTessellationThread(false);
                    me.terminateTessellationThread();
                };

                this._bIsInitTessellationThreadData = true;

                var pHeightTableCopy = new Float32Array(this._pHeightTable.length);
                pHeightTableCopy.set(this._pHeightTable);

                pThread.postMessage({
                    type: 1,
                    info: {
                        heightMapTable: pHeightTableCopy.buffer,
                        tableWidth: this.getTableWidth(),
                        tableHeight: this.getTableHeight(),
                        sectorUnits: this._iSectorUnits,
                        sectorCountX: this._iSectorCountX,
                        sectorCountY: this._iSectorCountY,
                        isUsedVertexNormal: this._bUseVertexNormal,
                        worldExtents: {
                            x0: this._pWorldExtents.x0,
                            x1: this._pWorldExtents.x1,
                            y0: this._pWorldExtents.y0,
                            y1: this._pWorldExtents.y1,
                            z0: this._pWorldExtents.z0,
                            z1: this._pWorldExtents.z1
                        },
                        maxHeight: this.getMaxHeight(),
                        maxTriTreeNodeCount: this._iMaxTriTreeNodes,
                        tessellationScale: this._fScale,
                        tessellationLimit: this._fLimit,
                        vertexID: this._iVertexID
                    }
                }, [pHeightTableCopy.buffer]);
            };

            TerrainROAM.prototype.terminateTessellationThread = function () {
                this._pTessellationThread.terminate();
                this._bIsInitTessellationThreadData = false;
            };

            TerrainROAM.prototype.successThreadInit = function () {
                var me = this;
                this._pTessellationTransferableData = new ArrayBuffer(4 * this._iMaxTriTreeNodes * 3 + 4);
                this._pTmpTransferableArray = [null];
                this._bIsReadyForTesseltion = true;

                this._pTessellationThread.onmessage = function (event) {
                    me.prepareIndexData(event.data);
                };
            };

            TerrainROAM.prototype._allocateSectors = function () {
                var nElementSize = 0;
                if (this._useVertexNormal()) {
                    nElementSize = (3 + 3 + 2);
                } else {
                    nElementSize = (3 + 2);
                }

                this._pSectorArray = new Array(this._iSectorCountX * this._iSectorCountY);

                //Вершинный буфер для всех
                this._pVerts = new Array((this._iSectorCountX * this._iSectorCountY) * (this._iSectorVerts * this._iSectorVerts) * (nElementSize));

                for (var i = 0; i < this._pSectorArray.length; i++) {
                    this._pSectorArray[i] = this.getScene().createTerrainSectionROAM();
                }

                for (var y = 0; y < this._iSectorCountY; ++y) {
                    for (var x = 0; x < this._iSectorCountX; ++x) {
                        //cVector2 sectorPos(
                        var v2fSectorPos = new Vec2();
                        v2fSectorPos.set(this._pWorldExtents.x0 + (x * this._v2fSectorSize.x), this._pWorldExtents.y0 + (y * this._v2fSectorSize.y));

                        //cRect2d r2fSectorRect(
                        var r2fSectorRect = new akra.geometry.Rect2d();
                        r2fSectorRect.set(v2fSectorPos.x, v2fSectorPos.x + this._v2fSectorSize.x, v2fSectorPos.y, v2fSectorPos.y + this._v2fSectorSize.y);

                        var iXPixel = x << this._iSectorShift;
                        var iYPixel = y << this._iSectorShift;
                        var iIndex = (y * this._iSectorCountX) + x;

                        if (!this._pSectorArray[iIndex]._internalCreate(this, x, y, iXPixel, iYPixel, this._iSectorVerts, this._iSectorVerts, r2fSectorRect, iIndex * (this._iSectorVerts * this._iSectorVerts))) {
                            return false;
                        }
                    }
                }

                var pVertexDescription = null;
                if (this._useVertexNormal()) {
                    pVertexDescription = [VE.float3(akra.data.Usages.POSITION), VE.float3(akra.data.Usages.NORMAL), VE.float2(akra.data.Usages.TEXCOORD)];
                } else {
                    pVertexDescription = [VE.float3(akra.data.Usages.POSITION), VE.float2(akra.data.Usages.TEXCOORD)];
                }

                this._iVertexID = this._pRenderData.allocateData(pVertexDescription, new Float32Array(this._pVerts));

                //Индексны буфер для всех
                this._iTotalIndices = 0;

                //Максимальное количество треугольников помноженное на 3 вершины на каждый треугольник
                this._pIndexList = new Float32Array(this._iMaxTriTreeNodes * 3);
                this._pRenderData.allocateIndex([VE.float(akra.data.Usages.INDEX0), VE.float(akra.data.Usages.POSITION, 0)], this._pIndexList);
                this._pRenderData.index(this._iVertexID, akra.data.Usages.INDEX0);
                this._pDataIndex = this._pRenderData.getAdvancedIndexData(akra.data.Usages.INDEX0);

                return true;
            };

            TerrainROAM.prototype.reset = function () {
                this._isRenderInThisFrame = false;

                if (this._isCreate) {
                    _super.prototype.reset.call(this);

                    for (var i = 0; i < this._iTessellationQueueCount; i++) {
                        this._pTessellationQueue[i] = null;
                    }

                    this._iTessellationQueueCount = 0;

                    // this._pTessellationQueue.length = this._iTessellationQueueSize;
                    if (!this._bUseTessellationThread && this._bIsInitTessellationSelfData) {
                        this._pNodePool.reset();

                        for (var i = 0; i < this._pSectorArray.length; i++) {
                            this._pSectorArray[i].reset();
                        }
                    }
                }
            };

            TerrainROAM.prototype.resetWithCamera = function (pCamera) {
                if (this._bIsReadyForTesseltion && !this._isOldCamera(pCamera)) {
                    if (this._isNeedReset) {
                        this.reset();
                        this._isNeedReset = false;

                        var v4fCameraCoord = Vec4.temp(pCamera.getWorldPosition(), 1.);

                        v4fCameraCoord = this.getInverseWorldMatrix().multiplyVec4(v4fCameraCoord);

                        this._v3fLocalCameraCoord.set(v4fCameraCoord.x, v4fCameraCoord.y, v4fCameraCoord.z);
                        // return true;
                    }

                    return true;
                    // return false;
                } else {
                    // return true;
                    return false;
                }
            };

            TerrainROAM.prototype.requestTriNode = function () {
                return this._pNodePool.request();
            };

            TerrainROAM.prototype.addToTessellationQueue = function (pSection) {
                if (this._iTessellationQueueCount < this._iTessellationQueueSize) {
                    this._pTessellationQueue[this._iTessellationQueueCount] = pSection;
                    this._iTessellationQueueCount++;
                    return true;
                }

                // while we handle this failure gracefully
                // in release builds, we alert ourselves
                // to the situation with an assert in debug
                // builds so we can increase the queue size
                akra.logger.warn("increase the size of the ROAM tessellation queue");
                return false;
            };

            TerrainROAM.prototype.processTessellationQueue = function () {
                // this._pTessellationQueue.length = this._iTessellationQueueCount;
                this._pTessellationQueue.sort(TerrainROAM.fnSortSection);

                if (this._bUseTessellationThread) {
                    var pDataView = new DataView(this._pTessellationTransferableData);

                    pDataView.setFloat32(0, this._v3fLocalCameraCoord.x, true);
                    pDataView.setFloat32(4, this._v3fLocalCameraCoord.y, true);
                    pDataView.setFloat32(8, this._v3fLocalCameraCoord.z, true);

                    pDataView.setUint32(12, this._iTessellationQueueCount, true);

                    for (var i = 0; i < this._iTessellationQueueCount; ++i) {
                        pDataView.setUint32(16 + i * 4, this._pTessellationQueue[i].getSectionIndex(), true);
                        // pSectionIndices[i] = this._pTessellationQueue[i].sectionIndex;
                    }

                    this._pTmpTransferableArray[0] = this._pTessellationTransferableData;
                    this._pTessellationThread.postMessage(this._pTessellationTransferableData, this._pTmpTransferableArray);
                    this._bIsReadyForTesseltion = false;
                } else {
                    for (var i = 0; i < this._iTessellationQueueCount; ++i) {
                        // split triangles based on the
                        // scale and limit values
                        this._pTessellationQueue[i].tessellate(this._fScale, this._fLimit);
                    }

                    this._iTotalIndices = 0;

                    for (var i = 0; i < this._iTessellationQueueCount; ++i) {
                        this._pTessellationQueue[i].buildTriangleList();
                    }

                    if (this._iTotalIndicesOld === this._iTotalIndices && this._iTotalIndices !== this._iTotalIndicesMax) {
                        return;
                    }

                    this._pRenderData._setIndexLength(this._iTotalIndices);
                    this._pDataIndex.setData(this._pIndexList, 0, akra.sizeof(5126 /* FLOAT */), 0, this._iTotalIndices);
                    this._iTotalIndicesOld = this._iTotalIndices;
                    this._iTotalIndicesMax = akra.math.max(this._iTotalIndicesMax, this._iTotalIndices);

                    this._pRenderableObject._setRenderData(this._pRenderData);
                }
            };

            TerrainROAM.prototype.prepareIndexData = function (pData) {
                var iTotalIndices = (new Uint32Array(pData, 0, 1))[0];
                var pTmpData = new Float32Array(pData, 4, iTotalIndices);

                this._iTotalIndices = iTotalIndices;
                this._pIndexList.set(pTmpData);

                this._pRenderData._setIndexLength(this._iTotalIndices);
                this._pDataIndex.setData(this._pIndexList, 0, akra.sizeof(5126 /* FLOAT */), 0, this._iTotalIndices);

                this._pRenderableObject._setRenderData(this._pRenderData);

                this._pTessellationTransferableData = pData;

                this._bIsReadyForTesseltion = true;
            };

            TerrainROAM.prototype._setTessellationParameters = function (fScale, fLimit) {
                this._fScale = fScale;
                this._fLimit = fLimit;
            };

            TerrainROAM.prototype._isOldCamera = function (pCamera) {
                return this._m4fLastCameraMatrix.isEqual(pCamera.getWorldMatrix());
            };

            TerrainROAM.prototype._onBeforeRender = function (pRenderableObject, pViewport) {
                if (this._bIsReadyForTesseltion) {
                    var pCamera = pViewport.getCamera();
                    var fCurrentTime = this.getScene().getManager().getEngine().getTime();

                    this._m4fLastCameraMatrix.set(pCamera.getWorldMatrix());

                    if ((this._bUseTessellationThread && fCurrentTime - this._fLastTessellationTime > this._fTessellationThreadInterval) || fCurrentTime - this._fLastTessellationTime > this._fTessellationSelfInterval) {
                        if (akra.config.PROFILE_TESSEALLATION) {
                            if (this._fLastTimeStart === 0) {
                                this._fLastTimeStart = fCurrentTime;
                                this._iCurrentTesselateCount++;
                                this._nSec = 1;
                                this._fAvgTesselateCallsInSec = 0;
                            } else if (this._fLastTimeStart + 1 > fCurrentTime) {
                                this._iCurrentTesselateCount++;
                            } else {
                                this._fAvgTesselateCallsInSec = this._fAvgTesselateCallsInSec * (this._nSec - 1) / this._nSec + this._iCurrentTesselateCount / this._nSec;

                                if (this._nSec % 3 === 0) {
                                    akra.logger.log("Avg:", this._fAvgTesselateCallsInSec.toFixed(2), "Last:", this._iCurrentTesselateCount);
                                }

                                this._nSec++;
                                this._fLastTimeStart = fCurrentTime;
                                this._iCurrentTesselateCount = 0;
                            }
                        }

                        if (!this._m4fLastCameraMatrix.isEqual(this._m4fLastTessellationMatrix)) {
                            this.processTessellationQueue();
                            this._m4fLastTessellationMatrix.set(this._m4fLastCameraMatrix);
                            //this._iTessellationQueueCountOld = this._iTessellationQueueCount;
                        }

                        this._fLastTessellationTime = fCurrentTime;
                    }
                }

                this._isNeedReset = true;
            };

            TerrainROAM.fnSortSection = function (pSectionA, pSectionB) {
                if (akra.isNull(pSectionA)) {
                    return 1;
                } else if (akra.isNull(pSectionB)) {
                    return -1;
                } else {
                    return pSectionA.getQueueSortValue() - pSectionB.getQueueSortValue();
                }
            };
            return TerrainROAM;
        })(terrain.Terrain);
        terrain.TerrainROAM = TerrainROAM;
    })(akra.terrain || (akra.terrain = {}));
    var terrain = akra.terrain;
})(akra || (akra = {}));
/// <reference path="../../geometry/Plane3d.ts" />
/// <reference path="../../geometry/Frustum.ts" />
/// <reference path="../../math/Vec3.ts" />
var akra;
(function (akra) {
    (function (scene) {
        (function (light) {
            var Vec3 = akra.math.Vec3;

            function calculatePlanesForFrustumLighting(pLightFrustum, v3fLightPosition, pCameraFrustum, pResultArray) {
                var pFrustumPlanesKeys = akra.geometry.Frustum.frustumPlanesKeys;

                var v3fNormal = Vec3.temp();
                var fDistance;

                var pPlanePoints = [Vec3.temp(), Vec3.temp(), Vec3.temp(), Vec3.temp()];

                var v3fTmp = Vec3.temp();
                var fThreshold = 0.1;

                for (var i = 0; i < 6; i++) {
                    var sKey = pFrustumPlanesKeys[i];
                    var pPlane = pCameraFrustum[sKey];

                    v3fNormal.set(pPlane.normal);
                    fDistance = pPlane.distance;

                    if (pPlane.signedDistance(v3fLightPosition) > 0) {
                        //extract four plane points (frustum verticies)
                        pCameraFrustum.getPlanePoints(sKey, pPlanePoints);

                        //we need find two farest points from v3fLightPosition;
                        var fLength0 = pPlanePoints[0].subtract(v3fLightPosition, v3fTmp).lengthSquare();
                        var fLength1 = pPlanePoints[1].subtract(v3fLightPosition, v3fTmp).lengthSquare();
                        var fLength2 = pPlanePoints[2].subtract(v3fLightPosition, v3fTmp).lengthSquare();
                        var fLength3 = pPlanePoints[3].subtract(v3fLightPosition, v3fTmp).lengthSquare();

                        var pIndexes;

                        if (fLength0 > fLength1 && fLength0 > fLength2 && fLength0 > fLength3) {
                            if (fLength1 > fLength2 && fLength1 > fLength3)
                                pIndexes = [0, 1, 2, 3];
                            else if (fLength2 > fLength1 && fLength2 > fLength3)
                                pIndexes = [0, 2, 1, 3];
                            else
                                pIndexes = [0, 3, 1, 2];
                        } else if (fLength1 > fLength0 && fLength1 > fLength2 && fLength1 > fLength3) {
                            if (fLength0 > fLength2 && fLength0 > fLength3)
                                pIndexes = [1, 0, 2, 3];
                            else if (fLength2 > fLength0 && fLength2 > fLength3)
                                pIndexes = [1, 2, 0, 3];
                            else
                                pIndexes = [1, 3, 0, 2];
                        } else if (fLength2 > fLength0 && fLength2 > fLength1 && fLength2 > fLength3) {
                            if (fLength0 > fLength1 && fLength0 > fLength3)
                                pIndexes = [2, 0, 1, 3];
                            else if (fLength1 > fLength0 && fLength1 > fLength3)
                                pIndexes = [2, 1, 0, 3];
                            else
                                pIndexes = [2, 3, 0, 1];
                        } else {
                            if (fLength0 > fLength1 && fLength0 > fLength2)
                                pIndexes = [3, 0, 1, 2];
                            else if (fLength1 > fLength0 && fLength1 > fLength2)
                                pIndexes = [3, 1, 0, 2];
                            else
                                pIndexes = [3, 2, 0, 1];
                        }

                        var pTestPlane = pResultArray[i];
                        pTestPlane.set(v3fLightPosition, pPlanePoints[pIndexes[0]], pPlanePoints[pIndexes[1]]);

                        //test with two remaining points
                        fLength1 = pTestPlane.signedDistance(pPlanePoints[pIndexes[2]]);
                        fLength2 = pTestPlane.signedDistance(pPlanePoints[pIndexes[3]]);

                        if (akra.math.abs(fLength1) <= fThreshold || akra.math.abs(fLength2) <= fThreshold) {
                            pTestPlane.set(pPlane.normal, -pPlane.normal.dot(v3fLightPosition));
                        } else if (fLength1 > 0 && fLength2 > 0) {
                            pTestPlane.negate();
                        }
                    } else {
                        pResultArray[i].set(v3fNormal, fDistance);
                    }
                }
                return 6;
            }
            light.calculatePlanesForFrustumLighting = calculatePlanesForFrustumLighting;

            function calculatePlanesForOrthogonalLighting(pLightFrustum, v3fLightPosition, pCameraFrustum, pResultArray) {
                //orthogonal projection
                //defining light sight direction;
                var pFrustumPlanesKeys = akra.geometry.Frustum.frustumPlanesKeys;

                var v3fLightDirection = pLightFrustum.getViewDirection(Vec3.temp());
                var fThreshold = 0.1;

                var pPlanePoints = [Vec3.temp(), Vec3.temp(), Vec3.temp(), Vec3.temp()];

                var v3fTmp = Vec3.temp();

                var nAdditionalTestLength = 0;

                for (var i = 0; i < 6; i++) {
                    var sKey = pFrustumPlanesKeys[i];
                    var pPlane = pCameraFrustum[sKey];

                    if (v3fLightDirection.dot(pPlane.normal) >= 0.) {
                        //adding plane
                        pResultArray[nAdditionalTestLength].set(pPlane);
                        nAdditionalTestLength++;
                    } else {
                        pCameraFrustum.getPlanePoints(sKey, pPlanePoints);

                        //we need find two farest points from v3fLightPosition;
                        var fLength0 = pPlanePoints[0].subtract(v3fLightPosition, v3fTmp).lengthSquare();
                        var fLength1 = pPlanePoints[1].subtract(v3fLightPosition, v3fTmp).lengthSquare();
                        var fLength2 = pPlanePoints[2].subtract(v3fLightPosition, v3fTmp).lengthSquare();
                        var fLength3 = pPlanePoints[3].subtract(v3fLightPosition, v3fTmp).lengthSquare();

                        var pIndexes;

                        if (fLength0 > fLength1 && fLength0 > fLength2 && fLength0 > fLength3) {
                            if (fLength1 > fLength2 && fLength1 > fLength3)
                                pIndexes = [0, 1, 2, 3];
                            else if (fLength2 > fLength1 && fLength2 > fLength3)
                                pIndexes = [0, 2, 1, 3];
                            else
                                pIndexes = [0, 3, 1, 2];
                        } else if (fLength1 > fLength0 && fLength1 > fLength2 && fLength1 > fLength3) {
                            if (fLength0 > fLength2 && fLength0 > fLength3)
                                pIndexes = [1, 0, 2, 3];
                            else if (fLength2 > fLength0 && fLength2 > fLength3)
                                pIndexes = [1, 2, 0, 3];
                            else
                                pIndexes = [1, 3, 0, 2];
                        } else if (fLength2 > fLength0 && fLength2 > fLength1 && fLength2 > fLength3) {
                            if (fLength0 > fLength1 && fLength0 > fLength3)
                                pIndexes = [2, 0, 1, 3];
                            else if (fLength1 > fLength0 && fLength1 > fLength3)
                                pIndexes = [2, 1, 0, 3];
                            else
                                pIndexes = [2, 3, 0, 1];
                        } else {
                            if (fLength0 > fLength1 && fLength0 > fLength2)
                                pIndexes = [3, 0, 1, 2];
                            else if (fLength1 > fLength0 && fLength1 > fLength2)
                                pIndexes = [3, 1, 0, 2];
                            else
                                pIndexes = [3, 2, 0, 1];
                        }

                        var pPoint1 = pPlanePoints[pIndexes[0]];
                        var pPoint2 = pPlanePoints[pIndexes[1]];

                        var v3fDir = pPoint2.subtract(pPoint1, v3fTmp);

                        var v3fNormal = v3fDir.cross(v3fLightDirection).normalize();

                        var pTestPlane = pResultArray[nAdditionalTestLength];
                        pTestPlane.set(v3fNormal, -v3fNormal.dot(pPoint1));

                        var pVertices = pCameraFrustum.getFrustumVertices();

                        //test on right orientation new plane (two point already on plane)
                        var iTest = 0;
                        for (var k = 0; k < 8; k++) {
                            if (pTestPlane.signedDistance(pVertices[k]) > fThreshold) {
                                iTest++;
                            }
                        }

                        if (iTest == 6) {
                            pTestPlane.negate();
                        } else if (iTest != 0) {
                            continue;
                        }

                        nAdditionalTestLength++;
                    }
                }

                return nAdditionalTestLength;
            }
            light.calculatePlanesForOrthogonalLighting = calculatePlanesForOrthogonalLighting;
        })(scene.light || (scene.light = {}));
        var light = scene.light;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
/// <reference path="../../idl/IShadowCaster.ts" />
/// <reference path="../objects/Camera.ts" />
/// <reference path="../../util/ObjectArray.ts" />
/// <reference path="../../math/Mat4.ts" />
/// <reference path="../../geometry/Rect3d.ts" />
var akra;
(function (akra) {
    (function (scene) {
        (function (light) {
            var Mat4 = akra.math.Mat4;

            var Vec2 = akra.math.Vec2;
            var Vec3 = akra.math.Vec3;
            var Vec4 = akra.math.Vec4;

            var __11 = akra.math.__11;
            var __12 = akra.math.__12;
            var __13 = akra.math.__13;
            var __14 = akra.math.__14;
            var __21 = akra.math.__21;
            var __22 = akra.math.__22;
            var __23 = akra.math.__23;
            var __24 = akra.math.__24;
            var __31 = akra.math.__31;
            var __32 = akra.math.__32;
            var __33 = akra.math.__33;
            var __34 = akra.math.__34;
            var __41 = akra.math.__41;
            var __42 = akra.math.__42;
            var __43 = akra.math.__43;
            var __44 = akra.math.__44;

            var ShadowCaster = (function (_super) {
                __extends(ShadowCaster, _super);
                function ShadowCaster(pLightPoint, iFace) {
                    if (typeof iFace === "undefined") { iFace = 0 /* POSITIVE_X */; }
                    _super.call(this, pLightPoint.getScene(), 5 /* SHADOW_CASTER */);
                    this._pLightPoint = null;
                    this._iFace = 0;
                    this._pAffectedObjects = new akra.util.ObjectArray();
                    this._m4fOptimizedProj = new Mat4();
                    this._isShadowCasted = false;

                    this._pLightPoint = pLightPoint;
                    this._iFace = iFace;
                }
                ShadowCaster.prototype.getLightPoint = function () {
                    return this._pLightPoint;
                };

                ShadowCaster.prototype.getFace = function () {
                    return this._iFace;
                };

                ShadowCaster.prototype.getAffectedObjects = function () {
                    return this._pAffectedObjects;
                };

                ShadowCaster.prototype.getOptimizedProjection = function () {
                    return this._m4fOptimizedProj;
                };

                ShadowCaster.prototype.isShadowCasted = function () {
                    return this._isShadowCasted;
                };

                ShadowCaster.prototype.setShadowCasted = function (isShadowCasted) {
                    this._isShadowCasted = isShadowCasted;
                };

                ShadowCaster.prototype._optimizeProjectionMatrix = function (pEffectiveCameraFrustum) {
                    if (this._pAffectedObjects.getLength() === 0) {
                        this._m4fOptimizedProj.set(this.getProjectionMatrix());
                        return;
                    }

                    var m4fView = this.getViewMatrix();
                    var m4fProj = this.getProjectionMatrix();
                    var m4fProjData = m4fProj.data;

                    var pBox = akra.geometry.Rect3d.temp();

                    var pAffectedObjects = this._pAffectedObjects;

                    var fX0, fX1, fY0, fY1, fZ0, fZ1;
                    var fX, fY, fZ, fW;

                    var fX_Left, fY_Bottom;
                    var fX_Right, fY_Top;
                    var fZ_Near, fZ_Far;

                    //первый бокс должен быть, либо построен по первому элементу, что приводит к усложнению функции
                    //либо записан таким образом (то есть минимально (максимально) возможные значения), тогда можно просто все делать в цикле
                    var fXRes_Left = 1., fXRes_Right = -1, fYRes_Bottom = 1, fYRes_Top = -1, fZRes_Near = 1, fZRes_Far = -1;

                    var fTmp;

                    for (var i = 0; i < pAffectedObjects.getLength(); i++) {
                        var pObject = pAffectedObjects.value(i);

                        if (!pObject.getShadow()) {
                            continue;
                        }

                        pBox.set(pObject.getWorldBounds());
                        pBox.transform(m4fView);

                        fX0 = pBox.x0;
                        fX1 = pBox.x1;
                        fY0 = pBox.y0;
                        fY1 = pBox.y1;
                        fZ0 = pBox.z0;
                        fZ1 = pBox.z1;

                        //z - отрицательное => ближняя к камере грань fZ1, а fZ0 - дальняя
                        //left bottom near
                        fX = m4fProjData[__11] * fX0 + m4fProjData[__12] * fY0 + m4fProjData[__13] * fZ1 + m4fProjData[__14];
                        fY = m4fProjData[__21] * fX0 + m4fProjData[__22] * fY0 + m4fProjData[__23] * fZ1 + m4fProjData[__24];
                        fZ = m4fProjData[__31] * fX0 + m4fProjData[__32] * fY0 + m4fProjData[__33] * fZ1 + m4fProjData[__34];
                        fW = m4fProjData[__41] * fX0 + m4fProjData[__42] * fY0 + m4fProjData[__43] * fZ1 + m4fProjData[__44];

                        if (fW <= 0) {
                            //обходим особые случаи
                            fX = -1;
                            fY = -1;
                            fZ = -1;
                            fW = 1;
                        }

                        fX_Left = fX / fW;
                        fY_Bottom = fY / fW;

                        ////////////////////////////////
                        //z near
                        fZ_Near = fZ / fW;

                        ////////////////////////////////
                        //left bottom far
                        fX = m4fProjData[__11] * fX0 + m4fProjData[__12] * fY0 + m4fProjData[__13] * fZ0 + m4fProjData[__14];
                        fY = m4fProjData[__21] * fX0 + m4fProjData[__22] * fY0 + m4fProjData[__23] * fZ0 + m4fProjData[__24];
                        fZ = m4fProjData[__31] * fX0 + m4fProjData[__32] * fY0 + m4fProjData[__33] * fZ0 + m4fProjData[__34];
                        fW = m4fProjData[__41] * fX0 + m4fProjData[__42] * fY0 + m4fProjData[__43] * fZ0 + m4fProjData[__44];

                        //в этой части особенностей нет, так как w всегда больше нуля, иначе объект будет вне frustum-а
                        fTmp = fX / fW;
                        fX_Left = (fTmp < fX_Left) ? fTmp : fX_Left;

                        fTmp = fY / fW;
                        fY_Bottom = (fTmp < fY_Bottom) ? fTmp : fY_Bottom;

                        ////////////////////////////////
                        //z far
                        fZ_Far = fZ / fW;

                        ////////////////////////////////
                        //right top near
                        fX = m4fProjData[__11] * fX1 + m4fProjData[__12] * fY1 + m4fProjData[__13] * fZ1 + m4fProjData[__14];
                        fY = m4fProjData[__21] * fX1 + m4fProjData[__22] * fY1 + m4fProjData[__23] * fZ1 + m4fProjData[__24];
                        fW = m4fProjData[__41] * fX1 + m4fProjData[__42] * fY1 + m4fProjData[__43] * fZ1 + m4fProjData[__44];

                        if (fW <= 0) {
                            //обходим особые случаи
                            fX = 1;
                            fY = 1;
                            fW = 1;
                        }

                        fX_Right = fX / fW;
                        fY_Top = fY / fW;

                        //right top far
                        fX = m4fProjData[__11] * fX1 + m4fProjData[__12] * fY1 + m4fProjData[__13] * fZ0 + m4fProjData[__14];
                        fY = m4fProjData[__21] * fX1 + m4fProjData[__22] * fY1 + m4fProjData[__23] * fZ0 + m4fProjData[__24];
                        fW = m4fProjData[__41] * fX1 + m4fProjData[__42] * fY1 + m4fProjData[__43] * fZ0 + m4fProjData[__44];

                        //в этой части особенностей нет, так как w всегда больше нуля, иначе объект будет вне frustum-а
                        fTmp = fX / fW;
                        fX_Right = (fTmp > fX_Right) ? fTmp : fX_Right;

                        fTmp = fY / fW;
                        fY_Top = (fTmp > fY_Top) ? fTmp : fY_Top;

                        ////////////////////////////////
                        fXRes_Left = (fX_Left < fXRes_Left) ? fX_Left : fXRes_Left;
                        fXRes_Right = (fX_Right > fXRes_Right) ? fX_Right : fXRes_Right;

                        fYRes_Bottom = (fY_Bottom < fYRes_Bottom) ? fY_Bottom : fYRes_Bottom;
                        fYRes_Top = (fY_Top > fYRes_Top) ? fY_Top : fYRes_Top;

                        fZRes_Near = (fZ_Near < fZRes_Near) ? fZ_Near : fZRes_Near;
                        fZRes_Far = (fZ_Far > fZRes_Far) ? fZ_Far : fZRes_Far;
                    }

                    //test with camera frustum
                    var pCameraBox = this._getBoxForCameraFrustum(pEffectiveCameraFrustum, new akra.geometry.Rect2d());

                    var fCameraMinX = -1.;
                    var fCameraMaxX = 1;

                    var fCameraMinY = -1;
                    var fCameraMaxY = 1;

                    fXRes_Left = akra.math.max((fXRes_Left < -1 || fXRes_Left == 1) ? -1 : fXRes_Left, fCameraMinX);
                    fXRes_Right = akra.math.min((fXRes_Right > 1 || fXRes_Right == -1) ? 1 : fXRes_Right, fCameraMaxX);

                    fYRes_Bottom = akra.math.max((fYRes_Bottom < -1 || fYRes_Bottom == 1) ? -1 : fYRes_Bottom, fCameraMinY);
                    fYRes_Top = akra.math.min((fYRes_Top > 1 || fYRes_Top == -1) ? 1 : fYRes_Top, fCameraMaxY);

                    fZRes_Near = (fZRes_Near < -1 || fZRes_Near == 1) ? -1 : fZRes_Near;
                    fZRes_Far = (fZRes_Far > 1 || fZRes_Far == -1) ? 1 : fZRes_Far;

                    //optimized parameters
                    var v4fTmp1 = m4fProj.unproj(Vec3.temp(fXRes_Left, fYRes_Bottom, fZRes_Near), Vec4.temp());
                    var v4fTmp2 = m4fProj.unproj(Vec3.temp(fXRes_Right, fYRes_Top, fZRes_Near), Vec4.temp());

                    //////////////////////////
                    fX_Left = v4fTmp1.x;
                    fX_Right = v4fTmp2.x;
                    fY_Bottom = v4fTmp1.y;
                    fY_Top = v4fTmp2.y;
                    fZ_Near = v4fTmp1.z;
                    fZ_Far = m4fProj.unprojZ(fZRes_Far);

                    if (m4fProj.isOrthogonalProjection()) {
                        //ortho-projection
                        Mat4.orthogonalProjectionAsymmetric(fX_Left, fX_Right, fY_Bottom, fY_Top, -fZ_Near, -fZ_Far, this._m4fOptimizedProj);
                    } else {
                        //frustum
                        Mat4.frustum(fX_Left, fX_Right, fY_Bottom, fY_Top, -fZ_Near, -fZ_Far, this._m4fOptimizedProj);
                    }
                };

                ShadowCaster.prototype._getBoxForCameraFrustum = function (pEffectiveCameraFrustum, pDestination) {
                    if (!akra.isDef(pDestination)) {
                        pDestination = new akra.geometry.Rect2d();
                    }
                    var m4fProjView = this.getProjViewMatrix();
                    var pFrusutumVertices = pEffectiveCameraFrustum.getFrustumVertices();

                    var v4fTmp = Vec4.temp();
                    var v2fTmp = Vec2.temp();

                    for (var i = 0; i < 8; i++) {
                        v4fTmp.set(pFrusutumVertices[i], 1.);

                        m4fProjView.multiplyVec4(v4fTmp);

                        v2fTmp.set(v4fTmp.x, v4fTmp.y).scale(akra.math.abs(1. / v4fTmp.w));

                        if (i == 0) {
                            pDestination.set(v2fTmp, v2fTmp);
                        } else {
                            pDestination.unionPoint(v2fTmp);
                        }
                    }

                    return pDestination;
                };

                ShadowCaster.isShadowCaster = function (pEntity) {
                    return !akra.isNull(pEntity) && pEntity.getType() === 5 /* SHADOW_CASTER */;
                };
                return ShadowCaster;
            })(scene.objects.Camera);
            light.ShadowCaster = ShadowCaster;
        })(scene.light || (scene.light = {}));
        var light = scene.light;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
/// <reference path="../../idl/ITexture.ts" />
/// <reference path="../../idl/IFrustum.ts" />
/// <reference path="../../idl/IResourcePoolManager.ts" />
/// <reference path="../../idl/IRenderTarget.ts" />
/// <reference path="../../util/ObjectArray.ts" />
/// <reference path="../../geometry/Plane3d.ts" />
/// <reference path="../../geometry/classify/classify.ts" />
var akra;
(function (akra) {
    (function (scene) {
        /// <reference path="CalculatePlanesForLighting.ts" />
        /// <reference path="ShadowCaster.ts" />
        (function (light) {
            var Color = akra.color.Color;
            var Vec3 = akra.math.Vec3;
            var Mat4 = akra.math.Mat4;

            var ProjectParameters = (function () {
                function ProjectParameters() {
                    this.ambient = new Color;
                    this.diffuse = new Color;
                    this.specular = new Color;
                    this.attenuation = new Vec3;
                }
                return ProjectParameters;
            })();
            light.ProjectParameters = ProjectParameters;

            var ProjectLight = (function (_super) {
                __extends(ProjectLight, _super);
                function ProjectLight(pScene) {
                    _super.call(this, pScene, 1 /* PROJECT */);
                    this._pDepthTexture = null;
                    this._pColorTexture = null;
                    this._pLightParameters = new ProjectParameters;
                    this._pShadowCaster = pScene._createShadowCaster(this);
                }
                ProjectLight.prototype.getParams = function () {
                    return this._pLightParameters;
                };

                ProjectLight.prototype.isShadowCaster = function () {
                    return this._isShadowCaster;
                };

                /**
                * overridden setter isShadow caster,
                * if depth texture don't created then create depth texture
                */
                ProjectLight.prototype.setShadowCaster = function (bValue) {
                    this._isShadowCaster = bValue;
                    if (bValue && akra.isNull(this._pDepthTexture)) {
                        this.initializeTextures();
                    }
                };

                ProjectLight.prototype.getLightingDistance = function () {
                    return this._pShadowCaster.getFarPlane();
                };

                ProjectLight.prototype.setLightingDistance = function (fDistance) {
                    this._pShadowCaster.setFarPlane(fDistance);
                };

                ProjectLight.prototype.getShadowCaster = function () {
                    return this._pShadowCaster;
                };

                ProjectLight.prototype.getDepthTexture = function () {
                    return this._pDepthTexture;
                };

                ProjectLight.prototype.getRenderTarget = function () {
                    return this._pColorTexture.getBuffer().getRenderTarget();
                };

                ProjectLight.prototype.create = function (isShadowCaster, iMaxShadowResolution) {
                    if (typeof isShadowCaster === "undefined") { isShadowCaster = true; }
                    if (typeof iMaxShadowResolution === "undefined") { iMaxShadowResolution = 256; }
                    var isOk = _super.prototype.create.call(this, isShadowCaster, iMaxShadowResolution);

                    var pCaster = this._pShadowCaster;

                    pCaster.setParameter(1 /* CONST_ASPECT */, true);
                    pCaster.setInheritance(4 /* ALL */);
                    pCaster.attachToParent(this);

                    if (this.isShadowCaster()) {
                        this.initializeTextures();
                    }

                    return isOk;
                };

                ProjectLight.prototype.initializeTextures = function () {
                    var pEngine = this.getScene().getManager().getEngine();
                    var pResMgr = pEngine.getResourceManager();
                    var iSize = this._iMaxShadowResolution;

                    var pDepthTexture = this._pDepthTexture = pResMgr.createTexture("depth_texture_" + this.guid);
                    pDepthTexture.create(iSize, iSize, 1, null, 0, 0, 0, 3553 /* TEXTURE_2D */, 46 /* DEPTH32 */);

                    pDepthTexture.setWrapMode(10242 /* WRAP_S */, 33071 /* CLAMP_TO_EDGE */);
                    pDepthTexture.setWrapMode(10243 /* WRAP_T */, 33071 /* CLAMP_TO_EDGE */);
                    pDepthTexture.setFilter(10240 /* MAG_FILTER */, 9729 /* LINEAR */);
                    pDepthTexture.setFilter(10241 /* MIN_FILTER */, 9729 /* LINEAR */);

                    var eColorFormat = 8 /* A4R4G4B4 */;

                    var pColorTexture = pResMgr.createTexture("light_color_texture_" + this.guid);
                    pColorTexture.create(iSize, iSize, 1, null, 512 /* RENDERTARGET */, 0, 0, 3553 /* TEXTURE_2D */, eColorFormat);

                    this._pColorTexture = pColorTexture;

                    //TODO: Multiple render target
                    this.getRenderTarget().attachDepthTexture(pDepthTexture);
                    this.getRenderTarget().setAutoUpdated(false);
                    this.getRenderTarget().addViewport(new akra.render.ShadowViewport(this._pShadowCaster));
                };

                ProjectLight.prototype._calculateShadows = function () {
                    if (this.isEnabled() && this.isShadowCaster()) {
                        this.getRenderTarget().update();
                    }
                };

                ProjectLight.prototype._prepareForLighting = function (pCamera) {
                    if (!this.isEnabled()) {
                        return false;
                    } else {
                        /*************************************************************/
                        //optimize camera frustum
                        var pDepthRange = pCamera.getDepthRange();

                        var fFov = pCamera.getFOV();
                        var fAspect = pCamera.getAspect();

                        var m4fTmp = Mat4.perspective(fFov, fAspect, -pDepthRange.min, -pDepthRange.max, Mat4.temp());

                        this.getOptimizedCameraFrustum().extractFromMatrix(m4fTmp, pCamera.getWorldMatrix());

                        /*************************************************************/
                        if (!this.isShadowCaster()) {
                            var pResult = this._defineLightingInfluence(pCamera);
                            return (pResult.getLength() === 0) ? false : true;
                        } else {
                            var pResult = this._defineShadowInfluence(pCamera);
                            return (pResult.getLength() === 0) ? false : true;
                        }
                    }
                };

                ProjectLight.prototype._defineLightingInfluence = function (pCamera) {
                    var pShadowCaster = this._pShadowCaster;
                    var pCameraFrustum = this.getOptimizedCameraFrustum();

                    var pResult = pShadowCaster.getAffectedObjects();
                    pResult.clear();

                    //fast test on frustum intersection
                    if (!pCameraFrustum.testFrustum(pShadowCaster.getFrustum())) {
                        //frustums don't intersecting
                        return pResult;
                    }

                    var pRawResult = pShadowCaster.display(scene.Scene3d.DL_DEFAULT);

                    for (var i = 0; i < pRawResult.getLength(); i++) {
                        var pObject = pRawResult.value(i);

                        if (pCameraFrustum.testRect(pObject.getWorldBounds())) {
                            pResult.push(pObject);
                        }
                    }

                    return pResult;
                };

                ProjectLight.prototype._defineShadowInfluence = function (pCamera) {
                    var pShadowCaster = this._pShadowCaster;
                    var pCameraFrustum = this.getOptimizedCameraFrustum();

                    var pResult = pShadowCaster.getAffectedObjects();
                    pResult.clear();

                    //fast test on frustum intersection
                    if (!pCameraFrustum.testFrustum(pShadowCaster.getFrustum())) {
                        //frustums don't intersecting
                        pShadowCaster._optimizeProjectionMatrix(pCameraFrustum);
                        return pResult;
                    }

                    var pRawResult = pShadowCaster.display(scene.Scene3d.DL_DEFAULT);

                    var pTestArray = ProjectLight._pFrustumPlanes;
                    var nAdditionalTestLength = 0;

                    if (pShadowCaster.getProjectionMatrix().isOrthogonalProjection()) {
                        nAdditionalTestLength = light.calculatePlanesForOrthogonalLighting(pShadowCaster.getFrustum(), pShadowCaster.getWorldPosition(), pCameraFrustum, pTestArray);
                    } else {
                        nAdditionalTestLength = light.calculatePlanesForFrustumLighting(pShadowCaster.getFrustum(), pShadowCaster.getWorldPosition(), pCameraFrustum, pTestArray);
                    }

                    var v3fMidPoint = Vec3.temp();
                    var v3fShadowDir = Vec3.temp();
                    var v3fCameraDir = Vec3.temp();

                    for (var i = 0; i < pRawResult.getLength(); i++) {
                        var pObject = pRawResult.value(i);
                        var pWorldBounds = pObject.getWorldBounds();

                        //have object shadows?
                        if (pObject.getShadow()) {
                            var j = 0;
                            for (j = 0; j < nAdditionalTestLength; j++) {
                                var pPlane = pTestArray[j];

                                if (akra.geometry.classify.planeRect3d(pPlane, pWorldBounds) == 0 /* PLANE_FRONT */) {
                                    break;
                                }
                            }
                            if (j == nAdditionalTestLength) {
                                //discard shadow by distance?
                                pWorldBounds.midPoint(v3fMidPoint);

                                v3fMidPoint.subtract(pShadowCaster.getWorldPosition(), v3fShadowDir);
                                v3fMidPoint.subtract(pCamera.getWorldPosition(), v3fCameraDir);

                                if (v3fCameraDir.dot(v3fShadowDir) > 0 && pWorldBounds.distanceToPoint(pCamera.getWorldPosition()) >= akra.config.render.shadows.discardDistance) {
                                } else {
                                    pResult.push(pObject);
                                }
                            }
                        } else {
                            if (pCameraFrustum.testRect(pWorldBounds)) {
                                pResult.push(pObject);
                            }
                        }
                    }

                    pShadowCaster._optimizeProjectionMatrix(pCameraFrustum);

                    return pResult;
                };

                ProjectLight._pFrustumPlanes = new Array(6);
                return ProjectLight;
            })(light.LightPoint);
            light.ProjectLight = ProjectLight;

            for (var i = 0; i < 6; i++) {
                ProjectLight._pFrustumPlanes[i] = new akra.geometry.Plane3d();
            }
        })(scene.light || (scene.light = {}));
        var light = scene.light;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
/// <reference path="../../idl/ITexture.ts" />
/// <reference path="../../util/ObjectArray.ts" />
/// <reference path="../../geometry/Plane3d.ts" />
/// <reference path="../../geometry/classify/classify.ts" />
/// <reference path="ShadowCaster.ts" />
/// <reference path="CalculatePlanesForLighting.ts" />
var akra;
(function (akra) {
    (function (scene) {
        (function (light) {
            var Color = akra.color.Color;

            var Vec3 = akra.math.Vec3;
            var Mat4 = akra.math.Mat4;

            var OmniParameters = (function () {
                function OmniParameters() {
                    this.ambient = new Color;
                    this.diffuse = new Color;
                    this.specular = new Color;
                    this.attenuation = new Vec3;
                }
                return OmniParameters;
            })();
            light.OmniParameters = OmniParameters;

            var OmniLight = (function (_super) {
                __extends(OmniLight, _super);
                function OmniLight(pScene) {
                    _super.call(this, pScene, 2 /* OMNI */);
                    this._pDepthTextureCube = null;
                    this._pColorTextureCube = null;
                    this._pLightParameters = new OmniParameters;
                    this._pShadowCasterCube = null;

                    this._pShadowCasterCube = new Array(6);

                    for (var i = 0; i < 6; i++) {
                        this._pShadowCasterCube[i] = pScene._createShadowCaster(this, i);
                    }
                }
                OmniLight.prototype.getParams = function () {
                    return this._pLightParameters;
                };

                OmniLight.prototype.isShadowCaster = function () {
                    return this._isShadowCaster;
                };

                /**
                * overridden setter isShadow caster,
                * if depth textures don't created then create depth textures
                */
                OmniLight.prototype.setShadowCaster = function (bValue) {
                    this._isShadowCaster = bValue;
                    if (bValue && akra.isNull(this._pDepthTextureCube)) {
                        this.initializeTextures();
                    }
                };

                OmniLight.prototype.getLightingDistance = function () {
                    return this._pShadowCasterCube[0].getFarPlane();
                };

                OmniLight.prototype.setLightingDistance = function (fDistance) {
                    var pCube = this._pShadowCasterCube;
                    for (var i = 0; i < 6; i++) {
                        pCube[i].setFarPlane(fDistance);
                    }
                };

                OmniLight.prototype.getDepthTextureCube = function () {
                    return this._pDepthTextureCube;
                };

                OmniLight.prototype.getRenderTarget = function (iFace) {
                    // return this._pDepthTextureCube[iFace].getBuffer().getRenderTarget();
                    return this._pColorTextureCube[iFace].getBuffer().getRenderTarget();
                };

                OmniLight.prototype.getShadowCaster = function () {
                    return this._pShadowCasterCube;
                };

                OmniLight.prototype.create = function (isShadowCaster, iMaxShadowResolution) {
                    if (typeof isShadowCaster === "undefined") { isShadowCaster = true; }
                    if (typeof iMaxShadowResolution === "undefined") { iMaxShadowResolution = 256; }
                    var isOk = _super.prototype.create.call(this, isShadowCaster, iMaxShadowResolution);

                    var pCasterCube = this._pShadowCasterCube;
                    var pCaster;

                    for (var i = 0; i < 6; i++) {
                        pCaster = pCasterCube[i];
                        pCaster.setInheritance(4 /* ALL */);
                        pCaster.attachToParent(this);
                        pCaster.setProjParams(akra.math.PI / 2, 1, 0.01, 1000);
                        pCaster.setParameter(1 /* CONST_ASPECT */, true);
                    }

                    //POSITIVE_X
                    pCasterCube[0].setLocalMatrix(Mat4.temp([
                        0, 0, 1, 0,
                        0, 1, 0, 0,
                        -1, 0, 0, 0,
                        0, 0, 0, 1
                    ]));

                    //NEGATIVE_X
                    pCasterCube[1].setLocalMatrix(Mat4.temp([
                        0, 0, -1, 0,
                        0, 1, 0, 0,
                        1, 0, 0, 0,
                        0, 0, 0, 1
                    ]));

                    //POSITIVE_Y
                    pCasterCube[2].setLocalMatrix(Mat4.temp([
                        1, 0, 0, 0,
                        0, 0, 1, 0,
                        0, -1, 0, 0,
                        0, 0, 0, 1
                    ]));

                    //NEGATIVE_Y
                    pCasterCube[3].setLocalMatrix(Mat4.temp([
                        1, 0, 0, 0,
                        0, 0, -1, 0,
                        0, 1, 0, 0,
                        0, 0, 0, 1
                    ]));

                    //POSITIVE_Z
                    pCasterCube[4].setLocalMatrix(Mat4.temp([
                        -1, 0, 0, 0,
                        0, 1, 0, 0,
                        0, 0, -1, 0,
                        0, 0, 0, 1
                    ]));

                    //NEGATIVE_Z
                    pCasterCube[5].setLocalMatrix(Mat4.temp([
                        1, 0, 0, 0,
                        0, 1, 0, 0,
                        0, 0, 1, 0,
                        0, 0, 0, 1
                    ]));

                    if (this.isShadowCaster()) {
                        this.initializeTextures();
                    }

                    return isOk;
                };

                OmniLight.prototype.initializeTextures = function () {
                    var pEngine = this.getScene().getManager().getEngine();
                    var pResMgr = pEngine.getResourceManager();
                    var iSize = this._iMaxShadowResolution;

                    this._pDepthTextureCube = new Array(6);
                    this._pColorTextureCube = new Array(6);

                    for (var i = 0; i < 6; ++i) {
                        // if (this._pDepthTextureCube[i]) {
                        // 	this._pDepthTextureCube[i].destroyResource();
                        // }
                        var pDepthTexture = this._pDepthTextureCube[i] = pResMgr.createTexture("depth_texture_" + i + "_" + this.guid);
                        pDepthTexture.create(iSize, iSize, 1, null, 0, 0, 0, 3553 /* TEXTURE_2D */, 46 /* DEPTH32 */);

                        pDepthTexture.setWrapMode(10242 /* WRAP_S */, 33071 /* CLAMP_TO_EDGE */);
                        pDepthTexture.setWrapMode(10243 /* WRAP_T */, 33071 /* CLAMP_TO_EDGE */);
                        pDepthTexture.setFilter(10240 /* MAG_FILTER */, 9729 /* LINEAR */);
                        pDepthTexture.setFilter(10241 /* MIN_FILTER */, 9729 /* LINEAR */);

                        var eColorFormat = 8 /* A4R4G4B4 */;

                        var pColorTexture = this._pColorTextureCube[i] = pResMgr.createTexture("light_color_texture_" + i + "_" + this.guid);
                        pColorTexture.create(iSize, iSize, 1, null, 512 /* RENDERTARGET */, 0, 0, 3553 /* TEXTURE_2D */, eColorFormat);

                        //TODO: Multiple render target
                        this.getRenderTarget(i).attachDepthTexture(pDepthTexture);
                        this.getRenderTarget(i).setAutoUpdated(false);
                        this.getRenderTarget(i).addViewport(new akra.render.ShadowViewport(this._pShadowCasterCube[i]));
                    }
                };

                OmniLight.prototype._calculateShadows = function () {
                    if (this.isEnabled() && this.isShadowCaster()) {
                        for (var i = 0; i < 6; i++) {
                            this.getRenderTarget(i).update();
                        }
                    }
                };

                OmniLight.prototype._prepareForLighting = function (pCamera) {
                    if (!this.isEnabled()) {
                        return false;
                    } else {
                        /*************************************************************/
                        //optimize camera frustum
                        var pDepthRange = pCamera.getDepthRange();

                        var fFov = pCamera.getFOV();
                        var fAspect = pCamera.getAspect();

                        var m4fTmp = Mat4.perspective(fFov, fAspect, -pDepthRange.min, -pDepthRange.max, Mat4.temp());

                        this.getOptimizedCameraFrustum().extractFromMatrix(m4fTmp, pCamera.getWorldMatrix());

                        /*************************************************************/
                        var haveInfluence = false;
                        if (!this.isShadowCaster()) {
                            for (var i = 0; i < 6; i++) {
                                var pResult = this._defineLightingInfluence(pCamera, i);
                                if (pResult.getLength() !== 0) {
                                    haveInfluence = true;
                                }
                            }
                            return haveInfluence;
                        } else {
                            for (var i = 0; i < 6; i++) {
                                var pResult = this._defineShadowInfluence(pCamera, i);
                                if (pResult.getLength() !== 0) {
                                    haveInfluence = true;
                                }
                            }
                            return haveInfluence;
                        }
                    }
                };

                OmniLight.prototype._defineLightingInfluence = function (pCamera, iFace) {
                    var pShadowCaster = this._pShadowCasterCube[iFace];
                    var pCameraFrustum = this.getOptimizedCameraFrustum();

                    // var pCameraFrustum: IFrustum = pCamera.frustum;
                    var pResult = pShadowCaster.getAffectedObjects();
                    pResult.clear();

                    //fast test on frustum intersection
                    if (!pCameraFrustum.testFrustum(pShadowCaster.getFrustum())) {
                        //frustums don't intersecting
                        return pResult;
                    }

                    var pRawResult = pShadowCaster.display(scene.Scene3d.DL_DEFAULT);

                    for (var i = 0; i < pRawResult.getLength(); i++) {
                        var pObject = pRawResult.value(i);

                        if (pCameraFrustum.testRect(pObject.getWorldBounds())) {
                            pResult.push(pObject);
                        }
                    }

                    return pResult;
                };

                OmniLight.prototype._defineShadowInfluence = function (pCamera, iFace) {
                    var pShadowCaster = this._pShadowCasterCube[iFace];
                    var pCameraFrustum = this.getOptimizedCameraFrustum();

                    var pResult = pShadowCaster.getAffectedObjects();
                    pResult.clear();

                    //fast test on frustum intersection
                    if (!pCameraFrustum.testFrustum(pShadowCaster.getFrustum())) {
                        //frustums don't intersecting
                        pShadowCaster._optimizeProjectionMatrix(pCameraFrustum);
                        return pResult;
                    }

                    var pRawResult = pShadowCaster.display(scene.Scene3d.DL_DEFAULT);

                    var pTestArray = OmniLight._pFrustumPlanes;
                    var pFrustumPlanesKeys = akra.geometry.Frustum.frustumPlanesKeys;

                    light.calculatePlanesForFrustumLighting(pShadowCaster.getFrustum(), pShadowCaster.getWorldPosition(), pCameraFrustum, pTestArray);

                    var v3fMidPoint = Vec3.temp();
                    var v3fShadowDir = Vec3.temp();
                    var v3fCameraDir = Vec3.temp();

                    for (var i = 0; i < pRawResult.getLength(); i++) {
                        var pObject = pRawResult.value(i);
                        var pWorldBounds = pObject.getWorldBounds();

                        //have object shadows?
                        if (pObject.getShadow()) {
                            var j = 0;
                            for (j = 0; j < 6; j++) {
                                var pPlane = pTestArray[j];

                                if (akra.geometry.classify.planeRect3d(pPlane, pWorldBounds) == 0 /* PLANE_FRONT */) {
                                    break;
                                }
                            }

                            if (j == 6) {
                                //discard shadow by distance?
                                pWorldBounds.midPoint(v3fMidPoint);

                                v3fMidPoint.subtract(pShadowCaster.getWorldPosition(), v3fShadowDir);
                                v3fMidPoint.subtract(pCamera.getWorldPosition(), v3fCameraDir);

                                if (v3fCameraDir.dot(v3fShadowDir) > 0 && pWorldBounds.distanceToPoint(pCamera.getWorldPosition()) >= akra.config.render.shadows.discardDistance) {
                                } else {
                                    pResult.push(pObject);
                                }
                            }
                        } else {
                            if (pCameraFrustum.testRect(pWorldBounds)) {
                                pResult.push(pObject);
                            }
                        }
                    }

                    pShadowCaster._optimizeProjectionMatrix(pCameraFrustum);

                    return pResult;
                };

                OmniLight._pFrustumPlanes = new Array(6);
                return OmniLight;
            })(light.LightPoint);
            light.OmniLight = OmniLight;

            for (var i = 0; i < 6; i++) {
                OmniLight._pFrustumPlanes[i] = new akra.geometry.Plane3d();
            }
        })(scene.light || (scene.light = {}));
        var light = scene.light;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
/// <refeence path="../idl/ISunLight.ts" />
/// <refeence path="../idl/ITexture.ts" />
/// <refeence path="../idl/IResourcePoolManager.ts" />
/// <refeence path="../idl/IRenderTarget.ts" />
/// <refeence path="../util/ObjectArray.ts" />
var akra;
(function (akra) {
    (function (scene) {
        /// <refeence path="CalculatePlanesForLighting.ts" />
        (function (light) {
            var Vec3 = akra.math.Vec3;
            var Mat4 = akra.math.Mat4;

            var SunParameters = (function () {
                function SunParameters() {
                    this.eyePosition = new Vec3;
                    this.sunDir = new Vec3;
                    this.groundC0 = new Vec3;
                    this.groundC1 = new Vec3;
                    this.hg = new Vec3;
                }
                return SunParameters;
            })();
            light.SunParameters = SunParameters;

            var SunLight = (function (_super) {
                __extends(SunLight, _super);
                function SunLight(pScene) {
                    _super.call(this, pScene, 3 /* SUN */);
                    this._pLightParameters = new SunParameters;
                    this._pSkyDome = null;
                    this._pColorTexture = null;
                    this._pDepthTexture = null;
                    this._pShadowCaster = pScene._createShadowCaster(this);
                }
                SunLight.prototype.getParams = function () {
                    return this._pLightParameters;
                };

                SunLight.prototype.getSkyDome = function () {
                    return this._pSkyDome;
                };

                SunLight.prototype.setSkyDome = function (pSkyDome) {
                    this._pSkyDome = pSkyDome;
                };

                SunLight.prototype.getLightingDistance = function () {
                    return this._pShadowCaster.getFarPlane();
                };

                SunLight.prototype.setLightingDistance = function (fDistance) {
                    this._pShadowCaster.setFarPlane(fDistance);
                };

                SunLight.prototype.isShadowCaster = function () {
                    return this._isShadowCaster;
                };

                SunLight.prototype.setShadowCaster = function (bValue) {
                    this._isShadowCaster = bValue;
                    if (bValue && akra.isNull(this._pDepthTexture)) {
                        this.initializeTextures();
                    }
                };

                SunLight.prototype.getDepthTexture = function () {
                    return this._pDepthTexture;
                };

                SunLight.prototype.getRenderTarget = function () {
                    // return this._pDepthTexture.getBuffer().getRenderTarget();
                    return this._pColorTexture.getBuffer().getRenderTarget();
                };

                SunLight.prototype.getShadowCaster = function () {
                    return this._pShadowCaster;
                };

                SunLight.prototype.create = function (isShadowCaster, iMaxShadowResolution) {
                    if (typeof isShadowCaster === "undefined") { isShadowCaster = true; }
                    if (typeof iMaxShadowResolution === "undefined") { iMaxShadowResolution = 256; }
                    var isOk = _super.prototype.create.call(this, isShadowCaster, iMaxShadowResolution);

                    var pCaster = this._pShadowCaster;

                    pCaster.setParameter(1 /* CONST_ASPECT */, true);
                    pCaster.setOrthoParams(1000., 1000., 0., 1000.);
                    pCaster.setInheritance(4 /* ALL */);
                    pCaster.attachToParent(this);

                    if (this.isShadowCaster()) {
                        this.initializeTextures();
                    }

                    return isOk;
                };

                SunLight.prototype._calculateShadows = function () {
                    if (this.isEnabled() && this.isShadowCaster()) {
                        // LOG(this._pShadowCaster.affectedObjects);
                        this.getRenderTarget().update();
                    }
                };

                // create(caster: boolean): boolean{
                // 	return super.create(false, 0);
                // };
                SunLight.prototype._prepareForLighting = function (pCamera) {
                    // if(!this.enabled){
                    // 	return false;
                    // }
                    // return true;
                    if (!this.isEnabled()) {
                        return false;
                    } else {
                        /*************************************************************/
                        //optimize camera frustum
                        var pDepthRange = pCamera.getDepthRange();

                        var fFov = pCamera.getFOV();
                        var fAspect = pCamera.getAspect();

                        var m4fTmp = Mat4.perspective(fFov, fAspect, -pDepthRange.min, -pDepthRange.max, Mat4.temp());

                        this.getOptimizedCameraFrustum().extractFromMatrix(m4fTmp, pCamera.getWorldMatrix());

                        /*************************************************************/
                        if (!this.isShadowCaster()) {
                            var pResult = this._defineLightingInfluence(pCamera);
                            return (pResult.getLength() === 0) ? false : true;
                        } else {
                            var pResult = this._defineShadowInfluence(pCamera);

                            // this._pShadowCaster.optimizedProjection.set(this._pShadowCaster.projectionMatrix);
                            return (pResult.getLength() === 0) ? false : true;
                        }
                    }
                };

                SunLight.prototype._defineLightingInfluence = function (pCamera) {
                    var pShadowCaster = this._pShadowCaster;
                    var pCameraFrustum = this.getOptimizedCameraFrustum();

                    var pResult = pShadowCaster.getAffectedObjects();
                    pResult.clear();

                    // fast test on frustum intersection
                    if (!pCameraFrustum.testFrustum(pShadowCaster.getFrustum())) {
                        //frustums don't intersecting
                        return pResult;
                    }

                    var pRawResult = pShadowCaster.display(scene.Scene3d.DL_DEFAULT);

                    for (var i = 0; i < pRawResult.getLength(); i++) {
                        var pObject = pRawResult.value(i);

                        if (pCameraFrustum.testRect(pObject.getWorldBounds())) {
                            pResult.push(pObject);
                        }
                    }

                    return pResult;
                };

                SunLight.prototype._defineShadowInfluence = function (pCamera) {
                    var pShadowCaster = this._pShadowCaster;
                    var pCameraFrustum = this.getOptimizedCameraFrustum();

                    var pResult = pShadowCaster.getAffectedObjects();
                    pResult.clear();

                    // fast test on frustum intersection
                    if (!pCameraFrustum.testFrustum(pShadowCaster.getFrustum())) {
                        //frustums don't intersecting
                        pShadowCaster._optimizeProjectionMatrix(pCameraFrustum);

                        // pShadowCaster.optimizedProjection.set(pShadowCaster.projectionMatrix);
                        return pResult;
                    }

                    var pRawResult = pShadowCaster.display(scene.Scene3d.DL_DEFAULT);

                    var pTestArray = SunLight._pFrustumPlanes;
                    var nAdditionalTestLength = 0;

                    nAdditionalTestLength = light.calculatePlanesForOrthogonalLighting(pShadowCaster.getFrustum(), pShadowCaster.getWorldPosition(), pCameraFrustum, pTestArray);

                    var v3fMidPoint = Vec3.temp();
                    var v3fShadowDir = Vec3.temp();
                    var v3fCameraDir = Vec3.temp();

                    for (var i = 0; i < pRawResult.getLength(); i++) {
                        var pObject = pRawResult.value(i);
                        var pWorldBounds = pObject.getWorldBounds();

                        //have object shadows?
                        if (pObject.getShadow()) {
                            var j = 0;
                            for (j = 0; j < nAdditionalTestLength; j++) {
                                var pPlane = pTestArray[j];

                                if (akra.geometry.classify.planeRect3d(pPlane, pWorldBounds) == 0 /* PLANE_FRONT */) {
                                    break;
                                }
                            }
                            if (j == nAdditionalTestLength) {
                                //discard shadow by distance?
                                pWorldBounds.midPoint(v3fMidPoint);

                                v3fMidPoint.subtract(pShadowCaster.getWorldPosition(), v3fShadowDir);
                                v3fMidPoint.subtract(pCamera.getWorldPosition(), v3fCameraDir);

                                if (v3fCameraDir.dot(v3fShadowDir) > 0 && pWorldBounds.distanceToPoint(pCamera.getWorldPosition()) >= akra.config.render.shadows.discardDistance) {
                                } else {
                                    pResult.push(pObject);
                                }
                            }
                        } else {
                            if (pCameraFrustum.testRect(pWorldBounds)) {
                                pResult.push(pObject);
                            }
                        }
                    }

                    pShadowCaster._optimizeProjectionMatrix(pCameraFrustum);

                    return pResult;
                };

                SunLight.prototype.updateSunDirection = function (v3fSunDir) {
                    // var m4fMat: IMat4 = Mat4.temp(this.localMatrix);
                    // m4fMat.data[__13] = -v3fSunDir.x;
                    // m4fMat.data[__23] = -v3fSunDir.y;
                    // m4fMat.data[__33] = -v3fSunDir.z;
                    //this.localMatrix = Mat4.fromXYZ(Vec3.temp(v3fSunDir.x, v3fSunDir.y, v3fSunDir.z).scale(-1., Vec3.temp()), Mat4.temp()).setTranslation(Vec3.temp(0., 0., 1.));
                    // var pViewMat = Mat4.temp();
                    var pViewMat = Mat4.lookAt(Vec3.temp(0.), Vec3.temp(v3fSunDir).scale(-1.), Vec3.temp(0., 0., 1.), Mat4.temp());

                    this.setLocalMatrix(pViewMat.inverse());

                    this.getLocalMatrix().setTranslation(v3fSunDir.scale(500., Vec3.temp()));
                    //this.localMatrix.setTranslation();
                };

                SunLight.prototype.initializeTextures = function () {
                    var pEngine = this.getScene().getManager().getEngine();
                    var pResMgr = pEngine.getResourceManager();
                    var iSize = this._iMaxShadowResolution;

                    var pDepthTexture = this._pDepthTexture = pResMgr.createTexture("depth_texture_" + this.guid);
                    pDepthTexture.create(iSize, iSize, 1, null, 0, 0, 0, 3553 /* TEXTURE_2D */, 46 /* DEPTH32 */);

                    pDepthTexture.setWrapMode(10242 /* WRAP_S */, 33071 /* CLAMP_TO_EDGE */);
                    pDepthTexture.setWrapMode(10243 /* WRAP_T */, 33071 /* CLAMP_TO_EDGE */);
                    pDepthTexture.setFilter(10240 /* MAG_FILTER */, 9729 /* LINEAR */);
                    pDepthTexture.setFilter(10241 /* MIN_FILTER */, 9729 /* LINEAR */);

                    var eColorFormat = 8 /* A4R4G4B4 */;

                    var pColorTexture = pResMgr.createTexture("light_color_texture_" + this.guid);
                    pColorTexture.create(iSize, iSize, 1, null, 512 /* RENDERTARGET */, 0, 0, 3553 /* TEXTURE_2D */, eColorFormat);

                    this._pColorTexture = pColorTexture;

                    //TODO: Multiple render target
                    this.getRenderTarget().attachDepthTexture(pDepthTexture);
                    this.getRenderTarget().setAutoUpdated(false);
                    this.getRenderTarget().addViewport(new akra.render.ShadowViewport(this._pShadowCaster));
                };

                SunLight._pFrustumPlanes = new Array(6);
                SunLight._pTmpPlanePoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];
                SunLight._pTmpIndexList = [0, 0, 0, 0];
                SunLight._pTmpDirLengthList = [0.0, 0.0, 0.0, 0.0];
                return SunLight;
            })(light.LightPoint);
            light.SunLight = SunLight;

            for (var i = 0; i < 6; i++) {
                SunLight._pFrustumPlanes[i] = new akra.geometry.Plane3d();
            }
        })(scene.light || (scene.light = {}));
        var light = scene.light;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
/// <reference path="../idl/IModel.ts" />
/// <reference path="../idl/IScene3d.ts" />
/// <reference path="../idl/ISceneManager.ts" />
/// <reference path="../idl/IDisplayList.ts" />
/// <reference path="../idl/ILightGraph.ts" />
/// <reference path="../idl/ILightPoint.ts" />
/// <reference path="../idl/IOcTree.ts" />
var akra;
(function (akra) {
    /// <reference path="../events.ts" />
    /// <reference path="../debug.ts" />
    /// <reference path="Joint.ts" />
    /// <reference path="SceneNode.ts" />
    /// <reference path="SceneObject.ts" />
    /// <reference path="SceneModel.ts" />
    /// <reference path="OcTree.ts" />
    /// <reference path="LightGraph.ts" />
    /// <reference path="Sprite.ts" />
    /// <reference path="objects/ModelEntry.ts" />
    /// <reference path="objects/Camera.ts" />
    /// <reference path="../terrain/Terrain.ts" />
    /// <reference path="../terrain/TerrainROAM.ts" />
    /// <reference path="../terrain/TerrainSection.ts" />
    /// <reference path="../terrain/TerrainSectionROAM.ts" />
    /// <reference path="light/ProjectLight.ts" />
    /// <reference path="light/OmniLight.ts" />
    /// <reference path="light/SunLight.ts" />
    /// <reference path="light/ShadowCaster.ts" />
    (function (scene) {
        var Scene3d = (function () {
            function Scene3d(pSceneManager, sName) {
                if (typeof sName === "undefined") { sName = null; }
                this.guid = akra.guid();
                // protected _pNodeList: ISceneNode[];
                // protected _pObjectList: ISceneObject[];
                this._pDisplayLists = [];
                this._pDisplayListsCount = 0;
                this._isUpdated = false;
                this.setupSignals();

                this._pSceneManager = pSceneManager;
                this._sName = sName;
                this._pRootNode = this.createNode("root-node");
                this._pRootNode.create();

                var i;

                //TODO: fix this method, do right!!
                var pOctree = new scene.OcTree();
                pOctree.create(new akra.geometry.Rect3d(1024, 1024, 1024), 5, 100);

                var i = this.addDisplayList(pOctree);
                akra.debug.assert(i == Scene3d.DL_DEFAULT, "invalid default list index");

                var pLightGraph = new scene.LightGraph();

                i = this.addDisplayList(pLightGraph);
                akra.debug.assert(i == Scene3d.DL_LIGHTING, "invalid default list index");
                // this._pNodeList = [];
                // this._pObjectList = [];
                //TODO передача пользовательских параметров в OcTree
                // i = this.addDisplayList(new OcTree);
                // debug.assert(i == DL_DEFAULT, "invalid default list index");
                //TODO передача пользовательских параметров в LightGraph
                // i = this.addDisplayList(new LightGraph);
                // debug.assert(i == DL_LIGHTING, "invalid lighting list index");
            }
            Scene3d.prototype.getType = function () {
                return 0 /* TYPE_3D */;
            };

            Scene3d.prototype.getTotalDL = function () {
                return this._pDisplayListsCount;
            };

            Scene3d.prototype.getName = function () {
                return this._sName;
            };

            Scene3d.prototype.setupSignals = function () {
                this.displayListAdded = this.displayListAdded || new akra.Signal(this);
                this.displayListRemoved = this.displayListRemoved || new akra.Signal(this);

                this.beforeUpdate = this.beforeUpdate || new akra.Signal(this);
                this.postUpdate = this.postUpdate || new akra.Signal(this);
                this.preUpdate = this.preUpdate || new akra.Signal(this);

                this.nodeAttachment = this.nodeAttachment || new akra.Signal(this);
                this.nodeDetachment = this.nodeDetachment || new akra.Signal(this);
            };

            Scene3d.prototype.getManager = function () {
                return this._pSceneManager;
            };

            Scene3d.prototype.isUpdated = function () {
                return this._isUpdated;
            };

            Scene3d.prototype.getRootNode = function () {
                return this._pRootNode;
            };

            Scene3d.prototype.recursivePreUpdate = function () {
                this._isUpdated = false;
                this.preUpdate.emit();
                this._pRootNode.recursivePreUpdate();
            };

            Scene3d.prototype.recursiveUpdate = function () {
                this.beforeUpdate.emit();
                this._isUpdated = this._pRootNode.recursiveUpdate();
                this.postUpdate.emit();
            };

            Scene3d.prototype.updateCamera = function () {
                return false;
            };

            Scene3d.prototype.updateScene = function () {
                return false;
            };

            Scene3d.prototype.createObject = function (sName) {
                if (typeof sName === "undefined") { sName = null; }
                var pNode = new scene.SceneObject(this);

                if (!pNode.create()) {
                    akra.logger.error("cannot create scene node..");
                    return null;
                }

                return this.setupNode(pNode, sName);
            };

            Scene3d.prototype.createNode = function (sName) {
                if (typeof sName === "undefined") { sName = null; }
                var pNode = new scene.SceneNode(this);

                if (!pNode.create()) {
                    akra.logger.error("cannot create scene node..");
                    return null;
                }

                return this.setupNode(pNode, sName);
            };

            Scene3d.prototype.createModel = function (sName) {
                if (typeof sName === "undefined") { sName = null; }
                var pNode = new scene.SceneModel(this);

                if (!pNode.create()) {
                    akra.logger.error("cannot create model..");
                    return null;
                }

                return this.setupNode(pNode, sName);
            };

            Scene3d.prototype.createCamera = function (sName) {
                if (typeof sName === "undefined") { sName = null; }
                var pCamera = new scene.objects.Camera(this);

                if (!pCamera.create()) {
                    akra.logger.error("cannot create camera..");
                    return null;
                }

                return this.setupNode(pCamera, sName);
            };

            Scene3d.prototype.createLightPoint = function (eType, isShadowCaster, iMaxShadowResolution, sName) {
                if (typeof eType === "undefined") { eType = 0 /* UNKNOWN */; }
                if (typeof isShadowCaster === "undefined") { isShadowCaster = true; }
                if (typeof iMaxShadowResolution === "undefined") { iMaxShadowResolution = 256; }
                if (typeof sName === "undefined") { sName = null; }
                var pLight;

                switch (eType) {
                    case 1 /* PROJECT */:
                        pLight = (new scene.light.ProjectLight(this));
                        break;
                    case 2 /* OMNI */:
                        pLight = (new scene.light.OmniLight(this));
                        break;
                    case 3 /* SUN */:
                        pLight = (new scene.light.SunLight(this));
                        break;
                    default:
                        return null;
                }

                if (!pLight.create(isShadowCaster, iMaxShadowResolution)) {
                    akra.logger.error("cannot create light");
                    return null;
                }

                return this.setupNode(pLight, sName);
            };

            Scene3d.prototype.createSprite = function (sName) {
                if (typeof sName === "undefined") { sName = null; }
                var pSprite = new scene.Sprite(this);

                if (!pSprite.create()) {
                    akra.logger.error("cannot create sprite..");
                    return null;
                }

                return this.setupNode(pSprite, sName);
            };

            Scene3d.prototype.createJoint = function (sName) {
                if (typeof sName === "undefined") { sName = null; }
                return this.setupNode(new scene.Joint(this), sName);
            };

            Scene3d.prototype._createModelEntry = function (pModel) {
                return this.setupNode(new scene.objects.ModelEntry(this, pModel));
            };

            Scene3d.prototype.createText3d = function (sName) {
                if (typeof sName === "undefined") { sName = null; }
                return null;
            };

            Scene3d.prototype.createTerrain = function (sName) {
                var pTerrain = new akra.terrain.Terrain(this);

                if (!pTerrain.create()) {
                    akra.logger.error("cannot create terrain..");
                    return null;
                }

                return this.setupNode(pTerrain, sName);
            };

            Scene3d.prototype.createTerrainROAM = function (sName) {
                var pTerrainROAM = new akra.terrain.TerrainROAM(this);

                if (!pTerrainROAM.create()) {
                    akra.logger.error("cannot create terrain..");
                    return null;
                }

                return this.setupNode(pTerrainROAM, sName);
            };

            Scene3d.prototype.createTerrainSection = function (sName) {
                var pNode = new akra.terrain.TerrainSection(this);

                if (!pNode.create()) {
                    akra.logger.error("cannot create terrain section..");
                    return null;
                }

                return this.setupNode(pNode, sName);
            };

            Scene3d.prototype.createTerrainSectionROAM = function (sName) {
                var pNode = new akra.terrain.TerrainSectionROAM(this);

                if (!pNode.create()) {
                    akra.logger.error("cannot create terrain section roam..");
                    return null;
                }

                return this.setupNode(pNode, sName);
            };

            Scene3d.prototype._createShadowCaster = function (pLightPoint, iFace, sName) {
                if (typeof iFace === "undefined") { iFace = 0 /* POSITIVE_X */; }
                if (typeof sName === "undefined") { sName = null; }
                var pShadowCaster = new scene.light.ShadowCaster(pLightPoint, iFace);

                if (!pShadowCaster.create()) {
                    akra.logger.error("cannot create shadow caster..");
                    return null;
                }

                return this.setupNode(pShadowCaster, sName);
            };

            Scene3d.prototype.getDisplayList = function (i) {
                akra.debug.assert(akra.isDefAndNotNull(this._pDisplayLists[i]), "display list not defined");
                return this._pDisplayLists[i];
            };

            Scene3d.prototype.getDisplayListByName = function (csName) {
                for (var i = 0; i < this._pDisplayLists.length; ++i) {
                    if (this._pDisplayLists[i].getName() === csName) {
                        return i;
                    }
                }

                return -1;
            };

            Scene3d.prototype._render = function (pCamera, pViewport) {
            };

            Scene3d.prototype.setupNode = function (pNode, sName) {
                if (typeof sName === "undefined") { sName = null; }
                pNode.setName(sName);

                pNode.attached.connect(this.nodeAttachment);
                pNode.detached.connect(this.nodeDetachment);

                return pNode;
            };

            Scene3d.prototype.delDisplayList = function (index) {
                var pLists = this._pDisplayLists;

                for (var i = 0; i < pLists.length; ++i) {
                    if (i === index && akra.isDefAndNotNull(pLists[i])) {
                        pLists[i] = null;
                        this._pDisplayListsCount--;

                        this.displayListRemoved.emit(pLists[i], i);

                        return true;
                    }
                }

                return false;
            };

            Scene3d.prototype.addDisplayList = function (pList) {
                akra.debug.assert(akra.isDefAndNotNull(this.getDisplayListByName(pList.getName())), "DL with name <" + pList.getName() + "> already exists");

                var pLists = this._pDisplayLists;
                var iIndex = this._pDisplayLists.length;

                for (var i = 0; i < pLists.length; ++i) {
                    if (pLists[i] === null) {
                        pLists[i] = pList;
                        iIndex = i;
                        break;
                    }
                }

                if (iIndex == this._pDisplayLists.length) {
                    this._pDisplayLists.push(pList);
                }

                pList._setup(this);

                this.displayListAdded.emit(pList, iIndex);

                this._pDisplayListsCount++;

                return iIndex;
            };

            Scene3d.DL_DEFAULT = 0;
            Scene3d.DL_LIGHTING = 1;
            return Scene3d;
        })();
        scene.Scene3d = Scene3d;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
/// <reference path="../idl/IDSViewport.ts" />
/// <reference path="../idl/IScene3d.ts" />
/// <reference path="../idl/IRenderTechnique.ts" />
/// <reference path="../idl/IRenderPass.ts" />
/// <reference path="../idl/ILightPoint.ts" />
/// <reference path="../idl/IOmniLight.ts" />
/// <reference path="../idl/IProjectLight.ts" />
/// <reference path="../idl/IShadowCaster.ts" />
/// <reference path="../idl/IEffect.ts" />
var akra;
(function (akra) {
    /// <reference path="Viewport.ts" />
    /// <reference path="ViewportWithTransparencyMode.ts" />
    /// <reference path="ShadedViewport.ts" />
    /// <reference path="LightingUniforms.ts" />
    /// <reference path="RenderableObject.ts" />
    /// <reference path="Screen.ts" />
    /// <reference path="../info/info.ts" />
    /// <reference path="../util/ObjectArray.ts" />
    /// <reference path="../webgl/DepthRange.ts" />
    /// <reference path="../color/Color.ts" />
    /// <reference path="../scene/Scene3d.ts" />
    (function (render) {
        var Vec2 = akra.math.Vec2;

        var Color = akra.color.Color;
        var Scene3d = akra.scene.Scene3d;

        var pDepthPixel = new akra.pixelUtil.PixelBox(new akra.geometry.Box(0, 0, 1, 1), 29 /* FLOAT32_DEPTH */, new Uint8Array(4 * 1));
        var pFloatColorPixel = new akra.pixelUtil.PixelBox(new akra.geometry.Box(0, 0, 1, 1), 25 /* FLOAT32_RGBA */, new Uint8Array(4 * 4));
        var pColor = new Color(0);

        var DSViewport = (function (_super) {
            __extends(DSViewport, _super);
            function DSViewport(pCamera, fLeft, fTop, fWidth, fHeight, iZIndex) {
                if (typeof fLeft === "undefined") { fLeft = 0.; }
                if (typeof fTop === "undefined") { fTop = 0.; }
                if (typeof fWidth === "undefined") { fWidth = 1.; }
                if (typeof fHeight === "undefined") { fHeight = 1.; }
                if (typeof iZIndex === "undefined") { iZIndex = 0; }
                _super.call(this, pCamera, null, fLeft, fTop, fWidth, fHeight, iZIndex);
                this._pDeferredEffect = null;
                this._pDeferredColorTextures = [];
                this._pDeferredView = null;
                this._pDeferredSkyTexture = null;
                //highligting
                this._pHighlightedObject = { object: null, renderable: null };
            }
            DSViewport.prototype.setupSignals = function () {
                this.addedSkybox = this.addedSkybox || new akra.Signal(this);
                this.addedBackground = this.addedBackground || new akra.Signal(this);

                _super.prototype.setupSignals.call(this);
            };

            DSViewport.prototype.getType = function () {
                return 1 /* DSVIEWPORT */;
            };

            DSViewport.prototype.getEffect = function () {
                return this._pDeferredEffect;
            };

            DSViewport.prototype.getColorTextures = function () {
                return this._pDeferredColorTextures;
            };

            DSViewport.prototype.getView = function () {
                return this._pDeferredView;
            };

            DSViewport.prototype.getTextureWithObjectID = function () {
                return this._pDeferredColorTextures[0];
            };

            DSViewport.prototype.setShadingModel = function (eModel) {
                _super.prototype.setShadingModel.call(this, eModel);

                if (akra.isDefAndNotNull(this._pTextureForTransparentObjects)) {
                    this._pTextureForTransparentObjects.getBuffer().getRenderTarget().getViewport(0).setShadingModel(eModel);
                }
            };

            DSViewport.prototype.setDefaultEnvironmentMap = function (pEnvMap) {
                _super.prototype.setDefaultEnvironmentMap.call(this, pEnvMap);

                if (akra.isDefAndNotNull(this._pTextureForTransparentObjects)) {
                    this._pTextureForTransparentObjects.getBuffer().getRenderTarget().getViewport(0).setDefaultEnvironmentMap(pEnvMap);
                }
            };

            DSViewport.prototype.setTransparencySupported = function (bEnable) {
                _super.prototype.setTransparencySupported.call(this, bEnable);

                if (akra.isDefAndNotNull(this._pDeferredColorTextures)) {
                    for (var i = 0; i < this._pDeferredColorTextures.length; i++) {
                        this._pDeferredColorTextures[i].getBuffer().getRenderTarget().getViewport(0).setTransparencyMode(!bEnable);
                    }
                }

                if (bEnable && akra.isNull(this._pTextureForTransparentObjects)) {
                    this.initTextureForTransparentObjects();
                }

                this._pTextureForTransparentObjects.getBuffer().getRenderTarget().getViewport(0).setFog(this.isFogged());

                if (bEnable) {
                    this.getEffect().addComponent("akra.system.applyTransparency", 3, 0);
                } else {
                    this.getEffect().addComponent("akra.system.applyTransparency", 3, 0);
                }
            };

            DSViewport.prototype._getTransparencyViewport = function () {
                return this.isTransparencySupported() ? this._pTextureForTransparentObjects.getBuffer().getRenderTarget().getViewport(0) : null;
            };

            DSViewport.prototype._setTarget = function (pTarget) {
                _super.prototype._setTarget.call(this, pTarget);

                //common api access
                var pEngine = pTarget.getRenderer().getEngine();
                var pResMgr = pEngine.getResourceManager();

                //textures for deferred shading
                var pDeferredData = new Array(2);
                var pDeferredTextures = new Array(2);
                var pDepthTexture;

                //renderable for displaying result from deferred textures
                var pDefferedView = new render.Screen(pEngine.getRenderer());

                //unique idetifier for creation dependent resources
                var iGuid = this.guid;

                //Float point texture must be power of two.
                var iWidth = akra.math.ceilingPowerOfTwo(this.getActualWidth());
                var iHeight = akra.math.ceilingPowerOfTwo(this.getActualHeight());

                //detect max texture resolution correctly
                if (akra.config.WEBGL) {
                    iWidth = akra.math.min(iWidth, akra.webgl.maxTextureSize);
                    iHeight = akra.math.min(iHeight, akra.webgl.maxTextureSize);
                }

                //creating depth
                pDepthTexture = pResMgr.createTexture("deferred-depth-texture-" + iGuid);
                pDepthTexture.create(iWidth, iHeight, 1, null, 0, 0, 0, 3553 /* TEXTURE_2D */, 46 /* DEPTH32 */);
                pDepthTexture.setFilter(10240 /* MAG_FILTER */, 9729 /* LINEAR */);
                pDepthTexture.setFilter(10241 /* MIN_FILTER */, 9729 /* LINEAR */);

                this.setDepthTexture(pDepthTexture);

                var pViewport;

                for (var i = 0; i < 2; ++i) {
                    pDeferredTextures[i] = this._pDeferredColorTextures[i] = pResMgr.createTexture("deferred-color-texture-" + i + "-" + iGuid);

                    pDeferredTextures[i].create(iWidth, iHeight, 1, null, 512 /* RENDERTARGET */, 0, 0, 3553 /* TEXTURE_2D */, 25 /* FLOAT32_RGBA */);

                    pDeferredData[i] = pDeferredTextures[i].getBuffer().getRenderTarget();
                    pDeferredData[i].setAutoUpdated(false);
                    pViewport = pDeferredData[i].addViewport(new render.ViewportWithTransparencyMode(this.getCamera(), this._csDefaultRenderMethod + "deferred_shading_pass_" + i, 0, 0, this.getActualWidth() / pDeferredTextures[i].getWidth(), this.getActualHeight() / pDeferredTextures[i].getHeight()));
                    pDeferredData[i].attachDepthTexture(pDepthTexture);

                    if (i === 1) {
                        pViewport.setDepthParams(true, false, 4 /* EQUAL */);
                        pViewport.setClearEveryFrame(true, 1 /* COLOR */);
                    }
                }

                //creatin deferred effects
                var pDSMethod = null;
                var pDSEffect = null;

                pDSMethod = pResMgr.createRenderMethod(".deferred_shading" + iGuid);
                pDSEffect = pResMgr.createEffect(".deferred_shading" + iGuid);

                pDSEffect.addComponent("akra.system.deferredShading");
                pDSEffect.addComponent("akra.system.omniLighting");
                pDSEffect.addComponent("akra.system.omniLightingRestricted");
                pDSEffect.addComponent("akra.system.projectLighting");
                pDSEffect.addComponent("akra.system.omniShadowsLighting");
                pDSEffect.addComponent("akra.system.projectShadowsLighting");
                pDSEffect.addComponent("akra.system.sunLighting");
                pDSEffect.addComponent("akra.system.sunShadowsLighting");
                pDSEffect.addComponent("akra.system.pbsReflection");

                pDSMethod.setEffect(pDSEffect);

                this._pDeferredEffect = pDSEffect;
                this._pDeferredView = pDefferedView;

                pDefferedView.getTechnique().setMethod(pDSMethod);

                this.setClearEveryFrame(false);
                this.setDepthParams(false, false, 0);

                //AA is default
                this.setFXAA(true);

                this.setTransparencySupported(this.isTransparencySupported());
            };

            DSViewport.prototype.setCamera = function (pCamera) {
                var isOk = _super.prototype.setCamera.call(this, pCamera);
                this._pDeferredColorTextures[0].getBuffer().getRenderTarget().getViewport(0).setCamera(pCamera);
                this._pDeferredColorTextures[1].getBuffer().getRenderTarget().getViewport(0).setCamera(pCamera);
                return isOk;
            };

            DSViewport.prototype._updateDimensions = function (bEmitEvent) {
                if (typeof bEmitEvent === "undefined") { bEmitEvent = true; }
                _super.prototype._updateDimensions.call(this, false);

                var pDeferredTextures = this._pDeferredColorTextures;

                if (akra.isDefAndNotNull(this.getDepthTexture())) {
                    this.getDepthTexture().reset(akra.math.ceilingPowerOfTwo(this.getActualWidth()), akra.math.ceilingPowerOfTwo(this.getActualHeight()));
                    for (var i = 0; i < 2; ++i) {
                        pDeferredTextures[i].reset(akra.math.ceilingPowerOfTwo(this.getActualWidth()), akra.math.ceilingPowerOfTwo(this.getActualHeight()));
                        pDeferredTextures[i].getBuffer().getRenderTarget().getViewport(0).setDimensions(0., 0., this.getActualWidth() / pDeferredTextures[i].getWidth(), this.getActualHeight() / pDeferredTextures[i].getHeight());
                    }
                }

                if (akra.isDefAndNotNull(this._pTextureForTransparentObjects)) {
                    this._pTextureForTransparentObjects.reset(akra.math.ceilingPowerOfTwo(this.getActualWidth()), akra.math.ceilingPowerOfTwo(this.getActualHeight()));

                    this._pTextureForTransparentObjects.getBuffer().getRenderTarget().getViewport(0).setDimensions(0., 0., this.getActualWidth() / this._pTextureForTransparentObjects.getWidth(), this.getActualHeight() / this._pTextureForTransparentObjects.getHeight());
                }

                if (bEmitEvent) {
                    this.viewportDimensionsChanged.emit();
                }
            };

            DSViewport.prototype._updateImpl = function () {
                this.prepareForDeferredShading();

                //prepare deferred textures
                this._pDeferredColorTextures[0].getBuffer().getRenderTarget().update();
                this._pDeferredColorTextures[1].getBuffer().getRenderTarget().update();

                //camera last viewport changed, because camera used in deferred textures updating
                this._pCamera._keepLastViewport(this);

                //calculate lighting
                //TODO: Display techniques return sceneNodes, LightPoints and SceneObjects
                var pLights = this.getCamera().display(Scene3d.DL_LIGHTING);

                if (this.isShadowEnabled() && !this._isManualUpdateForLightUniforms()) {
                    for (var i = 0; i < pLights.getLength(); i++) {
                        pLights.value(i)._calculateShadows();
                    }
                }

                this._pLightPoints = pLights;

                if (this.isTransparencySupported()) {
                    this._pTextureForTransparentObjects.getBuffer().getRenderTarget().update();
                }

                //render deferred
                this._pDeferredView.render(this);
            };

            DSViewport.prototype.endFrame = function () {
                this.getTarget().getRenderer().executeQueue(false);
            };

            DSViewport.prototype.prepareForDeferredShading = function () {
                var pNodeList = this.getCamera().display();

                for (var i = 0; i < pNodeList.getLength(); ++i) {
                    var pSceneObject = pNodeList.value(i);

                    for (var k = 0; k < pSceneObject.getTotalRenderable(); k++) {
                        var pRenderable = pSceneObject.getRenderable(k);
                        var pTechCurr = pRenderable.getTechnique(this._csDefaultRenderMethod);

                        for (var j = 0; j < 2; j++) {
                            var sMethod = this._csDefaultRenderMethod + "deferred_shading_pass_" + j;
                            var pTechnique = pRenderable.getTechnique(sMethod);

                            if (akra.isNull(pTechnique) || pTechCurr.getModified() > pTechnique.getModified()) {
                                if (!pRenderable.addRenderMethod(pRenderable.getRenderMethodByName(this._csDefaultRenderMethod), sMethod)) {
                                    akra.logger.critical("cannot clone active render method");
                                }

                                pTechnique = pRenderable.getTechnique(sMethod);

                                //TODO: need something else
                                pTechnique.render._syncSignal(pTechCurr.render);
                                pTechnique.copyTechniqueOwnComponentBlend(pTechCurr);

                                //pTechnique._syncTable(pTechCurr);
                                var iTotalPasses = pTechnique.getTotalPasses();
                                for (var k = 0; k < iTotalPasses; k++) {
                                    var pPass = pTechnique.getPass(k);
                                    pPass.blend("akra.system.prepareForDeferredShading", j);
                                }

                                pTechnique.updatePasses(false);

                                for (var k = 0; k < iTotalPasses; k++) {
                                    var pPass = pTechnique.getPass(k);
                                    if (j === 0) {
                                        pPass.setForeign("OPTIMIZE_FOR_DEFERRED_PASS0", true);
                                    } else {
                                        pPass.setForeign("OPTIMIZE_FOR_DEFERRED_PASS1", true);
                                    }
                                }
                            }
                        }
                    }
                }
            };

            DSViewport.prototype.getSkybox = function () {
                return this._pDeferredSkyTexture;
            };

            //protected _getDepthRangeImpl(): IDepthRange{
            //	var pRange: IDepthRange = config.WEBGL ?
            //		webgl.getDepthRange(this._pDeferredDepthTexture):
            //		<IDepthRange>{min: 0., max: 1.};
            //	//[0,1] -> [-1, 1]
            //	pRange.min = pRange.min * 2. - 1.;
            //	pRange.max = pRange.max * 2. - 1.;
            //	return pRange;
            //}
            DSViewport.prototype._getRenderId = function (x, y) {
                return this._getDeferredTexValue(0, x, y).a;
            };

            DSViewport.prototype._getDeferredTexValue = function (iTex, x, y) {
                akra.logger.assert(x < this.getActualWidth() && y < this.getActualHeight(), "invalid pixel: {" + x + "(" + this.getActualWidth() + ")" + ", " + y + "(" + this.getActualHeight() + ")" + "}");

                var pColorTexture = this._pDeferredColorTextures[iTex];

                //depth texture has POT sized, but viewport not;
                //depth texture attached to left bottom angle of viewport
                y = pColorTexture.getHeight() - y - 1;
                pFloatColorPixel.left = x;
                pFloatColorPixel.top = y;
                pFloatColorPixel.right = x + 1;
                pFloatColorPixel.bottom = y + 1;

                pColorTexture.getBuffer(0, 0).readPixels(pFloatColorPixel);

                return pFloatColorPixel.getColorAt(pColor, 0, 0);
            };

            DSViewport.prototype.getDepth = function (x, y) {
                akra.logger.assert(x < this.getActualWidth() && y < this.getActualHeight(), "invalid pixel: {" + x + ", " + y + "}");

                var pDepthTexture = this.getDepthTexture();

                //depth texture has POT sized, but viewport not;
                //depth texture attached to left bottom angle of viewport
                // y = y + (pDepthTexture.height - this.actualHeight);
                // pDepthPixel.left = x;
                // pDepthPixel.top = y;
                // pDepthPixel.right = x + 1;
                // pDepthPixel.bottom = y + 1;
                y = pDepthTexture.getHeight() - y - 1;
                pDepthPixel.left = x;
                pDepthPixel.top = y;
                pDepthPixel.right = x + 1;
                pDepthPixel.bottom = y + 1;

                pDepthTexture.getBuffer(0, 0).readPixels(pDepthPixel);

                return pDepthPixel.getColorAt(pColor, 0, 0).r;
            };

            DSViewport.prototype.setSkybox = function (pSkyTexture) {
                if (pSkyTexture.getTextureType() !== 34067 /* TEXTURE_CUBE_MAP */) {
                    return null;
                }

                var pTechnique = this._pDeferredView.getTechnique();
                var pEffect = this._pDeferredEffect;

                if (pSkyTexture) {
                    pEffect.addComponent("akra.system.skybox", 1, 0);
                } else {
                    pEffect.delComponent("akra.system.skybox", 1, 0);
                }

                this._pDeferredSkyTexture = pSkyTexture;

                this.addedSkybox.emit(pSkyTexture);

                return true;
            };

            DSViewport.prototype.setFXAA = function (bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                var pEffect = this._pDeferredEffect;

                if (bValue) {
                    pEffect.addComponent("akra.system.fxaa", 4, 0);
                } else {
                    pEffect.delComponent("akra.system.fxaa", 4, 0);
                }
            };

            DSViewport.prototype.highlight = function (a) {
                var pComposer = this.getTarget().getRenderer().getEngine().getComposer();
                var pEffect = this._pDeferredEffect;
                var iRid = 0;
                var p = this._pHighlightedObject;
                var pObjectPrev = p.object;

                if (akra.isNull(arguments[0])) {
                    p.object = null;
                    p.renderable = null;
                } else if (akra.isInt(arguments[0])) {
                    iRid = a;
                    p.object = pComposer._getObjectByRid(iRid);
                    p.renderable = pComposer._getRenderableByRid(iRid);
                } else if (arguments[0] instanceof akra.scene.SceneObject) {
                    p.object = arguments[0];
                    p.renderable = arguments[1];
                } else {
                    p.object = arguments[0].object;
                    p.renderable = arguments[0].renderable;
                }

                if (p.object && akra.isNull(pObjectPrev)) {
                    pEffect.addComponent("akra.system.outline", 1, 0);
                } else if (akra.isNull(p.object) && pObjectPrev) {
                    pEffect.delComponent("akra.system.outline", 1, 0);

                    //FIX ME: Need do understood how to know that skybox added like single effect, and not as imported component
                    if (!akra.isNull(this._pDeferredSkyTexture)) {
                        pEffect.addComponent("akra.system.skybox", 1, 0);
                    }
                }
            };

            DSViewport.prototype.isFXAA = function () {
                return this.getEffect().hasComponent("akra.system.fxaa");
            };

            DSViewport.prototype.isAntialiased = function () {
                return this.isFXAA();
            };

            DSViewport.prototype.setAntialiasing = function (bEnabled) {
                if (typeof bEnabled === "undefined") { bEnabled = true; }
                this.setFXAA(bEnabled);
            };

            DSViewport.prototype.setFog = function (bEnabled) {
                if (typeof bEnabled === "undefined") { bEnabled = true; }
                if (bEnabled) {
                    this.getEffect().addComponent("akra.system.fog", 2, 0);
                } else {
                    this.getEffect().delComponent("akra.system.fog", 2, 0);
                }

                if (this.isTransparencySupported()) {
                    this._pTextureForTransparentObjects.getBuffer().getRenderTarget().getViewport(0).setFog(bEnabled);
                }
            };

            DSViewport.prototype.isFogged = function () {
                return this.getEffect().hasComponent("akra.system.fog");
            };

            DSViewport.prototype.destroy = function () {
                _super.prototype.destroy.call(this);

                this.getDepthTexture().destroyResource();

                this._pDeferredColorTextures[0].destroyResource();
                this._pDeferredColorTextures[1].destroyResource();

                this._pDeferredView.destroy();
                this._pDeferredView = null;

                this._pDeferredSkyTexture = null;
            };

            DSViewport.prototype._onRender = function (pTechnique, iPass, pRenderable, pSceneObject) {
                var pPass = pTechnique.getPass(iPass);
                var pDepthTexture = this.getDepthTexture();
                var pDeferredTextures = this._pDeferredColorTextures;

                switch (iPass) {
                    case 0:
                        var pLightUniforms = this._pLightingUnifoms;
                        var pLightPoints = this._pLightPoints;
                        var pCamera = this.getCamera();

                        this.createLightingUniforms(pCamera, pLightPoints, pLightUniforms);

                        pPass.setForeign("NUM_OMNI", pLightUniforms.omni.length);
                        pPass.setForeign("NUM_OMNI_SHADOWS", pLightUniforms.omniShadows.length);
                        pPass.setForeign("NUM_PROJECT", pLightUniforms.project.length);
                        pPass.setForeign("NUM_PROJECT_SHADOWS", pLightUniforms.projectShadows.length);
                        pPass.setForeign("NUM_SUN", pLightUniforms.sun.length);
                        pPass.setForeign("NUM_SUN_SHADOWS", pLightUniforms.sunShadows.length);

                        pPass.setForeign("NUM_OMNI_RESTRICTED", pLightUniforms.omniRestricted.length);

                        pPass.setStruct("points_omni", pLightUniforms.omni);
                        pPass.setStruct("points_project", pLightUniforms.project);
                        pPass.setStruct("points_omni_shadows", pLightUniforms.omniShadows);
                        pPass.setStruct("points_project_shadows", pLightUniforms.projectShadows);
                        pPass.setStruct("points_sun", pLightUniforms.sun);
                        pPass.setStruct("points_sun_shadows", pLightUniforms.sunShadows);

                        pPass.setStruct("points_omni_restricted", pLightUniforms.omniRestricted);

                        //for (var i: int = 0; i < pLightUniforms.textures.length; i++) {
                        //	pPass.setTexture("TEXTURE" + i, pLightUniforms.textures[i]);
                        //}
                        pPass.setUniform("PROJECT_SHADOW_SAMPLER", pLightUniforms.samplersProject);
                        pPass.setUniform("OMNI_SHADOW_SAMPLER", pLightUniforms.samplersOmni);
                        pPass.setUniform("SUN_SHADOW_SAMPLER", pLightUniforms.samplersSun);

                        pPass.setUniform("MIN_SHADOW_VALUE", 0.5);
                        pPass.setUniform("SHADOW_CONSTANT", 5.e+2);

                        pPass.setUniform("SCREEN_TEXTURE_RATIO", Vec2.temp(this.getActualWidth() / pDepthTexture.getWidth(), this.getActualHeight() / pDepthTexture.getHeight()));

                        pPass.setTexture("DEFERRED_TEXTURE0", pDeferredTextures[0]);
                        pPass.setTexture("DEFERRED_TEXTURE1", pDeferredTextures[1]);
                        pPass.setTexture("SCENE_DEPTH_TEXTURE", pDepthTexture);

                        pPass.setForeign("IS_USED_PNONG", this.getShadingModel() === 1 /* PHONG */);
                        pPass.setForeign("IS_USED_BLINN_PNONG", this.getShadingModel() === 0 /* BLINNPHONG */);
                        pPass.setForeign("IS_USED_PBS_SIMPLE", this.getShadingModel() === 2 /* PBS_SIMPLE */);

                        if (akra.isDefAndNotNull(this.getDefaultEnvironmentMap())) {
                            pPass.setForeign("IS_USED_PBS_REFLECTIONS", true);
                            pPass.setTexture("ENVMAP", this.getDefaultEnvironmentMap());
                        } else {
                            pPass.setForeign("IS_USED_PBS_REFLECTIONS", false);
                        }

                        break;

                    case 1:
                    case 2:
                    case 3:
                        //fog
                        pPass.setTexture("DEPTH_TEXTURE", this.getDepthTexture());

                        //transparency
                        pPass.setTexture("TRANSPARENT_TEXTURE", this.isTransparencySupported() ? this._pTextureForTransparentObjects : null);

                        //skybox
                        pPass.setTexture("OBJECT_ID_TEXTURE", pDeferredTextures[0]);
                        pPass.setTexture("SKYBOX_TEXTURE", this._pDeferredSkyTexture);

                        pPass.setUniform("SCREEN_TEXTURE_RATIO", Vec2.temp(this.getActualWidth() / pDepthTexture.getWidth(), this.getActualHeight() / pDepthTexture.getHeight()));

                        //outline
                        var p = this._pHighlightedObject;

                        if (!akra.isNull(p.object)) {
                            var iRid = this.getTarget().getRenderer().getEngine().getComposer()._calcRenderID(p.object, p.renderable);

                            pPass.setUniform("OUTLINE_TARGET", iRid);
                            pPass.setUniform("OUTLINE_SOID", (iRid - 1) >>> 10);
                            pPass.setUniform("OUTLINE_REID", (iRid - 1) & 1023);
                        }

                        pPass.setUniform("SCREEN_TEXTURE_RATIO", Vec2.temp(this.getActualWidth() / pDepthTexture.getWidth(), this.getActualHeight() / pDepthTexture.getHeight()));
                        break;
                }

                _super.prototype._onRender.call(this, pTechnique, iPass, pRenderable, pSceneObject);
            };
            return DSViewport;
        })(render.ShadedViewport);
        render.DSViewport = DSViewport;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="IViewport3D.ts" />
/// <reference path="../idl/ILPPViewport.ts" />
/// <reference path="ShadedViewport.ts" />
/// <reference path="../scene/Scene3d.ts" />
/// <reference path="LightingUniforms.ts" />
/// <reference path="ViewportWithTransparencyMode.ts" />
var akra;
(function (akra) {
    (function (render) {
        var Vec2 = akra.math.Vec2;

        var Color = akra.color.Color;

        var pDepthPixel = new akra.pixelUtil.PixelBox(new akra.geometry.Box(0, 0, 1, 1), 29 /* FLOAT32_DEPTH */, new Uint8Array(4 * 1));
        var pFloatColorPixel = new akra.pixelUtil.PixelBox(new akra.geometry.Box(0, 0, 1, 1), 25 /* FLOAT32_RGBA */, new Uint8Array(4 * 4));
        var pColor = new Color(0);

        var LPPViewport = (function (_super) {
            __extends(LPPViewport, _super);
            function LPPViewport(pCamera, fLeft, fTop, fWidth, fHeight, iZIndex) {
                if (typeof fLeft === "undefined") { fLeft = 0.; }
                if (typeof fTop === "undefined") { fTop = 0.; }
                if (typeof fWidth === "undefined") { fWidth = 1.; }
                if (typeof fHeight === "undefined") { fHeight = 1.; }
                if (typeof iZIndex === "undefined") { iZIndex = 0; }
                _super.call(this, pCamera, null, fLeft, fTop, fWidth, fHeight, iZIndex);
                /** Buffer with normal, shininess and objectID */
                this._pNormalBufferTexture = null;
                /**
                * 0 - Diffuse and specular
                * 1 - Ambient and shadow
                */
                this._pLightBufferTextures = null;
                /** Resyult of LPP with out posteffects */
                this._pResultLPPTexture = null;
                this._pViewScreen = null;
                this._v2fTextureRatio = null;
                this._v2fScreenSize = null;
                this._pHighlightedObject = { object: null, renderable: null };
                this._pSkyboxTexture = null;
            }
            LPPViewport.prototype.setupSignals = function () {
                this.addedSkybox = this.addedSkybox || new akra.Signal(this);

                _super.prototype.setupSignals.call(this);
            };

            LPPViewport.prototype.getType = function () {
                return 5 /* LPPVIEWPORT */;
            };

            LPPViewport.prototype.getView = function () {
                return this._pViewScreen;
            };

            LPPViewport.prototype.getEffect = function () {
                return this.getView().getRenderMethodDefault().getEffect();
            };

            LPPViewport.prototype.getSkybox = function () {
                return this._pSkyboxTexture;
            };

            LPPViewport.prototype.getTextureWithObjectID = function () {
                return this._pNormalBufferTexture;
            };

            LPPViewport.prototype.setShadingModel = function (eModel) {
                _super.prototype.setShadingModel.call(this, eModel);

                if (eModel === 2 /* PBS_SIMPLE */) {
                    this._pViewScreen.getRenderMethodByName("passA").setForeign("PREPARE_ONLY_POSITION", false);
                }

                if (akra.isDefAndNotNull(this._pTextureForTransparentObjects)) {
                    this._pTextureForTransparentObjects.getBuffer().getRenderTarget().getViewport(0).setShadingModel(eModel);
                }
            };

            LPPViewport.prototype.setDefaultEnvironmentMap = function (pEnvMap) {
                _super.prototype.setDefaultEnvironmentMap.call(this, pEnvMap);

                if (akra.isDefAndNotNull(this._pTextureForTransparentObjects)) {
                    this._pTextureForTransparentObjects.getBuffer().getRenderTarget().getViewport(0).setDefaultEnvironmentMap(pEnvMap);
                }
            };

            LPPViewport.prototype.setTransparencySupported = function (bEnable) {
                _super.prototype.setTransparencySupported.call(this, bEnable);

                if (akra.isDefAndNotNull(this._pNormalBufferTexture)) {
                    this._pNormalBufferTexture.getBuffer().getRenderTarget().getViewport(0).setTransparencyMode(!bEnable);
                    this._pResultLPPTexture.getBuffer().getRenderTarget().getViewport(0).setTransparencyMode(!bEnable);
                }

                if (bEnable && akra.isNull(this._pTextureForTransparentObjects)) {
                    this.initTextureForTransparentObjects();
                }

                this._pTextureForTransparentObjects.getBuffer().getRenderTarget().getViewport(0).setFog(this.isFogged());

                if (bEnable) {
                    this.getEffect().addComponent("akra.system.applyTransparency", 3, 0);
                } else {
                    this.getEffect().addComponent("akra.system.applyTransparency", 3, 0);
                }
            };

            LPPViewport.prototype._getTransparencyViewport = function () {
                return this.isTransparencySupported() ? this._pTextureForTransparentObjects.getBuffer().getRenderTarget().getViewport(0) : null;
            };

            LPPViewport.prototype._setTarget = function (pTarget) {
                _super.prototype._setTarget.call(this, pTarget);

                //common api access
                var pEngine = pTarget.getRenderer().getEngine();
                var pResMgr = pEngine.getResourceManager();

                //renderable for displaying result from deferred textures
                this._pViewScreen = new render.Screen(pEngine.getRenderer());

                //unique idetifier for creation dependent resources
                var iGuid = this.guid;

                //Float point texture must be power of two.
                var iWidth = akra.math.ceilingPowerOfTwo(this.getActualWidth());
                var iHeight = akra.math.ceilingPowerOfTwo(this.getActualHeight());

                //detect max texture resolution correctly
                if (akra.config.WEBGL) {
                    iWidth = akra.math.min(iWidth, akra.webgl.maxTextureSize);
                    iHeight = akra.math.min(iHeight, akra.webgl.maxTextureSize);
                }

                this.createNormalBufferRenderTarget(iWidth, iHeight);
                this.createLightBuffersRenderTargets(iWidth, iHeight);
                this.createResultLPPRenderTarget(iWidth, iHeight);

                this._v2fTextureRatio = new akra.math.Vec2(this.getActualWidth() / this._pNormalBufferTexture.getWidth(), this.getActualHeight() / this._pNormalBufferTexture.getHeight());
                this._v2fScreenSize = new Vec2(this.getActualWidth(), this.getActualHeight());

                this.prepareRenderMethods();

                this.setClearEveryFrame(false);
                this.setBackgroundColor(akra.color.ZERO);
                this.setDepthParams(false, false, 0);

                this.setFXAA(true);

                this.setTransparencySupported(this.isTransparencySupported());
            };

            LPPViewport.prototype.setCamera = function (pCamera) {
                var isOk = _super.prototype.setCamera.call(this, pCamera);
                this._pNormalBufferTexture.getBuffer().getRenderTarget().getViewport(0).setCamera(pCamera);
                this._pLightBufferTextures[0].getBuffer().getRenderTarget().getViewport(0).setCamera(pCamera);
                this._pLightBufferTextures[1].getBuffer().getRenderTarget().getViewport(0).setCamera(pCamera);
                this._pResultLPPTexture.getBuffer().getRenderTarget().getViewport(0).setCamera(pCamera);
                return isOk;
            };

            LPPViewport.prototype._getRenderId = function (x, y) {
                akra.logger.assert(x < this.getActualWidth() && y < this.getActualHeight(), "invalid pixel: {" + x + "(" + this.getActualWidth() + ")" + ", " + y + "(" + this.getActualHeight() + ")" + "}");

                var pColorTexture = this._pNormalBufferTexture;

                //depth texture has POT sized, but viewport not;
                //depth texture attached to left bottom angle of viewport
                y = pColorTexture.getHeight() - y - 1;
                pFloatColorPixel.left = x;
                pFloatColorPixel.top = y;
                pFloatColorPixel.right = x + 1;
                pFloatColorPixel.bottom = y + 1;

                pColorTexture.getBuffer(0, 0).readPixels(pFloatColorPixel);

                return pFloatColorPixel.getColorAt(pColor, 0, 0).a;
            };

            LPPViewport.prototype._updateDimensions = function (bEmitEvent) {
                if (typeof bEmitEvent === "undefined") { bEmitEvent = true; }
                _super.prototype._updateDimensions.call(this, false);

                if (akra.isDefAndNotNull(this._pNormalBufferTexture)) {
                    this.updateRenderTextureDimensions(this._pNormalBufferTexture);
                    this.updateRenderTextureDimensions(this._pLightBufferTextures[0]);
                    this.updateRenderTextureDimensions(this._pLightBufferTextures[1]);
                    this.updateRenderTextureDimensions(this._pResultLPPTexture);

                    this.getDepthTexture().reset(akra.math.ceilingPowerOfTwo(this.getActualWidth()), akra.math.ceilingPowerOfTwo(this.getActualHeight()));

                    this._v2fTextureRatio.set(this.getActualWidth() / this._pNormalBufferTexture.getWidth(), this.getActualHeight() / this._pNormalBufferTexture.getHeight());
                    this._v2fScreenSize.set(this.getActualWidth(), this.getActualHeight());
                }

                if (akra.isDefAndNotNull(this._pTextureForTransparentObjects)) {
                    //this._pTextureForTransparentObjects.reset(math.ceilingPowerOfTwo(this.getActualWidth()), math.ceilingPowerOfTwo(this.getActualHeight()));
                    //this._pTextureForTransparentObjects.getBuffer().getRenderTarget().getViewport(0)
                    //	.setDimensions(0., 0., this.getActualWidth() / this._pTextureForTransparentObjects.getWidth(), this.getActualHeight() / this._pTextureForTransparentObjects.getHeight());
                    this.updateRenderTextureDimensions(this._pTextureForTransparentObjects);
                }

                if (bEmitEvent) {
                    this.viewportDimensionsChanged.emit();
                }
            };

            LPPViewport.prototype._updateImpl = function () {
                var pRenderer = this.getTarget().getRenderer();

                this.prepareForLPPShading();

                //prepare normal buffer texture
                this._pNormalBufferTexture.getBuffer().getRenderTarget().update();

                //camera last viewport changed, because camera used in normal buffer textures updating
                this._pCamera._keepLastViewport(this);

                //render light map
                var pLights = this.getCamera().display(akra.scene.Scene3d.DL_LIGHTING);

                if (this.isShadowEnabled() && !this._isManualUpdateForLightUniforms()) {
                    for (var i = 0; i < pLights.getLength(); i++) {
                        pLights.value(i)._calculateShadows();
                    }
                }

                this._pLightPoints = pLights;
                this.createLightingUniforms(this.getCamera(), this._pLightPoints, this._pLightingUnifoms);

                //render deferred
                this._pViewScreen.render(this._pLightBufferTextures[0].getBuffer().getRenderTarget().getViewport(0), "passA");

                //pRenderer.executeQueue(false);
                if (this.getShadingModel() === 1 /* PHONG */ || this.getShadingModel() === 2 /* PBS_SIMPLE */) {
                    this._pViewScreen.render(this._pLightBufferTextures[1].getBuffer().getRenderTarget().getViewport(0), "passB");
                }

                pRenderer.executeQueue(false);

                //var pRenderViewport: IViewport = this._pResultLPPTexture.getBuffer().getRenderTarget().getViewport(0);
                //var pState: IViewportState = this._getViewportState();
                if (this.isTransparencySupported()) {
                    this._pTextureForTransparentObjects.getBuffer().getRenderTarget().update();
                }

                this._pResultLPPTexture.getBuffer().getRenderTarget().update();

                this._pViewScreen.render(this);
                this._pCamera._keepLastViewport(this);
                pRenderer.executeQueue(false);
                //this.renderAsNormal("apply_lpp_shading", this.getCamera());
            };

            LPPViewport.prototype.setSkybox = function (pSkyTexture) {
                if (pSkyTexture.getTextureType() !== 34067 /* TEXTURE_CUBE_MAP */) {
                    return null;
                }

                var pEffect = this.getEffect();

                if (pSkyTexture) {
                    pEffect.addComponent("akra.system.skybox", 1, 0);
                } else {
                    pEffect.delComponent("akra.system.skybox", 1, 0);
                }

                this._pSkyboxTexture = pSkyTexture;

                this.addedSkybox.emit(pSkyTexture);

                return true;
            };

            LPPViewport.prototype.setFXAA = function (bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                var pEffect = this.getEffect();

                if (bValue) {
                    pEffect.addComponent("akra.system.fxaa", 4, 0);
                } else {
                    pEffect.delComponent("akra.system.fxaa", 4, 0);
                }
            };

            LPPViewport.prototype.isFXAA = function () {
                return this.getEffect().hasComponent("akra.system.fxaa");
            };

            LPPViewport.prototype.setAntialiasing = function (bEnabled) {
                if (typeof bEnabled === "undefined") { bEnabled = true; }
                this.setFXAA(true);
            };

            LPPViewport.prototype.isAntialiased = function () {
                return this.isFXAA();
            };

            LPPViewport.prototype.setFog = function (bEnabled) {
                if (typeof bEnabled === "undefined") { bEnabled = true; }
                if (bEnabled) {
                    this.getEffect().addComponent("akra.system.fog", 2, 0);
                } else {
                    this.getEffect().delComponent("akra.system.fog", 2, 0);
                }

                if (this.isTransparencySupported()) {
                    this._pTextureForTransparentObjects.getBuffer().getRenderTarget().getViewport(0).setFog(bEnabled);
                }
            };

            LPPViewport.prototype.isFogged = function () {
                return this.getEffect().hasComponent("akra.system.fog");
            };

            LPPViewport.prototype.highlight = function (a) {
                var pComposer = this.getTarget().getRenderer().getEngine().getComposer();
                var pEffect = this.getEffect();
                var iRid = 0;
                var p = this._pHighlightedObject;
                var pObjectPrev = p.object;

                if (akra.isNull(arguments[0])) {
                    p.object = null;
                    p.renderable = null;
                } else if (akra.isInt(arguments[0])) {
                    iRid = a;
                    p.object = pComposer._getObjectByRid(iRid);
                    p.renderable = pComposer._getRenderableByRid(iRid);
                } else if (arguments[0] instanceof akra.scene.SceneObject) {
                    p.object = arguments[0];
                    p.renderable = arguments[1];
                } else {
                    p.object = arguments[0].object;
                    p.renderable = arguments[0].renderable;
                }

                if (p.object && akra.isNull(pObjectPrev)) {
                    pEffect.addComponent("akra.system.outline", 1, 0);
                } else if (akra.isNull(p.object) && pObjectPrev) {
                    pEffect.delComponent("akra.system.outline", 1, 0);

                    //FIX ME: Need do understood how to know that skybox added like single effect, and not as imported component
                    if (!akra.isNull(this._pSkyboxTexture)) {
                        pEffect.addComponent("akra.system.skybox", 1, 0);
                    }
                }
            };

            LPPViewport.prototype._onNormalBufferRender = function (pViewport, pTechnique, iPass, pRenderable, pSceneObject) {
                var pPass = pTechnique.getPass(iPass);

                pPass.setForeign("OPTIMIZE_FOR_LPP_PREPARE", true);
            };

            LPPViewport.prototype._onLightMapRender = function (pViewport, pTechnique, iPass, pRenderable, pSceneObject) {
                var pPass = pTechnique.getPass(iPass);

                var pLightUniforms = this._pLightingUnifoms;
                var pLightPoints = this._pLightPoints;
                var pCamera = this.getCamera();

                pPass.setForeign("NUM_OMNI", pLightUniforms.omni.length);
                pPass.setForeign("NUM_OMNI_SHADOWS", pLightUniforms.omniShadows.length);
                pPass.setForeign("NUM_PROJECT", pLightUniforms.project.length);
                pPass.setForeign("NUM_PROJECT_SHADOWS", pLightUniforms.projectShadows.length);
                pPass.setForeign("NUM_SUN", pLightUniforms.sun.length);
                pPass.setForeign("NUM_SUN_SHADOWS", pLightUniforms.sunShadows.length);

                pPass.setForeign("NUM_OMNI_RESTRICTED", pLightUniforms.omniRestricted.length);

                pPass.setStruct("points_omni", pLightUniforms.omni);
                pPass.setStruct("points_project", pLightUniforms.project);
                pPass.setStruct("points_omni_shadows", pLightUniforms.omniShadows);
                pPass.setStruct("points_project_shadows", pLightUniforms.projectShadows);
                pPass.setStruct("points_sun", pLightUniforms.sun);
                pPass.setStruct("points_sun_shadows", pLightUniforms.sunShadows);

                pPass.setStruct("points_omni_restricted", pLightUniforms.omniRestricted);

                //for (var i: int = 0; i < pLightUniforms.textures.length; i++) {
                //	pPass.setTexture("TEXTURE" + i, pLightUniforms.textures[i]);
                //}
                pPass.setUniform("PROJECT_SHADOW_SAMPLER", pLightUniforms.samplersProject);
                pPass.setUniform("OMNI_SHADOW_SAMPLER", pLightUniforms.samplersOmni);
                pPass.setUniform("SUN_SHADOW_SAMPLER", pLightUniforms.samplersSun);

                pPass.setUniform("MIN_SHADOW_VALUE", 0.5);
                pPass.setUniform("SHADOW_CONSTANT", 5.e+2);

                pPass.setTexture("LPP_DEPTH_BUFFER_TEXTURE", this.getDepthTexture());
                pPass.setTexture("LPP_NORMAL_BUFFER_TEXTURE", this._pNormalBufferTexture);
                pPass.setUniform("SCREEN_TEXTURE_RATIO", this._v2fTextureRatio);

                pPass.setForeign("IS_USED_PNONG", this.getShadingModel() === 1 /* PHONG */);
                pPass.setForeign("IS_USED_BLINN_PNONG", this.getShadingModel() === 0 /* BLINNPHONG */);
                pPass.setForeign("IS_USED_PBS_SIMPLE", this.getShadingModel() === 2 /* PBS_SIMPLE */);

                pPass.setUniform("NUM_LIGHTS_WITH_PBS", pLightUniforms.omni.length + pLightUniforms.omniShadows.length + pLightUniforms.project.length + pLightUniforms.projectShadows.length + pLightUniforms.sun.length + pLightUniforms.sunShadows.length);
            };

            LPPViewport.prototype._onObjectsRender = function (pViewport, pTechnique, iPass, pRenderable, pSceneObject) {
                var pPass = pTechnique.getPass(iPass);

                pPass.setUniform("SCREEN_TEXTURE_RATIO", this._v2fTextureRatio);
                pPass.setTexture("LPP_LIGHT_BUFFER_A", this._pLightBufferTextures[0]);
                pPass.setTexture("LPP_LIGHT_BUFFER_B", this._pLightBufferTextures[1]);
                pPass.setTexture("LPP_NORMAL_BUFFER_TEXTURE", this._pNormalBufferTexture);

                pPass.setUniform("SCREEN_SIZE", this._v2fScreenSize);
                pPass.setForeign("OPTIMIZE_FOR_LPP_APPLY", true);

                pPass.setForeign("IS_USED_PNONG", this.getShadingModel() === 1 /* PHONG */);
                pPass.setForeign("IS_USED_BLINN_PNONG", this.getShadingModel() === 0 /* BLINNPHONG */);
                pPass.setForeign("IS_USED_PBS_SIMPLE", this.getShadingModel() === 2 /* PBS_SIMPLE */);

                if (akra.isDefAndNotNull(this.getDefaultEnvironmentMap())) {
                    pPass.setForeign("IS_USED_PBS_REFLECTIONS", true);
                    pPass.setTexture("ENVMAP", this.getDefaultEnvironmentMap());
                } else {
                    pPass.setForeign("IS_USED_PBS_REFLECTIONS", false);
                }
            };

            LPPViewport.prototype._onRender = function (pTechnique, iPass, pRenderable, pSceneObject) {
                var pPass = pTechnique.getPass(iPass);

                switch (iPass) {
                    case 0:
                        pPass.setUniform("VIEWPORT", akra.math.Vec4.temp(0., 0., this._v2fTextureRatio.x, this._v2fTextureRatio.y));
                        pPass.setTexture("TEXTURE_FOR_SCREEN", this._pResultLPPTexture);
                        pPass.setForeign("SAVE_ALPHA", true);
                        break;
                    case 1:
                    case 2:
                    case 3:
                        //fog
                        pPass.setTexture("DEPTH_TEXTURE", this.getDepthTexture());

                        //transparency
                        pPass.setTexture("TRANSPARENT_TEXTURE", this._pTextureForTransparentObjects);

                        //skybox
                        pPass.setTexture("OBJECT_ID_TEXTURE", this._pNormalBufferTexture);
                        pPass.setTexture("SKYBOX_TEXTURE", this._pSkyboxTexture);

                        //outline
                        var p = this._pHighlightedObject;

                        if (!akra.isNull(p.object)) {
                            var iRid = this.getTarget().getRenderer().getEngine().getComposer()._calcRenderID(p.object, p.renderable);

                            pPass.setUniform("OUTLINE_TARGET", iRid);
                            pPass.setUniform("OUTLINE_SOID", (iRid - 1) >>> 10);
                            pPass.setUniform("OUTLINE_REID", (iRid - 1) & 1023);
                        }

                        pPass.setUniform("SCREEN_TEXTURE_RATIO", this._v2fTextureRatio);
                        break;
                }

                _super.prototype._onRender.call(this, pTechnique, iPass, pRenderable, pSceneObject);
            };

            LPPViewport.prototype.endFrame = function () {
                this.getTarget().getRenderer().executeQueue(false);
            };

            LPPViewport.prototype.getDepth = function (x, y) {
                akra.logger.assert(x < this.getActualWidth() && y < this.getActualHeight(), "invalid pixel: {" + x + ", " + y + "}");

                var pDepthTexture = this.getDepthTexture();

                y = pDepthTexture.getHeight() - y - 1;
                pDepthPixel.left = x;
                pDepthPixel.top = y;
                pDepthPixel.right = x + 1;
                pDepthPixel.bottom = y + 1;

                pDepthTexture.getBuffer(0, 0).readPixels(pDepthPixel);

                return pDepthPixel.getColorAt(pColor, 0, 0).r;
            };

            LPPViewport.prototype.createNormalBufferRenderTarget = function (iWidth, iHeight) {
                var pEngine = this._pTarget.getRenderer().getEngine();
                var pResMgr = pEngine.getResourceManager();

                var pNormalBufferTexture = pResMgr.createTexture("lpp-normal-buffer-" + this.guid);
                var pRenderTarget = null;
                var pViewport = null;

                pNormalBufferTexture.create(iWidth, iHeight, 1, null, 512 /* RENDERTARGET */, 0, 0, 3553 /* TEXTURE_2D */, 25 /* FLOAT32_RGBA */);
                pRenderTarget = pNormalBufferTexture.getBuffer().getRenderTarget();
                pRenderTarget.setAutoUpdated(false);
                pViewport = pRenderTarget.addViewport(new render.ViewportWithTransparencyMode(this.getCamera(), this._csDefaultRenderMethod + "lpp_normal_pass", 0, 0, this.getActualWidth() / pNormalBufferTexture.getWidth(), this.getActualHeight() / pNormalBufferTexture.getHeight()));

                var pDepthTexture = pResMgr.createTexture(".lpp-depth-buffer-" + this.guid);
                pDepthTexture.create(iWidth, iHeight, 1, null, 0, 0, 0, 3553 /* TEXTURE_2D */, 46 /* DEPTH32 */);
                pDepthTexture.setFilter(10240 /* MAG_FILTER */, 9729 /* LINEAR */);
                pDepthTexture.setFilter(10241 /* MIN_FILTER */, 9729 /* LINEAR */);

                pRenderTarget.attachDepthTexture(pDepthTexture);

                pViewport.render.connect(this._onNormalBufferRender);
                this._pNormalBufferTexture = pNormalBufferTexture;
                this.setDepthTexture(pDepthTexture);
            };

            LPPViewport.prototype.createLightBuffersRenderTargets = function (iWidth, iHeight) {
                var pEngine = this._pTarget.getRenderer().getEngine();
                var pResMgr = pEngine.getResourceManager();

                var pRenderTarget = null;
                var pViewport = null;
                var pLightMapTexture = null;

                this._pLightBufferTextures = new Array(2);

                for (var i = 0; i < 2; i++) {
                    pLightMapTexture = pResMgr.createTexture("lpp-light-buffer-" + i + "-" + this.guid);
                    pLightMapTexture.create(iWidth, iHeight, 1, null, 512 /* RENDERTARGET */, 0, 0, 3553 /* TEXTURE_2D */, 25 /* FLOAT32_RGBA */);
                    pRenderTarget = pLightMapTexture.getBuffer().getRenderTarget();
                    pRenderTarget.setAutoUpdated(false);
                    pViewport = pRenderTarget.addViewport(new render.Viewport(this.getCamera(), null, 0, 0, this.getActualWidth() / pLightMapTexture.getWidth(), this.getActualHeight() / pLightMapTexture.getHeight()));

                    pViewport.render.connect(this, this._onLightMapRender);
                    this._pLightBufferTextures[i] = pLightMapTexture;
                }
            };

            LPPViewport.prototype.createResultLPPRenderTarget = function (iWidth, iHeight) {
                var pEngine = this._pTarget.getRenderer().getEngine();
                var pResMgr = pEngine.getResourceManager();

                var pRenderTarget = null;
                var pViewport = null;

                this._pResultLPPTexture = pResMgr.createTexture("resultr-lpp-texture-" + this.guid);
                this._pResultLPPTexture.create(iWidth, iHeight, 1, null, 512 /* RENDERTARGET */, 0, 0, 3553 /* TEXTURE_2D */, 28 /* R8G8B8A8 */);
                pRenderTarget = this._pResultLPPTexture.getBuffer().getRenderTarget();
                pRenderTarget.setAutoUpdated(false);
                pRenderTarget.attachDepthTexture(this.getDepthTexture());
                pViewport = pRenderTarget.addViewport(new render.ViewportWithTransparencyMode(this.getCamera(), this._csDefaultRenderMethod + "apply_lpp_shading", 0, 0, this.getActualWidth() / this._pResultLPPTexture.getWidth(), this.getActualHeight() / this._pResultLPPTexture.getHeight()));
                pViewport.setClearEveryFrame(true, 1 /* COLOR */);
                pViewport.setDepthParams(true, false, 4 /* EQUAL */);

                pViewport.render.connect(this, this._onObjectsRender);
            };

            LPPViewport.prototype.prepareRenderMethods = function () {
                this._pViewScreen.switchRenderMethod(null);
                this._pViewScreen.getEffect().addComponent("akra.system.texture_to_screen");

                for (var i = 0; i < 2; i++) {
                    var sRenderMethod = i === 0 ? ".prepare_diffuse_specular" : ".prepare_ambient";
                    var sName = i === 0 ? "passA" : "passB";

                    if (this._pViewScreen.addRenderMethod(sRenderMethod, sName)) {
                        var pLPPMethod = this._pViewScreen.getRenderMethodByName(sName);
                        var pLPPEffect = pLPPMethod.getEffect();

                        pLPPEffect.addComponent("akra.system.prepare_lpp_lights_base");
                        pLPPEffect.addComponent("akra.system.omniLighting");
                        pLPPEffect.addComponent("akra.system.omniLightingRestricted");
                        pLPPEffect.addComponent("akra.system.projectLighting");
                        pLPPEffect.addComponent("akra.system.omniShadowsLighting");
                        pLPPEffect.addComponent("akra.system.projectShadowsLighting");
                        pLPPEffect.addComponent("akra.system.sunLighting");
                        pLPPEffect.addComponent("akra.system.sunShadowsLighting");

                        pLPPMethod.setForeign("PREPARE_ONLY_POSITION", this.getShadingModel() !== 2 /* PBS_SIMPLE */ && i === 1);
                        pLPPMethod.setForeign("IS_FOR_LPP_PASS0", i === 0);
                        pLPPMethod.setForeign("IS_FOR_LPP_PASS1", i === 1);
                        pLPPMethod.setForeign("IS_FOR_REAL_SHADING", false);
                        pLPPMethod.setForeign("SKIP_ALPHA", false);
                        pLPPMethod.setSurfaceMaterial(null);
                    } else {
                        akra.logger.critical("Cannot initialize LPPViewport(problem with '" + sRenderMethod + "' pass)");
                    }
                }
            };

            LPPViewport.prototype.updateRenderTextureDimensions = function (pTexture) {
                pTexture.reset(akra.math.ceilingPowerOfTwo(this.getActualWidth()), akra.math.ceilingPowerOfTwo(this.getActualHeight()));
                pTexture.getBuffer().getRenderTarget().getViewport(0).setDimensions(0., 0., this.getActualWidth() / pTexture.getWidth(), this.getActualHeight() / pTexture.getHeight());
            };

            LPPViewport.prototype.prepareForLPPShading = function () {
                var pNodeList = this.getCamera().display();

                for (var i = 0; i < pNodeList.getLength(); ++i) {
                    var pSceneObject = pNodeList.value(i);

                    for (var k = 0; k < pSceneObject.getTotalRenderable(); k++) {
                        var pRenderable = pSceneObject.getRenderable(k);
                        var pTechCurr = pRenderable.getTechnique(this._csDefaultRenderMethod);

                        var sMethod = this._csDefaultRenderMethod + "lpp_normal_pass";
                        var pTechnique = null;

                        if (akra.isNull(pRenderable.getTechnique(sMethod))) {
                            if (!pRenderable.addRenderMethod(pRenderable.getRenderMethodByName(this._csDefaultRenderMethod), sMethod)) {
                                akra.logger.critical("cannot create render method for first pass of LPP");
                            }

                            pTechnique = pRenderable.getTechnique(sMethod);
                            pTechnique.render._syncSignal(pTechCurr.render);
                            pTechnique.copyTechniqueOwnComponentBlend(pTechCurr);
                            pTechnique.addComponent("akra.system.prepare_lpp_geometry");
                        }

                        sMethod = this._csDefaultRenderMethod + "apply_lpp_shading";

                        if (akra.isNull(pRenderable.getTechnique(sMethod))) {
                            if (!pRenderable.addRenderMethod(pRenderable.getRenderMethodByName(this._csDefaultRenderMethod), sMethod)) {
                                akra.logger.critical("cannot create render method for first pass of LPP");
                            }

                            pTechnique = pRenderable.getTechnique(sMethod);
                            pTechnique.render._syncSignal(pTechCurr.render);
                            pTechnique.copyTechniqueOwnComponentBlend(pTechCurr);
                            pTechnique.addComponent("akra.system.apply_lpp_shading");
                            pTechnique.addComponent("akra.system.pbsReflection");
                        }
                    }
                }
            };
            return LPPViewport;
        })(render.ShadedViewport);
        render.LPPViewport = LPPViewport;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="IViewport3D.ts" />
/// <reference path="../idl/IForwardViewport.ts" />
/// <reference path="Viewport.ts" />
/// <reference path="Viewport3D.ts" />
/// <reference path="ShadedViewport.ts" />
/// <reference path="../scene/Scene3d.ts" />
/// <reference path="LightingUniforms.ts" />
var akra;
(function (akra) {
    (function (render) {
        var Vec2 = akra.math.Vec2;
        var Vec3 = akra.math.Vec3;

        var Mat4 = akra.math.Mat4;

        var Color = akra.color.Color;

        var pDepthPixel = new akra.pixelUtil.PixelBox(new akra.geometry.Box(0, 0, 1, 1), 29 /* FLOAT32_DEPTH */, new Uint8Array(4 * 1));
        var pFloatColorPixel = new akra.pixelUtil.PixelBox(new akra.geometry.Box(0, 0, 1, 1), 25 /* FLOAT32_RGBA */, new Uint8Array(4 * 4));
        var pColor = new Color(0);

        ;

        var ForwardViewport = (function (_super) {
            __extends(ForwardViewport, _super);
            function ForwardViewport(pCamera, fLeft, fTop, fWidth, fHeight, iZIndex) {
                if (typeof fLeft === "undefined") { fLeft = 0.; }
                if (typeof fTop === "undefined") { fTop = 0.; }
                if (typeof fWidth === "undefined") { fWidth = 1.; }
                if (typeof fHeight === "undefined") { fHeight = 1.; }
                if (typeof iZIndex === "undefined") { iZIndex = 0; }
                _super.call(this, pCamera, null, fLeft, fTop, fWidth, fHeight, iZIndex);
                /** Buffer with objectID */
                this._pTextureWithObjectID = null;
                /** Texture with result of rendereingd(for global posteffects) */
                this._pResultTexture = null;
                this._pViewScreen = null;
                this._v2fTextureRatio = null;
                this._v2fScreenSize = null;
                this._pSkyboxTexture = null;
                this._pTextureToScreenViewport = null;
                this._bRenderOnlyTransparentObjects = false;
                this._pSkybox = null;
                this._isFogEnabled = false;
                this._fnSort = function (a, b) {
                    return b.dist - a.dist;
                };
                this._pTransparencyObjectList = [];
                this._iNumOfTransparencyObjects = 0;
            }
            ForwardViewport.prototype.setupSignals = function () {
                this.addedSkybox = this.addedSkybox || new akra.Signal(this);

                _super.prototype.setupSignals.call(this);
            };

            ForwardViewport.prototype.getType = function () {
                return 6 /* FORWARDVIEWPORT */;
            };

            ForwardViewport.prototype.getView = function () {
                return this._pViewScreen;
            };

            ForwardViewport.prototype.getEffect = function () {
                return this.getView().getRenderMethodDefault().getEffect();
            };

            ForwardViewport.prototype.getSkybox = function () {
                return this._pSkyboxTexture;
            };

            ForwardViewport.prototype.getTextureWithObjectID = function () {
                return this._pTextureWithObjectID;
            };

            ForwardViewport.prototype._renderOnlyTransparentObjects = function (bValue) {
                this._bRenderOnlyTransparentObjects = bValue;

                if (bValue && !this.isTransparencySupported()) {
                    this.setTransparencySupported(true);
                }
            };

            ForwardViewport.prototype._getTransparencyViewport = function () {
                return this.isTransparencySupported() ? this : null;
            };

            ForwardViewport.prototype._setTarget = function (pTarget) {
                _super.prototype._setTarget.call(this, pTarget);

                //common api access
                var pEngine = pTarget.getRenderer().getEngine();
                var pResMgr = pEngine.getResourceManager();

                //renderable for displaying result from deferred textures
                this._pViewScreen = new render.Screen(pEngine.getRenderer());

                //unique idetifier for creation dependent resources
                var iGuid = this.guid;

                //Float point texture must be power of two.
                var iWidth = akra.math.ceilingPowerOfTwo(this.getActualWidth());
                var iHeight = akra.math.ceilingPowerOfTwo(this.getActualHeight());

                //detect max texture resolution correctly
                if (akra.config.WEBGL) {
                    iWidth = akra.math.min(iWidth, akra.webgl.maxTextureSize);
                    iHeight = akra.math.min(iHeight, akra.webgl.maxTextureSize);
                }

                //this.createNormalBufferRenderTarget(iWidth, iHeight);
                //this.createLightBuffersRenderTargets(iWidth, iHeight);
                this.createResultRenderTarget(iWidth, iHeight);

                this._v2fTextureRatio = new akra.math.Vec2(this.getActualWidth() / this._pResultTexture.getWidth(), this.getActualHeight() / this._pResultTexture.getHeight());
                this._v2fScreenSize = new Vec2(this.getActualWidth(), this.getActualHeight());

                this.prepareRenderMethods();

                this.setClearEveryFrame(true, 1 /* COLOR */ | 2 /* DEPTH */);
                this.setBackgroundColor(akra.color.ZERO);
                this.setDepthParams(true, true, 2 /* LESS */);

                this.setFXAA(true);

                this._pTextureToScreenViewport = pTarget.addViewport(new render.Viewport(this.getCamera(), null, this.getLeft(), this.getTop(), this.getWidth(), this.getHeight(), 66));
                this._pTextureToScreenViewport.setAutoUpdated(false);
                this._pTextureToScreenViewport.setClearEveryFrame(true, 1 /* COLOR */);
                this._pTextureToScreenViewport.setDepthParams(false, false, 0);

                this._pTextureToScreenViewport.render.connect(this, this._onScreenRender);
            };

            ForwardViewport.prototype._getRenderId = function (x, y) {
                return 0;
            };

            ForwardViewport.prototype._updateDimensions = function (bEmitEvent) {
                if (typeof bEmitEvent === "undefined") { bEmitEvent = true; }
                _super.prototype._updateDimensions.call(this, false);

                if (akra.isDefAndNotNull(this._pResultTexture)) {
                    this.updateRenderTextureDimensions(this._pResultTexture);

                    this._v2fTextureRatio.set(this.getActualWidth() / this._pResultTexture.getWidth(), this.getActualHeight() / this._pResultTexture.getHeight());
                    this._v2fScreenSize.set(this.getActualWidth(), this.getActualHeight());
                }

                if (bEmitEvent) {
                    this.viewportDimensionsChanged.emit();
                }
            };

            ForwardViewport.prototype._updateImpl = function () {
                var pRenderer = this.getTarget().getRenderer();

                this.prepareForForwardShading();
                this._pCamera._keepLastViewport(this);

                if (this._pSkybox) {
                    this._pSkybox.render(this, ".skybox-render", null);
                    this.getTarget().getRenderer().executeQueue(true);
                }

                //render light map
                var pLights = this.getCamera().display(akra.scene.Scene3d.DL_LIGHTING);

                if (this.isShadowEnabled() && !this._isManualUpdateForLightUniforms()) {
                    for (var i = 0; i < pLights.getLength(); i++) {
                        pLights.value(i)._calculateShadows();
                    }
                }

                this._pLightPoints = pLights;
                this.createLightingUniforms(this.getCamera(), this._pLightPoints, this._pLightingUnifoms);
                this._pCamera._keepLastViewport(this);

                if (!this._bRenderOnlyTransparentObjects) {
                    this.renderAsNormal(this._csDefaultRenderMethod + "forwardShading", this.getCamera());
                    this.getTarget().getRenderer().executeQueue(true);
                }

                if (this.isTransparencySupported()) {
                    this.renderTransparentObjects(this._csDefaultRenderMethod + "forwardShading", this.getCamera());
                    this.getTarget().getRenderer().executeQueue(false);
                }
                //var pRenderer: IRenderer = this._pTarget.getRenderer();
                //var pCurrentViewport: IViewport = pRenderer._getViewport();
                //pRenderer._setViewport(this);
                //(<webgl.WebGLTextureBuffer>this._pResultTexture.getBuffer())._copyFromFramebuffer(0);
                //pRenderer._setViewport(pCurrentViewport);
                //this._pViewScreen.render(this._pTextureToScreenViewport);
                //this.getTarget().getRenderer().executeQueue(false);
                //TODO: use copyTexSubImage2D, for render global postEffects
                //this.renderAsNormal("apply_lpp_shading", this.getCamera());
            };

            ForwardViewport.prototype.renderAsNormal = function (csMethod, pCamera) {
                var pVisibleObjects = pCamera.display();
                var pRenderable;

                for (var i = 0; i < pVisibleObjects.getLength(); ++i) {
                    pVisibleObjects.value(i).prepareForRender(this);
                }

                for (var i = 0; i < pVisibleObjects.getLength(); ++i) {
                    var pSceneObject = pVisibleObjects.value(i);

                    for (var j = 0; j < pSceneObject.getTotalRenderable(); j++) {
                        pRenderable = pSceneObject.getRenderable(j);

                        if (!akra.isNull(pRenderable) && pRenderable.getRenderMethodByName(csMethod) && !(this.isTransparencySupported() && pRenderable.getRenderMethodByName(csMethod).getMaterial().isTransparent())) {
                            pRenderable.render(this, csMethod, pSceneObject);
                        }
                    }
                }
            };

            ForwardViewport.prototype.renderTransparentObjects = function (csMethod, pCamera) {
                if (!this.isTransparencySupported()) {
                    return;
                }

                var pVisibleObjects = pCamera.display();
                var pRenderable;

                this.resetTransparencyObjectsQueue();

                var v3fMidPoint = Vec3.temp();
                var v4fMidPoint = akra.math.Vec4.temp(v3fMidPoint, 1.);

                for (var i = 0; i < pVisibleObjects.getLength(); ++i) {
                    var pSceneObject = pVisibleObjects.value(i);

                    for (var j = 0; j < pSceneObject.getTotalRenderable(); j++) {
                        pRenderable = pSceneObject.getRenderable(j);

                        if (!akra.isNull(pRenderable) && pRenderable.getRenderMethodByName(csMethod) && pRenderable.getRenderMethodByName(csMethod).getMaterial().isTransparent()) {
                            //pRenderable.render(this, csMethod, pSceneObject);
                            var pSubMesh = pRenderable;

                            if (pRenderable.getType() === 1 /* MESH_SUBSET */) {
                                pSubMesh.getBoundingBox().midPoint(v3fMidPoint);
                                v4fMidPoint.set(v3fMidPoint, 1.);
                                pSceneObject.getWorldMatrix().multiplyVec4(v4fMidPoint);
                            } else {
                                v4fMidPoint.set(pSceneObject.getWorldPosition(), 1.);
                            }

                            pCamera.getProjViewMatrix().multiplyVec4(v4fMidPoint);

                            this.pushTransparencyObjectInQueue(v4fMidPoint.z / v4fMidPoint.w, pRenderable, pSceneObject);
                        }
                    }
                }

                this.sortTransparencyObjectsQueue();
                this.renderTransparencyObjectsQueue(csMethod, pCamera);
            };

            ForwardViewport.prototype.endFrame = function () {
                this.getTarget().getRenderer().executeQueue(true);
            };

            ForwardViewport.prototype.setSkybox = function (pSkyTexture) {
                if (pSkyTexture.getTextureType() !== 34067 /* TEXTURE_CUBE_MAP */) {
                    return null;
                }

                this._pSkyboxTexture = pSkyTexture;

                this.addedSkybox.emit(pSkyTexture);

                return true;
            };

            ForwardViewport.prototype.setSkyboxModel = function (pRenderable) {
                this._pSkybox = pRenderable;
                pRenderable.addRenderMethod(".skybox-render", ".skybox-render");
                pRenderable.getRenderMethodByName(".skybox-render").getEffect().addComponent("akra.system.skybox_model");
                pRenderable.getRenderMethodByName(".skybox-render").getEffect().addComponent("akra.system.fogForForward");
                var pMat = new Mat4();
                pMat.identity();

                pRenderable.getTechnique(".skybox-render").render.connect(function (pTech, iPass, pRenderable, pSceneObject, pViewport) {
                    pMat.set(pViewport.getCamera().getFarPlane(), pViewport.getCamera().getFarPlane(), pViewport.getCamera().getFarPlane(), 1.);

                    pTech.getPass(iPass).setTexture("SKYBOX_TEXTURE", pViewport.getSkybox());
                    pTech.getPass(iPass).setUniform("MODEL_MATRIX", pMat);
                });
            };

            ForwardViewport.prototype.setFXAA = function (bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                var pEffect = this.getEffect();

                if (bValue) {
                    pEffect.addComponent("akra.system.fxaa", 2, 0);
                } else {
                    pEffect.delComponent("akra.system.fxaa", 2, 0);
                }
            };

            ForwardViewport.prototype.isFXAA = function () {
                return this.getEffect().hasComponent("akra.system.fxaa");
            };

            ForwardViewport.prototype.setAntialiasing = function (bEnabled) {
                if (typeof bEnabled === "undefined") { bEnabled = true; }
                this.setFXAA(true);
            };

            ForwardViewport.prototype.isAntialiased = function () {
                return this.isFXAA();
            };

            ForwardViewport.prototype.highlight = function (a) {
            };

            ForwardViewport.prototype.setFog = function (bEnabled) {
                if (typeof bEnabled === "undefined") { bEnabled = true; }
                this._isFogEnabled = bEnabled;
            };

            ForwardViewport.prototype.isFogged = function () {
                return this._isFogEnabled;
            };

            ForwardViewport.prototype._onScreenRender = function (pViewport, pTechnique, iPass, pRenderable, pSceneObject) {
                var pPass = pTechnique.getPass(iPass);

                switch (iPass) {
                    case 0:
                        pPass.setUniform("VIEWPORT", akra.math.Vec4.temp(0., 0., this._v2fTextureRatio.x, this._v2fTextureRatio.y));
                        pPass.setTexture("TEXTURE_FOR_SCREEN", this._pResultTexture);
                        pPass.setForeign("SAVE_ALPHA", true);
                        break;
                }
            };

            ForwardViewport.prototype._onRender = function (pTechnique, iPass, pRenderable, pSceneObject) {
                var pPass = pTechnique.getPass(iPass);

                var pLightUniforms = this._pLightingUnifoms;
                var pLightPoints = this._pLightPoints;
                var pCamera = this.getCamera();

                //if (pRenderable["transparency"]) {
                //	pPass.setRenderState
                //}
                pPass.setForeign("NUM_OMNI", pLightUniforms.omni.length);
                pPass.setForeign("NUM_OMNI_SHADOWS", pLightUniforms.omniShadows.length);
                pPass.setForeign("NUM_PROJECT", pLightUniforms.project.length);
                pPass.setForeign("NUM_PROJECT_SHADOWS", pLightUniforms.projectShadows.length);
                pPass.setForeign("NUM_SUN", pLightUniforms.sun.length);
                pPass.setForeign("NUM_SUN_SHADOWS", pLightUniforms.sunShadows.length);

                pPass.setForeign("NUM_OMNI_RESTRICTED", pLightUniforms.omniRestricted.length);

                pPass.setStruct("points_omni", pLightUniforms.omni);
                pPass.setStruct("points_project", pLightUniforms.project);
                pPass.setStruct("points_omni_shadows", pLightUniforms.omniShadows);
                pPass.setStruct("points_project_shadows", pLightUniforms.projectShadows);
                pPass.setStruct("points_sun", pLightUniforms.sun);
                pPass.setStruct("points_sun_shadows", pLightUniforms.sunShadows);

                pPass.setStruct("points_omni_restricted", pLightUniforms.omniRestricted);

                //for (var i: int = 0; i < pLightUniforms.textures.length; i++) {
                //	pPass.setTexture("SHADOW_TEXTURE" + i, pLightUniforms.textures[i]);
                //}
                pPass.setUniform("PROJECT_SHADOW_SAMPLER", pLightUniforms.samplersProject);
                pPass.setUniform("OMNI_SHADOW_SAMPLER", pLightUniforms.samplersOmni);
                pPass.setUniform("SUN_SHADOW_SAMPLER", pLightUniforms.samplersSun);

                pPass.setUniform("MIN_SHADOW_VALUE", 0.5);
                pPass.setUniform("SHADOW_CONSTANT", 5.e+2);

                //pPass.setUniform("SCREEN_TEXTURE_RATIO", this._v2fTextureRatio);
                pPass.setForeign("IS_USED_PNONG", this.getShadingModel() === 1 /* PHONG */);
                pPass.setForeign("IS_USED_BLINN_PNONG", this.getShadingModel() === 0 /* BLINNPHONG */);
                pPass.setForeign("IS_USED_PBS_SIMPLE", this.getShadingModel() === 2 /* PBS_SIMPLE */);
                pPass.setForeign("SKIP_ALPHA", false);

                if (akra.isDefAndNotNull(this.getDefaultEnvironmentMap())) {
                    pPass.setForeign("IS_USED_PBS_REFLECTIONS", true);
                    pPass.setTexture("ENVMAP", this.getDefaultEnvironmentMap());
                } else {
                    pPass.setForeign("IS_USED_PBS_REFLECTIONS", false);
                }

                pPass.setForeign("IS_FOG_ENABLED", this._isFogEnabled);
            };

            ForwardViewport.prototype.prepareForForwardShading = function () {
                var pNodeList = this.getCamera().display();

                for (var i = 0; i < pNodeList.getLength(); ++i) {
                    var pSceneObject = pNodeList.value(i);

                    for (var k = 0; k < pSceneObject.getTotalRenderable(); k++) {
                        var pRenderable = pSceneObject.getRenderable(k);
                        var pTechCurr = pRenderable.getTechnique(this._csDefaultRenderMethod);

                        var sMethod = this._csDefaultRenderMethod + "forwardShading";
                        var pTechnique = null;

                        if (akra.isNull(pRenderable.getTechnique(sMethod))) {
                            if (!pRenderable.addRenderMethod(pRenderable.getRenderMethodByName(this._csDefaultRenderMethod), sMethod)) {
                                akra.logger.critical("cannot create render method for ForwardShading");
                            }

                            pTechnique = pRenderable.getTechnique(sMethod);
                            pTechnique.render._syncSignal(pTechCurr.render);
                            pTechnique.copyTechniqueOwnComponentBlend(pTechCurr);

                            pTechnique.addComponent("akra.system.applyForwardShading");
                            pTechnique.addComponent("akra.system.omniLighting");
                            pTechnique.addComponent("akra.system.omniLightingRestricted");
                            pTechnique.addComponent("akra.system.projectLighting");
                            pTechnique.addComponent("akra.system.omniShadowsLighting");
                            pTechnique.addComponent("akra.system.projectShadowsLighting");
                            pTechnique.addComponent("akra.system.sunLighting");
                            pTechnique.addComponent("akra.system.sunShadowsLighting");
                            pTechnique.addComponent("akra.system.pbsReflection");

                            //pTechnique.addComponent("akra.system.forceSetAlpha");
                            pTechnique.addComponent("akra.system.applyAlpha");
                            pTechnique.addComponent("akra.system.fogForForward");
                        }
                    }
                }
            };

            ForwardViewport.prototype.updateRenderTextureDimensions = function (pTexture) {
                pTexture.reset(akra.math.ceilingPowerOfTwo(this.getActualWidth()), akra.math.ceilingPowerOfTwo(this.getActualHeight()));
                pTexture.getBuffer().getRenderTarget().getViewport(0).setDimensions(0., 0., this.getActualWidth() / pTexture.getWidth(), this.getActualHeight() / pTexture.getHeight());
            };

            ForwardViewport.prototype.prepareRenderMethods = function () {
                this._pViewScreen.switchRenderMethod(null);
                this._pViewScreen.getEffect().addComponent("akra.system.texture_to_screen");
            };

            ForwardViewport.prototype.createResultRenderTarget = function (iWidth, iHeight) {
                var pEngine = this._pTarget.getRenderer().getEngine();
                var pResMgr = pEngine.getResourceManager();

                var pRenderTarget = null;
                var pViewport = null;

                this._pResultTexture = pResMgr.createTexture("resultr-forward-texture-" + this.guid);
                this._pResultTexture.create(iWidth, iHeight, 1, null, 512 /* RENDERTARGET */, 0, 0, 3553 /* TEXTURE_2D */, 28 /* R8G8B8A8 */);
                pRenderTarget = this._pResultTexture.getBuffer().getRenderTarget();
                pRenderTarget.setAutoUpdated(false);

                pViewport = pRenderTarget.addViewport(new render.Viewport(this.getCamera(), null, 0, 0, this.getActualWidth() / this._pResultTexture.getWidth(), this.getActualHeight() / this._pResultTexture.getHeight()));
                pViewport.setClearEveryFrame(true, 1 /* COLOR */);
                pViewport.setDepthParams(false, false, 4 /* EQUAL */);
            };

            ForwardViewport.prototype.initTextureForTransparentObjects = function () {
            };

            ForwardViewport.prototype.resetTransparencyObjectsQueue = function () {
                this._iNumOfTransparencyObjects = 0;
            };

            ForwardViewport.prototype.pushTransparencyObjectInQueue = function (fDistance, pRenderable, pSceneObject) {
                var pInfo = null;

                if (this._iNumOfTransparencyObjects === this._pTransparencyObjectList.length) {
                    pInfo = this._pTransparencyObjectList[this._iNumOfTransparencyObjects] = {
                        distance: fDistance,
                        renderable: pRenderable,
                        sceneObject: pSceneObject
                    };
                } else {
                    pInfo = this._pTransparencyObjectList[this._iNumOfTransparencyObjects];
                    pInfo.distance = fDistance;
                    pInfo.renderable = pRenderable;
                    pInfo.sceneObject = pSceneObject;
                }

                this._iNumOfTransparencyObjects++;
            };

            ForwardViewport.prototype.sortTransparencyObjectsQueue = function (iStart, iEnd) {
                if (typeof iStart === "undefined") { iStart = 0; }
                if (typeof iEnd === "undefined") { iEnd = (this._iNumOfTransparencyObjects - 1); }
                if (iEnd === -1) {
                    return;
                }
                var i = iStart;
                var j = iEnd;
                var fMiddle = this._pTransparencyObjectList[(iStart + iEnd) >> 1].distance;

                do {
                    while (this._pTransparencyObjectList[i].distance > fMiddle)
                        ++i;
                    while (this._pTransparencyObjectList[j].distance < fMiddle)
                        --j;

                    if (i <= j) {
                        var pTemp = this._pTransparencyObjectList[i];
                        this._pTransparencyObjectList[i] = this._pTransparencyObjectList[j];
                        this._pTransparencyObjectList[j] = pTemp;
                        i++;
                        j--;
                    }
                } while(i < j);

                if (iStart < j)
                    this.sortTransparencyObjectsQueue(iStart, j);
                if (i < iEnd)
                    this.sortTransparencyObjectsQueue(i, iEnd);
            };

            ForwardViewport.prototype.renderTransparencyObjectsQueue = function (csMethod, pCamera) {
                for (var i = 0; i < this._iNumOfTransparencyObjects; i++) {
                    this._pTransparencyObjectList[i].renderable.render(this, csMethod, this._pTransparencyObjectList[i].sceneObject);
                }
            };
            return ForwardViewport;
        })(render.ShadedViewport);
        render.ForwardViewport = ForwardViewport;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="IViewport.ts" />
/// <reference path="IPlane3d.ts" />
/// <reference path="../idl/IMirrorViewport.ts" />
/// <reference path="Viewport.ts" />
/// <reference path="../scene/Scene3d.ts" />
/// <reference path="LightingUniforms.ts" />
var akra;
(function (akra) {
    (function (render) {
        var Vec3 = akra.math.Vec3;

        var Color = akra.color.Color;

        var pDepthPixel = new akra.pixelUtil.PixelBox(new akra.geometry.Box(0, 0, 1, 1), 29 /* FLOAT32_DEPTH */, new Uint8Array(4 * 1));
        var pFloatColorPixel = new akra.pixelUtil.PixelBox(new akra.geometry.Box(0, 0, 1, 1), 25 /* FLOAT32_RGBA */, new Uint8Array(4 * 4));
        var pColor = new Color(0);

        var MirrorViewport = (function (_super) {
            __extends(MirrorViewport, _super);
            function MirrorViewport(pCamera, fLeft, fTop, fWidth, fHeight, iZIndex) {
                if (typeof fLeft === "undefined") { fLeft = 0.; }
                if (typeof fTop === "undefined") { fTop = 0.; }
                if (typeof fWidth === "undefined") { fWidth = 1.; }
                if (typeof fHeight === "undefined") { fHeight = 1.; }
                if (typeof iZIndex === "undefined") { iZIndex = 0; }
                _super.call(this, pCamera, null, fLeft, fTop, fWidth, fHeight, iZIndex);
                this._pReflectionPlane = new akra.geometry.Plane3d(Vec3.temp(0., 1., 0.), -1.24);
                this._pInternal3dViewport = null;
                this._v4fReflPlaneStruct = new akra.math.Vec4();
            }
            MirrorViewport.prototype.getReflectionPlane = function () {
                return this._pReflectionPlane;
            };

            MirrorViewport.prototype.getInternalViewport = function () {
                return this._pInternal3dViewport;
            };

            MirrorViewport.prototype._setTarget = function (pTarget) {
                _super.prototype._setTarget.call(this, pTarget);

                this._pInternal3dViewport = new render.ForwardViewport(this.getCamera(), this.getLeft(), this.getTop(), this.getWidth(), this.getHeight(), 1001);
                this._pInternal3dViewport._setDefaultRenderMethod(this._csDefaultRenderMethod + "render_plane_culling");
                pTarget.addViewport(this._pInternal3dViewport);
                this._pInternal3dViewport.setAutoUpdated(false);
                this._pInternal3dViewport.setShadowEnabled(false);
                this._pInternal3dViewport.setTransparencySupported(false);
            };

            MirrorViewport.prototype._updateImpl = function () {
                this._v4fReflPlaneStruct.set(this._pReflectionPlane.normal, this._pReflectionPlane.distance);
                this.prepareForMirrorRender();
                this._pInternal3dViewport.update();
            };
            MirrorViewport.prototype._onRenderReflection = function (pTech, iPass, pRenderable, pSceneObject, pViewport) {
                if (pViewport === this._pInternal3dViewport) {
                    pTech.getPass(iPass).setUniform("MESH_IS_CULLED_BY_PLANE", true);
                    pTech.getPass(iPass).setUniform("MESH_CULLING_PLANE", this._v4fReflPlaneStruct);
                }
            };
            MirrorViewport.prototype.prepareForMirrorRender = function () {
                var pNodeList = this.getCamera().display();

                for (var i = 0; i < pNodeList.getLength(); ++i) {
                    var pSceneObject = pNodeList.value(i);

                    for (var k = 0; k < pSceneObject.getTotalRenderable(); k++) {
                        var pRenderable = pSceneObject.getRenderable(k);
                        var pTechCurr = pRenderable.getTechnique(this._csDefaultRenderMethod);

                        var sMethod = this._csDefaultRenderMethod + "render_plane_culling";
                        var pTechnique = null;

                        if (akra.isNull(pRenderable.getTechnique(sMethod))) {
                            if (!pRenderable.addRenderMethod(pRenderable.getRenderMethodByName(this._csDefaultRenderMethod), sMethod)) {
                                akra.logger.critical("error adding render_plane_culling render method");
                            }

                            pTechnique = pRenderable.getTechnique(sMethod);
                            pTechnique.render._syncSignal(pTechCurr.render);
                            pTechnique.copyTechniqueOwnComponentBlend(pTechCurr);
                            pTechnique.addComponent("akra.system.render_plane_culling");
                            pTechnique.render.connect(this, this._onRenderReflection);
                        }
                    }
                }
            };
            return MirrorViewport;
        })(render.Viewport);
        render.MirrorViewport = MirrorViewport;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="Viewport.ts" />
/// <reference path="../idl/IObjectArray.ts" />
/// <reference path="../idl/IRenderTexture.ts" />
var akra;
(function (akra) {
    (function (render) {
        var DEFAULT_COLORPICKER_NAME = ".color-picker";

        var pPixel = new akra.pixelUtil.PixelBox(new akra.geometry.Box(0, 0, 1, 1), 28 /* BYTE_RGBA */, new Uint8Array(4));

        var ColorViewport = (function (_super) {
            __extends(ColorViewport, _super);
            function ColorViewport(pCamera, fLeft, fTop, fWidth, fHeight, iZIndex) {
                if (typeof fLeft === "undefined") { fLeft = 0.; }
                if (typeof fTop === "undefined") { fTop = 0.; }
                if (typeof fWidth === "undefined") { fWidth = 1.; }
                if (typeof fHeight === "undefined") { fHeight = 1.; }
                if (typeof iZIndex === "undefined") { iZIndex = 0; }
                _super.call(this, pCamera, DEFAULT_COLORPICKER_NAME, fLeft, fTop, fWidth, fHeight, iZIndex);
                this._pGuidToColorMap = {};
                this._pColorToSceneObjectMap = new Array(256);
                this._pColorToRenderableMap = new Array(256);
            }
            ColorViewport.prototype.getGuidToColorMap = function () {
                return this._pGuidToColorMap;
            };

            ColorViewport.prototype.getType = function () {
                return 3 /* COLORVIEWPORT */;
            };

            ColorViewport.prototype._updateImpl = function () {
                var pVisibleObjects = this.getCamera().display();
                var pRenderable;

                for (var i = 0; i < pVisibleObjects.getLength(); ++i) {
                    pVisibleObjects.value(i).prepareForRender(this);
                }

                for (var i = 0; i < 256; ++i) {
                    this._pColorToSceneObjectMap[i] = null;
                    this._pColorToRenderableMap[i] = null;
                }

                for (var g in this._pGuidToColorMap) {
                    this._pGuidToColorMap[g] = 0;
                }

                var r = 1;
                var s = 1;

                for (var i = 0; i < pVisibleObjects.getLength(); ++i) {
                    var pSceneObject = pVisibleObjects.value(i);

                    this._pGuidToColorMap[pSceneObject.guid] = s;
                    this._pColorToSceneObjectMap[s] = pSceneObject;
                    s++;

                    for (var j = 0; j < pSceneObject.getTotalRenderable(); j++) {
                        pRenderable = pSceneObject.getRenderable(j);

                        if (!akra.isNull(pRenderable) && !pRenderable.isFrozen()) {
                            this._pGuidToColorMap[pRenderable.guid] = r;
                            this._pColorToRenderableMap[r] = pRenderable;
                            r++;

                            this.prepareRenderableForPicking(pRenderable);
                            pRenderable.render(this, this._csDefaultRenderMethod, pSceneObject);
                        }
                    }
                }
                // this._pCamera = pOldCamera;
            };

            ColorViewport.prototype.pick = function (x, y) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                var pTarget = this.getTarget();

                if (pTarget instanceof render.RenderTexture) {
                    var pPixelBuffer = pTarget.getPixelBuffer();
                    x = akra.math.round(x);
                    y = akra.math.round(y);

                    pPixel.left = x;
                    pPixel.right = x + 1;
                    pPixel.top = y;
                    pPixel.bottom = y + 1;

                    if (pPixelBuffer.readPixels(pPixel)) {
                        console.log(pPixel.data[0], pPixel.data[1], pPixel.data[2], pPixel.data[3]);
                        return {
                            object: this._pColorToSceneObjectMap[pPixel.data[0]] || null,
                            renderable: this._pColorToRenderableMap[pPixel.data[1]] || null
                        };
                    }
                }

                return null;
            };

            ColorViewport.prototype._onRender = function (pTechnique, iPass, pRenderable, pSceneObject) {
                var pPass = pTechnique.getPass(iPass);

                pPass.setUniform("RENDERABLE_ID", this.getGuidToColorMap()[pRenderable.guid]);
                pPass.setUniform("OPTIMIZED_PROJ_MATRIX", this.getCamera().getProjectionMatrix());

                //pPass.setUniform("color", util.colorToVec4(util.randomColor(true)));
                if (!akra.isNull(pSceneObject)) {
                    pPass.setUniform("SCENE_OBJECT_ID", this.getGuidToColorMap()[pSceneObject.guid]);
                }

                _super.prototype._onRender.call(this, pTechnique, iPass, pRenderable, pSceneObject);
            };

            ColorViewport.prototype.prepareRenderableForPicking = function (pRenderable) {
                var pRenderTechnique = pRenderable.getTechnique(this._csDefaultRenderMethod);

                if (!akra.isNull(pRenderTechnique)) {
                    return;
                }

                var pRmgr = this.getTarget().getRenderer().getEngine().getResourceManager();
                var pMethodPool = pRmgr.getRenderMethodPool();
                var pMethod = pMethodPool.findResource(".method-color-picker");

                if (akra.isNull(pMethod)) {
                    pMethod = pRmgr.createRenderMethod(".method-color-picker");
                    pMethod.setEffect(pRmgr.createEffect(".effect-color-picker"));
                    pMethod.getEffect().addComponent("akra.system.colorPicker");
                }

                pRenderable.addRenderMethod(pMethod, this._csDefaultRenderMethod);
            };
            return ColorViewport;
        })(render.Viewport);
        render.ColorViewport = ColorViewport;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="Viewport.ts" />
/// <reference path="../scene/light/ShadowCaster.ts" />
var akra;
(function (akra) {
    //#define DEFAULT_SHADOW_TECHNIQUE_NAME ".prepare-shadows"
    (function (render) {
        var DEFAULT_SHADOW_TECHNIQUE_NAME = ".prepare-shadows";

        var ShadowViewport = (function (_super) {
            __extends(ShadowViewport, _super);
            function ShadowViewport(pCamera, fLeft, fTop, fWidth, fHeight, iZIndex) {
                if (typeof fLeft === "undefined") { fLeft = 0.; }
                if (typeof fTop === "undefined") { fTop = 0.; }
                if (typeof fWidth === "undefined") { fWidth = 1.; }
                if (typeof fHeight === "undefined") { fHeight = 1.; }
                if (typeof iZIndex === "undefined") { iZIndex = 0; }
                _super.call(this, pCamera, DEFAULT_SHADOW_TECHNIQUE_NAME, fLeft, fTop, fWidth, fHeight, iZIndex);

                this.setClearEveryFrame(true, 2 /* DEPTH */);
                this.setDepthParams(true, true, 2 /* LESS */);
                this.setDepthClear(1.);
            }
            ShadowViewport.prototype.getType = function () {
                return 2 /* SHADOWVIEWPORT */;
            };

            ShadowViewport.prototype._updateImpl = function () {
                // LOG("SAHDOW VIEWPORT #" + this.getGuid());
                var pShadowCaster = this._pCamera;
                var pAffectedObjects = pShadowCaster.getAffectedObjects();

                var pRenderable;
                var pSceneObject;

                var nShadowsCasted = 0;

                for (var i = 0; i < pAffectedObjects.getLength(); i++) {
                    pSceneObject = pAffectedObjects.value(i);

                    if (pSceneObject.getShadow()) {
                        for (var j = 0; j < pSceneObject.getTotalRenderable(); j++) {
                            pRenderable = pSceneObject.getRenderable(j);

                            if (!akra.isNull(pRenderable) && pRenderable.getShadow()) {
                                this.prepareRenderableForShadows(pRenderable);
                                pRenderable.render(this, this._csDefaultRenderMethod, pSceneObject);
                                nShadowsCasted++;
                            }
                        }
                    }
                }

                pShadowCaster.setShadowCasted((nShadowsCasted > 0) ? true : false);
            };

            ShadowViewport.prototype.prepareRenderableForShadows = function (pRenderable) {
                var pRenderTechnique = pRenderable.getTechnique(this._csDefaultRenderMethod);

                if (!akra.isNull(pRenderTechnique)) {
                    return;
                }

                var pRmgr = this.getTarget().getRenderer().getEngine().getResourceManager();
                var pMethodPool = pRmgr.getRenderMethodPool();

                var pMethod = pMethodPool.findResource(".method-prepare-shadows");

                if (akra.isNull(pMethod)) {
                    pMethod = pRmgr.createRenderMethod(".method-prepare-shadows");
                    pMethod.setEffect(pRmgr.createEffect(".effect-prepare-shadows"));
                    pMethod.getEffect().addComponent("akra.system.prepareShadows");
                }

                pRenderable.addRenderMethod(pMethod, this._csDefaultRenderMethod);
            };

            ShadowViewport.prototype._getDepthRangeImpl = function () {
                var pDepthTexture;
                var pShadowCaster = this._pCamera;

                var pLightPoint = pShadowCaster.getLightPoint();

                switch (pLightPoint.getLightType()) {
                    case 1 /* PROJECT */:
                        pDepthTexture = pLightPoint.getDepthTexture();
                        break;
                    case 2 /* OMNI */:
                        pDepthTexture = pLightPoint.getDepthTextureCube()[pShadowCaster.getFace()];
                        break;
                    default:
                        pDepthTexture = null;
                        break;
                }

                if (akra.isDefAndNotNull(pDepthTexture)) {
                    var pRange = akra.config.WEBGL ? akra.webgl.getDepthRange(pDepthTexture) : { min: 0., max: 1. };
                    console.log("shadow viewport min & max depth range > ", pRange.min, pRange.max);

                    //[0,1] -> [-1, 1]
                    pRange.min = pRange.min * 2. - 1.;
                    pRange.max = pRange.max * 2. - 1.;

                    return pRange;
                }
                return null;
            };
            return ShadowViewport;
        })(render.Viewport);
        render.ShadowViewport = ShadowViewport;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="../idl/IRenderTarget.ts" />
/// <reference path="../idl/IDepthBuffer.ts" />
/// <reference path="../idl/IFrameStats.ts" />
/// <reference path="../idl/IPixelBuffer.ts" />
var akra;
(function (akra) {
    /// <reference path="Viewport.ts" />
    /// <reference path="TextureViewport.ts" />
    /// <reference path="DSViewport.ts" />
    /// <reference path="LPPViewport.ts" />
    /// <reference path="ForwardViewport.ts" />
    /// <reference path="MirrorViewport.ts" />
    /// <reference path="ColorViewport.ts" />
    /// <reference path="ShadowViewport.ts" />
    /// <reference path="../events.ts" />
    /// <reference path="../pixelUtil/pixelUtil.ts" />
    /// <reference path="../config/config.ts" />
    /// <reference path="../guid.ts" />
    (function (render) {
        var RenderTarget = (function () {
            function RenderTarget(pRenderer) {
                this.guid = akra.guid();
                this._iPriority = RenderTarget.DEFAULT_RT_GROUP;
                this._pDepthBuffer = null;
                this._pDepthPixelBuffer = null;
                this._isActive = true;
                this._isAutoUpdate = true;
                this._bHwGamma = false;
                this._pViewportList = [];
                //user event handing
                this._iUserEvents = 0;
                this.setupSignals();
                this._pRenderer = pRenderer;

                //this._pTimer = pRenderer.getEngine().getTimer();
                this._pFrameStats = {
                    fps: {
                        last: 0.,
                        avg: 0.,
                        best: 0.,
                        worst: 0.
                    },
                    time: {
                        best: 0.,
                        worst: 0.
                    },
                    polygonsCount: 0
                };

                this.resetStatistics();
            }
            RenderTarget.prototype.setupSignals = function () {
                this.preUpdate = this.preUpdate || new akra.Signal(this);
                this.postUpdate = this.postUpdate || new akra.Signal(this);

                this.viewportPreUpdate = this.viewportPreUpdate || new akra.Signal(this);
                this.viewportPostUpdate = this.viewportPostUpdate || new akra.Signal(this);
                this.viewportAdded = this.viewportAdded || new akra.Signal(this);
                this.viewportRemoved = this.viewportRemoved || new akra.Signal(this);

                this.resized = this.resized || new akra.Signal(this);
                this.cameraRemoved = this.cameraRemoved || new akra.Signal(this);
            };

            RenderTarget.prototype.getWidth = function () {
                return this._iWidth;
            };

            RenderTarget.prototype.getHeight = function () {
                return this._iHeight;
            };

            RenderTarget.prototype.getColorDepth = function () {
                return this._iColorDepth;
            };

            RenderTarget.prototype.getTotalViewports = function () {
                return this._pViewportList.length;
            };

            RenderTarget.prototype.getTotalFrames = function () {
                return this._iFrameCount;
            };

            RenderTarget.prototype.getPriority = function () {
                return this._iPriority;
            };

            RenderTarget.prototype.getName = function () {
                return this._sName;
            };

            RenderTarget.prototype.setName = function (sName) {
                this._sName = sName;
            };

            RenderTarget.prototype.enableSupportForUserEvent = function (iType) {
                //get events that have not yet been activated
                var iNotActivate = (this._iUserEvents ^ 0x7fffffff) & iType;

                this._iUserEvents = akra.bf.setAll(this._iUserEvents, iNotActivate);

                return iNotActivate;
            };

            RenderTarget.prototype.isUserEventSupported = function (eType) {
                return akra.bf.testAny(this._iUserEvents, eType);
            };

            RenderTarget.prototype.getRenderer = function () {
                return this._pRenderer;
            };

            RenderTarget.prototype.destroy = function () {
                var pViewport;

                for (var i in this._pViewportList) {
                    pViewport = this._pViewportList[i];
                    this.viewportRemoved.emit(pViewport);
                    pViewport.destroy();
                }

                this.detachDepthBuffer();

                akra.debug.log("RenderTarget '%s'\n Average FPS: %s\n Best FPS: %s\n Worst FPS: %s", this._sName, this._pFrameStats.fps.avg, this._pFrameStats.fps.best, this._pFrameStats.fps.worst);
            };

            RenderTarget.prototype.getDepthBuffer = function () {
                return this._pDepthBuffer;
            };

            RenderTarget.prototype.attachDepthBuffer = function (pBuffer) {
                var isOk = false;

                if ((isOk = pBuffer.isCompatible(this))) {
                    this.detachDepthBuffer();
                    this._pDepthBuffer = pBuffer;
                    this._pDepthBuffer._notifyRenderTargetAttached(this);
                }

                return isOk;
            };

            RenderTarget.prototype.attachDepthPixelBuffer = function (pBuffer) {
                if (this._iWidth !== pBuffer.getWidth() || this._iHeight !== pBuffer.getHeight()) {
                    return false;
                }

                var eFormat = pBuffer.getFormat();
                if (eFormat !== 29 /* FLOAT32_DEPTH */ || eFormat !== 44 /* DEPTH8 */) {
                    return false;
                }

                this.detachDepthPixelBuffer();
                this._pDepthPixelBuffer = pBuffer;

                return true;
            };

            RenderTarget.prototype.detachDepthPixelBuffer = function () {
                if (this._pDepthPixelBuffer) {
                    this._pDepthPixelBuffer = null;
                }
            };

            RenderTarget.prototype.detachDepthBuffer = function () {
                if (this._pDepthBuffer) {
                    this._pDepthBuffer._notifyRenderTargetDetached(this);
                    this._pDepthBuffer = null;
                }
            };

            RenderTarget.prototype.attachDepthTexture = function (pTexture) {
                return false;
            };

            RenderTarget.prototype.detachDepthTexture = function () {
            };

            RenderTarget.prototype._detachDepthBuffer = function () {
                this._pDepthBuffer = null;
            };

            RenderTarget.prototype._beginUpdate = function () {
                this.preUpdate.emit();

                this._pFrameStats.polygonsCount = 0;
            };

            RenderTarget.prototype._updateAutoUpdatedViewports = function (bUpdateStatistics) {
                var _this = this;
                if (typeof bUpdateStatistics === "undefined") { bUpdateStatistics = true; }
                this._pViewportList.forEach(function (pViewport, i) {
                    if (pViewport.isAutoUpdated()) {
                        _this._updateViewport(pViewport, bUpdateStatistics);
                    }
                });
            };

            RenderTarget.prototype._endUpdate = function () {
                this.postUpdate.emit();
                this.updateStats();
            };

            RenderTarget.prototype._updateViewport = function (pViewportPtr, bUpdateStatistics) {
                if (typeof bUpdateStatistics === "undefined") { bUpdateStatistics = true; }
                var pViewport;
                var iZIndex;

                if (akra.isNumber(arguments[0])) {
                    iZIndex = arguments[0];
                    pViewport = this._pViewportList[iZIndex];

                    akra.logger.assert(akra.isDefAndNotNull(pViewport), "No viewport with given z-index : %s", iZIndex, "RenderTarget::_updateViewport");
                } else {
                    pViewport = arguments[0];
                }

                akra.logger.assert(pViewport.getTarget() == this, "RenderTarget::_updateViewport the requested viewport is not bound to the rendertarget!");

                this.viewportPreUpdate.emit(pViewport);

                pViewport.update();

                if (bUpdateStatistics) {
                    this._pFrameStats.polygonsCount += pViewport._getNumRenderedPolygons();
                }

                this.viewportPostUpdate.emit(pViewport);
            };

            RenderTarget.prototype.addViewport = function (pViewport) {
                if (akra.isNull(pViewport)) {
                    return null;
                }

                var iZIndex = pViewport.getZIndex();

                if (akra.isDefAndNotNull(this._pViewportList[iZIndex])) {
                    akra.logger.critical("Can't create another viewport for %s with Z-index %s \
					because a viewport exists with this Z-Order already.", this._sName, iZIndex, "RenderTarget::addViewport");
                }

                pViewport._setTarget(this);

                this._pViewportList[iZIndex] = pViewport;
                this.viewportAdded.emit(pViewport);

                return pViewport;
            };

            RenderTarget.prototype.removeViewport = function (iZIndex) {
                var pViewport = this._pViewportList[iZIndex];

                if (akra.isDefAndNotNull(pViewport)) {
                    this.viewportRemoved.emit(pViewport);

                    this._pViewportList.splice(iZIndex, 1);
                    pViewport = null;

                    return true;
                }

                return false;
            };

            RenderTarget.prototype.removeAllViewports = function () {
                var pViewport;
                var iTotal;

                for (var i in this._pViewportList) {
                    pViewport = this._pViewportList[i];
                    this.viewportRemoved.emit(pViewport);
                }

                iTotal = this._pViewportList.length;

                this._pViewportList.clear();

                return iTotal;
            };

            RenderTarget.prototype.getStatistics = function () {
                return this._pFrameStats;
            };

            RenderTarget.prototype.getLastFPS = function () {
                return this._pFrameStats.fps.last;
            };

            RenderTarget.prototype.getAverageFPS = function () {
                return this._pFrameStats.fps.avg;
            };

            RenderTarget.prototype.getBestFPS = function () {
                return this._pFrameStats.fps.best;
            };

            RenderTarget.prototype.getWorstFPS = function () {
                return this._pFrameStats.fps.worst;
            };

            RenderTarget.prototype.getPolygonCount = function () {
                return this._pFrameStats.polygonsCount;
            };

            RenderTarget.prototype.getBestFrameTime = function () {
                return this._pFrameStats.time.best;
            };

            RenderTarget.prototype.getWorstFrameTime = function () {
                return this._pFrameStats.time.worst;
            };

            RenderTarget.prototype.resetStatistics = function () {
                var pStats = this._pFrameStats;
                pStats.fps.avg = 0.;
                pStats.fps.best = 0.;
                pStats.fps.last = 0.;
                pStats.fps.worst = 999.;

                pStats.polygonsCount = 0;

                pStats.time.best = 9999999;
                pStats.time.worst = 0;

                //FIXME: get right time!!!
                this._fLastTime = this._pRenderer.getEngine().getTime();
                this._fLastSecond = this._fLastTime;
                this._iFrameCount = 0;
            };

            RenderTarget.prototype.updateStats = function () {
                this._iFrameCount++;

                var fThisTime = this._pRenderer.getEngine().getTime();

                var fFrameTime = fThisTime - this._fLastTime;

                this._pFrameStats.time.best = akra.math.min(this._pFrameStats.time.best, fFrameTime);
                this._pFrameStats.time.worst = akra.math.min(this._pFrameStats.time.worst, fFrameTime);

                if (fThisTime - this._fLastTime > 1.) {
                    this._pFrameStats.fps.last = this._iFrameCount / (fThisTime - this._fLastSecond);

                    if (this._pFrameStats.fps.avg == 0.) {
                        this._pFrameStats.fps.avg = this._pFrameStats.fps.last;
                    } else {
                        this._pFrameStats.fps.avg = (this._pFrameStats.fps.avg + this._pFrameStats.fps.last) / 2.;

                        this._pFrameStats.fps.best = akra.math.max(this._pFrameStats.fps.best, this._pFrameStats.fps.last);
                        this._pFrameStats.fps.worst = akra.math.max(this._pFrameStats.fps.worst, this._pFrameStats.fps.last);

                        this._fLastSecond = fThisTime;
                        this._iFrameCount = 0;
                    }

                    this._fLastTime = fThisTime;
                }
            };

            RenderTarget.prototype.getCustomAttribute = function (sName) {
                return null;
            };

            RenderTarget.prototype.getViewport = function (iIndex) {
                akra.logger.assert(iIndex < this._pViewportList.length, "Index out of bounds");

                for (var i in this._pViewportList) {
                    if (iIndex--) {
                        continue;
                    }

                    return this._pViewportList[i];
                }

                return null;
            };

            RenderTarget.prototype.getViewportByZIndex = function (iZIndex) {
                var pViewport = this._pViewportList[iZIndex];

                akra.logger.assert(akra.isDefAndNotNull(pViewport), "No viewport with given z-index : " + String(iZIndex), "RenderTarget::getViewportByZIndex");

                return pViewport;
            };

            RenderTarget.prototype.hasViewportByZIndex = function (iZIndex) {
                return akra.isDefAndNotNull(this._pViewportList[iZIndex]);
            };

            RenderTarget.prototype.isActive = function () {
                return this._isActive;
            };

            RenderTarget.prototype.setActive = function (bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                this._isActive = bValue;
            };

            RenderTarget.prototype.setAutoUpdated = function (isAutoUpdate) {
                if (typeof isAutoUpdate === "undefined") { isAutoUpdate = true; }
                this._isAutoUpdate = isAutoUpdate;
            };

            RenderTarget.prototype._notifyCameraRemoved = function (pCamera) {
                var isRemoved = false;
                for (var i in this._pViewportList) {
                    var pViewport = this._pViewportList[i];

                    if (pViewport.getCamera() === pCamera) {
                        pViewport.setCamera(null);
                        isRemoved = true;
                    }
                }

                if (isRemoved) {
                    this.cameraRemoved.emit(pCamera);
                }
            };

            RenderTarget.prototype.isAutoUpdated = function () {
                return this._isAutoUpdate;
            };

            RenderTarget.prototype.isPrimary = function () {
                // RenderWindow will override and return true for the primary window
                return false;
            };

            RenderTarget.prototype.update = function () {
                this.updateImpl();
            };

            RenderTarget.prototype.readPixels = function (ppDest, eFramebuffer) {
                return null;
            };

            RenderTarget.prototype.updateImpl = function () {
                this._beginUpdate();
                this._updateAutoUpdatedViewports(true);
                this._endUpdate();
            };

            RenderTarget.NUM_RENDERTARGET_GROUPS = 10;
            RenderTarget.DEFAULT_RT_GROUP = 4;
            RenderTarget.REND_TO_TEX_RT_GROUP = 2;
            return RenderTarget;
        })();
        render.RenderTarget = RenderTarget;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="../idl/IRenderEntry.ts" />
/// <reference path="../idl/IShaderInput.ts" />
var akra;
(function (akra) {
    (function (render) {
        var RenderEntry = (function () {
            function RenderEntry() {
                //target of rendering
                this.viewport = null;
                this.renderTarget = null;
                //wraper for shader program
                this.maker = null;
                //complex info of native shader data
                // + buffers
                // + uniforms
                // + samplers
                this.input = null;
                //needed for call direct render with index
                this.bufferMap = null;
                this.material = 0;
            }
            RenderEntry.prototype.clear = function () {
                this.maker._releaseShaderInput(this.input);
                this.viewport = null;
                this.renderTarget = null;
                this.bufferMap = null;
                this.input = null;
                this.maker = null;
                this.material = 0;
            };
            return RenderEntry;
        })();
        render.RenderEntry = RenderEntry;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="../idl/IRenderer.ts" />
/// <reference path="../idl/IRenderQueue.ts" />
var akra;
(function (akra) {
    /// <reference path="../util/ObjectArray.ts" />
    /// <reference path="../config/config.ts" />
    /// <reference path="RenderEntry.ts" />
    (function (render) {
        var RenderQueue = (function () {
            function RenderQueue(pRenderer) {
                this._fnSortFunction = null;
                this._pRenderer = pRenderer;
                this._pEntryList = new akra.util.ObjectArray();
                this._fnSortFunction = function (a, b) {
                    if (akra.isNull(a) || akra.isNull(a.maker)) {
                        return 1;
                    }
                    if (akra.isNull(b) || akra.isNull(b.maker)) {
                        return -1;
                    } else {
                        return a.maker.guid - b.maker.guid;
                    }
                };
            }
            RenderQueue.prototype.execute = function (bSort) {
                if (typeof bSort === "undefined") { bSort = false; }
                this._pRenderer._beginRender();
                if (bSort && this._pEntryList.getLength() > 0) {
                    this.quickSortQueue(0, this._pEntryList.getLength() - 1);
                }

                for (var i = 0; i < this._pEntryList.getLength(); i++) {
                    var pEntry = this._pEntryList.value(i);

                    this._pRenderer._renderEntry(pEntry);

                    if (!akra.config.__VIEW_INTERNALS__) {
                        this.releaseEntry(pEntry);
                    }
                }

                this._pEntryList.clear(false);

                this._pRenderer._endRender();
            };

            RenderQueue.prototype.quickSortQueue = function (iStart, iEnd) {
                var i = iStart;
                var j = iEnd;
                var iMiddleMaker = this._pEntryList.value((iStart + iEnd) >> 1).maker.guid;
                var iMiddleMaterial = this._pEntryList.value((iStart + iEnd) >> 1).material;

                do {
                    while (this._pEntryList.value(i).maker.guid < iMiddleMaker || (this._pEntryList.value(i).maker.guid === iMiddleMaker && this._pEntryList.value(i).material < iMiddleMaterial))
                        ++i;
                    while (this._pEntryList.value(j).maker.guid > iMiddleMaker || (this._pEntryList.value(j).maker.guid === iMiddleMaker && this._pEntryList.value(j).material > iMiddleMaterial))
                        --j;

                    if (i <= j) {
                        this._pEntryList.swap(i, j);
                        i++;
                        j--;
                    }
                } while(i < j);

                if (iStart < j)
                    this.quickSortQueue(iStart, j);
                if (i < iEnd)
                    this.quickSortQueue(i, iEnd);
            };

            RenderQueue.prototype.push = function (pEntry) {
                this._pEntryList.push(pEntry);
            };

            RenderQueue.prototype.createEntry = function () {
                return RenderQueue.createEntry();
            };

            RenderQueue.prototype.releaseEntry = function (pEntry) {
                return RenderQueue.releaseEntry(pEntry);
            };

            RenderQueue.createEntry = function () {
                return RenderQueue.pool.getLength() > 0 ? RenderQueue.pool.pop() : new render.RenderEntry;
            };

            RenderQueue.releaseEntry = function (pEntry) {
                RenderQueue.pool.push(pEntry);
                pEntry.clear();
            };

            RenderQueue.pool = new akra.util.ObjectArray();
            return RenderQueue;
        })();
        render.RenderQueue = RenderQueue;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="../idl/IRenderer.ts" />
var akra;
(function (akra) {
    /// <reference path="../idl/IAFXComponent.ts" />
    /// <reference path="../idl/IAFXEffect.ts" />
    /// <reference path="../idl/IAFXPreRenderState.ts" />
    /// <reference path="../idl/IAFXComponentBlend.ts" />
    /// <reference path="../idl/IAFXPassBlend.ts" />
    /// <reference path="../idl/IMesh.ts" />
    /// <reference path="../idl/IRenderableObject.ts" />
    /// <reference path="../idl/ISceneObject.ts" />
    /// <reference path="../idl/IBufferMap.ts" />
    /// <reference path="../idl/IShaderProgram.ts" />
    /// <reference path="../idl/ISurfaceMaterial.ts" />
    /// <reference path="../idl/IVertexData.ts" />
    /// <reference path="../idl/IVertexBuffer.ts" />
    /// <reference path="../idl/ITexture.ts" />
    /// <reference path="../idl/IIndexBuffer.ts" />
    /// <reference path="../idl/IRenderResource.ts" />
    /// <reference path="../idl/IRenderEntry.ts" />
    /// <reference path="../idl/IViewport.ts" />
    /// <reference path="../idl/ICanvas3d.ts" />
    /// <reference path="Viewport.ts" />
    /// <reference path="../events.ts" />
    /// <reference path="../render/RenderTarget.ts" />
    /// <reference path="../render/RenderQueue.ts" />
    /// <reference path="../sort/sort.ts" />
    (function (render) {
        render.SShaderPrefixes = {
            k_Sampler: "A_s_",
            k_Header: "A_h_",
            k_Attribute: "A_a_",
            k_Offset: "A_o_",
            k_Texture: "TEXTURE",
            k_Texcoord: "TEXCOORD",
            k_Texmatrix: "TEXMATRIX",
            k_Temp: "TEMP_",
            k_BlendType: "AUTO_BLEND_TYPE_"
        };

        render.ZEROSAMPLER = 19;

        render.SSystemSemantics = {
            MODEL_MATRIX: "MODEL_MATRIX",
            VIEW_MATRIX: "VIEW_MATRIX",
            PROJ_MATRIX: "PROJ_MATRIX",
            NORMAL_MATRIX: "NORMAL_MATRIX",
            BIND_MATRIX: "BIND_SHAPE_MATRIX",
            RENDER_OBJECT_ID: "RENDER_OBJECT_ID"
        };

        var Renderer = (function () {
            function Renderer(pEngine) {
                this.guid = akra.guid();
                this._isActive = false;
                this._pRenderTargets = [];
                this._pPrioritisedRenderTargets = {};
                this._pPriorityList = [];
                this._pRenderQueue = null;
                this._pActiveViewport = null;
                this._pActiveRenderTarget = null;
                /** TODO: FIX RENDER TARGET LOCK*/
                this._bLockRenderTarget = false;
                this.setupSignals();

                this._pEngine = pEngine;

                pEngine.active.connect(this.active);
                pEngine.inactive.connect(this.inactive);

                this._pRenderQueue = new render.RenderQueue(this);
            }
            Renderer.prototype.setupSignals = function () {
                this.active = this.active || new akra.Signal(this);
                this.inactive = this.inactive || new akra.Signal(this);

                this.active.setForerunner(this._activated);
                this.inactive.setForerunner(this._inactivated);
            };

            Renderer.prototype.getType = function () {
                return 0 /* UNKNOWN */;
            };

            Renderer.prototype.getEngine = function () {
                return this._pEngine;
            };

            Renderer.prototype.hasCapability = function (eCapability) {
                return false;
            };

            Renderer.prototype.debug = function (bValue, useApiTrace) {
                return false;
            };

            Renderer.prototype.isDebug = function () {
                return false;
            };

            Renderer.prototype.isValid = function () {
                return true;
            };

            Renderer.prototype.getError = function () {
                return null;
            };

            Renderer.prototype._beginRender = function () {
            };

            Renderer.prototype._renderEntry = function (pEntry) {
            };

            Renderer.prototype._endRender = function () {
            };

            Renderer.prototype.clearFrameBuffer = function (iBuffer, cColor, fDepth, iStencil) {
            };

            Renderer.prototype.attachRenderTarget = function (pTarget) {
                if (this._pRenderTargets.indexOf(pTarget) != -1) {
                    return false;
                }

                var pList = this._pPrioritisedRenderTargets[pTarget.getPriority()];

                if (!akra.isDef(pList)) {
                    pList = this._pPrioritisedRenderTargets[pTarget.getPriority()] = [];
                    this._pPriorityList.push(pTarget.getPriority());
                    this._pPriorityList.sort(akra.sort.minMax);
                }

                pList.push(pTarget);

                this._pRenderTargets.push(pTarget);

                return true;
            };

            Renderer.prototype.detachRenderTarget = function (pTarget) {
                var i = this._pRenderTargets.indexOf(pTarget);

                if (i == -1) {
                    return false;
                }

                this._pRenderTargets.splice(i, 1);

                i = this._pPrioritisedRenderTargets[pTarget.getPriority()].indexOf(pTarget);
                this._pPrioritisedRenderTargets[pTarget.getPriority()].splice(i, 1);

                return true;
            };

            Renderer.prototype.destroyRenderTarget = function (pTarget) {
                var hasTarget = this.detachRenderTarget(pTarget);
                if (hasTarget) {
                    pTarget.destroy();
                    pTarget = null;
                }
            };

            Renderer.prototype.getActiveProgram = function () {
                akra.logger.critical("Renderer::getActiveProgram() is uncompleted method!");
                return null;
            };

            Renderer.prototype._disableAllTextureUnits = function () {
                this._disableTextureUnitsFrom(0);
            };

            Renderer.prototype._disableTextureUnitsFrom = function (iUnit) {
            };

            Renderer.prototype._initRenderTargets = function () {
                for (var i = 0; i < this._pRenderTargets.length; ++i) {
                    this._pRenderTargets[i].resetStatistics();
                }
            };

            Renderer.prototype._updateAllRenderTargets = function () {
                var pTarget;
                for (var i = 0; i < this._pPriorityList.length; i++) {
                    var iPriority = this._pPriorityList[i];
                    var pTargetList = this._pPrioritisedRenderTargets[iPriority];

                    for (var j = 0; j < pTargetList.length; ++j) {
                        pTarget = pTargetList[j];

                        if (pTarget.isActive() && pTarget.isAutoUpdated()) {
                            pTarget.update();
                        }
                    }
                }
            };

            Renderer.prototype._setViewport = function (pViewport) {
            };

            Renderer.prototype._setViewportForRender = function (pViewport) {
                var isViewportUpdate = pViewport !== this._pActiveViewport || pViewport.isUpdated();
                var isRenderTargetUpdate = pViewport.getTarget() !== this._pActiveRenderTarget;

                if (isViewportUpdate || isRenderTargetUpdate) {
                    this._setViewport(pViewport);

                    if (isViewportUpdate) {
                        // pViewport._clearForFrame();
                        var pState = pViewport._getViewportState();

                        this._setCullingMode(pState.cullingMode);
                        this._setDepthBufferParams(pState.depthTest, pState.depthWrite, pState.depthFunction, pState.clearDepth);
                    }
                }
            };

            Renderer.prototype._getViewport = function () {
                return this._pActiveViewport;
            };

            Renderer.prototype._setRenderTarget = function (pTarget) {
            };

            Renderer.prototype._setCullingMode = function (eMode) {
            };

            Renderer.prototype._setDepthBufferParams = function (bDepthTest, bDepthWrite, eDepthFunction, fClearDepth) {
            };

            Renderer.prototype.getDefaultCanvas = function () {
                return null;
            };

            Renderer.prototype.createEntry = function () {
                return this._pRenderQueue.createEntry();
            };

            Renderer.prototype.releaseEntry = function (pEntry) {
                this._pRenderQueue.releaseEntry(pEntry);
            };

            Renderer.prototype.pushEntry = function (pEntry) {
                this._pRenderQueue.push(pEntry);
            };

            Renderer.prototype.executeQueue = function (bSort) {
                if (typeof bSort === "undefined") { bSort = false; }
                this._pRenderQueue.execute(bSort);
            };

            Renderer.prototype._lockRenderTarget = function () {
                this._bLockRenderTarget = true;
            };

            Renderer.prototype._unlockRenderTarget = function () {
                this._bLockRenderTarget = false;
            };

            Renderer.prototype._isLockRenderTarget = function () {
                return this._bLockRenderTarget;
            };

            Renderer.prototype._activated = function () {
                this._isActive = true;
            };

            Renderer.prototype._inactivated = function () {
                this._isActive = false;
            };
            return Renderer;
        })();
        render.Renderer = Renderer;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="../idl/IUtilTimer.ts" />
var akra;
(function (akra) {
    /// <reference path="../time.ts" />
    /// <reference path="../debug.ts" />
    (function (util) {
        var UtilTimer = (function () {
            function UtilTimer() {
                this._isTimerInitialized = false;
                this._isTimerStopped = false;
                this._fTicksPerSec = 0.;
                this._iStopTime = 0;
                this._iLastElapsedTime = 0;
                this._iBaseTime = 0;
            }
            UtilTimer.prototype.getAbsoluteTime = function () {
                return this.execCommand(4 /* TIMER_GET_ABSOLUTE_TIME */);
            };

            UtilTimer.prototype.getAppTime = function () {
                return this.execCommand(5 /* TIMER_GET_APP_TIME */);
            };

            UtilTimer.prototype.getElapsedTime = function () {
                return this.execCommand(6 /* TIMER_GET_ELAPSED_TIME */);
            };

            UtilTimer.prototype.start = function () {
                return this.execCommand(1 /* TIMER_START */) === 0;
            };
            UtilTimer.prototype.stop = function () {
                return this.execCommand(2 /* TIMER_STOP */) === 0;
            };

            UtilTimer.prototype.reset = function () {
                return this.execCommand(0 /* TIMER_RESET */) === 0;
            };

            UtilTimer.prototype.isStopped = function () {
                return this._isTimerStopped;
            };

            UtilTimer.prototype.execCommand = function (eCommand) {
                var fTime = 0.;
                var fElapsedTime = 0.;
                var iTime;

                if (this._isTimerInitialized == false) {
                    this._isTimerInitialized = true;
                    this._fTicksPerSec = 1000;
                }

                // Get either the current time or the stop time, depending
                // on whether we're stopped and what command was sent
                if (this._iStopTime != 0 && eCommand != 1 /* TIMER_START */ && eCommand != 4 /* TIMER_GET_ABSOLUTE_TIME */) {
                    iTime = this._iStopTime;
                } else {
                    iTime = akra.time();
                }

                // Return the elapsed time
                if (eCommand == 6 /* TIMER_GET_ELAPSED_TIME */) {
                    fElapsedTime = (iTime - this._iLastElapsedTime) / this._fTicksPerSec;

                    // LOG(iTime - this.iLastElapsedTime,  this.fTicksPerSec, fElapsedTime);
                    this._iLastElapsedTime = iTime;
                    return fElapsedTime;
                }

                // Return the current time
                if (eCommand == 5 /* TIMER_GET_APP_TIME */) {
                    var fAppTime = (iTime - this._iBaseTime) / this._fTicksPerSec;
                    return fAppTime;
                }

                // Reset the timer
                if (eCommand == 0 /* TIMER_RESET */) {
                    this._iBaseTime = iTime;
                    this._iLastElapsedTime = iTime;
                    this._iStopTime = 0;
                    this._isTimerStopped = false;
                    return 0;
                }

                // Start the timer
                if (eCommand == 1 /* TIMER_START */) {
                    if (this._isTimerStopped) {
                        this._iBaseTime += iTime - this._iStopTime;
                    }
                    this._iStopTime = 0;
                    this._iLastElapsedTime = iTime;
                    this._isTimerStopped = false;
                    return 0;
                }

                // Stop the timer
                if (eCommand == 2 /* TIMER_STOP */) {
                    if (!this._isTimerStopped) {
                        this._iStopTime = iTime;
                        this._iLastElapsedTime = iTime;
                        this._isTimerStopped = true;
                    }
                    return 0;
                }

                // Advance the timer by 1/10th second
                if (eCommand == 3 /* TIMER_ADVANCE */) {
                    this._iStopTime += this._fTicksPerSec / 10;
                    return 0;
                }

                if (eCommand == 4 /* TIMER_GET_ABSOLUTE_TIME */) {
                    fTime = iTime / this._fTicksPerSec;
                    return fTime;
                }

                // Invalid command specified
                return -1;
            };

            UtilTimer.start = function () {
                var pTimer = new UtilTimer;

                if (pTimer.start()) {
                    return pTimer;
                }

                akra.debug.log("cannot start util timer");

                return null;
            };
            return UtilTimer;
        })();
        util.UtilTimer = UtilTimer;
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
/// <reference path="../idl/ICanvas3d.ts" />
/// <reference path="../idl/IRenderer.ts" />
/// <reference path="../idl/IUtilTimer.ts" />
/// <reference path="../idl/ICanvasInfo.ts" />
/// <reference path="../util/UtilTimer.ts" />
var akra;
(function (akra) {
    /// <reference path="RenderTarget.ts" />
    (function (render) {
        var Canvas3d = (function (_super) {
            __extends(Canvas3d, _super);
            function Canvas3d(pRenderer) {
                _super.call(this, pRenderer);
                // private _useHarwareAntialiasing: boolean = false;
                this._isFullscreen = false;
                this._isPrimary = false;
                this._bAutoDeactivatedOnFocusChange = false;
                this._pRenderer = pRenderer;
            }
            Canvas3d.prototype.getLeft = function () {
                return 0;
            };
            Canvas3d.prototype.setLeft = function (iLeft) {
            };

            Canvas3d.prototype.getTop = function () {
                return 0;
            };
            Canvas3d.prototype.setTop = function (iTop) {
            };

            Canvas3d.prototype.getType = function () {
                return 2 /* TYPE_3D */;
            };

            Canvas3d.prototype.create = function (sName, iWidth, iHeight, isFullscreen) {
                if (typeof isFullscreen === "undefined") { isFullscreen = false; }
                return false;
            };

            Canvas3d.prototype.destroy = function () {
            };

            Canvas3d.prototype.setFullscreen = function (isFullscreen) {
            };

            Canvas3d.prototype.setVisible = function (bVisible) {
            };
            Canvas3d.prototype.setDeactivateOnFocusChange = function (bDeactivate) {
                this._bAutoDeactivatedOnFocusChange = bDeactivate;
            };

            Canvas3d.prototype.isFullscreen = function () {
                return this._isFullscreen;
            };

            Canvas3d.prototype.isVisible = function () {
                return true;
            };

            Canvas3d.prototype.isClosed = function () {
                return false;
            };

            Canvas3d.prototype.isPrimary = function () {
                return this._isPrimary;
            };

            Canvas3d.prototype.isDeactivatedOnFocusChange = function () {
                return this._bAutoDeactivatedOnFocusChange;
            };

            Canvas3d.prototype.resize = function (iWidth, iHeight) {
            };
            return Canvas3d;
        })(render.RenderTarget);
        render.Canvas3d = Canvas3d;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="../idl/IClickable.ts" />
/// <reference path="../idl/IRenderer.ts" />
var akra;
(function (akra) {
    /// <reference path="../render/Canvas3d.ts" />
    /// <reference path="../info/info.ts" />
    /// <reference path="webgl.ts" />
    (function (webgl) {
        var Vec2 = akra.math.Vec2;

        function absorbEvent(e) {
            e.preventDefault && e.preventDefault();
            e.stopPropagation && e.stopPropagation();
            e.cancelBubble = true;
            e.preventDefault ? e.preventDefault() : e.returnValue = false;
        }

        function offsetX(e) {
            return e.offsetX == undefined ? e.layerX : e.offsetX;
        }

        function offsetY(e) {
            return e.offsetY == undefined ? e.layerY : e.offsetY;
        }

        var WebGLCanvas = (function (_super) {
            __extends(WebGLCanvas, _super);
            function WebGLCanvas(pRenderer) {
                _super.call(this, pRenderer);
                //last viewport, that can be finded by mouse event
                //needed for simulating mouseover/mouseout events
                this._pUserEventViewportLast = null;
                this._pUserEventDragTarget = null;
                this._pUserEventMouseDownPos = { x: 0, y: 0 };
                //на сколько пикселей надо протащить курсор, чтобы сработал dragging
                this._iUserEventDragDeadZone = 2;
                this._bUserEventDragging = false;
                this._eUserEventDragBtn = 0 /* UNKNOWN */;
                //переменная нужна, для того чтобы пропустить событие клика приходящее после окончания драггинга
                //так как драггинг заканчивается вместе с событием отжатия мыши, которое в свою очередь всегда приходит раньше
                //клика
                this._bUserEventSkipNextClick = false;
                //events, that already has listeners via EventTarget.addEventListener()
                this._iUserHandledEvents = 0;
                this._pCanvas = pRenderer.getHTMLCanvas();
                this._pCanvasCreationInfo = akra.info.canvas(this._pCanvas);
            }
            WebGLCanvas.prototype.setupSignals = function () {
                this.click = this.click || new akra.Signal(this);
                this.mousemove = this.mousemove || new akra.Signal(this);
                this.mousedown = this.mousedown || new akra.Signal(this);
                this.mouseup = this.mouseup || new akra.Signal(this);
                this.mouseover = this.mouseover || new akra.Signal(this);
                this.mouseout = this.mouseout || new akra.Signal(this);
                this.mousewheel = this.mousewheel || new akra.Signal(this);

                this.dragstart = this.dragstart || new akra.Signal(this);
                this.dragstop = this.dragstop || new akra.Signal(this);
                this.dragging = this.dragging || new akra.Signal(this);

                this.click.setForerunner(this._onClick);
                this.mousemove.setForerunner(this._onMousemove);
                this.mousedown.setForerunner(this._onMousedown);
                this.mouseup.setForerunner(this._onMouseup);
                this.mouseover.setForerunner(this._onMouseover);
                this.mouseout.setForerunner(this._onMouseout);
                this.mousewheel.setForerunner(this._onMousewheel);

                this.dragstart.setForerunner(this._onDragstart);
                this.dragstop.setForerunner(this._onDragstop);
                this.dragging.setForerunner(this._onDragging);

                _super.prototype.setupSignals.call(this);
            };

            WebGLCanvas.prototype.getLeft = function () {
                var el = this._pCanvas;
                for (var lx = 0; el != null; lx += el.offsetLeft, el = el.offsetParent) {
                }
                ;
                return lx;
            };

            WebGLCanvas.prototype.setLeft = function (iLeft) {
                //TODO
            };

            WebGLCanvas.prototype.getTop = function () {
                var el = this._pCanvas;
                for (var ly = 0; el != null; ly += el.offsetTop, el = el.offsetParent) {
                }
                ;
                return ly;
            };

            WebGLCanvas.prototype.setTop = function (iTop) {
                //TODO
            };

            WebGLCanvas.prototype.getElement = function () {
                return this._pCanvas;
            };

            WebGLCanvas.prototype.hideCursor = function (bHide) {
                if (typeof bHide === "undefined") { bHide = true; }
                if (bHide) {
                    this.getElement().style.cursor = "none";
                } else {
                    this.getElement().style.cursor = "auto";
                }
            };

            WebGLCanvas.prototype.setCursor = function (sType) {
                this.getElement().style.cursor = sType;
            };

            WebGLCanvas.prototype.create = function (sName, iWidth, iHeight, isFullscreen) {
                if (typeof sName === "undefined") { sName = null; }
                if (typeof iWidth === "undefined") { iWidth = this._pCanvasCreationInfo.width; }
                if (typeof iHeight === "undefined") { iHeight = this._pCanvasCreationInfo.height; }
                if (typeof isFullscreen === "undefined") { isFullscreen = false; }
                this.setName(sName);

                this.resize(iWidth, iHeight);
                this.setFullscreen(isFullscreen);

                return true;
            };

            /** @return TRUE if event already handled, FALSE if not handled */
            WebGLCanvas.prototype.checkOrSaveEventHandler = function (eType) {
                if (this._iUserHandledEvents & eType)
                    return true;
                this._iUserHandledEvents = akra.bf.setAll(this._iUserHandledEvents, eType);
                return false;
            };

            WebGLCanvas.prototype.enableSupportForUserEvent = function (iType) {
                var _this = this;
                var iActivated = _super.prototype.enableSupportForUserEvent.call(this, iType);
                var pEl = this.getElement();
                if ((iActivated & 1 /* CLICK */) && !this.checkOrSaveEventHandler(1 /* CLICK */)) {
                    akra.debug.log("WebGLCanvas activate <CLICK> event handing.");
                    pEl.addEventListener("click", function (e) {
                        absorbEvent(e);

                        //0 --> 149, 149/150 --> 0
                        _this.click.emit(offsetX(e), _this.getHeight() - offsetY(e) - 1);
                        return false;
                    }, true);
                }

                if (akra.bf.testAny(iActivated, 2 /* MOUSEMOVE */ | 16 /* MOUSEOVER */ | 32 /* MOUSEOUT */ | 256 /* DRAGGING */) && !this.checkOrSaveEventHandler(2 /* MOUSEMOVE */)) {
                    akra.debug.log("WebGLCanvas activate <MOUSEMOVE> event handing.");
                    pEl.addEventListener("mousemove", function (e) {
                        absorbEvent(e);
                        _this.mousemove.emit(offsetX(e), _this.getHeight() - offsetY(e) - 1);
                        return false;
                    }, true);
                }

                if (akra.bf.testAny(iActivated, 4 /* MOUSEDOWN */ | 64 /* DRAGSTART */) && !this.checkOrSaveEventHandler(4 /* MOUSEDOWN */)) {
                    akra.debug.log("WebGLCanvas activate <MOUSEDOWN> event handing.");
                    pEl.addEventListener("mousedown", function (e) {
                        absorbEvent(e);
                        _this.mousedown.emit(e.which, offsetX(e), _this.getHeight() - offsetY(e) - 1);
                        return false;
                    }, true);
                }

                if (akra.bf.testAny(iActivated, 8 /* MOUSEUP */ | 128 /* DRAGSTOP */) && !this.checkOrSaveEventHandler(8 /* MOUSEUP */)) {
                    akra.debug.log("WebGLCanvas activate <MOUSEUP> event handing.");
                    pEl.addEventListener("mouseup", function (e) {
                        absorbEvent(e);
                        _this.mouseup.emit(e.which, offsetX(e), _this.getHeight() - offsetY(e) - 1);
                        return false;
                    }, true);
                }

                if ((iActivated & 16 /* MOUSEOVER */) && !this.checkOrSaveEventHandler(16 /* MOUSEOVER */)) {
                    akra.debug.log("WebGLCanvas activate <MOUSEOVER> event handing.");
                    pEl.addEventListener("mouseover", function (e) {
                        absorbEvent(e);
                        _this.mouseover.emit(offsetX(e), _this.getHeight() - offsetY(e) - 1);
                        return false;
                    }, true);
                }

                if ((iActivated & 32 /* MOUSEOUT */) && !this.checkOrSaveEventHandler(32 /* MOUSEOUT */)) {
                    akra.debug.log("WebGLCanvas activate <MOUSEOUT> event handing.");
                    pEl.addEventListener("mouseout", function (e) {
                        absorbEvent(e);
                        _this.mouseout.emit(offsetX(e), _this.getHeight() - offsetY(e) - 1);
                        return false;
                    }, true);
                }

                if ((iActivated & 512 /* MOUSEWHEEL */) && !this.checkOrSaveEventHandler(512 /* MOUSEWHEEL */)) {
                    akra.debug.log("WebGLCanvas activate <MOUSEWHEEL> event handing.");

                    var me = this;

                    function scroll(e) {
                        absorbEvent(e);

                        //FIXME: skipping middle button click
                        if (akra.isDef(e["wheelDeltaX"]) && e["wheelDeltaX"] > 0) {
                            // console.log("skip mouse wheel event:", e);
                            return;
                        }

                        var fDelta = 0.;
                        if ('wheelDelta' in e) {
                            fDelta = e.wheelDelta;
                        } else {
                            // The measurement units of the detail and wheelDelta properties are different.
                            fDelta = -40 * e.detail;
                        }

                        me.mousewheel.emit(offsetX(e), me.getHeight() - offsetY(e) - 1, fDelta);
                        return false;
                    }

                    pEl.addEventListener("DOMMouseScroll", scroll, false);
                    pEl.addEventListener("mousewheel", scroll, false);
                }

                return iActivated;
            };

            WebGLCanvas.prototype.destroy = function () {
                _super.prototype.destroy.call(this);

                this._pCanvas = null;
                this._pCanvasCreationInfo = null;
            };

            WebGLCanvas.prototype.getCustomAttribute = function (sName) {
                return null;
            };

            WebGLCanvas.prototype.setFullscreen = function (isFullscreen) {
                var _this = this;
                if (typeof isFullscreen === "undefined") { isFullscreen = true; }
                var pCanvasElement = this._pCanvas;
                var pScreen;
                var pCanvasInfo;
                var iRealWidth = this._iRealWidth;
                var iRealHeight = this._iRealHeight;
                var pCanvas = this;

                if (this._isFullscreen === isFullscreen) {
                    return;
                }

                if (WebGLCanvas.fullscreenLock) {
                    akra.logger.warn("fullscreen is changing, do not try change before process will be ended");
                    return;
                }

                this._isFullscreen = isFullscreen;

                if (isFullscreen) {
                    iRealWidth = this._iRealWidth = this._iWidth;
                    iRealHeight = this._iRealHeight = this._iHeight;
                }

                var el = pCanvasElement, doc = document, rfs = el.requestFullScreen || el.webkitRequestFullScreen || el.mozRequestFullScreen;

                try  {
                    WebGLCanvas.fullscreenLock = true;

                    if (isFullscreen) {
                        rfs.call(el);
                    }

                    el.onfullscreenchange = el.onmozfullscreenchange = el.onwebkitfullscreenchange = el.onfullscreenchange || (function (e) {
                        if (!!(doc.webkitFullscreenElement || doc.mozFullScreenElement || doc.fullscreenElement)) {
                            pCanvas.resize(akra.info.screen.getWidth(), akra.info.screen.getHeight());
                        } else {
                            _this.setFullscreen(false);
                            pCanvas.resize(iRealWidth, iRealHeight);
                        }

                        WebGLCanvas.fullscreenLock = false;
                    });
                } catch (e) {
                    akra.logger.error("Fullscreen API not supported", e);
                    throw e;
                }
            };

            WebGLCanvas.prototype.isVisible = function () {
                return this._pCanvas.style.display !== "none";
            };

            WebGLCanvas.prototype.setVisible = function (bVisible) {
                if (typeof bVisible === "undefined") { bVisible = true; }
                this._pCanvas.style.display = bVisible ? "block" : "none";
            };

            WebGLCanvas.prototype.resize = function (iWidth, iHeight) {
                if (typeof iWidth === "undefined") { iWidth = this._iWidth; }
                if (typeof iHeight === "undefined") { iHeight = this._iHeight; }
                if (this.getWidth() === iWidth && this.getHeight() === iHeight) {
                    return;
                }

                var pCanvas = this._pCanvas;

                this._iWidth = iWidth;
                this._iHeight = iHeight;

                pCanvas.width = iWidth;
                pCanvas.height = iHeight;

                this.resized.emit(iWidth, iHeight);
            };

            WebGLCanvas.prototype.readPixels = function (ppDest, eFramebuffer) {
                if (typeof ppDest === "undefined") { ppDest = null; }
                if (typeof eFramebuffer === "undefined") { eFramebuffer = 2 /* AUTO */; }
                if (akra.isNull(ppDest)) {
                    var ePixelFormat = 10 /* BYTE_RGB */;

                    ppDest = new akra.pixelUtil.PixelBox(this._iWidth, this._iHeight, 1, ePixelFormat, new Uint8Array(akra.pixelUtil.getMemorySize(this._iWidth, this._iHeight, 1, ePixelFormat)));
                }

                if ((ppDest.right > this._iWidth) || (ppDest.bottom > this._iHeight) || (ppDest.front != 0) || (ppDest.back != 1)) {
                    akra.logger.critical("Invalid box.", "GLXWindow::copyContentsToMemory");
                }

                if (eFramebuffer == 2 /* AUTO */) {
                    eFramebuffer = this._isFullscreen ? 0 /* FRONT */ : 1 /* BACK */;
                }

                var eFormat = webgl.getWebGLFormat(ppDest.format);
                var eType = webgl.getWebGLDataType(ppDest.format);

                if (eFormat == 0 /* NONE */ || eType == 0) {
                    akra.logger.critical("Unsupported format.", "WebGLCanvas::readPixels");
                }

                var pWebGLRenderer = this.getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                pWebGLRenderer._setViewport(this.getViewport(0));
                pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, null);

                // Must change the packing to ensure no overruns!
                pWebGLRenderer.pixelStorei(3333 /* PACK_ALIGNMENT */, 1);

                //glReadBuffer((buffer == FB_FRONT)? gl.FRONT : gl.BACK);
                // LOG("readPixels(", ppDest.left, ppDest.top, ppDest.width, ppDest.height, eFormat, eType, /*ppDest.data,*/ ")");
                pWebGLContext.readPixels(ppDest.left, ppDest.top, ppDest.getWidth(), ppDest.getHeight(), eFormat, eType, ppDest.data);

                // restore default alignment
                pWebGLRenderer.pixelStorei(3333 /* PACK_ALIGNMENT */, 4);

                //vertical flip
                // {
                // 	size_t rowSpan = dst.getWidth() * PixelUtil::getNumElemBytes(dst.format);
                // 	size_t height = dst.getHeight();
                // 	uchar *tmpData = new uchar[rowSpan * height];
                // 	uchar *srcRow = (uchar *)dst.data, *tmpRow = tmpData + (height - 1) * rowSpan;
                // 	while (tmpRow >= tmpData)
                // 	{
                // 		memcpy(tmpRow, srcRow, rowSpan);
                // 		srcRow += rowSpan;
                // 		tmpRow -= rowSpan;
                // 	}
                // 	memcpy(dst.data, tmpData, rowSpan * height);
                // 	delete [] tmpData;
                // }
                return ppDest;
            };

            WebGLCanvas.prototype.findViewportByPosition = function (x, y) {
                //propagation of click event to all viewports, that can be handle it
                var pViewport = null;

                for (var z in this._pViewportList) {
                    var pVp = this._pViewportList[z];
                    if (pVp.getActualLeft() <= x && pVp.getActualTop() <= y && pVp.getActualLeft() + pVp.getActualWidth() > x && pVp.getActualTop() + pVp.getActualHeight() > y) {
                        if (akra.isNull(pViewport) || pVp.getZIndex() > pViewport.getZIndex()) {
                            if (!pVp.isUserEventSupported(1023 /* ANY */)) {
                                akra.debug.log("Dropping the viewport, by virtue of his lack of support for 3D events.", pViewport);
                                continue;
                            }

                            pViewport = pVp;
                        }
                    }
                }

                return pViewport;
            };

            WebGLCanvas.prototype.getViewportByMouseEvent = function (x, y) {
                var pViewportCurr = this.findViewportByPosition(x, y);
                var pViewportPrev = this._pUserEventViewportLast;

                if (pViewportPrev !== pViewportCurr) {
                    if (!akra.isNull(pViewportPrev) && pViewportPrev.isUserEventSupported(32 /* MOUSEOUT */)) {
                        pViewportPrev.mouseout.emit(x - pViewportPrev.getActualLeft(), y - pViewportPrev.getActualTop());
                    }

                    if (!akra.isNull(pViewportCurr) && pViewportCurr.isUserEventSupported(16 /* MOUSEOVER */)) {
                        pViewportCurr.mouseover.emit(x - pViewportCurr.getActualLeft(), y - pViewportCurr.getActualTop());
                    }
                }

                this._pUserEventViewportLast = pViewportCurr;

                return pViewportCurr;
            };

            WebGLCanvas.prototype._onClick = function (x, y) {
                if (this._bUserEventSkipNextClick) {
                    this._bUserEventSkipNextClick = false;
                    return;
                }

                var pViewport = this.getViewportByMouseEvent(x, y);

                if (!akra.isNull(pViewport) && pViewport.isUserEventSupported(1 /* CLICK */)) {
                    pViewport.click.emit(x - pViewport.getActualLeft(), y - pViewport.getActualTop());
                }
            };

            WebGLCanvas.prototype._onMousemove = function (x, y) {
                var pViewport = this.getViewportByMouseEvent(x, y);
                if (this.isUserEventSupported(2 /* MOUSEMOVE */ | 16 /* MOUSEOVER */ | 32 /* MOUSEOUT */)) {
                    if (!akra.isNull(pViewport) && pViewport.isUserEventSupported(2 /* MOUSEMOVE */ | 32 /* MOUSEOUT */ | 16 /* MOUSEOVER */)) {
                        pViewport.mousemove.emit(x - pViewport.getActualLeft(), y - pViewport.getActualTop());
                    }
                }

                //dragging enabled
                if (!akra.isNull(this._pUserEventDragTarget)) {
                    if (this._bUserEventDragging) {
                        if (this.isUserEventSupported(256 /* DRAGGING */)) {
                            this.dragging.emit(this._eUserEventDragBtn, x, y, x - this._pUserEventMouseDownPos.x, y - this._pUserEventMouseDownPos.y);
                        }
                    } else //drag start event not emitted
                    if (Vec2.temp(x - this._pUserEventMouseDownPos.x, y - this._pUserEventMouseDownPos.y).length() > this._iUserEventDragDeadZone) {
                        if (this.isUserEventSupported(64 /* DRAGSTART */)) {
                            this.dragstart.emit(this._eUserEventDragBtn, x, y);
                        }
                    }
                }
            };

            WebGLCanvas.prototype._onMousedown = function (eBtn, x, y) {
                var pViewport = this.getViewportByMouseEvent(x, y);

                this._pUserEventMouseDownPos.x = x;
                this._pUserEventMouseDownPos.y = y;

                if (this.isUserEventSupported(4 /* MOUSEDOWN */)) {
                    if (!akra.isNull(pViewport) && pViewport.isUserEventSupported(4 /* MOUSEDOWN */)) {
                        pViewport.mousedown.emit(eBtn, x - pViewport.getActualLeft(), y - pViewport.getActualTop());
                    }
                }

                if (this.isUserEventSupported(64 /* DRAGSTART */) && this._eUserEventDragBtn === 0 /* UNKNOWN */) {
                    //only for viewport with drag events
                    if (!akra.isNull(pViewport) && pViewport.isUserEventSupported(64 /* DRAGSTART */)) {
                        this._pUserEventDragTarget = pViewport;
                    } else {
                        this._pUserEventDragTarget = null;
                    }

                    this._eUserEventDragBtn = eBtn;

                    if (this._iUserEventDragDeadZone === 0) {
                        this.dragstart.emit(eBtn, x, y);
                    }
                }
            };

            WebGLCanvas.prototype._onMouseup = function (eBtn, x, y) {
                var pViewport = this.getViewportByMouseEvent(x, y);

                if (!akra.isNull(pViewport) && pViewport.isUserEventSupported(8 /* MOUSEUP */)) {
                    pViewport.mouseup.emit(eBtn, x - pViewport.getActualLeft(), y - pViewport.getActualTop());
                }

                if (this.isUserEventSupported(128 /* DRAGSTOP */) && this._eUserEventDragBtn === eBtn) {
                    if (this._bUserEventDragging) {
                        this.dragstop.emit(eBtn, x, y);
                    }

                    this._pUserEventDragTarget = null;
                    this._eUserEventDragBtn = 0 /* UNKNOWN */;
                }
            };

            WebGLCanvas.prototype._onMouseover = function (x, y) {
                //mouseover event will be sended automaticli insine getViewportByMouseEvent() function.
                var pViewport = this.getViewportByMouseEvent(x, y);
            };

            WebGLCanvas.prototype._onMouseout = function (x, y) {
                //mouseout event will be sended automaticli insine getViewportByMouseEvent() function.
                var pViewport = this.getViewportByMouseEvent(x, y);

                //stop dragging if mouse goes out of target
                if (this.isUserEventSupported(128 /* DRAGSTOP */)) {
                    this.dragstop.emit(this._eUserEventDragBtn, x, y);

                    this._pUserEventDragTarget = null;
                    this._eUserEventDragBtn = 0 /* UNKNOWN */;
                }
            };

            WebGLCanvas.prototype._onMousewheel = function (x, y, fDelta) {
                var pViewport = this.getViewportByMouseEvent(x, y);

                if (!akra.isNull(pViewport) && pViewport.isUserEventSupported(512 /* MOUSEWHEEL */)) {
                    pViewport.mousewheel.emit(x - pViewport.getActualLeft(), y - pViewport.getActualTop(), fDelta);
                }
            };

            WebGLCanvas.prototype._onDragstart = function (eBtn, x, y) {
                this._bUserEventDragging = true;

                if (!akra.isNull(this._pUserEventDragTarget)) {
                    this._pUserEventDragTarget.dragstart.emit(eBtn, x - this._pUserEventDragTarget.getActualLeft(), y - this._pUserEventDragTarget.getActualTop());
                }
            };

            WebGLCanvas.prototype._onDragstop = function (eBtn, x, y) {
                this._bUserEventSkipNextClick = true;
                this._bUserEventDragging = false;

                if (!akra.isNull(this._pUserEventDragTarget)) {
                    this._pUserEventDragTarget.dragstop.emit(eBtn, x - this._pUserEventDragTarget.getActualLeft(), y - this._pUserEventDragTarget.getActualTop());
                }
            };

            WebGLCanvas.prototype._onDragging = function (eBtn, x, y) {
                if (!akra.isNull(this._pUserEventDragTarget) && this._pUserEventDragTarget.isUserEventSupported(256 /* DRAGGING */)) {
                    this._pUserEventDragTarget.dragging.emit(eBtn, x - this._pUserEventDragTarget.getActualLeft(), y - this._pUserEventDragTarget.getActualTop(), x - this._pUserEventDragTarget.getActualLeft() - this._pUserEventMouseDownPos.x, y - this._pUserEventDragTarget.getActualTop() - this._pUserEventMouseDownPos.y);
                }
            };

            WebGLCanvas.fullscreenLock = false;
            return WebGLCanvas;
        })(akra.render.Canvas3d);
        webgl.WebGLCanvas = WebGLCanvas;
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
/// <reference path="../idl/IShaderProgram.ts" />
/// <reference path="../idl/IBufferMap.ts" />
/// <reference path="../idl/IAFXSamplerState.ts" />
/// <reference path="../pool/ResourcePoolItem.ts" />
var akra;
(function (akra) {
    /// <reference path="../math/math.ts" />
    (function (webgl) {
        var WebGLShaderProgram = (function (_super) {
            __extends(WebGLShaderProgram, _super);
            function WebGLShaderProgram() {
                _super.apply(this, arguments);
                this._iTotalAttributes = 0;
            }
            WebGLShaderProgram.prototype.create = function (csVertex, csPixel) {
                if (arguments.length > 0) {
                    return this.compile(csVertex, csPixel);
                }

                return false;
            };

            WebGLShaderProgram.prototype.destroy = function () {
                this._pWebGLRenderer.deleteWebGLProgram(this._pWebGLProgram);

                this._pWebGLUniformLocations = null;
                this._pWebGLAttributeLocations = null;
                this._pWebGLAttributesInfo = null;

                this.notifyDestroyed();
                this.notifyDisabled();
            };

            WebGLShaderProgram.prototype.compile = function (csVertex, csPixel) {
                if (typeof csVertex === "undefined") { csVertex = webgl.GLSL_VS_SHADER_MIN; }
                if (typeof csPixel === "undefined") { csPixel = webgl.GLSL_FS_SHADER_MIN; }
                akra.debug.time("create shader program: " + this.findResourceName());

                var pWebGLRenderer = this._pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = this._pWebGLContext = pWebGLRenderer.getWebGLContext();
                var pWebGLProgram = this._pWebGLProgram = pWebGLRenderer.createWebGLProgram();

                var pWebGLVs = this.createWebGLShader(35633 /* VERTEX_SHADER */, csVertex);
                var pWebGLFs = this.createWebGLShader(35632 /* FRAGMENT_SHADER */, csPixel);

                // (<any>this)._debuginfo = {vs: csVertex, ps: csPixel};
                /** because, if not all units correctly activated, can obtained wronf link status */
                pWebGLRenderer._disableAllTextureUnits();

                pWebGLContext.attachShader(pWebGLProgram, pWebGLVs);
                pWebGLContext.attachShader(pWebGLProgram, pWebGLFs);

                pWebGLContext.linkProgram(pWebGLProgram);

                // logger.log("================================", this.findResourceName());
                // logger.log(pWebGLContext.getShaderSource(pWebGLVs));
                // logger.log(pWebGLContext.getShaderSource(pWebGLFs));
                // console.log(csPixel);
                if (!this.isLinked()) {
                    akra.logger.error("cannot link GLSL program(guid: %d)", this.guid);

                    if (akra.config.DEBUG) {
                        var sInfo = pWebGLContext.getProgramInfoLog(pWebGLProgram);

                        akra.logger.log("shader program errors: \n" + sInfo);

                        //+ "\n\nvertex code:\n"  + csVertex + "\n\n pixel code: " + csPixel);
                        if (webgl.loadExtension(pWebGLContext, webgl.WEBGL_DEBUG_SHADERS)) {
                            akra.logger.log("translated(from GLSL) VS shader: \n" + pWebGLContext.getExtension(webgl.WEBGL_DEBUG_SHADERS).getTranslatedShaderSource(pWebGLVs) + "\ntranslated(from GLSL) PS shader: \n" + pWebGLContext.getExtension(webgl.WEBGL_DEBUG_SHADERS).getTranslatedShaderSource(pWebGLFs));
                        } else {
                            akra.logger.log("translated(from GLSL) VS shader: \n" + csVertex + "\ntranslated(from GLSL) PS shader: \n" + csPixel);
                        }
                    }

                    return false;
                }

                pWebGLContext.validateProgram(pWebGLProgram);

                if (!this.isValid()) {
                    akra.logger.warn("GLSL program not valid(guid: %d)", this.guid);

                    akra.debug.log(pWebGLContext.getProgramInfoLog(pWebGLProgram));
                }

                this.obtainWebGLUniforms();
                this.obtainWebGLAttributes();

                this.notifyCreated();
                this.notifyRestored();

                akra.debug.timeEnd("create shader program: " + this.findResourceName());

                //saveAs(new Blob([csVertex], { type: "text" }), this.findResourceName() + ".vert");
                //saveAs(new Blob([csPixel], { type: "text" }), this.findResourceName() + ".frag");
                return true;
            };

            WebGLShaderProgram.prototype.getTotalAttributes = function () {
                return this._iTotalAttributes;
            };

            WebGLShaderProgram.prototype._getActiveUniformNames = function () {
                return Object.keys(this._pWebGLUniformLocations);
            };

            WebGLShaderProgram.prototype._getActiveAttributeNames = function () {
                return Object.keys(this._pWebGLAttributeLocations);
            };

            WebGLShaderProgram.prototype._getActiveAttribLocations = function () {
                return this._pWebGLAttributeLocations;
            };

            WebGLShaderProgram.prototype.isLinked = function () {
                return akra.isDefAndNotNull(this._pWebGLProgram) && this._pWebGLContext.getProgramParameter(this._pWebGLProgram, 35714 /* LINK_STATUS */);
            };

            WebGLShaderProgram.prototype.isValid = function () {
                return akra.isDefAndNotNull(this._pWebGLProgram) && this._pWebGLContext.getProgramParameter(this._pWebGLProgram, 35715 /* VALIDATE_STATUS */);
            };

            WebGLShaderProgram.prototype.isActive = function () {
                return (akra.isDefAndNotNull(this._pWebGLProgram) && this._pWebGLContext.getParameter(35725 /* CURRENT_PROGRAM */) === this._pWebGLProgram);
            };

            WebGLShaderProgram.prototype.setFloat = function (sName, fValue) {
                this._pWebGLContext.uniform1f(this._pWebGLUniformLocations[sName], fValue);
            };

            WebGLShaderProgram.prototype.setInt = function (sName, iValue) {
                this._pWebGLContext.uniform1i(this._pWebGLUniformLocations[sName], iValue);
            };

            WebGLShaderProgram.prototype.setVec2 = function (sName, v2fValue) {
                this._pWebGLContext.uniform2f(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y);
            };

            WebGLShaderProgram.prototype.setVec2i = function (sName, v2iValue) {
                this._pWebGLContext.uniform2i(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y);
            };

            WebGLShaderProgram.prototype.setVec3 = function (sName, v3fValue) {
                this._pWebGLContext.uniform3f(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y, arguments[1].z);
            };

            WebGLShaderProgram.prototype.setVec3i = function (sName, v3iValue) {
                this._pWebGLContext.uniform3i(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y, arguments[1].z);
            };

            WebGLShaderProgram.prototype.setVec4 = function (sName, v4fValue) {
                this._pWebGLContext.uniform4f(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y, arguments[1].z, arguments[1].w);
            };

            WebGLShaderProgram.prototype.setVec4i = function (sName, v4iValue) {
                this._pWebGLContext.uniform4i(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y, arguments[1].z, arguments[1].w);
            };

            WebGLShaderProgram.prototype.setMat3 = function (sName, m3fValue) {
                this._pWebGLContext.uniformMatrix3fv(this._pWebGLUniformLocations[sName], false, m3fValue.data);
            };

            WebGLShaderProgram.prototype.setMat4 = function (sName, m4fValue) {
                this._pWebGLContext.uniformMatrix4fv(this._pWebGLUniformLocations[sName], false, m4fValue.data);
            };

            WebGLShaderProgram.prototype.setFloat32Array = function (sName, pValue) {
                this._pWebGLContext.uniform1fv(this._pWebGLUniformLocations[sName], pValue);
            };

            WebGLShaderProgram.prototype.setInt32Array = function (sName, pValue) {
                this._pWebGLContext.uniform1iv(this._pWebGLUniformLocations[sName], pValue);
            };

            WebGLShaderProgram.prototype.setVec2Array = function (sName, pValue) {
                var pBuffer = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 2);
                for (var i = 0, j = 0; j < pValue.length; i += 2, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                }

                this._pWebGLContext.uniform2fv(this._pWebGLUniformLocations[sName], pBuffer);
            };

            WebGLShaderProgram.prototype.setVec2iArray = function (sName, pValue) {
                var pBuffer = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 2);
                for (var i = 0, j = 0; j < pValue.length; i += 2, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                }

                this._pWebGLContext.uniform2iv(this._pWebGLUniformLocations[sName], pBuffer);
            };

            WebGLShaderProgram.prototype.setVec3Array = function (sName, pValue) {
                var pBuffer = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 3);
                for (var i = 0, j = 0; j < pValue.length; i += 3, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                    pBuffer[i + 2] = pValue[j].z;
                }

                this._pWebGLContext.uniform3fv(this._pWebGLUniformLocations[sName], pBuffer);
            };

            WebGLShaderProgram.prototype.setVec3iArray = function (sName, pValue) {
                var pBuffer = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 3);
                for (var i = 0, j = 0; j < pValue.length; i += 3, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                    pBuffer[i + 2] = pValue[j].z;
                }

                this._pWebGLContext.uniform3iv(this._pWebGLUniformLocations[sName], pBuffer);
            };

            WebGLShaderProgram.prototype.setVec4Array = function (sName, pValue) {
                var pBuffer = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 4);
                for (var i = 0, j = 0; j < pValue.length; i += 4, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                    pBuffer[i + 2] = pValue[j].z;
                    pBuffer[i + 3] = pValue[j].w;
                }

                this._pWebGLContext.uniform4fv(this._pWebGLUniformLocations[sName], pBuffer);
            };

            WebGLShaderProgram.prototype.setVec4iArray = function (sName, pValue) {
                var pBuffer = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 4);
                for (var i = 0, j = 0; j < pValue.length; i += 4, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                    pBuffer[i + 2] = pValue[j].z;
                    pBuffer[i + 3] = pValue[j].w;
                }

                this._pWebGLContext.uniform4iv(this._pWebGLUniformLocations[sName], pBuffer);
            };

            WebGLShaderProgram.prototype.setMat3Array = function (sName, pValue) {
                var pBuffer = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 9);
                for (var i = 0; i < pValue.length; i++) {
                    pBuffer.set(pValue[i].data, 9 * i);
                }
                this._pWebGLContext.uniformMatrix3fv(this._pWebGLUniformLocations[sName], false, pBuffer);
            };

            WebGLShaderProgram.prototype.setMat4Array = function (sName, pValue) {
                var pBuffer = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 16);
                for (var i = 0; i < pValue.length; i++) {
                    pBuffer.set(pValue[i].data, 16 * i);
                }
                this._pWebGLContext.uniformMatrix4fv(this._pWebGLUniformLocations[sName], false, pBuffer);
            };

            WebGLShaderProgram.prototype.setStruct = function (sName, pData) {
            };

            WebGLShaderProgram.prototype.setSampler = function (sName, pSampler) {
                var iSlot = this.applySamplerState(pSampler);
                this.setInt(sName, iSlot);
            };

            WebGLShaderProgram.prototype.setVertexBuffer = function (sName, pBuffer) {
                var iSlot = this._pWebGLRenderer.activateWebGLTextureInAutoSlot(3553 /* TEXTURE_2D */, pBuffer.getWebGLTexture());
                this.setInt(sName, iSlot);
            };

            WebGLShaderProgram.prototype.setSamplerArray = function (sName, pList) {
                var pBuffer = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pList.length);

                for (var i = 0; i < pList.length; ++i) {
                    pBuffer[i] = this.applySamplerState(pList[i]);
                }

                this.setInt32Array(sName, pBuffer);
            };

            WebGLShaderProgram.prototype.setTexture = function (sName, pData) {
            };

            WebGLShaderProgram.prototype.applySamplerState = function (pSampler) {
                var pTexture = pSampler.texture;

                if (akra.isNull(pTexture)) {
                    return;
                }

                var pTextureStateManager = this._pWebGLRenderer._getTextureStateManager();
                var pStates = pTextureStateManager.add(pTexture);
                var iSlot = this._pWebGLRenderer.activateWebGLTextureInAutoSlot(pTexture._getWebGLTextureTarget(), pTexture.getWebGLTexture());

                if (pSampler.min_filter) {
                    pTexture.setFilter(10241 /* MIN_FILTER */, pSampler.min_filter);
                } else {
                    pTexture.setFilter(10241 /* MIN_FILTER */, pStates[10241 /* MIN_FILTER */]);
                }

                if (pSampler.mag_filter) {
                    pTexture.setFilter(10240 /* MAG_FILTER */, pSampler.mag_filter);
                } else {
                    pTexture.setFilter(10240 /* MAG_FILTER */, pStates[10240 /* MAG_FILTER */]);
                }

                if (pSampler.wrap_s) {
                    pTexture.setWrapMode(10242 /* WRAP_S */, pSampler.wrap_s);
                } else {
                    pTexture.setWrapMode(10242 /* WRAP_S */, pStates[10242 /* WRAP_S */]);
                }

                if (pSampler.wrap_t) {
                    pTexture.setWrapMode(10243 /* WRAP_T */, pSampler.wrap_t);
                } else {
                    pTexture.setWrapMode(10243 /* WRAP_T */, pStates[10243 /* WRAP_T */]);
                }

                // logger.log("sampler states: ",
                // (<any>pSampler.min_filter).toString(16),
                // (<any>pSampler.mag_filter).toString(16),
                // (<any>pSampler.wrap_s).toString(16),
                // (<any>pSampler.wrap_t).toString(16)
                // );
                // logger.log("texture states: ",
                // (<any>pTexture.getFilter(ETextureParameters.MIN_FILTER)).toString(16),
                // (<any>pTexture.getFilter(ETextureParameters.MAG_FILTER)).toString(16),
                // (<any>pTexture.getWrapMode(ETextureParameters.WRAP_S)).toString(16),
                // (<any>pTexture.getWrapMode(ETextureParameters.WRAP_T)).toString(16)
                // );
                // pTexture._setFilterInternalTexture(ETextureParameters.MIN_FILTER, pSampler.min_filter || pTexture.getFilter(ETextureParameters.MIN_FILTER));
                // pTexture._setFilterInternalTexture(ETextureParameters.MAG_FILTER, pSampler.mag_filter || pTexture.getFilter(ETextureParameters.MAG_FILTER));
                // pTexture._setWrapModeInternalTexture(ETextureParameters.WRAP_S, pSampler.wrap_s || pTexture.getWrapMode(ETextureParameters.WRAP_S));
                // pTexture._setWrapModeInternalTexture(ETextureParameters.WRAP_T, pSampler.wrap_t || pTexture.getWrapMode(ETextureParameters.WRAP_T));
                // if(pSampler.min_filter){
                //     pTexture._setFilterInternalTexture(ETextureParameters.MIN_FILTER, pSampler.min_filter);
                // }
                // if(pSampler.mag_filter){
                //     pTexture._setFilterInternalTexture(ETextureParameters.MAG_FILTER, pSampler.mag_filter);
                // }
                // if(pSampler.wrap_s) {
                //     pTexture._setWrapModeInternalTexture(ETextureParameters.WRAP_S, pSampler.wrap_s);
                // }
                // if(pSampler.wrap_t) {
                //     pTexture._setWrapModeInternalTexture(ETextureParameters.WRAP_T, pSampler.wrap_t);
                // }
                return iSlot;
            };

            WebGLShaderProgram.prototype.applyVertexData = function (sName, pData) {
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                var pVertexBuffer = pData.getBuffer();
                var iStride = pData.getStride();

                if (pVertexBuffer.getType() !== 1 /* VBO */) {
                    return false;
                }

                var pVertexDecl = pData.getVertexDeclaration();
                var pVertexElement;
                var iLoc;

                for (var i = 0; i < pVertexDecl.getLength(); ++i) {
                    pVertexElement = pVertexDecl[i];
                    iLoc = this.getWebGLAttributeLocation(pVertexElement.usage);

                    if (iLoc < 0) {
                        akra.debug.warn("founded invalid GLSL attribute location(guid: %s): %s", this.guid, pVertexElement.usage);
                        continue;
                    }

                    pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, pVertexBuffer.getWebGLBuffer());
                    pWebGLContext.vertexAttribPointer(iLoc, pVertexElement.count, pVertexElement.type, false, iStride, pVertexElement.offset);
                }

                return true;
            };

            WebGLShaderProgram.prototype._setFloat = function (pWebGLUniformLocation, fValue) {
                this._pWebGLContext.uniform1f(pWebGLUniformLocation, fValue);
            };

            WebGLShaderProgram.prototype._setInt = function (pWebGLUniformLocation, iValue) {
                this._pWebGLContext.uniform1i(pWebGLUniformLocation, iValue);
            };

            WebGLShaderProgram.prototype._setVec2 = function (pWebGLUniformLocation, v2fValue) {
                this._pWebGLContext.uniform2f(pWebGLUniformLocation, v2fValue.x, v2fValue.y);
            };

            WebGLShaderProgram.prototype._setVec2i = function (pWebGLUniformLocation, v2iValue) {
                this._pWebGLContext.uniform2i(pWebGLUniformLocation, v2iValue.x, v2iValue.y);
            };

            WebGLShaderProgram.prototype._setVec3 = function (pWebGLUniformLocation, v3fValue) {
                this._pWebGLContext.uniform3f(pWebGLUniformLocation, v3fValue.x, v3fValue.y, v3fValue.z);
            };

            WebGLShaderProgram.prototype._setVec3i = function (pWebGLUniformLocation, v3iValue) {
                this._pWebGLContext.uniform3i(pWebGLUniformLocation, v3iValue.x, v3iValue.y, v3iValue.z);
            };

            WebGLShaderProgram.prototype._setVec4 = function (pWebGLUniformLocation, v4fValue) {
                this._pWebGLContext.uniform4f(pWebGLUniformLocation, v4fValue.x, v4fValue.y, v4fValue.z, v4fValue.w);
            };

            WebGLShaderProgram.prototype._setVec4i = function (pWebGLUniformLocation, v4iValue) {
                this._pWebGLContext.uniform4i(pWebGLUniformLocation, v4iValue.x, v4iValue.y, v4iValue.z, v4iValue.w);
            };

            WebGLShaderProgram.prototype._setMat3 = function (pWebGLUniformLocation, m3fValue) {
                this._pWebGLContext.uniformMatrix3fv(pWebGLUniformLocation, false, m3fValue.data);
            };

            WebGLShaderProgram.prototype._setMat4 = function (pWebGLUniformLocation, m4fValue) {
                this._pWebGLContext.uniformMatrix4fv(pWebGLUniformLocation, false, m4fValue.data);
            };

            WebGLShaderProgram.prototype._setFloat32Array = function (pWebGLUniformLocation, pValue) {
                this._pWebGLContext.uniform1fv(pWebGLUniformLocation, pValue);
            };

            WebGLShaderProgram.prototype._setInt32Array = function (pWebGLUniformLocation, pValue) {
                !akra.isNull(pValue) && this._pWebGLContext.uniform1iv(pWebGLUniformLocation, pValue);
            };

            WebGLShaderProgram.prototype._setVec2Array = function (pWebGLUniformLocation, pValue) {
                if (akra.isNull(pValue)) {
                    return;
                }

                var pBuffer = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 2);

                for (var i = 0, j = 0; j < pValue.length; i += 2, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                }

                this._pWebGLContext.uniform2fv(pWebGLUniformLocation, pBuffer);
            };

            WebGLShaderProgram.prototype._setVec2iArray = function (pWebGLUniformLocation, pValue) {
                var pBuffer = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 2);
                for (var i = 0, j = 0; j < pValue.length; i += 2, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                }

                this._pWebGLContext.uniform2iv(pWebGLUniformLocation, pBuffer);
            };

            WebGLShaderProgram.prototype._setVec3Array = function (pWebGLUniformLocation, pValue) {
                var pBuffer = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 3);
                for (var i = 0, j = 0; i < pValue.length; i += 3, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                    pBuffer[i + 2] = pValue[j].z;
                }

                this._pWebGLContext.uniform3fv(pWebGLUniformLocation, pBuffer);
            };

            WebGLShaderProgram.prototype._setVec3iArray = function (pWebGLUniformLocation, pValue) {
                var pBuffer = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 3);
                for (var i = 0, j = 0; i < pValue.length; i += 3, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                    pBuffer[i + 2] = pValue[j].z;
                }

                this._pWebGLContext.uniform3iv(pWebGLUniformLocation, pBuffer);
            };

            WebGLShaderProgram.prototype._setVec4Array = function (pWebGLUniformLocation, pValue) {
                var pBuffer = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 4);
                for (var i = 0, j = 0; i < pValue.length; i += 4, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                    pBuffer[i + 2] = pValue[j].z;
                    pBuffer[i + 3] = pValue[j].w;
                }

                this._pWebGLContext.uniform4fv(pWebGLUniformLocation, pBuffer);
            };

            WebGLShaderProgram.prototype._setVec4iArray = function (pWebGLUniformLocation, pValue) {
                var pBuffer = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 4);
                for (var i = 0, j = 0; i < pValue.length; i += 4, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                    pBuffer[i + 2] = pValue[j].z;
                    pBuffer[i + 3] = pValue[j].w;
                }

                this._pWebGLContext.uniform4iv(pWebGLUniformLocation, pBuffer);
            };

            WebGLShaderProgram.prototype._setMat3Array = function (pWebGLUniformLocation, pValue) {
                var pBuffer = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 9);
                for (var i = 0; i < pValue.length; i++) {
                    pBuffer.set(pValue[i].data, 9 * i);
                }
                this._pWebGLContext.uniformMatrix3fv(pWebGLUniformLocation, false, pBuffer);
            };

            WebGLShaderProgram.prototype._setMat4Array = function (pWebGLUniformLocation, pValue) {
                var pBuffer = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 16);
                for (var i = 0; i < pValue.length; i++) {
                    pBuffer.set(pValue[i].data, 16 * i);
                }
                this._pWebGLContext.uniformMatrix4fv(pWebGLUniformLocation, false, pBuffer);
            };

            WebGLShaderProgram.prototype._setSampler = function (pWebGLUniformLocation, pSampler) {
                var iSlot = this.applySamplerState(pSampler);
                this._setInt(pWebGLUniformLocation, iSlot);
            };

            WebGLShaderProgram.prototype._setVertexBuffer = function (pWebGLUniformLocation, pBuffer) {
                var iSlot = this._pWebGLRenderer.activateWebGLTextureInAutoSlot(3553 /* TEXTURE_2D */, pBuffer.getWebGLTexture());
                this._setInt(pWebGLUniformLocation, iSlot);
            };

            WebGLShaderProgram.prototype._setSamplerArray = function (pWebGLUniformLocation, pList) {
                var pBuffer = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pList.length);

                for (var i = 0; i < pList.length; ++i) {
                    pBuffer[i] = this.applySamplerState(pList[i]);
                }

                this._setInt32Array(pWebGLUniformLocation, pBuffer);
            };

            WebGLShaderProgram.prototype.applyBufferMap = function (pMap) {
                akra.logger.critical("WebGLShaderProgram::applyBufferMap() is uncompleted method!");
            };

            WebGLShaderProgram.prototype.getWebGLAttributeLocation = function (sName) {
                return akra.isDef(this._pWebGLAttributeLocations[sName]) ? this._pWebGLAttributeLocations[sName] : -1;
            };

            WebGLShaderProgram.prototype.getWebGLUniformLocations = function () {
                return this._pWebGLUniformLocations;
            };

            WebGLShaderProgram.prototype.getWebGLUniformLocation = function (sName) {
                if (akra.config.DEBUG) {
                    var iLoc = this._pWebGLUniformLocations[sName];

                    if (!akra.isDef(iLoc)) {
                        akra.logger.warn("could not find location for GLSL attribute(guid: %s): %s", this.guid, sName);
                    }

                    return iLoc;
                } else {
                    return this._pWebGLUniformLocations[sName] || null;
                }
            };

            WebGLShaderProgram.prototype.getWebGLProgram = function () {
                return this._pWebGLProgram;
            };

            WebGLShaderProgram.prototype.getTranslatedShaderCode = function (eWebGLType) {
                if (akra.config.DEBUG) {
                    var sReturn = "";
                    var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                    var pWebGLContext = pWebGLRenderer.getWebGLContext();

                    if (!webgl.loadExtension(pWebGLContext, webgl.WEBGL_DEBUG_SHADERS)) {
                        return null;
                    }

                    var pWebGLShaderList = pWebGLContext.getAttachedShaders(this._pWebGLProgram);

                    for (var i = 0; i < pWebGLShaderList.length; i++) {
                        var eShaderType = pWebGLContext.getShaderParameter(pWebGLShaderList[i], 35663 /* SHADER_TYPE */);

                        if (eShaderType === eWebGLType) {
                            sReturn = pWebGLContext.getExtension(webgl.WEBGL_DEBUG_SHADERS).getTranslatedShaderSource(pWebGLShaderList[i]);
                            break;
                        }
                    }

                    return sReturn;
                } else {
                    return "";
                }
            };

            WebGLShaderProgram.prototype.printTranslatedShaderCode = function (eWebGLType) {
                if (typeof eWebGLType === "undefined") { eWebGLType = -1; }
                if (akra.config.DEBUG) {
                    if (eWebGLType === -1) {
                        akra.logger.log("translated(from GLSL) VS shader: \n" + this.getTranslatedShaderCode(35633 /* VERTEX_SHADER */));
                        akra.logger.log("translated(from GLSL) PS shader: \n" + this.getTranslatedShaderCode(35632 /* FRAGMENT_SHADER */));
                    } else {
                        akra.logger.log("translated(from GLSL) " + (eWebGLType === 35633 /* VERTEX_SHADER */ ? "VS" : "PS") + " shader: \n" + this.getTranslatedShaderCode(eWebGLType));
                    }
                }
            };

            WebGLShaderProgram.prototype.createWebGLShader = function (eType, csCode) {
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                var pWebGLShader = pWebGLContext.createShader(eType);

                pWebGLContext.shaderSource(pWebGLShader, csCode);
                pWebGLContext.compileShader(pWebGLShader);

                if (!pWebGLContext.getShaderParameter(pWebGLShader, 35713 /* COMPILE_STATUS */)) {
                    akra.logger.error("cannot compile GLSL shader(guid: %d)", this.guid);

                    if (akra.config.DEBUG) {
                        var sInfo = pWebGLContext.getShaderInfoLog(pWebGLShader);
                        var sCode = pWebGLContext.getShaderSource(pWebGLShader) || csCode;

                        akra.logger.log("shader errors: \n %s \n----------\n %s", sInfo, sCode);

                        if (webgl.loadExtension(pWebGLContext, webgl.WEBGL_DEBUG_SHADERS)) {
                            akra.logger.log("translated(from GLSL) " + (eType == 35633 /* VERTEX_SHADER */ ? "VS" : "PS") + " shader: \n" + pWebGLContext.getExtension(webgl.WEBGL_DEBUG_SHADERS).getTranslatedShaderSource(pWebGLShader));
                        }
                    }

                    return null;
                }

                return pWebGLShader;
            };

            WebGLShaderProgram.prototype.saveResource = function (sName) {
                //var pBlob = new Blob([this.])
                return true;
            };

            WebGLShaderProgram.prototype.obtainWebGLUniforms = function () {
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                var nUniforms = pWebGLContext.getProgramParameter(this._pWebGLProgram, 35718 /* ACTIVE_UNIFORMS */);
                var pUniformLocations = {};
                var iLoc;
                var pUniformInfo;

                for (var i = 0; i < nUniforms; ++i) {
                    pUniformInfo = pWebGLContext.getActiveUniform(this._pWebGLProgram, i);
                    iLoc = pWebGLContext.getUniformLocation(this._pWebGLProgram, pUniformInfo.name);
                    pUniformLocations[pUniformInfo.name] = iLoc;
                }

                this._pWebGLUniformLocations = pUniformLocations;
            };

            WebGLShaderProgram.prototype.obtainWebGLAttributes = function () {
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                var nAttributes = pWebGLContext.getProgramParameter(this._pWebGLProgram, 35721 /* ACTIVE_ATTRIBUTES */);
                var pAttributeLocations = {};
                var pAttributesInfo = [];
                var iLoc;
                var pAttributeInfo;

                for (var i = 0; i < nAttributes; ++i) {
                    pAttributeInfo = pWebGLContext.getActiveAttrib(this._pWebGLProgram, i);
                    iLoc = pWebGLContext.getAttribLocation(this._pWebGLProgram, pAttributeInfo.name);
                    if (akra.config.DEBUG) {
                        if (iLoc < 0 || !akra.isDef(iLoc)) {
                            akra.logger.warn("could not get GLSL attribute location(guid: %s): %s", this.guid, pAttributeInfo.name);
                        }
                    }

                    pAttributeLocations[pAttributeInfo.name] = iLoc;
                    pAttributesInfo[iLoc] = pAttributeInfo;
                }

                this._pWebGLAttributeLocations = pAttributeLocations;
                this._pWebGLAttributesInfo = pAttributesInfo;
                this._iTotalAttributes = nAttributes;
            };
            WebGLShaderProgram.uniformBuffer = new ArrayBuffer(4096 * 16);
            return WebGLShaderProgram;
        })(akra.pool.ResourcePoolItem);
        webgl.WebGLShaderProgram = WebGLShaderProgram;
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
/// <reference path="WebGLRenderer.ts" />
/// <reference path="WebGLInternalTexture.ts" />
/// <reference path="../util/ObjectArray.ts" />
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLInternalTextureStateManager = (function () {
            function WebGLInternalTextureStateManager(pRenderer) {
                this._pActiveTextureStateMap = null;
                this._pActiveTextureList = null;
                this._pWebGLRenderer = null;
                this._pWebGLRenderer = pRenderer;

                this._pActiveTextureStateMap = {};
                this._pActiveTextureList = new akra.util.ObjectArray();
            }
            WebGLInternalTextureStateManager.prototype.add = function (pTexture) {
                var iGuid = pTexture.guid;
                var pTextureState = this._pActiveTextureStateMap[iGuid];

                if (!akra.isDef(pTextureState)) {
                    pTextureState = {
                        isUsed: true,
                        texture: pTexture,
                        states: {}
                    };

                    pTextureState.states[10241 /* MIN_FILTER */] = pTexture.getFilter(10241 /* MIN_FILTER */);
                    pTextureState.states[10240 /* MAG_FILTER */] = pTexture.getFilter(10240 /* MAG_FILTER */);
                    pTextureState.states[10242 /* WRAP_S */] = pTexture.getWrapMode(10242 /* WRAP_S */);
                    pTextureState.states[10243 /* WRAP_T */] = pTexture.getWrapMode(10243 /* WRAP_T */);

                    this._pActiveTextureStateMap[iGuid] = pTextureState;
                    this._pActiveTextureList.push(iGuid);

                    return pTextureState.states;
                }

                if (!pTextureState.isUsed) {
                    pTextureState.states[10241 /* MIN_FILTER */] = pTexture.getFilter(10241 /* MIN_FILTER */);
                    pTextureState.states[10240 /* MAG_FILTER */] = pTexture.getFilter(10240 /* MAG_FILTER */);
                    pTextureState.states[10242 /* WRAP_S */] = pTexture.getWrapMode(10242 /* WRAP_S */);
                    pTextureState.states[10243 /* WRAP_T */] = pTexture.getWrapMode(10243 /* WRAP_T */);

                    this._pActiveTextureList.push(iGuid);
                }

                return pTextureState.states;
            };

            WebGLInternalTextureStateManager.prototype.reset = function () {
                var iLength = this._pActiveTextureList.getLength();

                for (var i = 0; i < iLength; i++) {
                    var pTextureState = this._pActiveTextureStateMap[this._pActiveTextureList.value(i)];

                    pTextureState.texture.setFilter(10241 /* MIN_FILTER */, pTextureState.states[10241 /* MIN_FILTER */]);
                    pTextureState.texture.setFilter(10240 /* MAG_FILTER */, pTextureState.states[10240 /* MAG_FILTER */]);
                    pTextureState.texture.setWrapMode(10242 /* WRAP_S */, pTextureState.states[10242 /* WRAP_S */]);
                    pTextureState.texture.setWrapMode(10243 /* WRAP_T */, pTextureState.states[10243 /* WRAP_T */]);

                    pTextureState.isUsed = false;
                }

                this._pActiveTextureList.clear();
                //this._pWebGLRenderer.bindWebGLTexture(gl.TEXTURE_2D, null);
            };

            WebGLInternalTextureStateManager.prototype.getTextureState = function (iGuid) {
                return this._pActiveTextureStateMap[iGuid].states;
            };
            return WebGLInternalTextureStateManager;
        })();
        webgl.WebGLInternalTextureStateManager = WebGLInternalTextureStateManager;
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
/// <reference path="../idl/IShaderInput.ts" />
var akra;
(function (akra) {
    /// <reference path="../render/Renderer.ts" />
    /// <reference path="../render/Viewport.ts" />
    /// <reference path="../config/config.ts" />
    /// <reference path="webgl.ts" />
    /// <reference path="WebGLCanvas.ts" />
    /// <reference path="WebGLShaderProgram.ts" />
    /// <reference path="WebGLInternalTextureStateManager.ts" />
    (function (webgl) {
        var WebGLRenderer = (function (_super) {
            __extends(WebGLRenderer, _super);
            function WebGLRenderer(pEngine, options) {
                _super.call(this, pEngine);
                this._pCanvas = null;
                //real context, if debug context used
                this._pWebGLInternalContext = null;
                this._nActiveAttributes = 0;
                this._iSlot = 0;
                this._iCurrentTextureSlot = 0;
                this._iNextTextureSlot = 0;
                this._pTextureSlotList = null;
                /**
                * Need To reset texture states after render
                */
                this._pTextureStateManager = null;
                /**
                * Need to impove speed
                */
                this._pCurrentContextStates = WebGLRenderer.createWebGLContextStates();
                this._pRenderStatesPool = new akra.util.ObjectArray();
                this._pFreeRenderStatesPool = new akra.util.ObjectArray();
                this._pLastMaker = null;
                this._time = [0, 0, 0, 0, 0, 0, 0, 0];

                var pOptions = null;

                if (akra.isDefAndNotNull(arguments[1])) {
                    //get HTMLCanvasElement by id
                    if (akra.isString(arguments[1])) {
                        this._pCanvas = document.getElementById(arguments[1]);
                    } else if (arguments[1] instanceof HTMLCanvasElement) {
                        this._pCanvas = arguments[1];
                    } else {
                        pOptions = arguments[1];

                        if (pOptions.canvas instanceof HTMLCanvasElement) {
                            this._pCanvas = pOptions.canvas;
                        }
                    }
                }

                if (akra.isNull(this._pCanvas)) {
                    this._pCanvas = document.createElement('canvas');
                }

                if (akra.isNull(pOptions)) {
                    pOptions = WebGLRenderer.DEFAULT_OPTIONS;
                } else {
                    for (var i = 0, pOptList = Object.keys(WebGLRenderer.DEFAULT_OPTIONS); i < pOptList.length; ++i) {
                        var sOpt = pOptList[i];

                        if (!akra.isDef(pOptions[sOpt])) {
                            pOptions[sOpt] = WebGLRenderer.DEFAULT_OPTIONS[sOpt];
                        }
                    }
                }

                akra.debug.log("webgl context attributes:", pOptions);

                this._pWebGLContext = webgl.createContext(this._pCanvas, pOptions);

                akra.debug.assert(!akra.isNull(this._pWebGLContext), "webgl context is NULL");

                this._pWebGLFramebufferList = new Array(akra.config.webgl.preparedFramebuffersNum);

                for (var i = 0; i < this._pWebGLFramebufferList.length; ++i) {
                    this._pWebGLFramebufferList[i] = this._pWebGLContext.createFramebuffer();
                }

                this._pDefaultCanvas = new webgl.WebGLCanvas(this);
                akra.logger.assert(this._pDefaultCanvas.create("primary-target"), "could not create WebGL canvas");

                this.attachRenderTarget(this._pDefaultCanvas);

                this._pTextureSlotList = new Array(webgl.maxTextureImageUnits);

                for (var i = 0; i < this._pTextureSlotList.length; i++) {
                    this._pTextureSlotList[i] = null;
                }

                for (var i = 0; i < 4; i++) {
                    this._pFreeRenderStatesPool.push(WebGLRenderer.createWebGLContextStates());
                }

                this.forceUpdateContextRenderStates();

                this._pTextureStateManager = new webgl.WebGLInternalTextureStateManager(this);
            }
            WebGLRenderer.prototype.getType = function () {
                return 1 /* WEBGL */;
            };

            WebGLRenderer.prototype.hasCapability = function (eCapability) {
                switch (eCapability) {
                    case akra.ERenderCapabilities.AUTOMIPMAP:
                    case akra.ERenderCapabilities.BLENDING:
                    case akra.ERenderCapabilities.CUBEMAPPING:
                    case akra.ERenderCapabilities.HWSTENCIL:
                    case akra.ERenderCapabilities.VBO:
                    case akra.ERenderCapabilities.VERTEX_PROGRAM:
                    case akra.ERenderCapabilities.FRAGMENT_PROGRAM:
                    case akra.ERenderCapabilities.SCISSOR_TEST:
                    case akra.ERenderCapabilities.HWRENDER_TO_TEXTURE:
                    case akra.ERenderCapabilities.ALPHA_TO_COVERAGE:
                        return true;

                    case akra.ERenderCapabilities.POINT_EXTENDED_PARAMETERS:
                    case akra.ERenderCapabilities.POINT_SPRITES:
                    case akra.ERenderCapabilities.NON_POWER_OF_2_TEXTURES:
                    case akra.ERenderCapabilities.GEOMETRY_PROGRAM:
                    case akra.ERenderCapabilities.TEXTURE_3D:
                    case akra.ERenderCapabilities.FBO:
                    case akra.ERenderCapabilities.PBUFFER:
                    case akra.ERenderCapabilities.HWRENDER_TO_VERTEX_BUFFER:
                    case akra.ERenderCapabilities.SEPARATE_SHADER_OBJECTS:
                    case akra.ERenderCapabilities.DOT3:
                    case akra.ERenderCapabilities.TWO_SIDED_STENCIL:
                    case akra.ERenderCapabilities.USER_CLIP_PLANES:
                    case akra.ERenderCapabilities.HWOCCLUSION:
                    case akra.ERenderCapabilities.STENCIL_WRAP:
                    case akra.ERenderCapabilities.INFINITE_FAR_PLANE:
                    case akra.ERenderCapabilities.MIPMAP_LOD_BIAS:
                    case akra.ERenderCapabilities.FIXED_FUNCTION:
                    case akra.ERenderCapabilities.MRT_DIFFERENT_BIT_DEPTHS:
                    case akra.ERenderCapabilities.ADVANCED_BLEND_OPERATIONS:
                    case akra.ERenderCapabilities.CAN_GET_COMPILED_SHADER_BUFFER:
                    case akra.ERenderCapabilities.VERTEX_BUFFER_INSTANCE_DATA:
                        return false;

                    case akra.ERenderCapabilities.ANISOTROPY:
                        return webgl.hasExtension(webgl.EXT_TEXTURE_FILTER_ANISOTROPIC);

                    case akra.ERenderCapabilities.VERTEX_FORMAT_UBYTE4:
                        return webgl.hasExtension(webgl.OES_ELEMENT_INDEX_UINT);

                    case akra.ERenderCapabilities.VERTEX_TEXTURE_FETCH:
                        return webgl.maxVertexTextureImageUnits > 0;

                    case akra.ERenderCapabilities.TEXTURE_COMPRESSION_DXT:
                        return webgl.hasExtension(webgl.WEBGL_COMPRESSED_TEXTURE_S3TC);

                    case akra.ERenderCapabilities.TEXTURE_COMPRESSION_PVRTC:
                        return webgl.hasExtension(webgl.WEBGL_COMPRESSED_TEXTURE_PVRTC);

                    case akra.ERenderCapabilities.TEXTURE_COMPRESSION_ATC:
                        return webgl.hasExtension(webgl.WEBGL_COMPRESSED_TEXTURE_ATC);

                    case akra.ERenderCapabilities.TEXTURE_COMPRESSION:
                        return webgl.hasExtension(webgl.WEBGL_COMPRESSED_TEXTURE_S3TC) || webgl.hasExtension(webgl.WEBGL_COMPRESSED_TEXTURE_ATC) || webgl.hasExtension(webgl.WEBGL_COMPRESSED_TEXTURE_PVRTC);

                    case akra.ERenderCapabilities.TEXTURE_COMPRESSION_VTC:
                        return false;

                    case akra.ERenderCapabilities.TEXTURE_FLOAT:
                        return webgl.hasExtension(webgl.OES_TEXTURE_FLOAT) || webgl.hasExtension(webgl.OES_TEXTURE_HALF_FLOAT);

                    case akra.ERenderCapabilities.RTT_DEPTHBUFFER_RESOLUTION_LESSEQUAL:
                    case akra.ERenderCapabilities.RTT_MAIN_DEPTHBUFFER_ATTACHABLE:
                    case akra.ERenderCapabilities.RTT_SEPARATE_DEPTHBUFFER:
                        return webgl.hasExtension(webgl.WEBGL_DEPTH_TEXTURE);
                }

                return false;
            };

            WebGLRenderer.prototype.debug = function (bValue, useApiTrace) {
                if (typeof bValue === "undefined") { bValue = true; }
                if (typeof useApiTrace === "undefined") { useApiTrace = false; }
                var pWebGLInternalContext = this._pWebGLContext;

                if (bValue) {
                    if (akra.isDef(window.WebGLDebugUtils) && !akra.isNull(pWebGLInternalContext)) {
                        this._pWebGLContext = WebGLDebugUtils.makeDebugContext(pWebGLInternalContext, function (err, funcName, args) {
                            throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to: " + funcName;
                        }, useApiTrace ? function (funcName, args) {
                            akra.logger.log("gl." + funcName + "(" + WebGLDebugUtils.glFunctionArgsToString(funcName, args) + ")");
                        } : null);

                        this._pWebGLInternalContext = pWebGLInternalContext;

                        return true;
                    }
                } else if (this.isDebug()) {
                    this._pWebGLContext = this._pWebGLInternalContext;
                    this._pWebGLInternalContext = null;

                    return true;
                }

                return false;
            };

            WebGLRenderer.prototype.blendColor = function (fRed, fGreen, fBlue, fAlpha) {
                this._pWebGLContext.blendColor(fRed, fGreen, fBlue, fAlpha);
                this._pCurrentContextStates.blend_color[0] = fRed;
                this._pCurrentContextStates.blend_color[1] = fGreen;
                this._pCurrentContextStates.blend_color[2] = fBlue;
                this._pCurrentContextStates.blend_color[3] = fAlpha;
            };

            WebGLRenderer.prototype.blendEquation = function (iWebGLMode) {
                this._pWebGLContext.blendEquation(iWebGLMode);
                this._pCurrentContextStates.blend_equation_rgb = iWebGLMode;
                this._pCurrentContextStates.blend_equation_alpha = iWebGLMode;
            };

            WebGLRenderer.prototype.blendEquationSeparate = function (iWebGLModeRGB, iWebGLModeAlpha) {
                this._pWebGLContext.blendEquationSeparate(iWebGLModeRGB, iWebGLModeAlpha);
                this._pCurrentContextStates.blend_equation_rgb = iWebGLModeRGB;
                this._pCurrentContextStates.blend_equation_alpha = iWebGLModeAlpha;
            };

            WebGLRenderer.prototype.blendFunc = function (iWebGLSFactor, iWebGLDFactor) {
                this._pWebGLContext.blendFunc(iWebGLSFactor, iWebGLDFactor);
                this._pCurrentContextStates.blend_src_rgb = iWebGLSFactor;
                this._pCurrentContextStates.blend_src_alpha = iWebGLSFactor;
                this._pCurrentContextStates.blend_dst_rgb = iWebGLDFactor;
                this._pCurrentContextStates.blend_dst_alpha = iWebGLDFactor;
            };

            WebGLRenderer.prototype.blendFuncSeparate = function (iWebGLSFactorRGB, iWebGLDFactorRGB, iWebGLSFactorAlpha, iWebGLDFactorAlpha) {
                this._pWebGLContext.blendFuncSeparate(iWebGLSFactorRGB, iWebGLDFactorRGB, iWebGLSFactorAlpha, iWebGLDFactorAlpha);
                this._pCurrentContextStates.blend_src_rgb = iWebGLSFactorRGB;
                this._pCurrentContextStates.blend_src_alpha = iWebGLSFactorAlpha;
                this._pCurrentContextStates.blend_dst_rgb = iWebGLDFactorRGB;
                this._pCurrentContextStates.blend_dst_alpha = iWebGLDFactorAlpha;
            };

            WebGLRenderer.prototype.clearColor = function (fRed, fGreen, fBlue, fAlpha) {
                this._pWebGLContext.clearColor(fRed, fGreen, fBlue, fAlpha);
                this._pCurrentContextStates.color_clear_value[0] = fRed;
                this._pCurrentContextStates.color_clear_value[1] = fGreen;
                this._pCurrentContextStates.color_clear_value[2] = fBlue;
                this._pCurrentContextStates.color_clear_value[3] = fAlpha;
            };

            WebGLRenderer.prototype.clearDepth = function (fDepth) {
                this._pWebGLContext.clearDepth(fDepth);
                this._pCurrentContextStates.depth_clear_value = fDepth;
            };

            WebGLRenderer.prototype.clearStencil = function (iS) {
                this._pWebGLContext.clearStencil(iS);
                this._pCurrentContextStates.stencil_clear_value = iS;
            };

            WebGLRenderer.prototype.colorMask = function (bRed, bGreen, bBlue, bAlpha) {
                this._pWebGLContext.colorMask(bRed, bGreen, bBlue, bAlpha);
                this._pCurrentContextStates.color_writemask[0] = bRed;
                this._pCurrentContextStates.color_writemask[1] = bGreen;
                this._pCurrentContextStates.color_writemask[2] = bBlue;
                this._pCurrentContextStates.color_writemask[3] = bAlpha;
            };

            WebGLRenderer.prototype.cullFace = function (iWebGLMode) {
                this._pWebGLContext.cullFace(iWebGLMode);
                this._pCurrentContextStates.cull_face_mode = iWebGLMode;
            };

            WebGLRenderer.prototype.depthFunc = function (iWebGLMode) {
                this._pWebGLContext.depthFunc(iWebGLMode);
                this._pCurrentContextStates.depth_func = iWebGLMode;
            };

            WebGLRenderer.prototype.depthMask = function (bWrite) {
                this._pWebGLContext.depthMask(bWrite);
                this._pCurrentContextStates.depth_writemask = bWrite;
            };

            WebGLRenderer.prototype.depthRange = function (fZNear, fZFar) {
                this._pWebGLContext.depthRange(fZNear, fZFar);
                this._pCurrentContextStates.depth_range[0] = fZNear;
                this._pCurrentContextStates.depth_range[1] = fZFar;
            };

            WebGLRenderer.prototype.disable = function (iWebGLCap) {
                this._pWebGLContext.disable(iWebGLCap);

                switch (iWebGLCap) {
                    case 2884 /* CULL_FACE */:
                        this._pCurrentContextStates.cull_face = false;
                        return;
                    case 3042 /* BLEND */:
                        this._pCurrentContextStates.blend = false;
                        return;
                    case 3024 /* DITHER */:
                        this._pCurrentContextStates.dither = false;
                        return;
                    case 2960 /* STENCIL_TEST */:
                        this._pCurrentContextStates.stencil_test = false;
                        return;
                    case 2929 /* DEPTH_TEST */:
                        this._pCurrentContextStates.depth_test = false;
                        return;
                    case 3089 /* SCISSOR_TEST */:
                        this._pCurrentContextStates.scissor_test = false;
                        return;
                    case 32823 /* POLYGON_OFFSET_FILL */:
                        this._pCurrentContextStates.polygon_offset_fill = false;
                        return;
                }
            };

            WebGLRenderer.prototype.enable = function (iWebGLCap) {
                this._pWebGLContext.enable(iWebGLCap);

                switch (iWebGLCap) {
                    case 2884 /* CULL_FACE */:
                        this._pCurrentContextStates.cull_face = true;
                        return;
                    case 3042 /* BLEND */:
                        this._pCurrentContextStates.blend = true;
                        return;
                    case 3024 /* DITHER */:
                        this._pCurrentContextStates.dither = true;
                        return;
                    case 2960 /* STENCIL_TEST */:
                        this._pCurrentContextStates.stencil_test = true;
                        return;
                    case 2929 /* DEPTH_TEST */:
                        this._pCurrentContextStates.depth_test = true;
                        return;
                    case 3089 /* SCISSOR_TEST */:
                        this._pCurrentContextStates.scissor_test = true;
                        return;
                    case 32823 /* POLYGON_OFFSET_FILL */:
                        this._pCurrentContextStates.polygon_offset_fill = true;
                        return;
                }
            };

            WebGLRenderer.prototype.frontFace = function (iWebGLMode) {
                this._pWebGLContext.frontFace(iWebGLMode);
                this._pCurrentContextStates.front_face = iWebGLMode;
            };

            WebGLRenderer.prototype.getParameter = function (iWebGLName) {
                switch (iWebGLName) {
                    case 3042 /* BLEND */:
                        return this._pCurrentContextStates.blend;
                    case 32773 /* BLEND_COLOR */:
                        return this._pCurrentContextStates.blend_color;
                    case 32970 /* BLEND_DST_ALPHA */:
                        return this._pCurrentContextStates.blend_dst_alpha;
                    case 32968 /* BLEND_DST_RGB */:
                        return this._pCurrentContextStates.blend_dst_rgb;
                    case 34877 /* BLEND_EQUATION_ALPHA */:
                        return this._pCurrentContextStates.blend_equation_alpha;
                    case 32777 /* BLEND_EQUATION_RGB */:
                        return this._pCurrentContextStates.blend_equation_rgb;
                    case 32971 /* BLEND_SRC_ALPHA */:
                        return this._pCurrentContextStates.blend_src_alpha;
                    case 32969 /* BLEND_SRC_RGB */:
                        return this._pCurrentContextStates.blend_src_rgb;
                    case 3106 /* COLOR_CLEAR_VALUE */:
                        return this._pCurrentContextStates.color_clear_value;
                    case 3107 /* COLOR_WRITEMASK */:
                        return this._pCurrentContextStates.color_writemask;
                    case 2884 /* CULL_FACE */:
                        return this._pCurrentContextStates.cull_face;
                    case 2885 /* CULL_FACE_MODE */:
                        return this._pCurrentContextStates.cull_face_mode;
                    case 2931 /* DEPTH_CLEAR_VALUE */:
                        return this._pCurrentContextStates.depth_clear_value;
                    case 2932 /* DEPTH_FUNC */:
                        return this._pCurrentContextStates.depth_func;
                    case 2928 /* DEPTH_RANGE */:
                        return this._pCurrentContextStates.depth_range;
                    case 2929 /* DEPTH_TEST */:
                        return this._pCurrentContextStates.depth_test;
                    case 2930 /* DEPTH_WRITEMASK */:
                        return this._pCurrentContextStates.depth_writemask;
                    case 3024 /* DITHER */:
                        return this._pCurrentContextStates.dither;
                    case 2886 /* FRONT_FACE */:
                        return this._pCurrentContextStates.front_face;
                    case 2849 /* LINE_WIDTH */:
                        return this._pCurrentContextStates.line_width;
                    case 32824 /* POLYGON_OFFSET_FACTOR */:
                        return this._pCurrentContextStates.polygon_offset_factor;
                    case 32823 /* POLYGON_OFFSET_FILL */:
                        return this._pCurrentContextStates.polygon_offset_fill;
                    case 10752 /* POLYGON_OFFSET_UNITS */:
                        return this._pCurrentContextStates.polygon_offset_units;
                    case 32936 /* SAMPLE_BUFFERS */:
                        return this._pCurrentContextStates.sample_buffers;
                    case 32939 /* SAMPLE_COVERAGE_INVERT */:
                        return this._pCurrentContextStates.sample_coverage_invert;
                    case 32938 /* SAMPLE_COVERAGE_VALUE */:
                        return this._pCurrentContextStates.sample_coverage_value;
                    case 32937 /* SAMPLES */:
                        return this._pCurrentContextStates.samples;
                    case 3089 /* SCISSOR_TEST */:
                        return this._pCurrentContextStates.scissor_test;
                    case 34817 /* STENCIL_BACK_FAIL */:
                        return this._pCurrentContextStates.stencil_back_fail;
                    case 34816 /* STENCIL_BACK_FUNC */:
                        return this._pCurrentContextStates.stencil_back_func;
                    case 34818 /* STENCIL_BACK_PASS_DEPTH_FAIL */:
                        return this._pCurrentContextStates.stencil_back_pass_depth_fail;
                    case 34819 /* STENCIL_BACK_PASS_DEPTH_PASS */:
                        return this._pCurrentContextStates.stencil_back_pass_depth_pass;
                    case 36003 /* STENCIL_BACK_REF */:
                        return this._pCurrentContextStates.stencil_back_ref;
                    case 36004 /* STENCIL_BACK_VALUE_MASK */:
                        return this._pCurrentContextStates.stencil_back_value_mask;
                    case 36005 /* STENCIL_BACK_WRITEMASK */:
                        return this._pCurrentContextStates.stencil_back_writemask;
                    case 2961 /* STENCIL_CLEAR_VALUE */:
                        return this._pCurrentContextStates.stencil_clear_value;
                    case 2964 /* STENCIL_FAIL */:
                        return this._pCurrentContextStates.stencil_fail;
                    case 2962 /* STENCIL_FUNC */:
                        return this._pCurrentContextStates.stencil_func;
                    case 2965 /* STENCIL_PASS_DEPTH_FAIL */:
                        return this._pCurrentContextStates.stencil_pass_depth_fail;
                    case 2966 /* STENCIL_PASS_DEPTH_PASS */:
                        return this._pCurrentContextStates.stencil_pass_depth_pass;
                    case 2967 /* STENCIL_REF */:
                        return this._pCurrentContextStates.stencil_ref;
                    case 2960 /* STENCIL_TEST */:
                        return this._pCurrentContextStates.stencil_test;
                    case 2963 /* STENCIL_VALUE_MASK */:
                        return this._pCurrentContextStates.stencil_value_mask;
                    case 2968 /* STENCIL_WRITEMASK */:
                        return this._pCurrentContextStates.stencil_writemask;
                    case 3317 /* UNPACK_ALIGNMENT */:
                        return this._pCurrentContextStates.unpack_alignment;
                    case 3333 /* PACK_ALIGNMENT */:
                        return this._pCurrentContextStates.pack_alignment;
                    default:
                        return this._pWebGLContext.getParameter(iWebGLName);
                }
            };

            WebGLRenderer.prototype.lineWidth = function (fWidth) {
                this._pWebGLContext.lineWidth(fWidth);
                this._pCurrentContextStates.line_width = fWidth;
            };

            WebGLRenderer.prototype.pixelStorei = function (iWebGLName, iParam) {
                this._pWebGLContext.pixelStorei(iWebGLName, iParam);

                if (iWebGLName === 3317 /* UNPACK_ALIGNMENT */) {
                    this._pCurrentContextStates.unpack_alignment = iParam;
                } else {
                    this._pCurrentContextStates.pack_alignment = iParam;
                }
            };

            WebGLRenderer.prototype.polygonOffset = function (fFactor, fUnints) {
                this._pWebGLContext.polygonOffset(fFactor, fUnints);
                this._pCurrentContextStates.polygon_offset_factor = fFactor;
                this._pCurrentContextStates.polygon_offset_units = fUnints;
            };

            WebGLRenderer.prototype.sampleCoverage = function (fValue, bInvert) {
                this._pWebGLContext.sampleCoverage(fValue, bInvert);
                this._pCurrentContextStates.sample_coverage_value = fValue;
                this._pCurrentContextStates.sample_coverage_invert = bInvert;
            };

            WebGLRenderer.prototype.stencilFunc = function (iWebGLFunc, iRef, iMask) {
                this._pWebGLContext.stencilFunc(iWebGLFunc, iRef, iMask);
                this._pCurrentContextStates.stencil_func = iWebGLFunc;
                this._pCurrentContextStates.stencil_ref = iRef;
                this._pCurrentContextStates.stencil_value_mask = iMask;
                this._pCurrentContextStates.stencil_back_func = iWebGLFunc;
                this._pCurrentContextStates.stencil_back_ref = iRef;
                this._pCurrentContextStates.stencil_back_value_mask = iMask;
            };

            WebGLRenderer.prototype.stencilFuncSeparate = function (iWebGLFace, iWebGLFunc, iRef, iMask) {
                this._pWebGLContext.stencilFuncSeparate(iWebGLFace, iWebGLFunc, iRef, iMask);

                if (iWebGLFace === 1032 /* FRONT_AND_BACK */) {
                    this._pCurrentContextStates.stencil_func = iWebGLFunc;
                    this._pCurrentContextStates.stencil_ref = iRef;
                    this._pCurrentContextStates.stencil_value_mask = iMask;
                    this._pCurrentContextStates.stencil_back_func = iWebGLFunc;
                    this._pCurrentContextStates.stencil_back_ref = iRef;
                    this._pCurrentContextStates.stencil_back_value_mask = iMask;
                } else if (iWebGLFace === 1028 /* FRONT */) {
                    this._pCurrentContextStates.stencil_func = iWebGLFunc;
                    this._pCurrentContextStates.stencil_ref = iRef;
                    this._pCurrentContextStates.stencil_value_mask = iMask;
                } else {
                    this._pCurrentContextStates.stencil_back_func = iWebGLFunc;
                    this._pCurrentContextStates.stencil_back_ref = iRef;
                    this._pCurrentContextStates.stencil_back_value_mask = iMask;
                }
            };

            WebGLRenderer.prototype.stencilMask = function (iMask) {
                this._pWebGLContext.stencilMask(iMask);
                this._pCurrentContextStates.stencil_writemask = iMask;
                this._pCurrentContextStates.stencil_back_writemask = iMask;
            };

            WebGLRenderer.prototype.stencilMaskSeparate = function (iWebGLFace, iMask) {
                this._pWebGLContext.stencilMaskSeparate(iWebGLFace, iMask);

                if (iWebGLFace === 1032 /* FRONT_AND_BACK */) {
                    this._pCurrentContextStates.stencil_writemask = iMask;
                    this._pCurrentContextStates.stencil_back_writemask = iMask;
                } else if (iWebGLFace === 1028 /* FRONT */) {
                    this._pCurrentContextStates.stencil_writemask = iMask;
                } else {
                    this._pCurrentContextStates.stencil_back_writemask = iMask;
                }
            };

            WebGLRenderer.prototype.stencilOp = function (iFail, iZFail, iZPass) {
                this._pWebGLContext.stencilOp(iFail, iZFail, iZPass);

                this._pCurrentContextStates.stencil_fail = iFail;
                this._pCurrentContextStates.stencil_pass_depth_fail = iZFail;
                this._pCurrentContextStates.stencil_pass_depth_pass = iZPass;
                this._pCurrentContextStates.stencil_back_fail = iFail;
                this._pCurrentContextStates.stencil_back_pass_depth_fail = iZFail;
                this._pCurrentContextStates.stencil_back_pass_depth_pass = iZPass;
            };

            WebGLRenderer.prototype.stencilOpSeparate = function (iWebGLFace, iFail, iZFail, iZPass) {
                this._pWebGLContext.stencilOpSeparate(iWebGLFace, iFail, iZFail, iZPass);

                if (iWebGLFace === 1032 /* FRONT_AND_BACK */) {
                    this._pCurrentContextStates.stencil_fail = iFail;
                    this._pCurrentContextStates.stencil_pass_depth_fail = iZFail;
                    this._pCurrentContextStates.stencil_pass_depth_pass = iZPass;
                    this._pCurrentContextStates.stencil_back_fail = iFail;
                    this._pCurrentContextStates.stencil_back_pass_depth_fail = iZFail;
                    this._pCurrentContextStates.stencil_back_pass_depth_pass = iZPass;
                } else if (iWebGLFace === 1028 /* FRONT */) {
                    this._pCurrentContextStates.stencil_fail = iFail;
                    this._pCurrentContextStates.stencil_pass_depth_fail = iZFail;
                    this._pCurrentContextStates.stencil_pass_depth_pass = iZPass;
                } else {
                    this._pCurrentContextStates.stencil_back_fail = iFail;
                    this._pCurrentContextStates.stencil_back_pass_depth_fail = iZFail;
                    this._pCurrentContextStates.stencil_back_pass_depth_pass = iZPass;
                }
            };

            WebGLRenderer.prototype._getTextureStateManager = function () {
                return this._pTextureStateManager;
            };

            WebGLRenderer.prototype._beginRender = function () {
                this.enable(3089 /* SCISSOR_TEST */);
                this.disable(3042 /* BLEND */);
            };

            WebGLRenderer.prototype._printTime = function () {
                var _iTotalTime = 0;
                for (var i = 0; i < this._time.length; i++) {
                    _iTotalTime += this._time[i];
                }

                var _pPrinted = new Array(this._time.length);

                for (var i = 0; i < this._time.length; i++) {
                    _pPrinted[i] = (this._time[i] / _iTotalTime).toFixed(2);
                }

                akra.logger.log(_pPrinted.join("% "));
                akra.logger.log(this._time.join("ms "));
            };

            WebGLRenderer.prototype._renderEntry = function (pEntry) {
                var pViewport = pEntry.viewport;
                if (akra.isNull(pViewport)) {
                    akra.logger.log(pEntry);
                }
                var pRenderTarget = pViewport.getTarget();
                var pInput = pEntry.input;
                var pMaker = pEntry.maker;

                if (akra.config.__VIEW_INTERNALS__) {
                    console.log(pEntry);
                }

                if (!akra.isNull(pEntry.renderTarget)) {
                    this._setRenderTarget(pEntry.renderTarget);
                    this._lockRenderTarget();

                    this._setViewportForRender(pViewport);

                    this._unlockRenderTarget();
                } else {
                    this._setViewportForRender(pViewport);
                }

                var isNeedPopRenderStates = this.applyInputRenderStates(pInput.renderStates);

                var pWebGLProgram = (pMaker).getShaderProgram();

                if (this._pLastMaker !== pMaker) {
                    this.useWebGLProgram(pWebGLProgram.getWebGLProgram());

                    this.enableWebGLVertexAttribs(pWebGLProgram.getTotalAttributes());
                }

                var pAttribLocations = pWebGLProgram._getActiveAttribLocations();
                var pAttributeInfo = pMaker.getAttributeInfo();

                var pBufferMap = pEntry.bufferMap;

                if (!akra.isNull(pBufferMap.getIndex())) {
                    this.bindWebGLBuffer(34963 /* ELEMENT_ARRAY_BUFFER */, pBufferMap.getIndex().getBuffer().getWebGLBuffer());
                }

                for (var i = 0; i < pAttributeInfo.length; i++) {
                    var sAttrName = pAttributeInfo[i].name;
                    var sAttrSemantic = pAttributeInfo[i].semantic;
                    var iLoc = pAttribLocations[sAttrName];
                    var pFlow = pInput.attrs[i];
                    var pData = null;
                    var sSemantics = null;

                    if (pFlow.type === 1 /* MAPPABLE */) {
                        pData = pFlow.mapper.data;
                        sSemantics = pFlow.mapper.semantics;
                    } else {
                        pData = pFlow.data;
                        sSemantics = sAttrSemantic;
                    }

                    var pDecl = pData.getVertexDeclaration();
                    var pVertexElement = pDecl.findElement(sSemantics);

                    this.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, pData.getBuffer().getWebGLBuffer());
                    this._pWebGLContext.vertexAttribPointer(iLoc, pVertexElement.count, pVertexElement.type, false, pData.getStride(), pVertexElement.offset);
                }

                var pUniformNames = pMaker.getUniformNames();

                if (this._pLastMaker !== pMaker) {
                    pMaker._freeUniformCache();
                    this._pLastMaker = pMaker;
                }

                for (var i = 0; i < pUniformNames.length; i++) {
                    pMaker.setUniform(i, pInput.uniforms[i]);
                }

                pEntry.bufferMap._draw();

                if (isNeedPopRenderStates) {
                    this._popRenderStates(false);
                }
            };

            WebGLRenderer.prototype._endRender = function () {
                this.disable(3089 /* SCISSOR_TEST */);
                this._pTextureStateManager.reset();
                this._pLastMaker = null;
            };

            WebGLRenderer.prototype._setViewport = function (pViewport) {
                if (akra.isNull(pViewport)) {
                    this._pActiveViewport = null;
                    this._setRenderTarget(null);
                    return;
                }

                var isViewportUpdate = pViewport !== this._pActiveViewport || pViewport.isUpdated();
                var isRenderTargetUpdate = pViewport.getTarget() !== this._pActiveRenderTarget;

                if (isViewportUpdate || isRenderTargetUpdate) {
                    var pTarget = pViewport.getTarget();

                    this._setRenderTarget(pTarget);

                    if (isViewportUpdate) {
                        this._pActiveViewport = pViewport;

                        var x = pViewport.getActualLeft(), y = pViewport.getActualTop(), w = pViewport.getActualWidth(), h = pViewport.getActualHeight();

                        this._pWebGLContext.viewport(x, y, w, h);
                        this._pWebGLContext.scissor(x, y, w, h);

                        // if(w !== 2048){
                        // 	logger.log(x, y, w, h, pViewport.getGuid());
                        // }
                        pViewport._clearUpdatedFlag();
                    }
                }
            };

            WebGLRenderer.prototype._setRenderTarget = function (pTarget) {
                // if(true){
                // 	return;
                // }
                //May be unbind()
                if (this._isLockRenderTarget()) {
                    return;
                }

                this._pActiveRenderTarget = pTarget;

                if (!akra.isNull(pTarget)) {
                    var pFrameBuffer = pTarget.getCustomAttribute("FBO");
                    if (!akra.isNull(pFrameBuffer)) {
                        pFrameBuffer._bind();
                    } else {
                        this.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, null);
                    }
                }
            };

            WebGLRenderer.prototype._setCullingMode = function (eMode) {
                var iWebGLCullMode = 0;

                switch (eMode) {
                    case 1 /* NONE */:
                        this.disable(2884 /* CULL_FACE */);
                        return;

                    default:
                    case 2 /* CLOCKWISE */:
                        iWebGLCullMode = 1028 /* FRONT */;
                        break;

                    case 3 /* ANTICLOCKWISE */:
                        iWebGLCullMode = 1029 /* BACK */;
                        break;
                }

                this.enable(2884 /* CULL_FACE */);
                this.cullFace(iWebGLCullMode);
            };

            WebGLRenderer.prototype._setDepthBufferParams = function (bDepthTest, bDepthWrite, eDepthFunction, fClearDepth) {
                if (typeof fClearDepth === "undefined") { fClearDepth = 1.; }
                if (bDepthTest) {
                    this.clearDepth(fClearDepth);
                    this.enable(2929 /* DEPTH_TEST */);
                } else {
                    this.disable(2929 /* DEPTH_TEST */);
                }

                var iWebGLDepthFunc = this.convertCompareFunction(eDepthFunction);

                this.depthMask(bDepthWrite);
                this.depthFunc(iWebGLDepthFunc);
            };

            WebGLRenderer.prototype.isDebug = function () {
                return !akra.isNull(this._pWebGLInternalContext);
            };

            WebGLRenderer.prototype.getHTMLCanvas = function () {
                return this._pCanvas;
            };

            WebGLRenderer.prototype.getWebGLContext = function () {
                return this._pWebGLContext;
            };

            /** Buffer Objects. */
            WebGLRenderer.prototype.bindWebGLBuffer = function (eTarget, pBuffer) {
                this._pWebGLContext.bindBuffer(eTarget, pBuffer);
            };

            WebGLRenderer.prototype.createWebGLBuffer = function () {
                return this._pWebGLContext.createBuffer();
            };

            WebGLRenderer.prototype.deleteWebGLBuffer = function (pBuffer) {
                this._pWebGLContext.deleteBuffer(pBuffer);
            };

            /** Texture Objects. */
            WebGLRenderer.prototype.bindWebGLTexture = function (eTarget, pTexture) {
                if (this._pTextureSlotList[this._iCurrentTextureSlot] !== pTexture) {
                    this._pWebGLContext.bindTexture(eTarget, pTexture);
                    this._pTextureSlotList[this._iCurrentTextureSlot] = pTexture;
                }
            };

            WebGLRenderer.prototype.activateWebGLTexture = function (iWebGLSlot) {
                this._pWebGLContext.activeTexture(iWebGLSlot);
                this._iCurrentTextureSlot = iWebGLSlot - 33984 /* TEXTURE0 */;
            };

            WebGLRenderer.prototype.activateWebGLTextureInAutoSlot = function (eTarget, pTexture) {
                var iSlot = this._pTextureSlotList.indexOf(pTexture);

                if (iSlot === -1) {
                    iSlot = this._iNextTextureSlot;

                    this._iNextTextureSlot++;

                    if (this._iNextTextureSlot === webgl.maxTextureImageUnits) {
                        this._iNextTextureSlot = 0;
                    }

                    this.activateWebGLTexture(33984 /* TEXTURE0 */ + iSlot);
                    this.bindWebGLTexture(eTarget, pTexture);
                } else {
                    this.activateWebGLTexture(33984 /* TEXTURE0 */ + iSlot);
                    this.bindWebGLTexture(eTarget, pTexture);
                }

                return iSlot;
            };

            WebGLRenderer.prototype.createWebGLTexture = function () {
                return this._pWebGLContext.createTexture();
            };

            WebGLRenderer.prototype.deleteWebGLTexture = function (pTexture) {
                this._pWebGLContext.deleteTexture(pTexture);
            };

            /** Framebuffer Objects */
            WebGLRenderer.prototype.createWebGLFramebuffer = function () {
                if (this._pWebGLFramebufferList.length === 0) {
                    akra.logger.critical("WebGL framebuffer limit exidit");
                }

                return this._pWebGLFramebufferList.pop();
            };

            WebGLRenderer.prototype.bindWebGLFramebuffer = function (eTarget, pBuffer) {
                this._pWebGLContext.bindFramebuffer(eTarget, pBuffer);
                //this._pCurrentContextStates.framebuffer = pBuffer;
            };

            WebGLRenderer.prototype.bindWebGLFramebufferTexture2D = function (eTarget, eAttachment, eTexTarget, pTexture, iMipLevel) {
                if (typeof iMipLevel === "undefined") { iMipLevel = 0; }
                this._pWebGLContext.framebufferTexture2D(eTarget, eAttachment, eTexTarget, pTexture, iMipLevel);
            };

            WebGLRenderer.prototype.deleteWebGLFramebuffer = function (pBuffer) {
                this._pWebGLFramebufferList.push(pBuffer);
            };

            /** Renderbuffer Objects */
            WebGLRenderer.prototype.createWebGLRenderbuffer = function () {
                return this._pWebGLContext.createRenderbuffer();
            };

            WebGLRenderer.prototype.bindWebGLRenderbuffer = function (eTarget, pBuffer) {
                this._pWebGLContext.bindRenderbuffer(eTarget, pBuffer);
            };

            WebGLRenderer.prototype.deleteWebGLRenderbuffer = function (pBuffer) {
                this._pWebGLContext.deleteRenderbuffer(pBuffer);
            };

            WebGLRenderer.prototype.createWebGLProgram = function () {
                return this._pWebGLContext.createProgram();
            };

            WebGLRenderer.prototype.deleteWebGLProgram = function (pProgram) {
                this._pWebGLContext.deleteProgram(pProgram);
            };

            WebGLRenderer.prototype.useWebGLProgram = function (pProgram) {
                this._pWebGLContext.useProgram(pProgram);
            };

            WebGLRenderer.prototype.enableWebGLVertexAttribs = function (iTotal) {
                if (this._nActiveAttributes > iTotal) {
                    for (var i = iTotal; i < this._nActiveAttributes; i++) {
                        this._pWebGLContext.disableVertexAttribArray(i);
                    }
                } else {
                    for (var i = this._nActiveAttributes; i < iTotal; i++) {
                        this._pWebGLContext.enableVertexAttribArray(i);
                    }
                }

                this._nActiveAttributes = iTotal;
            };

            WebGLRenderer.prototype.disableAllWebGLVertexAttribs = function () {
                var i = 0;
                for (i = 0; i < this._nActiveAttributes; i++) {
                    this._pWebGLContext.disableVertexAttribArray(i);
                }

                this._nActiveAttributes = 0;
            };

            WebGLRenderer.prototype.getDefaultCanvas = function () {
                return this._pDefaultCanvas;
            };

            WebGLRenderer.prototype.clearFrameBuffer = function (iBuffers, cColor, fDepth, iStencil) {
                var bScissorTestEnable = this.getParameter(3089 /* SCISSOR_TEST */);

                this.enable(3089 /* SCISSOR_TEST */);

                var iWebGLFlag = 0;
                var bOldDepthWrite = this.getParameter(2930 /* DEPTH_WRITEMASK */);

                if (iBuffers & 1 /* COLOR */) {
                    iWebGLFlag |= 16384 /* COLOR_BUFFER_BIT */;
                    this._pWebGLContext.clearColor(cColor.r, cColor.g, cColor.b, cColor.a);
                }

                if (iBuffers & 2 /* DEPTH */) {
                    iWebGLFlag |= 256 /* DEPTH_BUFFER_BIT */;

                    if (!bOldDepthWrite) {
                        this._pWebGLContext.depthMask(true);
                    }

                    this._pWebGLContext.clearDepth(fDepth);
                }

                if (iBuffers & 4 /* STENCIL */) {
                    iWebGLFlag |= 1024 /* STENCIL_BUFFER_BIT */;

                    this._pWebGLContext.stencilMask(0xFFFFFFFF);
                    this._pWebGLContext.clearStencil(iStencil);
                }

                this._pWebGLContext.clear(iWebGLFlag);

                if (!bOldDepthWrite && (iBuffers & 2 /* DEPTH */)) {
                    this._pWebGLContext.depthMask(false);
                }

                if (!bScissorTestEnable) {
                    this.disable(3089 /* SCISSOR_TEST */);
                }
            };

            WebGLRenderer.prototype._disableTextureUnitsFrom = function (iUnit) {
                for (var i = iUnit; i < this._pTextureSlotList.length; i++) {
                    this._pTextureSlotList[i] = null;
                }
            };

            WebGLRenderer.prototype._pushRenderStates = function () {
                this._pRenderStatesPool.push(this._pCurrentContextStates);

                this._pCurrentContextStates = WebGLRenderer.copyWebGLContextStates(this.getFreeRenderStates(), this._pCurrentContextStates);
            };

            WebGLRenderer.prototype._popRenderStates = function (isForce) {
                if (this._pRenderStatesPool.getLength() === 0) {
                    akra.debug.warn("Can not pop context render states. Pool of context is empty.");
                }

                this._pFreeRenderStatesPool.push(this._pCurrentContextStates);

                if (isForce) {
                    this.forceUpdateContextRenderStates();
                }

                var pCurreentStates = this._pCurrentContextStates;
                this._pCurrentContextStates = this._pRenderStatesPool.pop();

                this.restoreWebGLContextRenderStates(pCurreentStates);
            };

            WebGLRenderer.prototype.restoreWebGLContextRenderStates = function (pStatesFrom) {
                this.restoreBlendStates(pStatesFrom);
                this.restoreCullStates(pStatesFrom);
                this.restoreColorStates(pStatesFrom);
                this.restoreDepthStates(pStatesFrom);
                this.restoreDitherStates(pStatesFrom);
                this.restoreFrontFaceStates(pStatesFrom);
                this.restorePolygonStates(pStatesFrom);
                this.restoreSampleStates(pStatesFrom);
                this.restoreScissorStates(pStatesFrom);
                this.restoreStencilStates(pStatesFrom);
                this.restorePackStates(pStatesFrom);
            };

            WebGLRenderer.prototype.restoreBlendStates = function (pStatesFrom) {
                var pRestoreStates = this._pCurrentContextStates;

                if (pRestoreStates.blend !== pStatesFrom.blend) {
                    if (pRestoreStates.blend) {
                        this._pWebGLContext.enable(3042 /* BLEND */);
                    } else {
                        this._pWebGLContext.disable(3042 /* BLEND */);
                    }
                }

                if (pRestoreStates.blend_equation_rgb !== pStatesFrom.blend_equation_rgb || pRestoreStates.blend_equation_alpha !== pStatesFrom.blend_equation_alpha) {
                    if (pRestoreStates.blend_equation_rgb === pRestoreStates.blend_equation_alpha) {
                        this._pWebGLContext.blendEquation(pRestoreStates.blend_equation_rgb);
                    } else {
                        this._pWebGLContext.blendEquationSeparate(pRestoreStates.blend_equation_rgb, pRestoreStates.blend_equation_alpha);
                    }
                }

                if (pRestoreStates.blend_dst_rgb !== pStatesFrom.blend_dst_rgb || pRestoreStates.blend_dst_alpha !== pStatesFrom.blend_dst_alpha || pRestoreStates.blend_src_rgb !== pStatesFrom.blend_src_rgb || pRestoreStates.blend_src_alpha !== pStatesFrom.blend_src_alpha) {
                    if (pRestoreStates.blend_dst_rgb === pRestoreStates.blend_dst_alpha && pRestoreStates.blend_src_rgb === pRestoreStates.blend_src_alpha) {
                        this._pWebGLContext.blendFunc(pRestoreStates.blend_src_rgb, pRestoreStates.blend_dst_rgb);
                    } else {
                        this._pWebGLContext.blendFuncSeparate(pRestoreStates.blend_src_rgb, pRestoreStates.blend_dst_rgb, pRestoreStates.blend_src_alpha, pRestoreStates.blend_dst_alpha);
                    }
                }
            };

            WebGLRenderer.prototype.restoreCullStates = function (pStatesFrom) {
                var pRestoreStates = this._pCurrentContextStates;

                if (pRestoreStates.cull_face !== pStatesFrom.cull_face) {
                    if (pRestoreStates.cull_face) {
                        this._pWebGLContext.enable(2884 /* CULL_FACE */);
                    } else {
                        this._pWebGLContext.disable(2884 /* CULL_FACE */);
                    }
                }

                if (pRestoreStates.cull_face_mode !== pStatesFrom.cull_face_mode) {
                    this._pWebGLContext.cullFace(pRestoreStates.cull_face_mode);
                }
            };

            WebGLRenderer.prototype.restoreColorStates = function (pStatesFrom) {
                var pRestoreStates = this._pCurrentContextStates;

                if (pRestoreStates.color_clear_value[0] !== pStatesFrom.color_clear_value[0] || pRestoreStates.color_clear_value[1] !== pStatesFrom.color_clear_value[1] || pRestoreStates.color_clear_value[2] !== pStatesFrom.color_clear_value[2] || pRestoreStates.color_clear_value[3] !== pStatesFrom.color_clear_value[3]) {
                    this._pWebGLContext.clearColor(pRestoreStates.color_clear_value[0], pRestoreStates.color_clear_value[1], pRestoreStates.color_clear_value[2], pRestoreStates.color_clear_value[3]);
                }

                if (pRestoreStates.color_writemask[0] !== pStatesFrom.color_writemask[0] || pRestoreStates.color_writemask[1] !== pStatesFrom.color_writemask[1] || pRestoreStates.color_writemask[2] !== pStatesFrom.color_writemask[2] || pRestoreStates.color_writemask[3] !== pStatesFrom.color_writemask[3]) {
                    this._pWebGLContext.colorMask(pRestoreStates.color_writemask[0], pRestoreStates.color_writemask[1], pRestoreStates.color_writemask[2], pRestoreStates.color_writemask[3]);
                }
            };

            WebGLRenderer.prototype.restoreDepthStates = function (pStatesFrom) {
                var pRestoreStates = this._pCurrentContextStates;

                if (pRestoreStates.depth_test !== pStatesFrom.depth_test) {
                    if (pRestoreStates.depth_test) {
                        this._pWebGLContext.enable(2929 /* DEPTH_TEST */);
                    } else {
                        this._pWebGLContext.disable(2929 /* DEPTH_TEST */);
                    }
                }

                if (pRestoreStates.depth_clear_value !== pStatesFrom.depth_clear_value) {
                    this._pWebGLContext.clearDepth(pRestoreStates.depth_clear_value);
                }

                if (pRestoreStates.depth_func !== pStatesFrom.depth_func) {
                    this._pWebGLContext.depthFunc(pRestoreStates.depth_func);
                }

                if (pRestoreStates.depth_writemask !== pStatesFrom.depth_writemask) {
                    this._pWebGLContext.depthMask(pRestoreStates.depth_writemask);
                }

                if (pRestoreStates.depth_range[0] !== pStatesFrom.depth_range[0] || pRestoreStates.depth_range[1] !== pStatesFrom.depth_range[1]) {
                    this._pWebGLContext.depthRange(pRestoreStates.depth_range[0], pRestoreStates.depth_range[1]);
                }
            };

            WebGLRenderer.prototype.restoreDitherStates = function (pStatesFrom) {
                var pRestoreStates = this._pCurrentContextStates;

                if (pRestoreStates.dither !== pStatesFrom.dither) {
                    if (pRestoreStates.dither) {
                        this._pWebGLContext.enable(3024 /* DITHER */);
                    } else {
                        this._pWebGLContext.disable(3024 /* DITHER */);
                    }
                }
            };

            WebGLRenderer.prototype.restoreFrontFaceStates = function (pStatesFrom) {
                var pRestoreStates = this._pCurrentContextStates;

                if (pRestoreStates.front_face !== pStatesFrom.front_face) {
                    this._pWebGLContext.frontFace(pRestoreStates.front_face);
                }
            };

            WebGLRenderer.prototype.restorePolygonStates = function (pStatesFrom) {
                var pRestoreStates = this._pCurrentContextStates;

                if (pRestoreStates.polygon_offset_fill !== pStatesFrom.polygon_offset_fill) {
                    if (pRestoreStates.polygon_offset_fill) {
                        this._pWebGLContext.enable(32823 /* POLYGON_OFFSET_FILL */);
                    } else {
                        this._pWebGLContext.disable(32823 /* POLYGON_OFFSET_FILL */);
                    }
                }

                if (pRestoreStates.polygon_offset_factor !== pStatesFrom.polygon_offset_factor || pRestoreStates.polygon_offset_units !== pStatesFrom.polygon_offset_units) {
                    this._pWebGLContext.polygonOffset(pRestoreStates.polygon_offset_factor, pRestoreStates.polygon_offset_units);
                }
            };

            WebGLRenderer.prototype.restoreSampleStates = function (pStatesFrom) {
                var pRestoreStates = this._pCurrentContextStates;

                if (pRestoreStates.sample_coverage_value !== pStatesFrom.sample_coverage_value || pRestoreStates.sample_coverage_invert !== pStatesFrom.sample_coverage_invert) {
                    this._pWebGLContext.sampleCoverage(pRestoreStates.sample_coverage_value, pRestoreStates.sample_coverage_invert);
                }
            };

            WebGLRenderer.prototype.restoreScissorStates = function (pStatesFrom) {
                var pRestoreStates = this._pCurrentContextStates;

                if (pRestoreStates.scissor_test !== pStatesFrom.scissor_test) {
                    if (pRestoreStates.scissor_test) {
                        this._pWebGLContext.enable(3089 /* SCISSOR_TEST */);
                    } else {
                        this._pWebGLContext.disable(3089 /* SCISSOR_TEST */);
                    }
                }
            };

            WebGLRenderer.prototype.restoreStencilStates = function (pStatesFrom) {
                var pRestoreStates = this._pCurrentContextStates;

                if (pRestoreStates.stencil_test !== pStatesFrom.stencil_test) {
                    if (pRestoreStates.stencil_test) {
                        this._pWebGLContext.enable(2960 /* STENCIL_TEST */);
                    } else {
                        this._pWebGLContext.disable(2960 /* STENCIL_TEST */);
                    }
                }

                if (pRestoreStates.stencil_clear_value !== pStatesFrom.stencil_clear_value) {
                    this._pWebGLContext.clearStencil(pRestoreStates.stencil_clear_value);
                }

                if (pRestoreStates.stencil_func !== pStatesFrom.stencil_func || pRestoreStates.stencil_ref !== pStatesFrom.stencil_ref || pRestoreStates.stencil_value_mask !== pStatesFrom.stencil_value_mask || pRestoreStates.stencil_back_func !== pStatesFrom.stencil_back_func || pRestoreStates.stencil_back_ref !== pStatesFrom.stencil_back_ref || pRestoreStates.stencil_back_value_mask !== pStatesFrom.stencil_back_value_mask) {
                    if (pRestoreStates.stencil_func === pRestoreStates.stencil_back_func || pRestoreStates.stencil_ref === pRestoreStates.stencil_back_ref || pRestoreStates.stencil_value_mask === pRestoreStates.stencil_back_value_mask) {
                        this._pWebGLContext.stencilFunc(pRestoreStates.stencil_func, pRestoreStates.stencil_ref, pRestoreStates.stencil_value_mask);
                    } else {
                        this._pWebGLContext.stencilFuncSeparate(1028 /* FRONT */, pRestoreStates.stencil_func, pRestoreStates.stencil_ref, pRestoreStates.stencil_value_mask);

                        this._pWebGLContext.stencilFuncSeparate(1029 /* BACK */, pRestoreStates.stencil_back_func, pRestoreStates.stencil_back_ref, pRestoreStates.stencil_back_value_mask);
                    }
                }

                if (pRestoreStates.stencil_writemask !== pStatesFrom.stencil_writemask || pRestoreStates.stencil_back_writemask !== pStatesFrom.stencil_back_writemask) {
                    if (pRestoreStates.stencil_writemask === pRestoreStates.stencil_back_writemask) {
                        this._pWebGLContext.stencilMask(pRestoreStates.stencil_writemask);
                    } else {
                        this._pWebGLContext.stencilMaskSeparate(1028 /* FRONT */, pRestoreStates.stencil_writemask);
                        this._pWebGLContext.stencilMaskSeparate(1029 /* BACK */, pRestoreStates.stencil_writemask);
                    }
                }

                if (pRestoreStates.stencil_fail !== pStatesFrom.stencil_fail || pRestoreStates.stencil_pass_depth_fail !== pStatesFrom.stencil_pass_depth_fail || pRestoreStates.stencil_pass_depth_pass !== pStatesFrom.stencil_pass_depth_pass || pRestoreStates.stencil_back_fail !== pStatesFrom.stencil_back_fail || pRestoreStates.stencil_back_pass_depth_fail !== pStatesFrom.stencil_back_pass_depth_fail || pRestoreStates.stencil_back_pass_depth_pass !== pStatesFrom.stencil_back_pass_depth_pass) {
                    if (pRestoreStates.stencil_fail === pRestoreStates.stencil_back_fail || pRestoreStates.stencil_pass_depth_fail === pRestoreStates.stencil_back_pass_depth_fail || pRestoreStates.stencil_pass_depth_pass === pRestoreStates.stencil_back_pass_depth_pass) {
                        this._pWebGLContext.stencilOp(pRestoreStates.stencil_fail, pRestoreStates.stencil_pass_depth_fail, pRestoreStates.stencil_pass_depth_pass);
                    } else {
                        this._pWebGLContext.stencilOpSeparate(1028 /* FRONT */, pRestoreStates.stencil_fail, pRestoreStates.stencil_pass_depth_fail, pRestoreStates.stencil_pass_depth_pass);

                        this._pWebGLContext.stencilOpSeparate(1029 /* BACK */, pRestoreStates.stencil_back_fail, pRestoreStates.stencil_back_pass_depth_fail, pRestoreStates.stencil_back_pass_depth_pass);
                    }
                }
            };

            WebGLRenderer.prototype.restorePackStates = function (pStatesFrom) {
                var pRestoreStates = this._pCurrentContextStates;

                if (pRestoreStates.unpack_alignment !== pStatesFrom.unpack_alignment) {
                    this._pWebGLContext.pixelStorei(3317 /* UNPACK_ALIGNMENT */, pRestoreStates.unpack_alignment);
                }

                if (pRestoreStates.pack_alignment !== pStatesFrom.pack_alignment) {
                    this._pWebGLContext.pixelStorei(3333 /* PACK_ALIGNMENT */, pRestoreStates.pack_alignment);
                }
            };

            WebGLRenderer.prototype.forceUpdateContextRenderStates = function () {
                WebGLRenderer.initStatesFromWebGLContext(this._pCurrentContextStates, this._pWebGLContext);
            };

            WebGLRenderer.prototype.getFreeRenderStates = function () {
                if (this._pFreeRenderStatesPool.getLength() > 0) {
                    return this._pFreeRenderStatesPool.pop();
                } else {
                    return WebGLRenderer.createWebGLContextStates();
                }
            };

            WebGLRenderer.prototype.applyInputRenderStates = function (pStates) {
                var isStatesChanged = false;
                var iWebGLValue = 0;

                if (pStates[0 /* BLENDENABLE */] !== 0 /* UNDEF */) {
                    iWebGLValue = this.convertRenderStateValue(pStates[0 /* BLENDENABLE */]);
                    if (this._pCurrentContextStates.blend !== !!iWebGLValue) {
                        !isStatesChanged && this._pushRenderStates();
                        isStatesChanged = true;
                        this._pCurrentContextStates.blend = !!iWebGLValue;

                        if (this._pCurrentContextStates.blend) {
                            this._pWebGLContext.enable(3042 /* BLEND */);
                        } else {
                            this._pWebGLContext.disable(3042 /* BLEND */);
                        }
                    }
                }

                if (pStates[1 /* CULLFACEENABLE */] !== 0 /* UNDEF */) {
                    iWebGLValue = this.convertRenderStateValue(pStates[1 /* CULLFACEENABLE */]);
                    if (this._pCurrentContextStates.cull_face !== !!iWebGLValue) {
                        !isStatesChanged && this._pushRenderStates();
                        isStatesChanged = true;
                        this._pCurrentContextStates.cull_face = !!iWebGLValue;

                        if (this._pCurrentContextStates.cull_face) {
                            this._pWebGLContext.enable(2884 /* CULL_FACE */);
                        } else {
                            this._pWebGLContext.disable(2884 /* CULL_FACE */);
                        }
                    }
                }

                if (pStates[2 /* ZENABLE */] !== 0 /* UNDEF */) {
                    iWebGLValue = this.convertRenderStateValue(pStates[2 /* ZENABLE */]);
                    if (this._pCurrentContextStates.depth_test !== !!iWebGLValue) {
                        !isStatesChanged && this._pushRenderStates();
                        isStatesChanged = true;
                        this._pCurrentContextStates.depth_test = !!iWebGLValue;

                        if (this._pCurrentContextStates.depth_test) {
                            this._pWebGLContext.enable(2929 /* DEPTH_TEST */);
                        } else {
                            this._pWebGLContext.disable(2929 /* DEPTH_TEST */);
                        }
                    }
                }

                if (pStates[4 /* DITHERENABLE */] !== 0 /* UNDEF */) {
                    iWebGLValue = this.convertRenderStateValue(pStates[4 /* DITHERENABLE */]);
                    if (this._pCurrentContextStates.dither !== !!iWebGLValue) {
                        !isStatesChanged && this._pushRenderStates();
                        isStatesChanged = true;
                        this._pCurrentContextStates.dither = !!iWebGLValue;

                        if (this._pCurrentContextStates.dither) {
                            this._pWebGLContext.enable(3024 /* DITHER */);
                        } else {
                            this._pWebGLContext.disable(3024 /* DITHER */);
                        }
                    }
                }

                if (pStates[3 /* ZWRITEENABLE */] !== 0 /* UNDEF */) {
                    !isStatesChanged && this._pushRenderStates();
                    isStatesChanged = true;
                    this._pCurrentContextStates.depth_writemask = this.convertRenderStateValue(pStates[3 /* ZWRITEENABLE */]);

                    this._pWebGLContext.depthMask(this._pCurrentContextStates.depth_writemask);
                }

                if (pStates[5 /* SCISSORTESTENABLE */] !== 0 /* UNDEF */) {
                    iWebGLValue = this.convertRenderStateValue(pStates[5 /* SCISSORTESTENABLE */]);
                    if (this._pCurrentContextStates.scissor_test !== !!iWebGLValue) {
                        !isStatesChanged && this._pushRenderStates();
                        isStatesChanged = true;
                        this._pCurrentContextStates.scissor_test = !!iWebGLValue;

                        if (this._pCurrentContextStates.scissor_test) {
                            this._pWebGLContext.enable(3089 /* SCISSOR_TEST */);
                        } else {
                            this._pWebGLContext.disable(3089 /* SCISSOR_TEST */);
                        }
                    }
                }

                if (pStates[6 /* STENCILTESTENABLE */] !== 0 /* UNDEF */) {
                    iWebGLValue = this.convertRenderStateValue(pStates[6 /* STENCILTESTENABLE */]);
                    if (this._pCurrentContextStates.stencil_test !== !!iWebGLValue) {
                        !isStatesChanged && this._pushRenderStates();
                        isStatesChanged = true;
                        this._pCurrentContextStates.stencil_test = !!iWebGLValue;

                        if (this._pCurrentContextStates.stencil_test) {
                            this._pWebGLContext.enable(2960 /* STENCIL_TEST */);
                        } else {
                            this._pWebGLContext.disable(2960 /* STENCIL_TEST */);
                        }
                    }
                }

                if (pStates[7 /* POLYGONOFFSETFILLENABLE */] !== 0 /* UNDEF */) {
                    iWebGLValue = this.convertRenderStateValue(pStates[7 /* POLYGONOFFSETFILLENABLE */]);
                    if (this._pCurrentContextStates.polygon_offset_fill !== !!iWebGLValue) {
                        !isStatesChanged && this._pushRenderStates();
                        isStatesChanged = true;
                        this._pCurrentContextStates.polygon_offset_fill = !!iWebGLValue;

                        if (this._pCurrentContextStates.polygon_offset_fill) {
                            this._pWebGLContext.enable(32823 /* POLYGON_OFFSET_FILL */);
                        } else {
                            this._pWebGLContext.disable(32823 /* POLYGON_OFFSET_FILL */);
                        }
                    }
                }

                if (pStates[8 /* CULLFACE */] !== 0 /* UNDEF */) {
                    iWebGLValue = this.convertRenderStateValue(pStates[8 /* CULLFACE */]);
                    if (this._pCurrentContextStates.cull_face_mode !== iWebGLValue) {
                        !isStatesChanged && this._pushRenderStates();
                        isStatesChanged = true;
                        this._pCurrentContextStates.cull_face_mode = iWebGLValue;

                        this._pWebGLContext.cullFace(this._pCurrentContextStates.cull_face_mode);
                    }
                }

                if (pStates[9 /* FRONTFACE */] !== 0 /* UNDEF */) {
                    iWebGLValue = this.convertRenderStateValue(pStates[9 /* FRONTFACE */]);
                    if (this._pCurrentContextStates.front_face !== iWebGLValue) {
                        !isStatesChanged && this._pushRenderStates();
                        isStatesChanged = true;
                        this._pCurrentContextStates.front_face = iWebGLValue;

                        this._pWebGLContext.frontFace(this._pCurrentContextStates.front_face);
                    }
                }

                if (pStates[16 /* ZFUNC */] !== 0 /* UNDEF */) {
                    iWebGLValue = this.convertRenderStateValue(pStates[16 /* ZFUNC */]);
                    if (this._pCurrentContextStates.depth_func !== iWebGLValue) {
                        !isStatesChanged && this._pushRenderStates();
                        isStatesChanged = true;
                        this._pCurrentContextStates.depth_func = iWebGLValue;

                        this._pWebGLContext.depthFunc(this._pCurrentContextStates.depth_func);
                    }
                }

                if (pStates[10 /* SRCBLENDCOLOR */] !== 0 /* UNDEF */ || pStates[11 /* DESTBLENDCOLOR */] !== 0 /* UNDEF */ || pStates[12 /* SRCBLENDALPHA */] !== 0 /* UNDEF */ || pStates[13 /* DESTBLENDALPHA */] !== 0 /* UNDEF */) {
                    var iWebGLSColor = (pStates[10 /* SRCBLENDCOLOR */] !== 0 /* UNDEF */) ? this.convertRenderStateValue(pStates[10 /* SRCBLENDCOLOR */]) : this._pCurrentContextStates.blend_src_rgb;
                    var iWebGLSAlpha = (pStates[12 /* SRCBLENDALPHA */] !== 0 /* UNDEF */) ? this.convertRenderStateValue(pStates[12 /* SRCBLENDALPHA */]) : this._pCurrentContextStates.blend_src_alpha;
                    var iWebGLDColor = (pStates[11 /* DESTBLENDCOLOR */] !== 0 /* UNDEF */) ? this.convertRenderStateValue(pStates[11 /* DESTBLENDCOLOR */]) : this._pCurrentContextStates.blend_dst_rgb;
                    var iWebGLDAlpha = (pStates[13 /* DESTBLENDALPHA */] !== 0 /* UNDEF */) ? this.convertRenderStateValue(pStates[13 /* DESTBLENDALPHA */]) : this._pCurrentContextStates.blend_dst_alpha;

                    if (this._pCurrentContextStates.blend_src_rgb !== iWebGLSColor || this._pCurrentContextStates.blend_src_alpha !== iWebGLSAlpha || this._pCurrentContextStates.blend_dst_rgb !== iWebGLDColor || this._pCurrentContextStates.blend_dst_alpha !== iWebGLDAlpha) {
                        !isStatesChanged && this._pushRenderStates();
                        isStatesChanged = true;

                        this._pCurrentContextStates.blend_src_rgb = iWebGLSColor;
                        this._pCurrentContextStates.blend_src_alpha = iWebGLSAlpha;
                        this._pCurrentContextStates.blend_dst_rgb = iWebGLDColor;
                        this._pCurrentContextStates.blend_dst_alpha = iWebGLDAlpha;

                        if (iWebGLSColor === iWebGLSAlpha && iWebGLDColor === iWebGLDAlpha) {
                            this._pWebGLContext.blendFunc(iWebGLSColor, iWebGLDColor);
                        } else {
                            this._pWebGLContext.blendFuncSeparate(iWebGLSColor, iWebGLDColor, iWebGLSAlpha, iWebGLDAlpha);
                        }
                    }
                }

                if (pStates[14 /* BLENDEQUATIONCOLOR */] !== 0 /* UNDEF */ || pStates[15 /* BLENDEQUATIONALPHA */] !== 0 /* UNDEF */) {
                    var iModeRGB = (pStates[14 /* BLENDEQUATIONCOLOR */] !== 0 /* UNDEF */) ? this.convertRenderStateValue(pStates[14 /* BLENDEQUATIONCOLOR */]) : this._pCurrentContextStates.blend_equation_rgb;
                    var iModeAlpha = (pStates[15 /* BLENDEQUATIONALPHA */] !== 0 /* UNDEF */) ? this.convertRenderStateValue(pStates[15 /* BLENDEQUATIONALPHA */]) : this._pCurrentContextStates.blend_equation_alpha;

                    if (this._pCurrentContextStates.blend_equation_rgb !== iModeRGB || this._pCurrentContextStates.blend_equation_alpha !== iModeAlpha) {
                        !isStatesChanged && this._pushRenderStates();
                        isStatesChanged = true;

                        this._pCurrentContextStates.blend_equation_rgb = iModeRGB;
                        this._pCurrentContextStates.blend_equation_alpha = iModeAlpha;

                        this._pWebGLContext.blendEquationSeparate(iModeRGB, iModeAlpha);
                    }
                }

                return isStatesChanged;
            };

            WebGLRenderer.prototype.convertRenderStateValue = function (eStateValue) {
                switch (eStateValue) {
                    case 1 /* TRUE */:
                        return 1;
                    case 2 /* FALSE */:
                        return 0;
                    case 3 /* ZERO */:
                        return 0 /* ZERO */;
                    case 4 /* ONE */:
                        return 1 /* ONE */;
                    case 5 /* SRCCOLOR */:
                        return 768 /* SRC_COLOR */;
                    case 6 /* INVSRCCOLOR */:
                        return 769 /* ONE_MINUS_SRC_COLOR */;
                    case 7 /* SRCALPHA */:
                        return 770 /* SRC_ALPHA */;
                    case 8 /* INVSRCALPHA */:
                        return 771 /* ONE_MINUS_SRC_ALPHA */;
                    case 9 /* DESTALPHA */:
                        return 772 /* DST_ALPHA */;
                    case 10 /* INVDESTALPHA */:
                        return 773 /* ONE_MINUS_DST_ALPHA */;
                    case 11 /* DESTCOLOR */:
                        return 774 /* DST_COLOR */;
                    case 12 /* INVDESTCOLOR */:
                        return 775 /* ONE_MINUS_DST_COLOR */;
                    case 13 /* SRCALPHASAT */:
                        return 776 /* SRC_ALPHA_SATURATE */;
                    case 14 /* NONE */:
                        return 0 /* NONE */;
                    case 15 /* CW */:
                        return 2304 /* CW */;
                    case 16 /* CCW */:
                        return 2305 /* CCW */;
                    case 17 /* FRONT */:
                        return 1028 /* FRONT */;
                    case 18 /* BACK */:
                        return 1029 /* BACK */;
                    case 19 /* FRONT_AND_BACK */:
                        return 1032 /* FRONT_AND_BACK */;
                    case 20 /* NEVER */:
                        return 512 /* NEVER */;
                    case 21 /* LESS */:
                        return 513 /* LESS */;
                    case 22 /* EQUAL */:
                        return 514 /* EQUAL */;
                    case 23 /* LESSEQUAL */:
                        return 515 /* LEQUAL */;
                    case 24 /* GREATER */:
                        return 516 /* GREATER */;
                    case 25 /* NOTEQUAL */:
                        return 517 /* NOTEQUAL */;
                    case 26 /* GREATEREQUAL */:
                        return 518 /* GEQUAL */;
                    case 27 /* ALWAYS */:
                        return 519 /* ALWAYS */;
                    case 28 /* FUNCADD */:
                        return 32774 /* FUNC_ADD */;
                    case 29 /* FUNCSUBTRACT */:
                        return 32778 /* FUNC_SUBTRACT */;
                    case 30 /* FUNCREVERSESUBTRACT */:
                        return 32779 /* FUNC_REVERSE_SUBTRACT */;
                }
            };

            WebGLRenderer.prototype.convertCompareFunction = function (eFunc) {
                switch (eFunc) {
                    case 0 /* ALWAYS_FAIL */:
                        return 512 /* NEVER */;
                    case 1 /* ALWAYS_PASS */:
                        return 519 /* ALWAYS */;
                    case 2 /* LESS */:
                        return 513 /* LESS */;
                    case 3 /* LESS_EQUAL */:
                        return 515 /* LEQUAL */;
                    case 4 /* EQUAL */:
                        return 514 /* EQUAL */;
                    case 5 /* NOT_EQUAL */:
                        return 517 /* NOTEQUAL */;
                    case 6 /* GREATER_EQUAL */:
                        return 518 /* GEQUAL */;
                    case 7 /* GREATER */:
                        return 516 /* GREATER */;
                }

                return 519 /* ALWAYS */;
            };

            WebGLRenderer.createWebGLContextStates = function (pStates) {
                if (typeof pStates === "undefined") { pStates = null; }
                return {
                    blend: akra.isNull(pStates) ? false : pStates.blend,
                    blend_color: akra.isNull(pStates) ? new Float32Array(4) : new Float32Array(pStates.blend_color),
                    blend_dst_alpha: akra.isNull(pStates) ? 0 : pStates.blend_dst_alpha,
                    blend_dst_rgb: akra.isNull(pStates) ? 0 : pStates.blend_dst_rgb,
                    blend_equation_alpha: akra.isNull(pStates) ? 0 : pStates.blend_equation_alpha,
                    blend_equation_rgb: akra.isNull(pStates) ? 0 : pStates.blend_equation_rgb,
                    blend_src_alpha: akra.isNull(pStates) ? 0 : pStates.blend_src_alpha,
                    blend_src_rgb: akra.isNull(pStates) ? 0 : pStates.blend_src_rgb,
                    color_clear_value: akra.isNull(pStates) ? new Float32Array(4) : new Float32Array(pStates.color_clear_value),
                    color_writemask: akra.isNull(pStates) ? [false, false, false, false] : pStates.color_writemask.slice(0),
                    cull_face: akra.isNull(pStates) ? false : pStates.cull_face,
                    cull_face_mode: akra.isNull(pStates) ? 0 : pStates.cull_face_mode,
                    depth_clear_value: akra.isNull(pStates) ? 0. : pStates.depth_clear_value,
                    depth_func: akra.isNull(pStates) ? 0 : pStates.depth_func,
                    depth_range: akra.isNull(pStates) ? new Float32Array(2) : new Float32Array(pStates.depth_range),
                    depth_test: akra.isNull(pStates) ? false : pStates.depth_test,
                    depth_writemask: akra.isNull(pStates) ? false : pStates.depth_writemask,
                    dither: akra.isNull(pStates) ? false : pStates.dither,
                    front_face: akra.isNull(pStates) ? 0 : pStates.front_face,
                    line_width: akra.isNull(pStates) ? 0. : pStates.line_width,
                    polygon_offset_factor: akra.isNull(pStates) ? 0. : pStates.polygon_offset_factor,
                    polygon_offset_fill: akra.isNull(pStates) ? false : pStates.polygon_offset_fill,
                    polygon_offset_units: akra.isNull(pStates) ? 0. : pStates.polygon_offset_units,
                    sample_buffers: akra.isNull(pStates) ? 0 : pStates.sample_buffers,
                    sample_coverage_invert: akra.isNull(pStates) ? false : pStates.sample_coverage_invert,
                    sample_coverage_value: akra.isNull(pStates) ? 0. : pStates.sample_coverage_value,
                    samples: akra.isNull(pStates) ? 0 : pStates.samples,
                    scissor_test: akra.isNull(pStates) ? false : pStates.scissor_test,
                    stencil_back_fail: akra.isNull(pStates) ? 0 : pStates.stencil_back_fail,
                    stencil_back_func: akra.isNull(pStates) ? 0 : pStates.stencil_back_func,
                    stencil_back_pass_depth_fail: akra.isNull(pStates) ? 0 : pStates.stencil_back_pass_depth_fail,
                    stencil_back_pass_depth_pass: akra.isNull(pStates) ? 0 : pStates.stencil_back_pass_depth_pass,
                    stencil_back_ref: akra.isNull(pStates) ? 0 : pStates.stencil_back_ref,
                    stencil_back_value_mask: akra.isNull(pStates) ? 0 : pStates.stencil_back_value_mask,
                    stencil_back_writemask: akra.isNull(pStates) ? 0 : pStates.stencil_back_writemask,
                    stencil_clear_value: akra.isNull(pStates) ? 0 : pStates.stencil_clear_value,
                    stencil_fail: akra.isNull(pStates) ? 0 : pStates.stencil_fail,
                    stencil_func: akra.isNull(pStates) ? 0 : pStates.stencil_func,
                    stencil_pass_depth_fail: akra.isNull(pStates) ? 0 : pStates.stencil_pass_depth_fail,
                    stencil_pass_depth_pass: akra.isNull(pStates) ? 0 : pStates.stencil_pass_depth_pass,
                    stencil_ref: akra.isNull(pStates) ? 0 : pStates.stencil_ref,
                    stencil_test: akra.isNull(pStates) ? false : pStates.stencil_test,
                    stencil_value_mask: akra.isNull(pStates) ? 0 : pStates.stencil_value_mask,
                    stencil_writemask: akra.isNull(pStates) ? 0 : pStates.stencil_writemask,
                    pack_alignment: akra.isNull(pStates) ? 0 : pStates.pack_alignment,
                    unpack_alignment: akra.isNull(pStates) ? 0 : pStates.unpack_alignment
                };
            };

            WebGLRenderer.copyWebGLContextStates = function (pStatesTo, pStatesFrom) {
                pStatesTo.blend = pStatesFrom.blend;
                pStatesTo.blend_color.set(pStatesFrom.blend_color);
                pStatesTo.blend_dst_alpha = pStatesFrom.blend_dst_alpha;
                pStatesTo.blend_dst_rgb = pStatesFrom.blend_dst_rgb;
                pStatesTo.blend_equation_alpha = pStatesFrom.blend_equation_alpha;
                pStatesTo.blend_equation_rgb = pStatesFrom.blend_equation_rgb;
                pStatesTo.blend_src_alpha = pStatesFrom.blend_src_alpha;
                pStatesTo.blend_src_rgb = pStatesFrom.blend_src_rgb;

                pStatesTo.color_clear_value.set(pStatesFrom.color_clear_value);
                pStatesTo.color_writemask[0] = pStatesFrom.color_writemask[0];
                pStatesTo.color_writemask[1] = pStatesFrom.color_writemask[1];
                pStatesTo.color_writemask[2] = pStatesFrom.color_writemask[2];
                pStatesTo.color_writemask[3] = pStatesFrom.color_writemask[3];

                pStatesTo.cull_face = pStatesFrom.cull_face;
                pStatesTo.cull_face_mode = pStatesFrom.cull_face_mode;

                pStatesTo.depth_clear_value = pStatesFrom.depth_clear_value;
                pStatesTo.depth_func = pStatesFrom.depth_func;
                pStatesTo.depth_range.set(pStatesFrom.depth_range);
                pStatesTo.depth_test = pStatesFrom.depth_test;
                pStatesTo.depth_writemask = pStatesFrom.depth_writemask;
                pStatesTo.dither = pStatesFrom.dither;

                pStatesTo.front_face = pStatesFrom.front_face;
                pStatesTo.line_width = pStatesFrom.line_width;

                pStatesTo.polygon_offset_factor = pStatesFrom.polygon_offset_factor;
                pStatesTo.polygon_offset_fill = pStatesFrom.polygon_offset_fill;
                pStatesTo.polygon_offset_units = pStatesFrom.polygon_offset_units;

                pStatesTo.sample_buffers = pStatesFrom.sample_buffers;
                pStatesTo.sample_coverage_invert = pStatesFrom.sample_coverage_invert;
                pStatesTo.sample_coverage_value = pStatesFrom.sample_coverage_value;
                pStatesTo.samples = pStatesFrom.samples;

                pStatesTo.scissor_test = pStatesFrom.scissor_test;

                pStatesTo.stencil_back_fail = pStatesFrom.stencil_back_fail;
                pStatesTo.stencil_back_func = pStatesFrom.stencil_back_func;
                pStatesTo.stencil_back_pass_depth_fail = pStatesFrom.stencil_back_pass_depth_fail;
                pStatesTo.stencil_back_pass_depth_pass = pStatesFrom.stencil_back_pass_depth_pass;
                pStatesTo.stencil_back_ref = pStatesFrom.stencil_back_ref;
                pStatesTo.stencil_back_value_mask = pStatesFrom.stencil_back_value_mask;
                pStatesTo.stencil_back_writemask = pStatesFrom.stencil_back_writemask;
                pStatesTo.stencil_clear_value = pStatesFrom.stencil_clear_value;
                pStatesTo.stencil_fail = pStatesFrom.stencil_fail;
                pStatesTo.stencil_func = pStatesFrom.stencil_func;
                pStatesTo.stencil_pass_depth_fail = pStatesFrom.stencil_pass_depth_fail;
                pStatesTo.stencil_pass_depth_pass = pStatesFrom.stencil_pass_depth_pass;
                pStatesTo.stencil_ref = pStatesFrom.stencil_ref;
                pStatesTo.stencil_test = pStatesFrom.stencil_test;
                pStatesTo.stencil_value_mask = pStatesFrom.stencil_value_mask;
                pStatesTo.stencil_writemask = pStatesFrom.stencil_writemask;

                pStatesTo.pack_alignment = pStatesFrom.pack_alignment;
                pStatesTo.unpack_alignment = pStatesFrom.unpack_alignment;

                return pStatesTo;
            };

            WebGLRenderer.initStatesFromWebGLContext = function (pStatesTo, pWebGLContext) {
                pStatesTo.blend = pWebGLContext.getParameter(3042 /* BLEND */);
                pStatesTo.blend_color = pWebGLContext.getParameter(32773 /* BLEND_COLOR */);
                pStatesTo.blend_dst_alpha = pWebGLContext.getParameter(32970 /* BLEND_DST_ALPHA */);
                pStatesTo.blend_dst_rgb = pWebGLContext.getParameter(32968 /* BLEND_DST_RGB */);
                pStatesTo.blend_equation_alpha = pWebGLContext.getParameter(34877 /* BLEND_EQUATION_ALPHA */);
                pStatesTo.blend_equation_rgb = pWebGLContext.getParameter(32777 /* BLEND_EQUATION_RGB */);
                pStatesTo.blend_src_alpha = pWebGLContext.getParameter(32971 /* BLEND_SRC_ALPHA */);
                pStatesTo.blend_src_rgb = pWebGLContext.getParameter(32969 /* BLEND_SRC_RGB */);

                pStatesTo.color_clear_value = pWebGLContext.getParameter(3106 /* COLOR_CLEAR_VALUE */);
                pStatesTo.color_writemask = pWebGLContext.getParameter(3107 /* COLOR_WRITEMASK */);

                pStatesTo.cull_face = pWebGLContext.getParameter(2884 /* CULL_FACE */);
                pStatesTo.cull_face_mode = pWebGLContext.getParameter(2885 /* CULL_FACE_MODE */);

                pStatesTo.depth_clear_value = pWebGLContext.getParameter(2931 /* DEPTH_CLEAR_VALUE */);
                pStatesTo.depth_func = pWebGLContext.getParameter(2932 /* DEPTH_FUNC */);
                pStatesTo.depth_range = pWebGLContext.getParameter(2928 /* DEPTH_RANGE */);
                pStatesTo.depth_test = pWebGLContext.getParameter(2929 /* DEPTH_TEST */);
                pStatesTo.depth_writemask = pWebGLContext.getParameter(2930 /* DEPTH_WRITEMASK */);
                pStatesTo.dither = pWebGLContext.getParameter(3024 /* DITHER */);

                pStatesTo.front_face = pWebGLContext.getParameter(2886 /* FRONT_FACE */);
                pStatesTo.line_width = pWebGLContext.getParameter(2849 /* LINE_WIDTH */);

                pStatesTo.polygon_offset_factor = pWebGLContext.getParameter(32824 /* POLYGON_OFFSET_FACTOR */);
                pStatesTo.polygon_offset_fill = pWebGLContext.getParameter(32823 /* POLYGON_OFFSET_FILL */);
                pStatesTo.polygon_offset_units = pWebGLContext.getParameter(10752 /* POLYGON_OFFSET_UNITS */);

                pStatesTo.sample_buffers = pWebGLContext.getParameter(32936 /* SAMPLE_BUFFERS */);
                pStatesTo.sample_coverage_invert = pWebGLContext.getParameter(32939 /* SAMPLE_COVERAGE_INVERT */);
                pStatesTo.sample_coverage_value = pWebGLContext.getParameter(32938 /* SAMPLE_COVERAGE_VALUE */);
                pStatesTo.samples = pWebGLContext.getParameter(32937 /* SAMPLES */);

                pStatesTo.scissor_test = pWebGLContext.getParameter(3089 /* SCISSOR_TEST */);

                pStatesTo.stencil_back_fail = pWebGLContext.getParameter(34817 /* STENCIL_BACK_FAIL */);
                pStatesTo.stencil_back_func = pWebGLContext.getParameter(34816 /* STENCIL_BACK_FUNC */);
                pStatesTo.stencil_back_pass_depth_fail = pWebGLContext.getParameter(34818 /* STENCIL_BACK_PASS_DEPTH_FAIL */);
                pStatesTo.stencil_back_pass_depth_pass = pWebGLContext.getParameter(34819 /* STENCIL_BACK_PASS_DEPTH_PASS */);
                pStatesTo.stencil_back_ref = pWebGLContext.getParameter(36003 /* STENCIL_BACK_REF */);
                pStatesTo.stencil_back_value_mask = pWebGLContext.getParameter(36004 /* STENCIL_BACK_VALUE_MASK */);
                pStatesTo.stencil_back_writemask = pWebGLContext.getParameter(36005 /* STENCIL_BACK_WRITEMASK */);
                pStatesTo.stencil_clear_value = pWebGLContext.getParameter(2961 /* STENCIL_CLEAR_VALUE */);
                pStatesTo.stencil_fail = pWebGLContext.getParameter(2964 /* STENCIL_FAIL */);
                pStatesTo.stencil_func = pWebGLContext.getParameter(2962 /* STENCIL_FUNC */);
                pStatesTo.stencil_pass_depth_fail = pWebGLContext.getParameter(2965 /* STENCIL_PASS_DEPTH_FAIL */);
                pStatesTo.stencil_pass_depth_pass = pWebGLContext.getParameter(2966 /* STENCIL_PASS_DEPTH_PASS */);
                pStatesTo.stencil_ref = pWebGLContext.getParameter(2967 /* STENCIL_REF */);
                pStatesTo.stencil_test = pWebGLContext.getParameter(2960 /* STENCIL_TEST */);
                pStatesTo.stencil_value_mask = pWebGLContext.getParameter(2963 /* STENCIL_VALUE_MASK */);
                pStatesTo.stencil_writemask = pWebGLContext.getParameter(2968 /* STENCIL_WRITEMASK */);

                pStatesTo.pack_alignment = pWebGLContext.getParameter(3333 /* PACK_ALIGNMENT */);
                pStatesTo.unpack_alignment = pWebGLContext.getParameter(3317 /* UNPACK_ALIGNMENT */);

                return pStatesTo;
            };
            WebGLRenderer.DEFAULT_OPTIONS = {
                depth: false,
                stencil: false,
                antialias: false,
                preserveDrawingBuffer: false,
                premultipliedAlpha: false,
                alpha: false
            };
            return WebGLRenderer;
        })(akra.render.Renderer);
        webgl.WebGLRenderer = WebGLRenderer;
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
/// <reference path="../model/MeshSubset.ts" />
/// <reference path="../config/config.ts" />
var akra;
(function (akra) {
    /// <reference path="WebGLRenderer.ts" />
    (function (webgl) {
        var Vec2 = akra.math.Vec2;

        var pWebGLScreenBuffer = null;

        function calculateSkin(pMeshSubset) {
            var pRenderData = pMeshSubset.getData();

            var isOk = pRenderData.selectIndexSet(".update_skinned_position");

            if (!isOk) {
                return false;
            }

            var pEngine = pRenderData.getBuffer().getEngine();
            var pResourceManager = pEngine.getResourceManager();
            var pWebGLRenderer = pEngine.getRenderer();
            var pWebGLContext = pWebGLRenderer.getWebGLContext();

            var pWebGLVertexTexture = pRenderData.getBuffer().getBuffer();
            var pWebGLTexture = pWebGLVertexTexture.getWebGLTexture();
            var pWebGLSkinVertexTexture = pRenderData._getAttribBuffer(1 /* DYNAMIC */);

            /*update skinned position program*/
            var pWebGLProgram = pResourceManager.getShaderProgramPool().findResource(".WEBGL_skinning_update");
            var pWebGLScreenTextureProgram = pResourceManager.getShaderProgramPool().findResource(".WEBGL_debug_screen_texture");
            if (akra.isNull(pWebGLProgram)) {
                pWebGLProgram = pResourceManager.getShaderProgramPool().createResource(".WEBGL_skinning_update");
                pWebGLProgram.create("																												\n\
				#ifndef A_VB_COMPONENT3																											\n\
				#define A_VB_COMPONENT4																											\n\
				#endif																															\n\
				#ifdef A_VB_COMPONENT4																											\n\
				#define A_VB_ELEMENT_SIZE 4.																									\n\
				#endif																															\n\
				#ifdef A_VB_COMPONENT3																											\n\
				#define A_VB_ELEMENT_SIZE 3.																									\n\
				#endif																															\n\
				#define A_tex2D(S, H, X, Y) texture2D(S, vec2(H.stepX * X , H.stepY * Y))														\n\
				#define A_tex2Dv(S, H, V) texture2D(S, V)																						\n\
																																				\n\
				struct A_TextureHeader { float width; float height; float stepX; float stepY; };												\n\
																																				\n\
				void A_extractTextureHeader(sampler2D src, out A_TextureHeader header){															\n\
					vec4 v = texture2D(src, vec2(0.00001));																						\n\
					header = A_TextureHeader(v.r, v.g, v.b, v.a);																				\n\
				}																																\n\
																																				\n\
				vec2 A_findPixel(A_TextureHeader header, float offset){																			\n\
					float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE);																		\n\
				return vec2(header.stepX * (mod(pixelNumber, header.width) + .5),																\n\
					 header.stepY * (floor(pixelNumber / header.width) + .5));																	\n\
				}																																\n\
																																				\n\
				vec2 A_extractVec2(sampler2D sampler, A_TextureHeader header, float offset){													\n\
					vec2 pPos = A_findPixel(header, offset);																					\n\
					int shift = int(mod(offset, A_VB_ELEMENT_SIZE));																			\n\
																																				\n\
					#ifdef A_VB_COMPONENT4																										\n\
																																				\n\
					if(shift == 0) return A_tex2Dv(sampler, header, pPos).rg;																	\n\
					else if(shift == 1) return A_tex2Dv(sampler, header, pPos).gb;																\n\
					else if(shift == 2) return A_tex2Dv(sampler, header, pPos).ba;																\n\
					else if(shift == 3) {																										\n\
						if(int(pPos.x*header.width) == int(header.width - 1.)){																	\n\
							return vec2(A_tex2Dv(sampler, header, pPos).a,																		\n\
								A_tex2Dv(sampler, header, vec2(0.5 * header.stepX, pPos.y + header.stepY)).r);									\n\
						}																														\n\
						else{																													\n\
							return vec2(A_tex2Dv(sampler, header, pPos).a, A_tex2Dv(sampler, header, vec2(pPos.x + header.stepX, pPos.y)).r);	\n\
						}																														\n\
					}																															\n\
					#endif																														\n\
																																				\n\
					return vec2(0.);																											\n\
				}																																\n\
																																				\n\
				vec4 A_extractVec4(sampler2D sampler, A_TextureHeader header, float offset){													\n\
					vec2 pPos = A_findPixel(header, offset);																					\n\
					int shift = int(mod(offset, A_VB_ELEMENT_SIZE));																			\n\
																																				\n\
					#ifdef A_VB_COMPONENT4																										\n\
																																				\n\
					if(shift == 0) return A_tex2Dv(sampler, header, pPos);																		\n\
					else if(shift == 1){																										\n\
						if(int(pPos.x*header.width) == int(header.width - 1.)){																	\n\
							return vec4(A_tex2Dv(sampler, header, pPos).gba,																	\n\
								A_tex2Dv(sampler, header, vec2(0.5 * header.stepX, pPos.y + header.stepY)).r);									\n\
						}																														\n\
						else{																													\n\
							return vec4(A_tex2Dv(sampler, header, pPos).gba, A_tex2Dv(sampler, header, vec2(pPos.x + header.stepX, pPos.y)).r);	\n\
						}																														\n\
					}																															\n\
					else if(shift == 2){																										\n\
						if(int(pPos.x*header.width) == int(header.width - 1.)){																	\n\
							return vec4(A_tex2Dv(sampler, header, pPos).ba,																		\n\
								A_tex2Dv(sampler, header, vec2(0.5 * header.stepX, pPos.y + header.stepY)).rg);									\n\
						}																														\n\
						else{																													\n\
							return vec4(A_tex2Dv(sampler, header, pPos).ba, A_tex2Dv(sampler, header, vec2(pPos.x + header.stepX, pPos.y)).rg);	\n\
						}																														\n\
					}																															\n\
					else if(shift == 3){																										\n\
						if(int(pPos.x*header.width) == int(header.width - 1.)){																	\n\
							return vec4(A_tex2Dv(sampler, header, pPos).a,																		\n\
								A_tex2Dv(sampler, header, vec2(0.5 * header.stepX, pPos.y + header.stepY)).rgb);								\n\
						}																														\n\
						else{																													\n\
							return vec4(A_tex2Dv(sampler, header, pPos).a, A_tex2Dv(sampler, header, vec2(pPos.x + header.stepX, pPos.y)).rgb);	\n\
						}																														\n\
					}																															\n\
																																				\n\
					#endif																														\n\
																																				\n\
					#ifdef A_VB_COMPONENT3																										\n\
					#endif																														\n\
																																				\n\
					return vec4(0.);																											\n\
				}																																\n\
																																				\n\
				mat4 A_extractMat4(sampler2D sampler, A_TextureHeader header, float offset){													\n\
					return mat4(A_tex2Dv(sampler, header, A_findPixel(header, offset)),															\n\
								A_tex2Dv(sampler, header, A_findPixel(header, offset + 4.)),													\n\
								A_tex2Dv(sampler, header, A_findPixel(header, offset + 8.)),													\n\
								A_tex2Dv(sampler, header, A_findPixel(header, offset + 12.)));													\n\
				}																																\n\
																																				\n\
				attribute float positionIndex;																									\n\
				attribute float normalIndex;																									\n\
				attribute float destinationIndex;																								\n\
																																				\n\
				uniform sampler2D videoBuffer;																									\n\
				uniform vec2 frameBufferSize;																									\n\
				uniform int type;																												\n\
				uniform mat4 bind_matrix;																										\n\
																																				\n\
				varying vec4 data;																												\n\
																																				\n\
				void main(void){																												\n\
					A_TextureHeader header;																										\n\
					A_extractTextureHeader(videoBuffer, header);																				\n\
																																				\n\
					vec4 position = A_extractVec4(videoBuffer, header, positionIndex);															\n\
					vec2 meta_data = A_extractVec2(videoBuffer, header, position.w);															\n\
																																				\n\
					float number_matrix = meta_data.x;																							\n\
					float bone_inf_ptr = meta_data.y;																							\n\
																																				\n\
					mat4 bone_matrix = mat4(0.);																								\n\
					float weight;																												\n\
																																				\n\
					mat4 result_mat = mat4(0.);																									\n\
																																				\n\
					for(float i = 0.; i < 16.; i++) {																							\n\
						if(i < number_matrix){																									\n\
							//get data about matrix and weight																					\n\
							vec2 bone_inf = A_extractVec2(videoBuffer, header, bone_inf_ptr + i * 2.);											\n\
																																				\n\
							bone_matrix = A_extractMat4(videoBuffer, header, bone_inf.x);														\n\
							weight = bone_inf.y;																								\n\
																																				\n\
							result_mat += bone_matrix * weight;																					\n\
						}																														\n\
						else {																													\n\
							break;																												\n\
						}																														\n\
					}																															\n\
																																				\n\
					result_mat = result_mat * bind_matrix;																						\n\
																																				\n\
					if(type == 0){																												\n\
						data = result_mat * vec4(position.xyz, 1.);																				\n\
					}																															\n\
					else if(type == 1){																											\n\
						vec4 normal = A_extractVec4(videoBuffer, header, normalIndex);															\n\
						data = vec4((result_mat * vec4(normal.xyz, 0.)).xyz, normal.w);															\n\
					}																															\n\
																																				\n\
					vec2 outPixelPosition = vec2((mod(destinationIndex/4., frameBufferSize.x) + 0.5)/frameBufferSize.x,							\n\
												 (floor(destinationIndex/4./frameBufferSize.x) + 0.5)/frameBufferSize.y);						\n\
																																				\n\
					gl_Position = vec4(outPixelPosition*2. - 1., 0. ,1.);																		\n\
					gl_PointSize = 1.;																											\n\
				}																																\n\
																																				\n\
				", "																																\n\
				precision highp float;          																								\n\
				varying vec4 data;                  																							\n\
																																				\n\
				void main(void) {                   																							\n\
					gl_FragColor = data;            																							\n\
				}                                   																							\n\
				");

                pWebGLScreenTextureProgram = pResourceManager.getShaderProgramPool().createResource(".WEBGL_debug_screen_texture");
                pWebGLScreenTextureProgram.create("				\n\
				attribute vec2 aVertexPosition;						\n\
				varying vec2 vTexcoord;								\n\
																	\n\
				void main(void ) {									\n\
					gl_Position = vec4(aVertexPosition, 0., 1.0);	\n\
					vTexcoord = (aVertexPosition + 1.)/2.;			\n\
				}", "													\n\
				precision highp float;								\n\
				uniform sampler2D videoBuffer;						\n\
				varying vec2 vTexcoord;								\n\
				void main(void) {									\n\
					gl_FragColor = vec4(texture2D(videoBuffer, vTexcoord));			\n\
				}");

                pWebGLScreenBuffer = pWebGLContext.createBuffer();
                pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, pWebGLScreenBuffer);
                pWebGLContext.bufferData(34962 /* ARRAY_BUFFER */, new Float32Array([-1, -1, -1, 1, 1, -1, 1, 1]), 35044 /* STATIC_DRAW */);
                pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, null);
            }

            var pOldFrameBuffer = pWebGLRenderer.getParameter(36006 /* FRAMEBUFFER_BINDING */);

            var pWebGLFramebuffer = pWebGLRenderer.createWebGLFramebuffer();

            pWebGLRenderer.disableAllWebGLVertexAttribs();

            pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pWebGLFramebuffer);
            pWebGLContext.framebufferTexture2D(36160 /* FRAMEBUFFER */, 36064 /* COLOR_ATTACHMENT0 */, 3553 /* TEXTURE_2D */, pWebGLSkinVertexTexture.getWebGLTexture(), 0);

            pWebGLRenderer.disable(2929 /* DEPTH_TEST */);
            pWebGLRenderer.disable(3089 /* SCISSOR_TEST */);
            pWebGLRenderer.disable(3042 /* BLEND */);
            pWebGLRenderer.disable(2884 /* CULL_FACE */);

            //pWebGLRenderer.useWebGLProgram(pWebGLScreenTextureProgram.getWebGLProgram());
            //pWebGLRenderer.bindWebGLBuffer(gl.ARRAY_BUFFER, pWebGLScreenBuffer);
            //var iPositionAttribLocation: uint = pWebGLScreenTextureProgram.getWebGLAttributeLocation("aVertexPosition");
            //pWebGLContext.enableVertexAttribArray(iPositionAttribLocation);
            //pWebGLContext.vertexAttribPointer(iPositionAttribLocation, 2, gl.FLOAT, false, 0, 0);
            //pWebGLRenderer.activateWebGLTexture(gl.TEXTURE0);
            //pWebGLRenderer.bindWebGLTexture(gl.TEXTURE_2D, pWebGLTexture);
            //pWebGLScreenTextureProgram.setInt("videoBuffer", 0);
            //pWebGLRenderer.bindWebGLFramebuffer(gl.FRAMEBUFFER, pWebGLFramebuffer);
            //pWebGLContext.viewport(0, 0, pWebGLVertexTexture._getWidth(), pWebGLVertexTexture._getHeight());
            //pWebGLContext.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            pWebGLRenderer.useWebGLProgram(pWebGLProgram.getWebGLProgram());

            var iPositionAttribLocation = pWebGLProgram.getWebGLAttributeLocation("positionIndex");
            var iNormalAttribLocation = pWebGLProgram.getWebGLAttributeLocation("normalIndex");
            var iDestinationAttribLocation = pWebGLProgram.getWebGLAttributeLocation("destinationIndex");

            pWebGLContext.enableVertexAttribArray(iPositionAttribLocation);
            pWebGLContext.enableVertexAttribArray(iNormalAttribLocation);
            pWebGLContext.enableVertexAttribArray(iDestinationAttribLocation);

            //get data from renderData for position update
            pRenderData.selectIndexSet(".update_skinned_position");
            var pIndexData = pRenderData.getIndices();
            var pBuffer = pIndexData.getBuffer();
            var pDeclaration = pIndexData.getVertexDeclaration();

            //LOG(pIndexData.toString());
            var iStride = pDeclaration.stride;
            var iPositionOffset = pDeclaration.findElement("UPP_INDEX").offset;
            var iDestinationOffset = pDeclaration.findElement("DESTINATION_SP").offset;
            var iNormalOffset = 0.;

            pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, pBuffer.getWebGLBuffer());
            pWebGLContext.vertexAttribPointer(iPositionAttribLocation, 1, 5126 /* FLOAT */, false, iStride, iPositionOffset);
            pWebGLContext.vertexAttribPointer(iDestinationAttribLocation, 1, 5126 /* FLOAT */, false, iStride, iDestinationOffset);

            /////////////////////////////////////////////////////////////////////////
            //просто подаем данные чтобы можно было порендерить, мы все равно ими не пользуемся
            pWebGLContext.vertexAttribPointer(iNormalAttribLocation, 1, 5126 /* FLOAT */, false, iStride, iPositionOffset);

            //
            /////////////////////////////////////////////////////////////////////////
            pWebGLRenderer.activateWebGLTexture(33984 /* TEXTURE0 */);
            pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, pWebGLTexture);

            var iWidth = pWebGLSkinVertexTexture._getWidth();
            var iHeight = pWebGLSkinVertexTexture._getHeight();

            pWebGLProgram.setInt("videoBuffer", 0);
            pWebGLProgram.setVec2("frameBufferSize", Vec2.temp(iWidth, iHeight));
            pWebGLProgram.setInt("type", 0);
            pWebGLProgram.setMat4("bind_matrix", pMeshSubset.getSkin().getBindMatrix());

            pWebGLContext.viewport(0, 0, iWidth, iHeight);

            //PASS 1
            ///////////////////////////////////////////////
            pWebGLContext.drawArrays(0 /* POINTS */, pIndexData.getByteOffset() / iStride, pIndexData.getLength());

            ///////////////////////////////////////////////
            //get data from renderData for normal update
            pRenderData.selectIndexSet(".update_skinned_normal");
            pIndexData = pRenderData.getIndices();
            pBuffer = pIndexData.getBuffer();
            pDeclaration = pIndexData.getVertexDeclaration();

            //LOG(pIndexData.toString());
            iStride = pDeclaration.stride;
            iPositionOffset = pDeclaration.findElement("UNP_INDEX").offset;
            iNormalOffset = pDeclaration.findElement("UNN_INDEX").offset;
            iDestinationOffset = pDeclaration.findElement("DESTINATION_SN").offset;

            pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, pBuffer.getWebGLBuffer());
            pWebGLContext.vertexAttribPointer(iPositionAttribLocation, 1, 5126 /* FLOAT */, false, iStride, iPositionOffset);
            pWebGLContext.vertexAttribPointer(iNormalAttribLocation, 1, 5126 /* FLOAT */, false, iStride, iNormalOffset);
            pWebGLContext.vertexAttribPointer(iDestinationAttribLocation, 1, 5126 /* FLOAT */, false, iStride, iDestinationOffset);

            pWebGLProgram.setInt("type", 1);

            //PASS 2
            ///////////////////////////////////////////////
            pWebGLContext.drawArrays(0 /* POINTS */, pIndexData.getByteOffset() / iStride, pIndexData.getLength());

            ///////////////////////////////////////////////
            //pWebGLContext.flush();
            pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pOldFrameBuffer);
            pWebGLRenderer.deleteWebGLFramebuffer(pWebGLFramebuffer);

            pWebGLContext.disableVertexAttribArray(iPositionAttribLocation);
            pWebGLContext.disableVertexAttribArray(iNormalAttribLocation);
            pWebGLContext.disableVertexAttribArray(iDestinationAttribLocation);

            pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, null);
            pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, null);
            pWebGLRenderer._setViewport(null);

            return true;
        }
        webgl.calculateSkin = calculateSkin;
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
/// <reference path="../idl/IMeshSubset.ts" />
/// <reference path="../idl/IRenderData.ts" />
/// <reference path="../idl/IMesh.ts" />
/// <reference path="../idl/ISkin.ts" />
/// <reference path="../idl/IRect3d.ts" />
/// <reference path="../idl/ISphere.ts" />
/// <reference path="../idl/IVertexData.ts" />
var akra;
(function (akra) {
    /// <reference path="../data/VertexElement.ts" />
    /// <reference path="../render/RenderableObject.ts" />
    /// <reference path="../geometry/geometry.ts" />
    /// <reference path="../material/materials.ts" />
    /// <reference path="../webgl/CalculateSkin.ts" />
    (function (model) {
        var VE = akra.data.VertexElement;
        var DeclUsages = akra.data.Usages;

        var Mat4 = akra.math.Mat4;
        var Vec4 = akra.math.Vec4;

        var MeshSubset = (function (_super) {
            __extends(MeshSubset, _super);
            function MeshSubset(pMesh, pRenderData, sName) {
                if (typeof sName === "undefined") { sName = null; }
                _super.call(this, 1 /* MESH_SUBSET */);
                this._sName = null;
                this._pMesh = null;
                this._pSkin = null;
                //in local coords
                this._pBoundingBox = null;
                this._pBoundingSphere = null;
                //is this mesh uses precomputed skin?
                this._isOptimizedSkinned = false;
                this._pInitialGeometryBoundingBox = null;
                this._pInitialGeometryBoundingSphere = null;
                //list of local bounding boxes for current skin.
                //this boxes neeeds for calculating common bounding box;
                this._pSkinLocalBounds = null;
                this.setup(pMesh, pRenderData, sName);
            }
            MeshSubset.prototype.getBoundingBox = function () {
                if (akra.isNull(this._pBoundingBox)) {
                    this.createBoundingBox();
                }

                return this._pBoundingBox;
            };

            MeshSubset.prototype.getBoundingSphere = function () {
                if (akra.isNull(this._pBoundingSphere)) {
                    this.createBoundingSphere();
                }

                return this._pBoundingSphere;
            };

            MeshSubset.prototype.getInitialGeometryBoundingBox = function () {
                if (akra.isNull(this._pInitialGeometryBoundingBox)) {
                    akra.logger.assert(this.createBoundingBox(), "could not compute bounding box");
                }

                return this._pInitialGeometryBoundingBox;
            };

            MeshSubset.prototype.getInitialGeometryBoundingSphere = function () {
                if (akra.isNull(this._pInitialGeometryBoundingSphere)) {
                    akra.logger.assert(this.createBoundingSphere(), "could not compute bounding sphere");
                }

                return this._pInitialGeometryBoundingSphere;
            };

            MeshSubset.prototype.getSkin = function () {
                return this._pSkin;
            };

            MeshSubset.prototype.getName = function () {
                return this._sName;
            };

            MeshSubset.prototype.getMesh = function () {
                return this._pMesh;
            };

            MeshSubset.prototype.setupSignals = function () {
                this.skinAdded = this.skinAdded || new akra.Signal(this);
                this.skinRemoved = this.skinRemoved || new akra.Signal(this);
                this.transformed = this.transformed || new akra.Signal(this);

                _super.prototype.setupSignals.call(this);
            };

            MeshSubset.prototype.setup = function (pMesh, pRenderData, sName) {
                akra.debug.assert(this._pMesh === null, "mesh subset already prepared");

                this._pMesh = pMesh;
                this._pRenderData = pRenderData;
                this._sName = sName;

                _super.prototype._setup.call(this, pMesh.getEngine().getRenderer());
            };

            MeshSubset.prototype.createBoundingBox = function () {
                var pVertexData;
                var pNewBoundingBox;

                pNewBoundingBox = new akra.geometry.Rect3d();
                pVertexData = this.getData()._getData(DeclUsages.POSITION);

                if (akra.isNull(pVertexData))
                    return false;

                if (akra.geometry.computeBoundingBox(pVertexData, pNewBoundingBox) == false)
                    return false;

                this._pInitialGeometryBoundingBox = pNewBoundingBox;

                if (akra.isNull(this._pBoundingBox)) {
                    this._pBoundingBox = pNewBoundingBox;
                }

                return true;
            };

            MeshSubset.prototype.createBoundingSphere = function () {
                var pVertexData;
                var pNewBoundingSphere;

                pNewBoundingSphere = new akra.geometry.Sphere();
                pVertexData = this.getData()._getData(DeclUsages.POSITION);

                if (!pVertexData) {
                    return false;
                }

                if (!akra.geometry.computeBoundingSphere(pVertexData, pNewBoundingSphere, false, this._pBoundingBox)) {
                    return false;
                }

                this._pInitialGeometryBoundingSphere = pNewBoundingSphere;

                if (akra.isNull(this._pBoundingSphere)) {
                    this._pBoundingSphere = pNewBoundingSphere;
                }

                return true;
            };

            MeshSubset.prototype.deleteBoundingBox = function () {
                this._pBoundingBox = null;

                return true;
            };
            MeshSubset.prototype.deleteBoundingSphere = function () {
                this._pBoundingSphere = null;
                return true;
            };

            MeshSubset.prototype._showBoundingBox = function () {
                if (akra.config.DEBUG) {
                    return false;
                }

                //TODO: write method correctly...
                /*
                var pMaterial: IMaterial;
                var iData: int;
                var iCurrentIndexSet: int;
                var pPoints: float[],
                pIndexes: uint[];
                
                if (isNull(this._pBoundingBox)) {
                if (!this.createBoundingBox()) {
                return false;
                }
                }
                
                pPoints = new Array();
                pIndexes = new Array();
                
                geometry.computeDataForCascadeBoundingBox(this._pBoundingBox, pPoints, pIndexes, 10.0);
                
                iCurrentIndexSet = this.getData().getIndexSet();
                
                if (!this.getData().selectIndexSet(".BoundingBox")) {
                if (this.getData().addIndexSet(false, EPrimitiveTypes.LINELIST, ".BoundingBox") == -1) {
                logger.error("could not add index set '.BoundingBox'");
                return false;
                }
                
                iData = this.getData().allocateData([VE.float3(DeclUsages.POSITION)], new Float32Array(pPoints));
                
                this.getData().allocateIndex([VE.float(DeclUsages.INDEX0)], new Float32Array(pIndexes));
                
                this.getData().index(iData, DeclUsages.INDEX0);
                }
                else {
                this.getData()._getData(DeclUsages.POSITION).setData(new Float32Array(pPoints), DeclUsages.POSITION);
                }
                
                this.getData().setRenderable(this.getData().getIndexSet(), true);
                this.getData().selectIndexSet(iCurrentIndexSet);
                
                return true;*/
                return false;
            };
            MeshSubset.prototype._isBoundingBoxVisible = function () {
                return akra.config.DEBUG && this.getData().isRenderable(this.getData().findIndexSet(".BoundingBox"));
            };
            MeshSubset.prototype._hideBoundingBox = function () {
                if (akra.config.DEBUG) {
                    return false;
                }

                /*
                var iCurrentIndexSet: int;
                iCurrentIndexSet = this.getData().getIndexSet();
                
                if (!this.getData().selectIndexSet(".BoundingBox")) {
                return false;
                }
                else {
                this.getData().setRenderable(this.getData().getIndexSet(), false);
                }
                
                return this.getData().selectIndexSet(iCurrentIndexSet);
                */
                return false;
            };

            MeshSubset.prototype._showBoundingSphere = function () {
                if (akra.config.DEBUG) {
                    return false;
                }

                /*
                var pMaterial: IMaterial;
                var iData: int;
                var iCurrentIndexSet: int;
                var pPoints: float[], pIndexes: uint[];
                
                if (isNull(this._pBoundingSphere)) {
                if (!this.createBoundingSphere()) {
                return false;
                }
                }
                
                pPoints = new Array();
                pIndexes = new Array();
                geometry.computeDataForCascadeBoundingSphere(this._pBoundingSphere, pPoints, pIndexes);
                
                iCurrentIndexSet = this.getData().getIndexSet();
                if (!this.getData().selectIndexSet(".BoundingSphere")) {
                this.getData().addIndexSet(false, EPrimitiveTypes.LINELIST, ".BoundingSphere");
                
                iData = this.getData().allocateData([VE.float3(DeclUsages.POSITION)], new Float32Array(pPoints));
                
                this.getData().allocateIndex([VE.float(DeclUsages.INDEX0)], new Float32Array(pIndexes));
                this.getData().index(iData, DeclUsages.INDEX0);
                }
                else {
                this.getData()._getData(DeclUsages.POSITION).setData(new Float32Array(pPoints), DeclUsages.POSITION);
                }
                
                this.getData().setRenderable(this.getData().getIndexSet(), true);
                this.getData().selectIndexSet(iCurrentIndexSet);
                
                return true;
                */
                return false;
            };
            MeshSubset.prototype._isBoundingSphereVisible = function () {
                return akra.config.DEBUG && this.getData().isRenderable(this.getData().findIndexSet(".BoundingSphere"));
            };
            MeshSubset.prototype._hideBoundingSphere = function () {
                if (akra.config.DEBUG) {
                    return false;
                }

                /*
                var iCurrentIndexSet: int = this.getData().getIndexSet();
                
                if (!this.getData().selectIndexSet(".BoundingSphere")) {
                return false;
                }
                else {
                this.getData().setRenderable(this.getData().getIndexSet(), false);
                }
                
                return this.getData().selectIndexSet(iCurrentIndexSet);
                */
                return false;
            };

            MeshSubset.prototype.getTotalBones = function () {
                if (!this.isSkinned()) {
                    return null;
                }

                return this._pSkin.getTotalBones();
            };

            MeshSubset.prototype.getBoneLocalBound = function (bone) {
                akra.debug.assert(this.isSkinned(), "could not get local bound for non-skinned model.");
                if (!this.isSkinned()) {
                    return null;
                }

                var iBone;

                if (akra.isString(arguments[0])) {
                    iBone = this._pSkin.getBoneIndex(arguments[0]);
                } else {
                    iBone = arguments[0];
                }

                return this._pSkinLocalBounds[iBone];
            };

            //computeNormals() {
            //TODO: calc normals
            //}
            MeshSubset.prototype.computeNormals = function () {
                var pData = this.getData();
                var pVertexData = this.getVertexData(DeclUsages.POSITION);
                var pNormalData = this.getVertexData(DeclUsages.NORMAL);

                var pVertexBuffer = pVertexData.getTypedData(DeclUsages.POSITION);
                var pNormalBuffer;

                //var nFaces: uint = this.getData().getPrimitiveCount();
                if (!akra.isNull(pNormalData)) {
                    akra.debug.warn("Could not compute face normals. Normals already exists.");
                    return false;
                }

                if (pData.useSingleIndex()) {
                    akra.logger.error("TODO: single index not supported yet.");
                    return false;
                }

                if (pData.useMultiIndex()) {
                    pNormalBuffer = new Float32Array(pVertexData.getLength() * 3);
                }

                akra.logger.error("TODO");

                return false;
            };

            MeshSubset.prototype.computeTangents = function () {
                //TODO: compute normals
            };

            MeshSubset.prototype.computeBinormals = function () {
                //TODO: calc binormals
            };

            MeshSubset.prototype.isSkinned = function () {
                return this._pSkin !== null;
            };

            MeshSubset.prototype.isOptimizedSkinned = function () {
                return this.isSkinned() && this._isOptimizedSkinned;
            };

            MeshSubset.prototype.getVertexData = function (sUsage) {
                var pFlow = this.getData()._getFlow(sUsage);

                if (!akra.isDefAndNotNull(pFlow)) {
                    return null;
                }

                return pFlow.data;
            };

            //исходим из того, что данные скина 1:1 соотносятся с вершинами.
            MeshSubset.prototype.setSkin = function (pSkin) {
                akra.logger.assert(pSkin.isReady(), "cannot add invalid skin");

                var pRenderData = this.getData();
                var pPosData;
                var pPositionFlow;
                var pNormalFlow;
                var pMetaData;

                // markup meta-data
                var pInfMetaData;

                // meta-data address (in floats)
                var iInfMetaDataLoc;

                // meta-data step (in floats)
                var iInfMetaDataStride;

                // Get vertex data to put in {W} component,
                // address of meta information about the impact of this on vertex.
                // getting vertex flow
                pPositionFlow = pRenderData._getFlow(DeclUsages.POSITION);
                akra.debug.assert(akra.isDefAndNotNull(pPositionFlow), "skin require position with indices in mesh subset");

                pPosData = pPositionFlow.data;

                // check that the data has not yet been tied to another Skin
                if (pPosData.hasSemantics(DeclUsages.BLENDMETA)) {
                    // Is the same skin?
                    if (pSkin.isAffect(pPosData)) {
                        return true;
                    }

                    akra.debug.error("Mesh subset already has another skin.");
                    return false;
                }

                // Check, that current mesh subset in Mesh, which stretched skin,
                // or his clone.
                akra.debug.assert(this.getData().getBuffer() == pSkin.getData(), "can not bind to skin mesh subset that does not belong skin's mesh.");

                // tie up the skin, according to the vertices of the current mesh susbset
                // ie add markup at the end of each pixel
                pSkin._attach(pPosData);

                var pDeclaration = pPosData.getVertexDeclaration();
                var pVEMeta = pDeclaration.findElement(DeclUsages.BLENDMETA);

                //if BLENDMETA not found
                akra.debug.assert(akra.isDefAndNotNull(pVEMeta), "you must specify location for storage blending data");

                //read all data for acceleration
                pMetaData = new Float32Array(pPosData.getData(0, pDeclaration.stride));

                // setup vertices metadata markup, so they immediately addressable data
                pInfMetaData = pSkin.getInfluenceMetaData();
                iInfMetaDataLoc = pInfMetaData.getByteOffset() / 4 /* BYTES_PER_FLOAT */;
                iInfMetaDataStride = pInfMetaData.getStride() / 4 /* BYTES_PER_FLOAT */;

                var iCount = pMetaData.byteLength / pDeclaration.stride;
                var iOffset = pVEMeta.offset / 4 /* BYTES_PER_FLOAT */;
                var iStride = pDeclaration.stride / 4 /* BYTES_PER_FLOAT */;

                for (var i = 0; i < iCount; ++i) {
                    //setuo meta data addresses
                    pMetaData[iOffset + i * iStride] = iInfMetaDataLoc + i * iInfMetaDataStride;
                }

                pPosData.setData(pMetaData, 0, pDeclaration.stride);

                var pIndexData = pRenderData.getIndices();

                pNormalFlow = pRenderData._getFlow(DeclUsages.NORMAL);

                var pPositionIndexData = pIndexData.getTypedData(pPositionFlow.mapper.semantics);
                var pNormalIndexData = pIndexData.getTypedData(pNormalFlow.mapper.semantics);

                var iAdditionPosition = pPosData.getByteOffset();
                var iAdditionNormal = pNormalFlow.data.getByteOffset();

                for (var i = 0; i < pPositionIndexData.length; i++) {
                    // calc real indexes ??
                    pPositionIndexData[i] = (pPositionIndexData[i] * 4 /* BYTES_PER_FLOAT */ - iAdditionPosition) / pPositionFlow.data.getStride();
                    pNormalIndexData[i] = (pNormalIndexData[i] * 4 /* BYTES_PER_FLOAT */ - iAdditionNormal) / pNormalFlow.data.getStride();
                }

                //update position index
                var pUPPositionIndex = new Float32Array(pPosData.getLength());

                for (var i = 0; i < pPosData.getLength(); i++) {
                    pUPPositionIndex[i] = i;
                }

                //update normal index
                var pTmp = {};

                var pSkinnedNormalIndex = [];

                var pUNPositionIndex = [];
                var pUNNormalIndex = [];
                var pDestinationSkinnedNormalIndex = [];

                var iCounter = 0;

                for (var i = 0; i < pPositionIndexData.length; i++) {
                    //real pair position & normal
                    var sKey = pPositionIndexData[i].toString() + "_" + pNormalIndexData[i].toString();

                    if (!akra.isDef(pTmp[sKey])) {
                        pTmp[sKey] = iCounter;
                        pUNPositionIndex.push(pPositionIndexData[i]);
                        pUNNormalIndex.push(pNormalIndexData[i]);
                        pSkinnedNormalIndex.push(iCounter);
                        pDestinationSkinnedNormalIndex.push(iCounter);
                        iCounter++;
                    } else {
                        pSkinnedNormalIndex.push(pDestinationSkinnedNormalIndex[pTmp[sKey]]);
                    }
                }

                //debug.time("\t\t\tMesh::setSkin allocations");
                pRenderData.allocateAttribute([VE.float3("SKINNED_POSITION"), VE.end(16)], new Float32Array(pPosData.getLength() * 4), 1 /* DYNAMIC */);

                // skinned vertices uses same index as vertices
                //FIXME: call VertexData resize...
                pRenderData.allocateIndex([VE.float("SP_INDEX")], pPositionIndexData);

                // skinned normals uses new index
                pRenderData.allocateIndex([VE.float("SN_INDEX")], new Float32Array(pSkinnedNormalIndex));

                pRenderData.allocateAttribute([VE.float3("SKINNED_NORMAL"), VE.end(16)], new Float32Array(pUNNormalIndex.length * 4), 1 /* DYNAMIC */);

                pRenderData.index("SKINNED_POSITION", "SP_INDEX");
                pRenderData.index("SKINNED_NORMAL", "SN_INDEX");

                var iPreviousSet = pRenderData.getIndexSet();

                //////////////////////////////////////////////////////////////////// [iUPIndexSet]
                var iUPIndexSet = pRenderData.addIndexSet(true, 0 /* POINTLIST */, ".update_skinned_position");

                pRenderData.allocateIndex([VE.float("UPP_INDEX")], pUPPositionIndex);
                pRenderData.allocateIndex([VE.float("DESTINATION_SP")], pUPPositionIndex); //FIXME: call VertexData resize...

                pRenderData.index(pPosData.getByteOffset(), "UPP_INDEX");
                pRenderData.index("SKINNED_POSITION", "DESTINATION_SP");

                //////////////////////////////////////////////////////////////////// [iUNIndexSet]
                var iUNIndexSet = pRenderData.addIndexSet(true, 0 /* POINTLIST */, ".update_skinned_normal");
                pRenderData.allocateIndex([VE.float("UNP_INDEX")], new Float32Array(pUNPositionIndex));
                pRenderData.allocateIndex([VE.float("DESTINATION_SN")], new Float32Array(pDestinationSkinnedNormalIndex)); //FIXME: call VertexData resize...
                pRenderData.allocateIndex([VE.float("UNN_INDEX")], new Float32Array(pUNNormalIndex));

                pRenderData.index(pPosData.getByteOffset(), "UNP_INDEX");
                pRenderData.index(pRenderData._getFlow(DeclUsages.NORMAL, false).data.getByteOffset(), "UNN_INDEX");
                pRenderData.index("SKINNED_NORMAL", "DESTINATION_SN");

                //debug.timeEnd("\t\t\tMesh::setSkin allocations");
                //////////////////////////
                pRenderData.selectIndexSet(iPreviousSet);

                pRenderData.setRenderable(iUPIndexSet, false);
                pRenderData.setRenderable(iUNIndexSet, false);

                this._pSkin = pSkin;
                this.skinAdded.emit(pSkin);
                pSkin.transformed.connect(this.transformed);

                this.calculateBoneLocalBoundingBoxes();

                return true;
            };

            MeshSubset.prototype.update = function () {
                var isUpdated = false;

                if (this.isSkinned()) {
                    isUpdated = this._pSkin.applyBoneMatrices() ? true : isUpdated;

                    if (isUpdated) {
                        this.calculateSkin();
                        this.calculateSkinBasedBoundingBox();
                    }
                }

                return isUpdated;
            };

            MeshSubset.prototype.calculateBoneLocalBoundingBoxes = function () {
                akra.debug.time("MeshSubset::calculateBonesLocalBoundingBoxes()");

                var pSkin = this.getSkin();

                //List of all bones.
                var nBones = pSkin.getTotalBones();

                //List of vertex indices depend on each of the bones.
                var pBoneDependentVertices = new Array(nBones);
                var pBoneDependentVerticesWeights = new Array(nBones);

                //Get bone influens meta data float2 = {BONE_INF_COUNT, BONE_INF_LOC}.
                var pInfMetaData = pSkin.getInfluenceMetaData();
                var pInfCount = pInfMetaData.getTypedData("BONE_INF_COUNT");

                //Get bome influences
                var pInfData = pSkin.getInfluences();

                //{weght, matrix_addr}
                var pInfWeightLoc = new Float32Array(pInfData.getData());

                //Get all vertices
                var pRenderData = this.getData();
                var pPositionFlow = pRenderData._getFlow(DeclUsages.POSITION);
                var pPosData = pPositionFlow.data;

                var pPositions = pPosData.getTypedData(DeclUsages.POSITION);

                //Get bone trasform matrices data
                var pMatricesData = pSkin.getBoneTransforms();

                //число влияний, которые мы прочитали, в соответствие с тегом <vcount> в collada
                var iTotalReadedInf = 0;

                for (var i = 0, n = 0; i < pPositions.length; i += 3, n++) {
                    for (var j = 0; j < pInfCount[n]; ++j) {
                        var k = (iTotalReadedInf + j) * 2;

                        var fWeight = pInfWeightLoc[k + 1];
                        var iMatAddr = pInfWeightLoc[k];
                        var iBone = (iMatAddr - pMatricesData.getByteOffset() / Float32Array.BYTES_PER_ELEMENT) / 16;

                        //console.log("matrix:", iBone, "weight", fWeight);
                        //skip weak influences
                        if (fWeight > 0.25) {
                            if (!akra.isDefAndNotNull(pBoneDependentVertices[iBone])) {
                                pBoneDependentVertices[iBone] = [];
                                pBoneDependentVerticesWeights[iBone] = [];
                            }

                            pBoneDependentVertices[iBone].push(n);
                            pBoneDependentVerticesWeights[iBone].push(fWeight);
                        }
                    }

                    iTotalReadedInf += pInfCount[n];
                }

                var mBindShapeMatrix = pSkin.getBindMatrix();

                var pBoneLocalBoxes = new Array(nBones);

                for (var iBone = 0; iBone < nBones; ++iBone) {
                    var pVertexIndices = pBoneDependentVertices[iBone];
                    var pvertexWeights = pBoneDependentVerticesWeights[iBone];

                    if (!pVertexIndices) {
                        pBoneLocalBoxes[iBone] = null;
                        continue;
                    }

                    var mBoneOffsetMatrix = pSkin.getBoneOffsetMatrix(iBone);
                    var pLocalBox = pBoneLocalBoxes[iBone] = new akra.geometry.Rect3d(akra.MAX_UINT32, akra.MIN_UINT32, akra.MAX_UINT32, akra.MIN_UINT32, akra.MAX_UINT32, akra.MIN_UINT32);

                    for (var j = 0; j < pVertexIndices.length; ++j) {
                        var iVertex = pVertexIndices[j] * 3;
                        var vVertex = Vec4.temp(pPositions[iVertex], pPositions[iVertex + 1], pPositions[iVertex + 2], 1.);
                        var fWeight = pvertexWeights[j];

                        var mBoneMatrix = mBoneOffsetMatrix.multiplyNumber(fWeight, Mat4.temp()).multiply(mBindShapeMatrix);

                        mBoneMatrix.multiplyVec4(vVertex);

                        pLocalBox.x0 = akra.math.min(pLocalBox.x0, vVertex.x);
                        pLocalBox.x1 = akra.math.max(pLocalBox.x1, vVertex.x);

                        pLocalBox.y0 = akra.math.min(pLocalBox.y0, vVertex.y);
                        pLocalBox.y1 = akra.math.max(pLocalBox.y1, vVertex.y);

                        pLocalBox.z0 = akra.math.min(pLocalBox.z0, vVertex.z);
                        pLocalBox.z1 = akra.math.max(pLocalBox.z1, vVertex.z);
                    }
                }

                akra.debug.timeEnd("MeshSubset::calculateBonesLocalBoundingBoxes()");

                this._pSkinLocalBounds = pBoneLocalBoxes;

                return pBoneLocalBoxes;
            };

            MeshSubset.prototype.calculateSkin = function () {
                var isOk = akra.config.WEBGL ? akra.webgl.calculateSkin(this) : false;
                this._isOptimizedSkinned = isOk;
                return isOk;
            };

            MeshSubset.prototype.calculateSkinBasedBoundingBox = function () {
                if (akra.isNull(this._pBoundingBox)) {
                    this._pBoundingBox = new akra.geometry.Rect3d();
                }

                var pLocalBounds = this._pSkinLocalBounds;
                var pSkin = this._pSkin;

                var pBB = this._pBoundingBox.set(akra.MAX_UINT32, akra.MIN_UINT32, akra.MAX_UINT32, akra.MIN_UINT32, akra.MAX_UINT32, akra.MIN_UINT32);

                for (var i = 0; i < pLocalBounds.length; ++i) {
                    if (akra.isNull(pLocalBounds[i])) {
                        continue;
                    }

                    var pLocalBB = akra.geometry.Rect3d.temp(pLocalBounds[i]).transform(pSkin.getAffectedNode(i).getWorldMatrix());

                    pBB.x0 = akra.math.min(pBB.x0, pLocalBB.x0);
                    pBB.x1 = akra.math.max(pBB.x1, pLocalBB.x1);

                    pBB.y0 = akra.math.min(pBB.y0, pLocalBB.y0);
                    pBB.y1 = akra.math.max(pBB.y1, pLocalBB.y1);

                    pBB.z0 = akra.math.min(pBB.z0, pLocalBB.z0);
                    pBB.z1 = akra.math.max(pBB.z1, pLocalBB.z1);
                }
                //var mInvWorldMatrix: IMat4 = (<INode>pSkin.getSkeleton().getRoot().getParent()).getInverseWorldMatrix();
                //pBB.transform(mInvWorldMatrix);
            };

            MeshSubset.isMeshSubset = function (pObject) {
                return pObject.getType() === 1 /* MESH_SUBSET */;
            };
            return MeshSubset;
        })(akra.render.RenderableObject);
        model.MeshSubset = MeshSubset;
    })(akra.model || (akra.model = {}));
    var model = akra.model;
})(akra || (akra = {}));
/// <reference path="../idl/IAFXComposer.ts" />
/// <reference path="../idl/IAFXEffect.ts" />
/// <reference path="../idl/IEngine.ts" />
/// <reference path="../idl/IResourcePool.ts" />
/// <reference path="../idl/IAFXComponent.ts" />
/// <reference path="../idl/IAFXMaker.ts" />
/// <reference path="../idl/IRenderer.ts" />
/// <reference path="../idl/IIndexData.ts" />
/// <reference path="../idl/IBufferMap.ts" />
/// <reference path="../idl/IAFXBlender.ts" />
/// <reference path="../idl/EPrimitiveTypes.ts" />
/// <reference path="../idl/IRID.ts" />
var akra;
(function (akra) {
    /// <reference path="../math/math.ts" />
    /// <reference path="../logger.ts" />
    /// <reference path="../color/colors.ts" />
    /// <reference path="../limit.ts" />
    /// <reference path="../webgl/webgl.ts" />
    /// <reference path="../render/render.ts" />
    /// <reference path="../util/ObjectArray.ts" />
    /// <reference path="instructions/VariableInstruction.ts" />
    /// <reference path="SamplerBlender.ts" />
    /// <reference path="Blender.ts" />
    /// <reference path="Effect.ts" />
    /// <reference path="../model/MeshSubset.ts" />
    (function (fx) {
        var MeshSubset = akra.model.MeshSubset;
        var Vec2 = akra.math.Vec2;

        /** @const */
        var RID_TOTAL = 1024;

        

        var AESystemUniformsIndices;
        (function (AESystemUniformsIndices) {
            AESystemUniformsIndices[AESystemUniformsIndices["k_ModelMatrix"] = 0] = "k_ModelMatrix";
            AESystemUniformsIndices[AESystemUniformsIndices["k_FramebufferSize"] = 1] = "k_FramebufferSize";
            AESystemUniformsIndices[AESystemUniformsIndices["k_ViewportSize"] = 2] = "k_ViewportSize";
            AESystemUniformsIndices[AESystemUniformsIndices["k_ViewMatrix"] = 3] = "k_ViewMatrix";
            AESystemUniformsIndices[AESystemUniformsIndices["k_ProjMatrix"] = 4] = "k_ProjMatrix";
            AESystemUniformsIndices[AESystemUniformsIndices["k_InvViewCameraMat"] = 5] = "k_InvViewCameraMat";
            AESystemUniformsIndices[AESystemUniformsIndices["k_CameraPosition"] = 6] = "k_CameraPosition";
            AESystemUniformsIndices[AESystemUniformsIndices["k_WorldPosition"] = 7] = "k_WorldPosition";
            AESystemUniformsIndices[AESystemUniformsIndices["k_WorldScale"] = 8] = "k_WorldScale";
            AESystemUniformsIndices[AESystemUniformsIndices["k_WorldOrientation"] = 9] = "k_WorldOrientation";
            AESystemUniformsIndices[AESystemUniformsIndices["k_LocalPosition"] = 10] = "k_LocalPosition";
            AESystemUniformsIndices[AESystemUniformsIndices["k_LocalScale"] = 11] = "k_LocalScale";
            AESystemUniformsIndices[AESystemUniformsIndices["k_LocalOrientation"] = 12] = "k_LocalOrientation";
            AESystemUniformsIndices[AESystemUniformsIndices["k_LocalMatrix"] = 13] = "k_LocalMatrix";
            AESystemUniformsIndices[AESystemUniformsIndices["k_OptimizedProjMatrix"] = 14] = "k_OptimizedProjMatrix";
            AESystemUniformsIndices[AESystemUniformsIndices["k_BindShapeMatrix"] = 15] = "k_BindShapeMatrix";
            AESystemUniformsIndices[AESystemUniformsIndices["k_RenderObjectId"] = 16] = "k_RenderObjectId";
            AESystemUniformsIndices[AESystemUniformsIndices["k_WireframeOverlay"] = 17] = "k_WireframeOverlay";

            // k_InputTexture,
            // k_InputSampler,
            AESystemUniformsIndices[AESystemUniformsIndices["k_InputTextureSize"] = 18] = "k_InputTextureSize";
            AESystemUniformsIndices[AESystemUniformsIndices["k_InputTextureRatio"] = 19] = "k_InputTextureRatio";

            AESystemUniformsIndices[AESystemUniformsIndices["k_useNormal"] = 20] = "k_useNormal";
            AESystemUniformsIndices[AESystemUniformsIndices["k_isDebug"] = 21] = "k_isDebug";
            AESystemUniformsIndices[AESystemUniformsIndices["k_isRealNormal"] = 22] = "k_isRealNormal";
            AESystemUniformsIndices[AESystemUniformsIndices["k_normalFix"] = 23] = "k_normalFix";
            AESystemUniformsIndices[AESystemUniformsIndices["k_isWithBalckSectors"] = 24] = "k_isWithBalckSectors";
            AESystemUniformsIndices[AESystemUniformsIndices["k_showTriangles"] = 25] = "k_showTriangles";
            AESystemUniformsIndices[AESystemUniformsIndices["k_u1"] = 26] = "k_u1";
            AESystemUniformsIndices[AESystemUniformsIndices["k_kFixNormal"] = 27] = "k_kFixNormal";
            AESystemUniformsIndices[AESystemUniformsIndices["k_fSunAmbient"] = 28] = "k_fSunAmbient";
            AESystemUniformsIndices[AESystemUniformsIndices["k_fSunSpecular"] = 29] = "k_fSunSpecular";
            AESystemUniformsIndices[AESystemUniformsIndices["k_cHeightFalloff"] = 30] = "k_cHeightFalloff";
            AESystemUniformsIndices[AESystemUniformsIndices["k_cGlobalDensity"] = 31] = "k_cGlobalDensity";
        })(AESystemUniformsIndices || (AESystemUniformsIndices = {}));

        var Composer = (function () {
            function Composer(pEngine) {
                this._pEngine = null;
                this._pTechniqueToBlendMap = null;
                this._pTechniqueToOwnBlendMap = null;
                this._pTechniqueLastGlobalBlendMap = null;
                this._pTechniqueNeedUpdateMap = null;
                this._pEffectResourceToComponentBlendMap = null;
                this._pBlender = null;
                this._pGlobalEffectResorceIdStack = null;
                // private _pGlobalEffectResorceShiftStack: int[] = null;
                this._pGlobalComponentBlendStack = null;
                this._pGlobalComponentBlend = null;
                //Data for render
                this._pCurrentSceneObject = null;
                this._pCurrentViewport = null;
                this._pCurrentRenderable = null;
                this._pCurrentBufferMap = null;
                this._pCurrentSurfaceMaterial = null;
                this._pComposerState = {
                    "mesh": {
                        "isSkinned": false,
                        "isOptimizedSkinned": false,
                        "transparent": false
                    },
                    "object": {
                        "isBillboard": false
                    },
                    "terrain": {
                        "isROAM": false
                    },
                    "renderable": {
                        "isAdvancedIndex": false
                    }
                };
                /** Render targets for global-post effects */
                this._pRenderTargetA = null;
                this._pRenderTargetB = null;
                this._pLastRenderTarget = null;
                this._pPostEffectViewport = null;
                this._pPostEffectTextureA = null;
                this._pPostEffectTextureB = null;
                this._pPostEffectDepthBuffer = null;
                //render id data
                this._pRidTable = {};
                this._pRidMap = {};
                this._nRidSO = 0;
                this._nRidRE = 0;
                //For fast set system uniforms
                this._pSystemUniformsNameIndexList = new Array();
                this._bIsFirstApplySystemUnifoms = true;
                this.bNormalFix = true;
                this.bUseNormalMap = true;
                this.bIsDebug = false;
                this.bIsRealNormal = false;
                this.bTerrainBlackSectors = false;
                this.bShowTriangles = false;
                //sun parameters
                this.kFixNormal = 0.43;
                this.fSunSpecular = 0.5;
                this.fSunAmbient = 0.22;
                //fog
                this.cHeightFalloff = 0.;
                this.cGlobalDensity = 0.;
                this._pEngine = pEngine;

                this._pBlender = new fx.Blender(this);

                this._pTechniqueToBlendMap = {};
                this._pTechniqueToOwnBlendMap = {};
                this._pTechniqueLastGlobalBlendMap = {};
                this._pTechniqueNeedUpdateMap = {};

                this._pEffectResourceToComponentBlendMap = {};

                this._pGlobalEffectResorceIdStack = [];
                this._pGlobalComponentBlendStack = [];
                this._pGlobalComponentBlend = null;

                this.initPostEffectTextures();

                if (akra.isNull(Composer.pDefaultSamplerBlender)) {
                    Composer.pDefaultSamplerBlender = new fx.SamplerBlender();
                }
            }
            Composer.prototype.getComponentByName = function (sComponentName) {
                return this._pEngine.getResourceManager().getComponentPool().findResource(sComponentName);
            };

            Composer.prototype.getEngine = function () {
                return this._pEngine;
            };

            //-----------------------------------------------------------------------------//
            //-----------------------------API for Effect-resource-------------------------//
            //-----------------------------------------------------------------------------//
            Composer.prototype.getComponentCountForEffect = function (pEffectResource) {
                var id = pEffectResource.getResourceHandle();

                if (akra.isDef(this._pEffectResourceToComponentBlendMap[id])) {
                    return this._pEffectResourceToComponentBlendMap[id].getComponentCount();
                } else {
                    return 0;
                }
            };

            Composer.prototype.getTotalPassesForEffect = function (pEffectResource) {
                var id = pEffectResource.getResourceHandle();

                if (akra.isDef(this._pEffectResourceToComponentBlendMap[id])) {
                    return this._pEffectResourceToComponentBlendMap[id].getTotalPasses();
                } else {
                    return 0;
                }
            };

            Composer.prototype.addComponentToEffect = function (pEffectResource, pComponent, iShift, iPass) {
                var id = pEffectResource.getResourceHandle();
                var pCurrentBlend = null;

                if (akra.isDef(this._pEffectResourceToComponentBlendMap[id])) {
                    pCurrentBlend = this._pEffectResourceToComponentBlendMap[id];
                }

                var pNewBlend = this._pBlender.addComponentToBlend(pCurrentBlend, pComponent, iShift, iPass);
                if (akra.isNull(pNewBlend)) {
                    return false;
                }

                this._pEffectResourceToComponentBlendMap[id] = pNewBlend;
                return true;
            };

            Composer.prototype.removeComponentFromEffect = function (pEffectResource, pComponent, iShift, iPass) {
                var id = pEffectResource.getResourceHandle();
                var pCurrentBlend = null;

                if (akra.isDef(this._pEffectResourceToComponentBlendMap[id])) {
                    pCurrentBlend = this._pEffectResourceToComponentBlendMap[id];
                }

                var pNewBlend = this._pBlender.removeComponentFromBlend(pCurrentBlend, pComponent, iShift, iPass);
                if (akra.isNull(pNewBlend)) {
                    return false;
                }

                this._pEffectResourceToComponentBlendMap[id] = pNewBlend;
                return true;
            };

            Composer.prototype.hasComponentForEffect = function (pEffectResource, pComponent, iShift, iPass) {
                var id = pEffectResource.getResourceHandle();
                var pCurrentBlend = null;

                if (akra.isDef(this._pEffectResourceToComponentBlendMap[id])) {
                    pCurrentBlend = this._pEffectResourceToComponentBlendMap[id];
                }

                if (akra.isNull(pCurrentBlend)) {
                    return false;
                }

                return pCurrentBlend.containComponent(pComponent, iShift, iPass);
            };

            Composer.prototype.activateEffectResource = function (pEffectResource, iShift) {
                var id = pEffectResource.getResourceHandle();
                var pComponentBlend = this._pEffectResourceToComponentBlendMap[id];

                if (!akra.isDef(pComponentBlend)) {
                    return false;
                }

                var pNewGlobalBlend = null;

                if (akra.isNull(this._pGlobalComponentBlend)) {
                    pNewGlobalBlend = pComponentBlend;
                } else {
                    pNewGlobalBlend = this._pBlender.addBlendToBlend(this._pGlobalComponentBlend, pComponentBlend, iShift);
                }

                if (akra.isNull(pNewGlobalBlend)) {
                    return false;
                }

                this._pGlobalEffectResorceIdStack.push(id);
                this._pGlobalComponentBlendStack.push(pNewGlobalBlend);

                this._pGlobalComponentBlend = pNewGlobalBlend;

                return true;
            };

            Composer.prototype.deactivateEffectResource = function (pEffectResource) {
                var id = pEffectResource.getResourceHandle();
                var iStackLength = this._pGlobalEffectResorceIdStack.length;

                if (iStackLength === 0) {
                    return false;
                }

                var iLastId = this._pGlobalEffectResorceIdStack[iStackLength - 1];

                if (iLastId !== id) {
                    return false;
                }

                this._pGlobalEffectResorceIdStack.splice(iStackLength - 1, 1);
                this._pGlobalComponentBlendStack.splice(iStackLength - 1, 1);

                if (iStackLength > 1) {
                    this._pGlobalComponentBlend = this._pGlobalComponentBlendStack[iStackLength - 2];
                } else {
                    this._pGlobalComponentBlend = null;
                }

                return true;
            };

            Composer.prototype.getPassInputBlendForEffect = function (pEffectResource, iPass) {
                var id = pEffectResource.getResourceHandle();
                var pBlend = this._pEffectResourceToComponentBlendMap[id];

                if (!akra.isDef(this._pEffectResourceToComponentBlendMap[id])) {
                    return null;
                }

                if (!pBlend.isReadyToUse()) {
                    pBlend.finalizeBlend();
                }

                return pBlend.getPassInputForPass(iPass);
            };

            //-----------------------------------------------------------------------------//
            //----------------------------API for RenderTechnique--------------------------//
            //-----------------------------------------------------------------------------//
            Composer.prototype.copyTechniqueOwnComponentBlend = function (pFrom, pTo) {
                var iFromId = pFrom.guid;
                var iToId = pTo.guid;

                var pCurrentBlendTo = null;
                var pCurrentBlendFrom = null;

                if (akra.isDef(this._pTechniqueToOwnBlendMap[iFromId])) {
                    pCurrentBlendFrom = this._pTechniqueToOwnBlendMap[iFromId];
                }

                if (akra.isDef(this._pTechniqueToOwnBlendMap[iToId])) {
                    pCurrentBlendTo = this._pTechniqueToOwnBlendMap[iToId];
                }

                var pNewBlend = this._pBlender.addBlendToBlend(pCurrentBlendTo, pCurrentBlendFrom, 0);

                this._pTechniqueToOwnBlendMap[iToId] = pNewBlend;
                this._pTechniqueNeedUpdateMap[iToId] = true;
            };

            Composer.prototype.getMinShiftForOwnTechniqueBlend = function (pRenderTechnique) {
                var id = pRenderTechnique.guid;
                var pBlend = this._pTechniqueToOwnBlendMap[id];

                if (akra.isDefAndNotNull(this._pTechniqueToOwnBlendMap[id])) {
                    return pBlend._getMinShift();
                } else {
                    return 0;
                }
            };

            Composer.prototype.getTotalPassesForTechnique = function (pRenderTechnique) {
                this.prepareTechniqueBlend(pRenderTechnique);

                var id = pRenderTechnique.guid;

                if (akra.isDefAndNotNull(this._pTechniqueToBlendMap[id])) {
                    return this._pTechniqueToBlendMap[id].getTotalPasses();
                } else {
                    return 0;
                }
            };

            Composer.prototype.addOwnComponentToTechnique = function (pRenderTechnique, pComponent, iShift, iPass) {
                var id = pRenderTechnique.guid;
                var pCurrentBlend = null;

                if (akra.isDef(this._pTechniqueToOwnBlendMap[id])) {
                    pCurrentBlend = this._pTechniqueToOwnBlendMap[id];
                }

                var pNewBlend = this._pBlender.addComponentToBlend(pCurrentBlend, pComponent, iShift, iPass);

                if (akra.isNull(pNewBlend)) {
                    return false;
                }

                this._pTechniqueToOwnBlendMap[id] = pNewBlend;
                this._pTechniqueNeedUpdateMap[id] = true;

                return true;
            };

            Composer.prototype.removeOwnComponentToTechnique = function (pRenderTechnique, pComponent, iShift, iPass) {
                var id = pRenderTechnique.guid;
                var pCurrentBlend = null;

                if (akra.isDef(this._pTechniqueToOwnBlendMap[id])) {
                    pCurrentBlend = this._pTechniqueToOwnBlendMap[id];
                }

                var pNewBlend = this._pBlender.removeComponentFromBlend(pCurrentBlend, pComponent, iShift, iPass);
                if (akra.isNull(pNewBlend)) {
                    return false;
                }

                this._pTechniqueToOwnBlendMap[id] = pNewBlend;
                this._pTechniqueNeedUpdateMap[id] = true;
                return true;
            };

            Composer.prototype.hasOwnComponentInTechnique = function (pRenderTechnique, pComponent, iShift, iPass) {
                var id = pRenderTechnique.guid;
                var pCurrentBlend = null;

                if (akra.isDef(this._pTechniqueToOwnBlendMap[id])) {
                    pCurrentBlend = this._pTechniqueToOwnBlendMap[id];
                }

                if (akra.isNull(pCurrentBlend)) {
                    return false;
                }

                return pCurrentBlend.containComponent(pComponent, iShift, iPass);
            };

            Composer.prototype.prepareTechniqueBlend = function (pRenderTechnique) {
                if (pRenderTechnique.isFreeze()) {
                    return true;
                }

                var id = pRenderTechnique.guid;

                var isTechniqueUpdate = !!(this._pTechniqueNeedUpdateMap[id]);
                var isUpdateGlobalBlend = (this._pGlobalComponentBlend !== this._pTechniqueLastGlobalBlendMap[id]);
                var isNeedToUpdatePasses = false;

                if (isTechniqueUpdate || isUpdateGlobalBlend) {
                    var iEffect = pRenderTechnique.getMethod().getEffect().getResourceHandle();
                    var pEffectBlend = this._pEffectResourceToComponentBlendMap[iEffect] || null;
                    var pTechniqueBlend = this._pTechniqueToOwnBlendMap[id] || null;

                    var pNewBlend = null;

                    pNewBlend = this._pBlender.addBlendToBlend(this._pGlobalComponentBlend, pEffectBlend, 0);
                    pNewBlend = this._pBlender.addBlendToBlend(pNewBlend, pTechniqueBlend, 0);

                    if (this._pTechniqueToBlendMap[id] !== pNewBlend) {
                        isNeedToUpdatePasses = true;
                    }

                    this._pTechniqueToBlendMap[id] = pNewBlend;
                    this._pTechniqueNeedUpdateMap[id] = false;
                    this._pTechniqueLastGlobalBlendMap[id] = this._pGlobalComponentBlend;
                }

                var pBlend = this._pTechniqueToBlendMap[id];

                if (akra.isDefAndNotNull(pBlend)) {
                    if (!pBlend.isReadyToUse()) {
                        isNeedToUpdatePasses = true;
                    }

                    if (!pBlend.finalizeBlend()) {
                        return false;
                    }

                    if (isNeedToUpdatePasses) {
                        pRenderTechnique.updatePasses(isTechniqueUpdate);
                    }

                    pRenderTechnique._setBlendPassTypes(pBlend.getPassTypes());
                    return true;
                } else {
                    return false;
                }
            };

            Composer.prototype.markTechniqueAsNeedUpdate = function (pRenderTechnique) {
                this._pTechniqueNeedUpdateMap[pRenderTechnique.guid] = true;
            };

            Composer.prototype.getPassInputBlendForTechnique = function (pRenderTechnique, iPass) {
                var id = pRenderTechnique.guid;

                if (!akra.isDef(this._pTechniqueToBlendMap[id])) {
                    return null;
                }

                return this._pTechniqueToBlendMap[id].getPassInputForPass(iPass);
            };

            //-----------------------------------------------------------------------------//
            //---------------------------------API for render------------------------------//
            //-----------------------------------------------------------------------------//
            Composer.prototype.applyBufferMap = function (pMap) {
                this._pCurrentBufferMap = pMap;
                return true;
                // var pBufferMap: util.BufferMap = <util.BufferMap>pMap;
                // var pState: AIPreRenderState = this._pPreRenderState;
                // if(pState.isClear){
                // 	pState.primType = pBufferMap.primType;
                // 	pState.offset = pBufferMap.offset;
                // 	pState.length = pBufferMap.length;
                // 	pState.index = pBufferMap.index;
                // }
                // else if(pState.primType !== pBufferMap.primType ||
                // 		pState.offset !== pBufferMap.offset ||
                // 		pState.length !== pBufferMap.length ||
                // 		pState.index !== pBufferMap.index) {
                // 	logger.error("Could not blend buffer maps");
                // 	return false;
                // }
                // var pFlows: IDataFlow[] = pBufferMap.flows;
                // for(var i: uint = 0; i < pFlows.length; i++){
                // 	pState.flows.push(pFlows[i]);
                // }
                // pState.isClear = false;
            };

            Composer.prototype.applySurfaceMaterial = function (pSurfaceMaterial) {
                this._pCurrentSurfaceMaterial = pSurfaceMaterial;
                return true;
            };

            Composer.prototype._setCurrentSceneObject = function (pSceneObject) {
                this._pCurrentSceneObject = pSceneObject;
            };

            Composer.prototype._setCurrentViewport = function (pViewport) {
                this._pCurrentViewport = pViewport;
            };

            Composer.prototype._setCurrentRenderableObject = function (pRenderable) {
                this._pCurrentRenderable = pRenderable;
            };

            Composer.prototype._getCurrentSceneObject = function () {
                return this._pCurrentSceneObject;
            };

            Composer.prototype._getCurrentViewport = function () {
                return this._pCurrentViewport;
            };

            Composer.prototype._getCurrentRenderableObject = function () {
                return this._pCurrentRenderable;
            };

            Composer.prototype._setDefaultCurrentState = function () {
                this._setCurrentViewport(null);
                this._setCurrentRenderableObject(null);
                this._setCurrentSceneObject(null);
            };

            Composer.prototype.renderTechniquePass = function (pRenderTechnique, iPass) {
                // if(true){
                // 	return;
                // }
                var pPass = pRenderTechnique.getPass(iPass);
                var pPassInput = pPass.getPassInput();

                var pPassBlend = null;
                var pMaker = null;

                this.applySystemUnifoms(pPassInput);

                // if(!pPassInput._isNeedToCalcShader()){
                // 	//TODO: set pShader to shader program by id
                // }
                // else {
                // if(!pPassInput._isNeedToCalcBlend()){
                // 	pPassBlend = this._pBlender.getPassBlendById(pPassInput._getLastPassBlendId());
                // }
                // else {
                var id = pRenderTechnique.guid;
                var pComponentBlend = this._pTechniqueToBlendMap[id];
                var pPassInstructionList = pComponentBlend.getPassListAtPass(iPass);

                this.prepareComposerState();

                pPassBlend = this._pBlender.generatePassBlend(pPassInstructionList, this._pComposerState, pPassInput.foreigns, pPassInput.uniforms);

                // }
                if (akra.isNull(pPassBlend)) {
                    akra.logger.error("Could not render. Error with generation pass-blend.");
                    return;
                }

                pMaker = pPassBlend.generateFXMaker(pPassInput, this._pCurrentSurfaceMaterial, this._pCurrentBufferMap);
                if (akra.isNull(pMaker)) {
                    return;
                }

                // }
                //TODO: generate input from PassInputBlend to correct unifoms and attributes list
                //TODO: generate RenderEntry
                //this.clearPreRenderState();
                var pInput = pMaker._make(pPassInput, this._pCurrentBufferMap);
                var pRenderer = this._pEngine.getRenderer();
                var pEntry = pRenderer.createEntry();

                pEntry.maker = pMaker;
                pEntry.input = pInput;
                pEntry.viewport = this._pCurrentViewport;
                pEntry.bufferMap = this._pCurrentBufferMap;
                pEntry.material = this._pCurrentSurfaceMaterial ? this._pCurrentSurfaceMaterial.getMaterial().guid : 0;

                this.prepareRenderTarget(pEntry, pRenderTechnique, iPass);

                pRenderer.pushEntry(pEntry);
            };

            //-----------------------------------------------------------------------------//
            //-----------------------API for load components/AFXEffects--------------------//
            //-----------------------------------------------------------------------------//
            Composer.prototype._loadEffectFromSyntaxTree = function (pTree, sFileName) {
                if (akra.config.AFX_ENABLE_TEXT_EFFECTS) {
                    var pEffect = new fx.Effect(this);

                    // LOG(sFileName, pTree);
                    pEffect.setAnalyzedFileName(sFileName);

                    // LOG("\n\n\n-------------------------Try to analyze '" + sFileName + "'-------------");
                    var isOk = pEffect.analyze(pTree);

                    if (isOk) {
                        // LOG("------ANALYZE IS GOOD '" + sFileName + "'.")
                        var pTechniqueList = pEffect.getTechniqueList();

                        for (var i = 0; i < pTechniqueList.length; i++) {
                            isOk = this.initComponent(pTechniqueList[i]);
                            if (!isOk) {
                                akra.logger.warn("Cannot initialize fx-component from technique '" + pTechniqueList[i]._getName() + "'.");
                                return false;
                            }
                        }
                    } else {
                        akra.logger.warn("Error are occured during analyze of effect file '" + sFileName + "'.");
                        return false;
                    }

                    return true;
                }

                return false;
            };

            Composer.prototype._loadEffectFromBinary = function (pData, sFileName) {
                return false;
            };

            Composer.prototype.initComponent = function (pTechnique) {
                var sTechniqueName = pTechnique._getName();
                var pComponentPool = this._pEngine.getResourceManager().getComponentPool();

                if (!akra.isNull(pComponentPool.findResource(sTechniqueName))) {
                    return false;
                }

                var pComponent = pComponentPool.createResource(sTechniqueName);
                pComponent.setTechnique(pTechnique);

                pTechnique._finalize(this);

                return true;
            };

            Composer.prototype.clearPreRenderState = function () {
                // this._pPreRenderState.primType = 0;
                // this._pPreRenderState.offset = 0;
                // this._pPreRenderState.length = 0;
                // this._pPreRenderState.index = null;
                // this._pPreRenderState.flows.clear(false);
                // this._pPreRenderState.isClear = true;
            };

            Composer.prototype._calcRenderID = function (pSceneObject, pRenderable, bCreateIfNotExists) {
                //assume, that less than 1024 draw calls may be & less than 1024 scene object will be rendered.
                //beacause only 1024
                if (typeof bCreateIfNotExists === "undefined") { bCreateIfNotExists = false; }
                var iSceneObjectGuid = !akra.isDefAndNotNull(pSceneObject) ? 0 : pSceneObject.guid;
                var iRenderableObjectGuid = !akra.isDefAndNotNull(pRenderable) ? akra.MAX_UINT32 : pRenderable.guid;

                if (this._nRidSO === RID_TOTAL || this._nRidRE === RID_TOTAL) {
                    this._pRidTable = {};
                    this._nRidRE = 0;
                    this._nRidSO = 0;
                }

                var pRidTable = this._pRidTable;
                var pRidMap = this._pRidMap;
                var pRidByRenderable = pRidTable[iSceneObjectGuid];
                var pRidPair;

                var iRid = 0;

                if (!akra.isDefAndNotNull(pRidByRenderable)) {
                    if (!bCreateIfNotExists) {
                        return 0;
                    }

                    pRidByRenderable = pRidTable[iSceneObjectGuid] = {};
                    pRidByRenderable[0] = this._nRidSO++;
                }

                iRid = pRidByRenderable[iRenderableObjectGuid];

                if (!akra.isDefAndNotNull(iRid)) {
                    if (!bCreateIfNotExists) {
                        // LOG("here...")
                        return 1 + pRidByRenderable[0] * 1024;
                    }

                    pRidByRenderable[iRenderableObjectGuid] = iRid = 1 + pRidByRenderable[0] * 1024 + this._nRidRE;
                    pRidPair = pRidMap[iRid];

                    if (!akra.isDefAndNotNull(pRidPair)) {
                        pRidPair = pRidMap[iRid] = { renderable: null, object: null };
                    }

                    // LOG("render pair created with id: ", iRid, "roid(", iRenderableObjectGuid, "): ", this._nRidRE, "soid(", iSceneObjectGuid,"): ", pRidByRenderable[0]);
                    pRidPair.renderable = pRenderable;
                    pRidPair.object = pSceneObject;

                    this._nRidRE++;
                }

                return iRid;
            };

            Composer.prototype._getRenderableByRid = function (iRid) {
                var pRidPair = this._pRidMap[iRid];
                var pRenderable = akra.isDefAndNotNull(pRidPair) ? pRidPair.renderable : null;
                return akra.isNull(pRenderable) || pRenderable.isFrozen() ? null : pRenderable;
            };

            Composer.prototype._getObjectByRid = function (iRid) {
                var pRidPair = this._pRidMap[iRid];
                var pSceneObject = akra.isDefAndNotNull(pRidPair) ? pRidPair.object : null;
                return akra.isNull(pSceneObject) || pSceneObject.isFrozen() ? null : pSceneObject;
            };

            Composer.prototype.applySystemUnifoms = function (pPassInput) {
                if (this._bIsFirstApplySystemUnifoms) {
                    this._pSystemUniformsNameIndexList[0 /* k_ModelMatrix */] = fx.instructions.VariableDeclInstruction._getIndex("MODEL_MATRIX");
                    this._pSystemUniformsNameIndexList[1 /* k_FramebufferSize */] = fx.instructions.VariableDeclInstruction._getIndex("FRAMEBUFFER_SIZE");
                    this._pSystemUniformsNameIndexList[2 /* k_ViewportSize */] = fx.instructions.VariableDeclInstruction._getIndex("VIEWPORT_SIZE");
                    this._pSystemUniformsNameIndexList[3 /* k_ViewMatrix */] = fx.instructions.VariableDeclInstruction._getIndex("VIEW_MATRIX");
                    this._pSystemUniformsNameIndexList[4 /* k_ProjMatrix */] = fx.instructions.VariableDeclInstruction._getIndex("PROJ_MATRIX");
                    this._pSystemUniformsNameIndexList[5 /* k_InvViewCameraMat */] = fx.instructions.VariableDeclInstruction._getIndex("INV_VIEW_CAMERA_MAT");
                    this._pSystemUniformsNameIndexList[6 /* k_CameraPosition */] = fx.instructions.VariableDeclInstruction._getIndex("CAMERA_POSITION");
                    this._pSystemUniformsNameIndexList[7 /* k_WorldPosition */] = fx.instructions.VariableDeclInstruction._getIndex("WORLD_POSITION");
                    this._pSystemUniformsNameIndexList[8 /* k_WorldScale */] = fx.instructions.VariableDeclInstruction._getIndex("WORLD_SCALE");
                    this._pSystemUniformsNameIndexList[9 /* k_WorldOrientation */] = fx.instructions.VariableDeclInstruction._getIndex("WORLD_ORIENTATION");
                    this._pSystemUniformsNameIndexList[11 /* k_LocalScale */] = fx.instructions.VariableDeclInstruction._getIndex("LOCAL_SCALE");
                    this._pSystemUniformsNameIndexList[10 /* k_LocalPosition */] = fx.instructions.VariableDeclInstruction._getIndex("LOCAL_POSITION");
                    this._pSystemUniformsNameIndexList[12 /* k_LocalOrientation */] = fx.instructions.VariableDeclInstruction._getIndex("LOCAL_ORIENTATION");
                    this._pSystemUniformsNameIndexList[13 /* k_LocalMatrix */] = fx.instructions.VariableDeclInstruction._getIndex("LOCAL_MATRIX");
                    this._pSystemUniformsNameIndexList[14 /* k_OptimizedProjMatrix */] = fx.instructions.VariableDeclInstruction._getIndex("OPTIMIZED_PROJ_MATRIX");
                    this._pSystemUniformsNameIndexList[15 /* k_BindShapeMatrix */] = fx.instructions.VariableDeclInstruction._getIndex("BIND_SHAPE_MATRIX");
                    this._pSystemUniformsNameIndexList[16 /* k_RenderObjectId */] = fx.instructions.VariableDeclInstruction._getIndex("RENDER_OBJECT_ID");
                    this._pSystemUniformsNameIndexList[17 /* k_WireframeOverlay */] = fx.instructions.VariableDeclInstruction._getIndex("WIREFRAME_OVERLAY");
                    this._pSystemUniformsNameIndexList[18 /* k_InputTextureSize */] = fx.instructions.VariableDeclInstruction._getIndex("INPUT_TEXTURE_SIZE");
                    this._pSystemUniformsNameIndexList[19 /* k_InputTextureRatio */] = fx.instructions.VariableDeclInstruction._getIndex("INPUT_TEXTURE_RATIO");

                    this._pSystemUniformsNameIndexList[20 /* k_useNormal */] = fx.instructions.VariableDeclInstruction._getIndex("useNormal");
                    this._pSystemUniformsNameIndexList[21 /* k_isDebug */] = fx.instructions.VariableDeclInstruction._getIndex("isDebug");
                    this._pSystemUniformsNameIndexList[22 /* k_isRealNormal */] = fx.instructions.VariableDeclInstruction._getIndex("isRealNormal");
                    this._pSystemUniformsNameIndexList[23 /* k_normalFix */] = fx.instructions.VariableDeclInstruction._getIndex("normalFix");
                    this._pSystemUniformsNameIndexList[24 /* k_isWithBalckSectors */] = fx.instructions.VariableDeclInstruction._getIndex("isWithBalckSectors");
                    this._pSystemUniformsNameIndexList[25 /* k_showTriangles */] = fx.instructions.VariableDeclInstruction._getIndex("showTriangles");
                    this._pSystemUniformsNameIndexList[26 /* k_u1 */] = fx.instructions.VariableDeclInstruction._getIndex("u1");
                    this._pSystemUniformsNameIndexList[27 /* k_kFixNormal */] = fx.instructions.VariableDeclInstruction._getIndex("kFixNormal");
                    this._pSystemUniformsNameIndexList[28 /* k_fSunAmbient */] = fx.instructions.VariableDeclInstruction._getIndex("fSunAmbient");
                    this._pSystemUniformsNameIndexList[29 /* k_fSunSpecular */] = fx.instructions.VariableDeclInstruction._getIndex("fSunSpecular");
                    this._pSystemUniformsNameIndexList[30 /* k_cHeightFalloff */] = fx.instructions.VariableDeclInstruction._getIndex("cHeightFalloff");
                    this._pSystemUniformsNameIndexList[31 /* k_cGlobalDensity */] = fx.instructions.VariableDeclInstruction._getIndex("cGlobalDensity");

                    this._bIsFirstApplySystemUnifoms = false;
                }

                var pSceneObject = this._getCurrentSceneObject();
                var pViewport = this._getCurrentViewport();
                var pRenderable = this._getCurrentRenderableObject();

                var iRenderableID = this._calcRenderID(pSceneObject, pRenderable, true);
                var iIndex = 0;

                if (!akra.isNull(pSceneObject)) {
                    //pSceneObject.getWorldMatrix()
                    pPassInput.uniforms[this._pSystemUniformsNameIndexList[0 /* k_ModelMatrix */]] = pSceneObject.getWorldMatrix();

                    pPassInput.uniforms[this._pSystemUniformsNameIndexList[7 /* k_WorldPosition */]] = pSceneObject.getWorldPosition();
                    pPassInput.uniforms[this._pSystemUniformsNameIndexList[8 /* k_WorldScale */]] = pSceneObject.getWorldScale();
                    pPassInput.uniforms[this._pSystemUniformsNameIndexList[9 /* k_WorldOrientation */]] = pSceneObject.getWorldOrientation();

                    pPassInput.uniforms[this._pSystemUniformsNameIndexList[11 /* k_LocalScale */]] = pSceneObject.getLocalScale();
                    pPassInput.uniforms[this._pSystemUniformsNameIndexList[10 /* k_LocalPosition */]] = pSceneObject.getLocalPosition();
                    pPassInput.uniforms[this._pSystemUniformsNameIndexList[12 /* k_LocalOrientation */]] = pSceneObject.getLocalOrientation();
                    pPassInput.uniforms[this._pSystemUniformsNameIndexList[13 /* k_LocalMatrix */]] = pSceneObject.getLocalMatrix();
                }

                if (!akra.isNull(pViewport)) {
                    pPassInput.uniforms[this._pSystemUniformsNameIndexList[1 /* k_FramebufferSize */]] = Vec2.temp(pViewport.getWidth(), pViewport.getHeight());
                    pPassInput.uniforms[this._pSystemUniformsNameIndexList[2 /* k_ViewportSize */]] = Vec2.temp(pViewport.getActualWidth(), pViewport.getActualHeight());

                    var pCamera = pViewport.getCamera();
                    if (!akra.isNull(pCamera)) {
                        pPassInput.uniforms[this._pSystemUniformsNameIndexList[3 /* k_ViewMatrix */]] = pCamera.getViewMatrix();
                        pPassInput.uniforms[this._pSystemUniformsNameIndexList[4 /* k_ProjMatrix */]] = pCamera.getProjectionMatrix();
                        pPassInput.uniforms[this._pSystemUniformsNameIndexList[5 /* k_InvViewCameraMat */]] = pCamera.getWorldMatrix();
                        pPassInput.uniforms[this._pSystemUniformsNameIndexList[6 /* k_CameraPosition */]] = pCamera.getWorldPosition();

                        if (pCamera.getType() === 5 /* SHADOW_CASTER */) {
                            pPassInput.uniforms[this._pSystemUniformsNameIndexList[14 /* k_OptimizedProjMatrix */]] = pCamera.getOptimizedProjection();
                        }
                    }
                }

                if (!akra.isNull(pRenderable)) {
                    if (MeshSubset.isMeshSubset(pRenderable) && pRenderable.isSkinned()) {
                        pPassInput.uniforms[this._pSystemUniformsNameIndexList[15 /* k_BindShapeMatrix */]] = pRenderable.getSkin().getBindMatrix();
                    }

                    pPassInput.uniforms[this._pSystemUniformsNameIndexList[16 /* k_RenderObjectId */]] = iRenderableID;
                    pPassInput.uniforms[this._pSystemUniformsNameIndexList[17 /* k_WireframeOverlay */]] = pRenderable["_bWireframeOverlay"];
                }

                if (!akra.isNull(this._pLastRenderTarget)) {
                    var pLastTexture = this._pLastRenderTarget === this._pRenderTargetA ? this._pPostEffectTextureA : this._pPostEffectTextureB;

                    pPassInput.setTexture("INPUT_TEXTURE", pLastTexture);
                    pPassInput.setSamplerTexture("INPUT_SAMPLER", pLastTexture);

                    pPassInput.uniforms[this._pSystemUniformsNameIndexList[18 /* k_InputTextureSize */]] = Vec2.temp(pLastTexture.getWidth(), pLastTexture.getHeight());
                    pPassInput.uniforms[this._pSystemUniformsNameIndexList[19 /* k_InputTextureRatio */]] = Vec2.temp(this._pCurrentViewport.getActualWidth() / pLastTexture.getWidth(), this._pCurrentViewport.getActualHeight() / pLastTexture.getHeight());
                }

                pPassInput.uniforms[this._pSystemUniformsNameIndexList[20 /* k_useNormal */]] = this.bUseNormalMap;
                pPassInput.uniforms[this._pSystemUniformsNameIndexList[21 /* k_isDebug */]] = this.bIsDebug;
                pPassInput.uniforms[this._pSystemUniformsNameIndexList[22 /* k_isRealNormal */]] = this.bIsRealNormal;
                pPassInput.uniforms[this._pSystemUniformsNameIndexList[23 /* k_normalFix */]] = this.bNormalFix;
                pPassInput.uniforms[this._pSystemUniformsNameIndexList[24 /* k_isWithBalckSectors */]] = this.bTerrainBlackSectors;
                pPassInput.uniforms[this._pSystemUniformsNameIndexList[25 /* k_showTriangles */]] = this.bShowTriangles;
                pPassInput.uniforms[this._pSystemUniformsNameIndexList[26 /* k_u1 */]] = 64;
                pPassInput.uniforms[this._pSystemUniformsNameIndexList[27 /* k_kFixNormal */]] = this.kFixNormal;
                pPassInput.uniforms[this._pSystemUniformsNameIndexList[28 /* k_fSunAmbient */]] = this.fSunAmbient;
                pPassInput.uniforms[this._pSystemUniformsNameIndexList[29 /* k_fSunSpecular */]] = this.fSunSpecular;
                pPassInput.uniforms[this._pSystemUniformsNameIndexList[30 /* k_cHeightFalloff */]] = this.cHeightFalloff;
                pPassInput.uniforms[this._pSystemUniformsNameIndexList[31 /* k_cGlobalDensity */]] = this.cGlobalDensity;

                pPassInput.setUniform("isBillboard", this._pCurrentSceneObject && this._pCurrentSceneObject.isBillboard());
            };

            Composer.prototype.prepareComposerState = function () {
                if (!akra.isNull(this._pCurrentRenderable)) {
                    this._pComposerState.renderable.isAdvancedIndex = this._pCurrentRenderable.getData().useAdvancedIndex();
                    this._pComposerState.object.isBillboard = this._pCurrentSceneObject && this._pCurrentSceneObject.isBillboard();

                    if (MeshSubset.isMeshSubset(this._pCurrentRenderable) && this._pCurrentRenderable.isSkinned()) {
                        this._pComposerState.mesh.isSkinned = true;
                        this._pComposerState.mesh.isOptimizedSkinned = this._pCurrentRenderable.isOptimizedSkinned();
                    } else {
                        this._pComposerState.mesh.isSkinned = false;
                        this._pComposerState.mesh.isOptimizedSkinned = false;
                    }

                    if (this._pCurrentSurfaceMaterial && this._pCurrentSurfaceMaterial.getMaterial().isTransparent()) {
                        this._pComposerState.mesh.transparent = true;
                    } else {
                        this._pComposerState.mesh.transparent = false;
                    }
                }

                if (!akra.isNull(this._pCurrentSceneObject)) {
                    if (this._pCurrentSceneObject.getType() === 67 /* TERRAIN_ROAM */) {
                        this._pComposerState.terrain.isROAM = true;
                    } else {
                        this._pComposerState.terrain.isROAM = false;
                    }
                }
            };

            Composer.prototype.initPostEffectTextures = function () {
                var pRmgr = this._pEngine.getResourceManager();
                this._pPostEffectTextureA = pRmgr.createTexture(".global-post-effect-texture-A");
                this._pPostEffectTextureB = pRmgr.createTexture(".global-post-effect-texture-B");

                this._pPostEffectTextureA.create(512, 512, 1, null, 512 /* RENDERTARGET */, 0, 0, 3553 /* TEXTURE_2D */, 28 /* R8G8B8A8 */);

                this._pPostEffectTextureB.create(512, 512, 1, null, 512 /* RENDERTARGET */, 0, 0, 3553 /* TEXTURE_2D */, 28 /* R8G8B8A8 */);

                // this._pPostEffectTextureA.notifyLoaded();
                // this._pPostEffectTextureB.notifyLoaded();
                this._pRenderTargetA = this._pPostEffectTextureA.getBuffer().getRenderTarget();
                this._pRenderTargetB = this._pPostEffectTextureB.getBuffer().getRenderTarget();

                this._pPostEffectDepthBuffer = pRmgr.getRenderBufferPool().createResource(".global-post-effect-depth");
                this._pPostEffectDepthBuffer.create(6402 /* DEPTH_COMPONENT */, 512, 512, false);

                this._pRenderTargetA.attachDepthPixelBuffer(this._pPostEffectDepthBuffer);

                this._pPostEffectViewport = this._pRenderTargetA.addViewport(new akra.render.Viewport(null));
            };

            Composer.prototype.resizePostEffectTextures = function (iWidth, iHeight) {
                iWidth = akra.math.ceilingPowerOfTwo(iWidth);
                iHeight = akra.math.ceilingPowerOfTwo(iHeight);

                this._pPostEffectTextureA.reset(iWidth, iHeight);
                this._pPostEffectTextureB.reset(iWidth, iHeight);
            };

            Composer.prototype.prepareRenderTarget = function (pEntry, pRenderTechnique, iPass) {
                var pRenderer = this._pEngine.getRenderer();

                if (pRenderTechnique.hasPostEffect()) {
                    if (pEntry.viewport.getActualWidth() > this._pRenderTargetA.getWidth() || pEntry.viewport.getActualHeight() > this._pRenderTargetA.getHeight()) {
                        this.resizePostEffectTextures(pEntry.viewport.getActualWidth(), pEntry.viewport.getActualHeight());
                    }

                    if (pRenderTechnique.isFirstPass(iPass)) {
                        var pRenderViewport = pEntry.viewport;

                        pRenderer._setDepthBufferParams(false, false, 0);
                        pRenderer._setRenderTarget(this._pRenderTargetA);

                        var pViewportState = pRenderViewport._getViewportState();
                        this._pPostEffectViewport.setDimensions(0., 0., pRenderViewport.getActualWidth() / this._pRenderTargetA.getWidth(), pRenderViewport.getActualHeight() / this._pRenderTargetA.getHeight());
                        this._pPostEffectViewport.setDepthParams(pViewportState.depthTest, pViewportState.depthWrite, pViewportState.depthFunction);
                        this._pPostEffectViewport.setCullingMode(pViewportState.cullingMode);

                        // pRenderer._lockRenderTarget();
                        if (pRenderViewport.getClearEveryFrame()) {
                            this._pPostEffectViewport.clear(pViewportState.clearBuffers, pViewportState.clearColor, pViewportState.clearDepth, 0);
                        } else {
                            this._pPostEffectViewport.clear(1 /* COLOR */ | 2 /* DEPTH */, akra.color.ZERO, 1., 0);
                        }

                        this._pLastRenderTarget = null;
                        // pRenderer._unlockRenderTarget();
                    }

                    if (pRenderTechnique.isLastPostEffectPass(iPass) || pRenderTechnique.isLastPass(iPass)) {
                        this._pLastRenderTarget = null;
                    } else if (!pRenderTechnique.isPostEffectPass(iPass)) {
                        if (akra.isNull(this._pLastRenderTarget)) {
                            this._pLastRenderTarget = this._pRenderTargetA;
                        }

                        pEntry.renderTarget = this._pLastRenderTarget;
                        pEntry.viewport = this._pPostEffectViewport;
                    } else {
                        if (this._pLastRenderTarget === this._pRenderTargetA) {
                            pEntry.renderTarget = this._pRenderTargetB;
                            this._pLastRenderTarget = this._pRenderTargetB;
                        } else {
                            pEntry.renderTarget = this._pRenderTargetA;
                            this._pLastRenderTarget = this._pRenderTargetA;
                        }

                        pEntry.viewport = this._pPostEffectViewport;
                    }
                }
            };
            Composer.pDefaultSamplerBlender = null;
            return Composer;
        })();
        fx.Composer = Composer;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (parser) {
        parser.END_POSITION = "END";
        parser.T_EMPTY = "EMPTY";
        parser.UNKNOWN_TOKEN = "UNNOWN";
        parser.START_SYMBOL = "S";
        parser.UNUSED_SYMBOL = "##";
        parser.END_SYMBOL = "$";
        parser.LEXER_RULES = "--LEXER--";
        parser.FLAG_RULE_CREATE_NODE = "--AN";
        parser.FLAG_RULE_NOT_CREATE_NODE = "--NN";
        parser.FLAG_RULE_FUNCTION = "--F";
        parser.EOF = "EOF";
        parser.T_STRING = "T_STRING";
        parser.T_FLOAT = "T_FLOAT";
        parser.T_UINT = "T_UINT";
        parser.T_TYPE_ID = "T_TYPE_ID";
        parser.T_NON_TYPE_ID = "T_NON_TYPE_ID";
    })(akra.parser || (akra.parser = {}));
    var parser = akra.parser;
})(akra || (akra = {}));
/// <reference path="../idl/parser/IParser.ts" />
var akra;
(function (akra) {
    /// <reference path="../logger.ts" />
    /// <reference path="symbols.ts" />
    (function (parser) {
        var LEXER_UNKNOWN_TOKEN = 2101;
        var LEXER_BAD_TOKEN = 2102;

        akra.logger.registerCodeFamily(2000, 2199, "ParserSyntaxErrors");

        akra.logger.registerCode(LEXER_UNKNOWN_TOKEN, "Unknown token: {tokenValue}");
        akra.logger.registerCode(LEXER_BAD_TOKEN, "Bad token: {tokenValue}");

        var Lexer = (function () {
            function Lexer(pParser) {
                this._iLineNumber = 0;
                this._iColumnNumber = 0;
                this._sSource = "";
                this._iIndex = 0;
                this._pParser = pParser;
                this._pPunctuatorsMap = {};
                this._pKeywordsMap = {};
                this._pPunctuatorsFirstSymbols = {};
            }
            Lexer._getPunctuatorName = function (sValue) {
                return "T_PUNCTUATOR_" + sValue.charCodeAt(0);
            };

            Lexer.prototype._addPunctuator = function (sValue, sName) {
                if (typeof sName === "undefined") { sName = Lexer._getPunctuatorName(sValue); }
                this._pPunctuatorsMap[sValue] = sName;
                this._pPunctuatorsFirstSymbols[sValue[0]] = true;
                return sName;
            };

            Lexer.prototype._addKeyword = function (sValue, sName) {
                this._pKeywordsMap[sValue] = sName;
                return sName;
            };

            Lexer.prototype._getTerminalValueByName = function (sName) {
                var sValue = "";

                for (sValue in this._pPunctuatorsMap) {
                    if (this._pPunctuatorsMap[sValue] === sName) {
                        return sValue;
                    }
                }

                for (sValue in this._pKeywordsMap) {
                    if (this._pKeywordsMap[sValue] === sName) {
                        return sValue;
                    }
                }

                return sName;
            };

            Lexer.prototype._init = function (sSource) {
                this._sSource = sSource;
                this._iLineNumber = 0;
                this._iColumnNumber = 0;
                this._iIndex = 0;
            };

            Lexer.prototype._getNextToken = function () {
                var ch = this.currentChar();
                if (!ch) {
                    return {
                        name: parser.END_SYMBOL,
                        value: parser.END_SYMBOL,
                        start: this._iColumnNumber,
                        end: this._iColumnNumber,
                        line: this._iLineNumber
                    };
                }
                var eType = this.identityTokenType();
                var pToken;
                switch (eType) {
                    case 1 /* k_NumericLiteral */:
                        pToken = this.scanNumber();
                        break;
                    case 2 /* k_CommentLiteral */:
                        this.scanComment();
                        pToken = this._getNextToken();
                        break;
                    case 3 /* k_StringLiteral */:
                        pToken = this.scanString();
                        break;
                    case 4 /* k_PunctuatorLiteral */:
                        pToken = this.scanPunctuator();
                        break;
                    case 6 /* k_IdentifierLiteral */:
                        pToken = this.scanIdentifier();
                        break;
                    case 5 /* k_WhitespaceLiteral */:
                        this.scanWhiteSpace();
                        pToken = this._getNextToken();
                        break;
                    default:
                        this._error(LEXER_UNKNOWN_TOKEN, {
                            name: parser.UNKNOWN_TOKEN,
                            value: ch + this._sSource[this._iIndex + 1],
                            start: this._iColumnNumber,
                            end: this._iColumnNumber + 1,
                            line: this._iLineNumber
                        });
                }
                return pToken;
            };

            Lexer.prototype._getIndex = function () {
                return this._iIndex;
            };

            Lexer.prototype._setSource = function (sSource) {
                this._sSource = sSource;
            };

            Lexer.prototype._setIndex = function (iIndex) {
                this._iIndex = iIndex;
            };

            Lexer.prototype._error = function (eCode, pToken) {
                var pLocation = {
                    file: this._pParser.getParseFileName(),
                    line: this._iLineNumber
                };
                var pInfo = {
                    tokenValue: pToken.value,
                    tokenType: pToken.type
                };

                var pLogEntity = { code: eCode, info: pInfo, location: pLocation };

                akra.logger.error(pLogEntity);

                throw new Error(eCode.toString());
            };

            Lexer.prototype.identityTokenType = function () {
                if (this.isIdentifierStart()) {
                    return 6 /* k_IdentifierLiteral */;
                }
                if (this.isWhiteSpaceStart()) {
                    return 5 /* k_WhitespaceLiteral */;
                }
                if (this.isStringStart()) {
                    return 3 /* k_StringLiteral */;
                }
                if (this.isCommentStart()) {
                    return 2 /* k_CommentLiteral */;
                }
                if (this.isNumberStart()) {
                    return 1 /* k_NumericLiteral */;
                }
                if (this.isPunctuatorStart()) {
                    return 4 /* k_PunctuatorLiteral */;
                }
                return 8 /* k_Unknown */;
            };

            Lexer.prototype.isNumberStart = function () {
                var ch = this.currentChar();

                if ((ch >= "0") && (ch <= "9")) {
                    return true;
                }

                var ch1 = this.nextChar();
                if (ch === "." && (ch1 >= "0") && (ch1 <= "9")) {
                    return true;
                }

                return false;
            };

            Lexer.prototype.isCommentStart = function () {
                var ch = this.currentChar();
                var ch1 = this.nextChar();

                if (ch === "/" && (ch1 === "/" || ch1 === "*")) {
                    return true;
                }

                return false;
            };

            Lexer.prototype.isStringStart = function () {
                var ch = this.currentChar();
                if (ch === "\"" || ch === "'") {
                    return true;
                }
                return false;
            };

            Lexer.prototype.isPunctuatorStart = function () {
                var ch = this.currentChar();
                if (this._pPunctuatorsFirstSymbols[ch]) {
                    return true;
                }
                return false;
            };

            Lexer.prototype.isWhiteSpaceStart = function () {
                var ch = this.currentChar();
                if (ch === " " || ch === "\n" || ch === "\r" || ch === "\t") {
                    return true;
                }
                return false;
            };

            Lexer.prototype.isIdentifierStart = function () {
                var ch = this.currentChar();
                if ((ch === "_") || (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z")) {
                    return true;
                }
                return false;
            };

            Lexer.prototype.isLineTerminator = function (sSymbol) {
                return (sSymbol === "\n" || sSymbol === "\r" || sSymbol === "\u2028" || sSymbol === "\u2029");
            };

            Lexer.prototype.isWhiteSpace = function (sSymbol) {
                return (sSymbol === " ") || (sSymbol === "\t");
            };

            Lexer.prototype.isKeyword = function (sValue) {
                return !!(this._pKeywordsMap[sValue]);
            };

            Lexer.prototype.isPunctuator = function (sValue) {
                return !!(this._pPunctuatorsMap[sValue]);
            };

            Lexer.prototype.nextChar = function () {
                return this._sSource[this._iIndex + 1];
            };

            Lexer.prototype.currentChar = function () {
                return this._sSource[this._iIndex];
            };

            Lexer.prototype.readNextChar = function () {
                this._iIndex++;
                this._iColumnNumber++;
                return this._sSource[this._iIndex];
            };

            Lexer.prototype.scanString = function () {
                var chFirst = this.currentChar();
                var sValue = chFirst;
                var ch = "";
                var chPrevious = chFirst;
                var isGoodFinish = false;
                var iStart = this._iColumnNumber;

                while (true) {
                    ch = this.readNextChar();
                    if (!ch) {
                        break;
                    }
                    sValue += ch;
                    if (ch === chFirst && chPrevious !== "\\") {
                        isGoodFinish = true;
                        this.readNextChar();
                        break;
                    }
                    chPrevious = ch;
                }

                if (isGoodFinish) {
                    return {
                        name: parser.T_STRING,
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber - 1,
                        line: this._iLineNumber
                    };
                } else {
                    if (!ch) {
                        ch = parser.EOF;
                    }
                    sValue += ch;

                    this._error(LEXER_BAD_TOKEN, {
                        type: 3 /* k_StringLiteral */,
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber,
                        line: this._iLineNumber
                    });
                    return null;
                }
            };

            Lexer.prototype.scanPunctuator = function () {
                var sValue = this.currentChar();
                var ch;
                var iStart = this._iColumnNumber;

                while (true) {
                    ch = this.readNextChar();
                    if (ch) {
                        sValue += ch;
                        this._iColumnNumber++;
                        if (!this.isPunctuator(sValue)) {
                            sValue = sValue.slice(0, sValue.length - 1);
                            break;
                        }
                    } else {
                        break;
                    }
                }

                return {
                    name: this._pPunctuatorsMap[sValue],
                    value: sValue,
                    start: iStart,
                    end: this._iColumnNumber - 1,
                    line: this._iLineNumber
                };
            };

            Lexer.prototype.scanNumber = function () {
                var ch = this.currentChar();
                var sValue = "";
                var isFloat = false;
                var chPrevious = ch;
                var isGoodFinish = false;
                var iStart = this._iColumnNumber;
                var isE = false;

                if (ch === ".") {
                    sValue += 0;
                    isFloat = true;
                }

                sValue += ch;

                while (true) {
                    ch = this.readNextChar();
                    if (ch === ".") {
                        if (isFloat) {
                            break;
                        } else {
                            isFloat = true;
                        }
                    } else if (ch === "e") {
                        if (isE) {
                            break;
                        } else {
                            isE = true;
                        }
                    } else if (((ch === "+" || ch === "-") && chPrevious === "e")) {
                        sValue += ch;
                        chPrevious = ch;
                        continue;
                    } else if (ch === "f" && isFloat) {
                        ch = this.readNextChar();
                        if ((ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z")) {
                            break;
                        }
                        isGoodFinish = true;
                        break;
                    } else if ((ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z")) {
                        break;
                    } else if (!((ch >= "0") && (ch <= "9")) || !ch) {
                        if ((isE && chPrevious !== "+" && chPrevious !== "-" && chPrevious !== "e") || !isE) {
                            isGoodFinish = true;
                        }
                        break;
                    }
                    sValue += ch;
                    chPrevious = ch;
                }

                if (isGoodFinish) {
                    var sName = isFloat ? parser.T_FLOAT : parser.T_UINT;
                    return {
                        name: sName,
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber - 1,
                        line: this._iLineNumber
                    };
                } else {
                    if (!ch) {
                        ch = parser.EOF;
                    }
                    sValue += ch;
                    this._error(LEXER_BAD_TOKEN, {
                        type: 1 /* k_NumericLiteral */,
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber,
                        line: this._iLineNumber
                    });
                    return null;
                }
            };

            Lexer.prototype.scanIdentifier = function () {
                var ch = this.currentChar();
                var sValue = ch;
                var iStart = this._iColumnNumber;
                var isGoodFinish = false;

                while (true) {
                    ch = this.readNextChar();
                    if (!ch) {
                        isGoodFinish = true;
                        break;
                    }
                    if (!((ch === "_") || (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z") || (ch >= "0" && ch <= "9"))) {
                        isGoodFinish = true;
                        break;
                    }
                    sValue += ch;
                }

                if (isGoodFinish) {
                    if (this.isKeyword(sValue)) {
                        return {
                            name: this._pKeywordsMap[sValue],
                            value: sValue,
                            start: iStart,
                            end: this._iColumnNumber - 1,
                            line: this._iLineNumber
                        };
                    } else {
                        var sName = this._pParser.isTypeId(sValue) ? parser.T_TYPE_ID : parser.T_NON_TYPE_ID;
                        return {
                            name: sName,
                            value: sValue,
                            start: iStart,
                            end: this._iColumnNumber - 1,
                            line: this._iLineNumber
                        };
                    }
                } else {
                    if (!ch) {
                        ch = parser.EOF;
                    }
                    sValue += ch;
                    this._error(LEXER_BAD_TOKEN, {
                        type: 6 /* k_IdentifierLiteral */,
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber,
                        line: this._iLineNumber
                    });
                    return null;
                }
            };

            Lexer.prototype.scanWhiteSpace = function () {
                var ch = this.currentChar();

                while (true) {
                    if (!ch) {
                        break;
                    }
                    if (this.isLineTerminator(ch)) {
                        if (ch === "\r" && this.nextChar() === "\n") {
                            this._iLineNumber--;
                        }
                        this._iLineNumber++;
                        ch = this.readNextChar();
                        this._iColumnNumber = 0;
                        continue;
                    } else if (ch === "\t") {
                        this._iColumnNumber += 3;
                    } else if (ch !== " ") {
                        break;
                    }
                    ch = this.readNextChar();
                }

                return true;
            };

            Lexer.prototype.scanComment = function () {
                var sValue = this.currentChar();
                var ch = this.readNextChar();
                sValue += ch;

                if (ch === "/") {
                    while (true) {
                        ch = this.readNextChar();
                        if (!ch) {
                            break;
                        }
                        if (this.isLineTerminator(ch)) {
                            if (ch === "\r" && this.nextChar() === "\n") {
                                this._iLineNumber--;
                            }
                            this._iLineNumber++;
                            this.readNextChar();
                            this._iColumnNumber = 0;
                            break;
                        }
                        sValue += ch;
                    }

                    return true;
                } else {
                    //Multiline Comment
                    var chPrevious = ch;
                    var isGoodFinish = false;
                    var iStart = this._iColumnNumber;

                    while (true) {
                        ch = this.readNextChar();
                        if (!ch) {
                            break;
                        }
                        sValue += ch;
                        if (ch === "/" && chPrevious === "*") {
                            isGoodFinish = true;
                            this.readNextChar();
                            break;
                        }
                        if (this.isLineTerminator(ch)) {
                            if (ch === "\r" && this.nextChar() === "\n") {
                                this._iLineNumber--;
                            }
                            this._iLineNumber++;
                            this._iColumnNumber = -1;
                        }
                        chPrevious = ch;
                    }

                    if (isGoodFinish) {
                        return true;
                    } else {
                        if (!ch) {
                            ch = parser.EOF;
                        }
                        sValue += ch;
                        this._error(LEXER_BAD_TOKEN, {
                            type: 2 /* k_CommentLiteral */,
                            value: sValue,
                            start: iStart,
                            end: this._iColumnNumber,
                            line: this._iLineNumber
                        });
                        return false;
                    }
                }
            };
            return Lexer;
        })();
        parser.Lexer = Lexer;
    })(akra.parser || (akra.parser = {}));
    var parser = akra.parser;
})(akra || (akra = {}));
/// <reference path="../idl/parser/IParser.ts" />
var akra;
(function (akra) {
    (function (parser) {
        var ParseTree = (function () {
            function ParseTree() {
                this._pRoot = null;
                this._pNodes = [];
                this._pNodesCountStack = [];
                this._isOptimizeMode = false;
            }
            ParseTree.prototype.getRoot = function () {
                return this._pRoot;
            };

            ParseTree.prototype.setRoot = function (pRoot) {
                this._pRoot = pRoot;
            };

            ParseTree.prototype.finishTree = function () {
                this._pRoot = this._pNodes.pop();
            };

            ParseTree.prototype.setOptimizeMode = function (isOptimize) {
                this._isOptimizeMode = isOptimize;
            };

            ParseTree.prototype.addToken = function (pToken) {
                var pNode = {
                    name: pToken.name,
                    value: pToken.value,
                    start: pToken.start,
                    end: pToken.end,
                    line: pToken.line,
                    children: null,
                    parent: null,
                    isAnalyzed: false,
                    position: this._pNodes.length
                };

                this.addNode(pNode);
            };

            ParseTree.prototype.addNode = function (pNode) {
                this._pNodes.push(pNode);
                this._pNodesCountStack.push(1);
            };

            ParseTree.prototype.reduceByRule = function (pRule, eCreate) {
                if (typeof eCreate === "undefined") { eCreate = 0 /* k_Default */; }
                var iReduceCount = 0;
                var pNodesCountStack = this._pNodesCountStack;
                var pNode;
                var iRuleLength = pRule.right.length;
                var pNodes = this._pNodes;
                var nOptimize = this._isOptimizeMode ? 1 : 0;

                while (iRuleLength) {
                    iReduceCount += pNodesCountStack.pop();
                    iRuleLength--;
                }

                if ((eCreate === 0 /* k_Default */ && iReduceCount > nOptimize) || (eCreate === 1 /* k_Necessary */)) {
                    pNode = {
                        name: pRule.left,
                        children: null,
                        parent: null,
                        value: "",
                        isAnalyzed: false,
                        position: this._pNodes.length
                    };

                    while (iReduceCount) {
                        this.addLink(pNode, pNodes.pop());
                        iReduceCount -= 1;
                    }

                    pNodes.push(pNode);
                    pNodesCountStack.push(1);
                } else {
                    pNodesCountStack.push(iReduceCount);
                }
            };

            ParseTree.prototype.toString = function () {
                if (this._pRoot) {
                    return this.toStringNode(this._pRoot);
                } else {
                    return "";
                }
            };

            ParseTree.prototype.clone = function () {
                var pTree = new ParseTree();
                pTree.setRoot(this.cloneNode(this._pRoot));
                return pTree;
            };

            ParseTree.prototype.getNodes = function () {
                return this._pNodes;
            };

            ParseTree.prototype.getLastNode = function () {
                return this._pNodes[this._pNodes.length - 1];
            };

            ParseTree.prototype.addLink = function (pParent, pNode) {
                if (!pParent.children) {
                    pParent.children = [];
                }
                pParent.children.push(pNode);
                pNode.parent = pParent;
            };

            ParseTree.prototype.cloneNode = function (pNode) {
                var pNewNode;
                pNewNode = {
                    name: pNode.name,
                    value: pNode.value,
                    children: null,
                    parent: null,
                    isAnalyzed: pNode.isAnalyzed,
                    position: pNode.position
                };

                var pChildren = pNode.children;
                for (var i = 0; pChildren && i < pChildren.length; i++) {
                    this.addLink(pNewNode, this.cloneNode(pChildren[i]));
                }

                return pNewNode;
            };

            ParseTree.prototype.toStringNode = function (pNode, sPadding) {
                if (typeof sPadding === "undefined") { sPadding = ""; }
                var sRes = sPadding + "{\n";
                var sOldPadding = sPadding;
                var sDefaultPadding = "  ";

                sPadding += sDefaultPadding;

                if (pNode.value) {
                    sRes += sPadding + "name : \"" + pNode.name + "\"" + ",\n";
                    sRes += sPadding + "value : \"" + pNode.value + "\"" + "\n";
                } else {
                    sRes += sPadding + "name : \"" + pNode.name + "\"" + "\n";
                    sRes += sPadding + "children : [";

                    var pChildren = pNode.children;

                    if (pChildren) {
                        sRes += "\n";
                        sPadding += sDefaultPadding;

                        for (var i = pChildren.length - 1; i >= 0; i--) {
                            sRes += this.toStringNode(pChildren[i], sPadding);
                            sRes += ",\n";
                        }

                        sRes = sRes.slice(0, sRes.length - 2);
                        sRes += "\n";
                        sRes += sOldPadding + sDefaultPadding + "]\n";
                    } else {
                        sRes += " ]\n";
                    }
                }
                sRes += sOldPadding + "}";
                return sRes;
            };
            return ParseTree;
        })();
        parser.ParseTree = ParseTree;
    })(akra.parser || (akra.parser = {}));
    var parser = akra.parser;
})(akra || (akra = {}));
/// <reference path="IItem.ts" />
/// <reference path="../IMap.ts" />
/// <reference path="../IMap.ts" />
/// <reference path="IState.ts" />
/// <reference path="IParser.ts" />
/// <reference path="../idl/IMap.ts" />
var akra;
(function (akra) {
    /// <reference path="../idl/parser/IParser.ts" />
    /// <reference path="../idl/parser/IItem.ts" />
    /// <reference path="../common.ts" />
    /// <reference path="symbols.ts" />
    (function (parser) {
        var Item = (function () {
            function Item(pRule, iPos, pExpected) {
                this._pRule = pRule;
                this._iPos = iPos;
                this._iIndex = 0;
                this._pState = null;

                this._isNewExpected = true;
                this._iLength = 0;
                this._pExpected = {};

                if (arguments.length === 3) {
                    var pKeys = Object.getOwnPropertyNames(arguments[2]);

                    for (var i = 0; i < pKeys.length; i++) {
                        this.addExpected(pKeys[i]);
                    }
                }
            }
            Item.prototype.getRule = function () {
                return this._pRule;
            };

            Item.prototype.setRule = function (pRule) {
                this._pRule = pRule;
            };

            Item.prototype.getPosition = function () {
                return this._iPos;
            };

            Item.prototype.setPosition = function (iPos) {
                this._iPos = iPos;
            };

            Item.prototype.getState = function () {
                return this._pState;
            };

            Item.prototype.setState = function (pState) {
                this._pState = pState;
            };

            Item.prototype.getIndex = function () {
                return this._iIndex;
            };

            Item.prototype.setIndex = function (iIndex) {
                this._iIndex = iIndex;
            };

            Item.prototype.getIsNewExpected = function () {
                return this._isNewExpected;
            };

            Item.prototype.setIsNewExpected = function (_isNewExpected) {
                this._isNewExpected = _isNewExpected;
            };

            Item.prototype.getExpectedSymbols = function () {
                return this._pExpected;
            };

            Item.prototype.getLength = function () {
                return this._iLength;
            };

            Item.prototype.isEqual = function (pItem, eType) {
                if (typeof eType === "undefined") { eType = 0 /* k_LR0 */; }
                if (eType === 0 /* k_LR0 */) {
                    return (this._pRule === pItem.getRule() && this._iPos === pItem.getPosition());
                } else if (eType === 1 /* k_LR1 */) {
                    if (!(this._pRule === pItem.getRule() && this._iPos === pItem.getPosition() && this._iLength === pItem.getLength())) {
                        return false;
                    }
                    var i = "";
                    for (i in this._pExpected) {
                        if (!pItem.isExpected(i)) {
                            return false;
                        }
                    }
                    return true;
                } else {
                    //We never must be here, for LALR(1) we work with LR0 items. This 'else'-stmt onlu for closure-compliler.
                    return false;
                }
            };

            Item.prototype.isParentItem = function (pItem) {
                return (this._pRule === pItem.getRule() && this._iPos === pItem.getPosition() + 1);
            };

            Item.prototype.isChildItem = function (pItem) {
                return (this._pRule === pItem.getRule() && this._iPos === pItem.getPosition() - 1);
            };

            Item.prototype.mark = function () {
                var pRight = this._pRule.right;
                if (this._iPos === pRight.length) {
                    return parser.END_POSITION;
                }
                return pRight[this._iPos];
            };

            Item.prototype.end = function () {
                return this._pRule.right[this._pRule.right.length - 1] || parser.T_EMPTY;
            };

            Item.prototype.nextMarked = function () {
                return this._pRule.right[this._iPos + 1] || parser.END_POSITION;
            };

            Item.prototype.isExpected = function (sSymbol) {
                return !!(this._pExpected[sSymbol]);
            };

            Item.prototype.addExpected = function (sSymbol) {
                if (this._pExpected[sSymbol]) {
                    return false;
                }
                this._pExpected[sSymbol] = true;
                this._isNewExpected = true;
                this._iLength++;
                return true;
            };

            Item.prototype.toString = function () {
                var sMsg = this._pRule.left + " -> ";
                var sExpected = "";
                var pRight = this._pRule.right;

                for (var k = 0; k < pRight.length; k++) {
                    if (k === this._iPos) {
                        sMsg += ". ";
                    }
                    sMsg += pRight[k] + " ";
                }

                if (this._iPos === pRight.length) {
                    sMsg += ". ";
                }

                if (akra.isDef(this._pExpected)) {
                    sExpected = ", ";
                    var pKeys = Object.getOwnPropertyNames(this._pExpected);

                    for (var l = 0; l < pKeys.length; ++l) {
                        sExpected += pKeys[l] + "/";
                    }

                    if (sExpected !== ", ") {
                        sMsg += sExpected;
                    }
                }

                sMsg = sMsg.slice(0, sMsg.length - 1);
                return sMsg;
            };
            return Item;
        })();
        parser.Item = Item;
    })(akra.parser || (akra.parser = {}));
    var parser = akra.parser;
})(akra || (akra = {}));
/// <reference path="../idl/IMap.ts" />
/// <reference path="../idl/parser/IItem.ts" />
/// <reference path="../idl/parser/IState.ts" />
var akra;
(function (akra) {
    (function (parser) {
        var State = (function () {
            function State() {
                this._pItemList = [];
                this._pNextStates = {};
                this._iIndex = 0;
                this._nBaseItems = 0;
            }
            State.prototype.getIndex = function () {
                return this._iIndex;
            };

            State.prototype.setIndex = function (iIndex) {
                this._iIndex = iIndex;
            };

            State.prototype.getItems = function () {
                return this._pItemList;
            };

            State.prototype.getNumBaseItems = function () {
                return this._nBaseItems;
            };

            State.prototype.getNextStates = function () {
                return this._pNextStates;
            };

            State.prototype.hasItem = function (pItem, eType) {
                var i;
                var pItems = this._pItemList;
                for (i = 0; i < pItems.length; i++) {
                    if (pItems[i].isEqual(pItem, eType)) {
                        return pItems[i];
                    }
                }
                return null;
            };

            State.prototype.hasParentItem = function (pItem) {
                var i;
                var pItems = this._pItemList;
                for (i = 0; i < pItems.length; i++) {
                    if (pItems[i].isParentItem(pItem)) {
                        return pItems[i];
                    }
                }
                return null;
            };

            State.prototype.hasChildItem = function (pItem) {
                var i;
                var pItems = this._pItemList;
                for (i = 0; i < pItems.length; i++) {
                    if (pItems[i].isChildItem(pItem)) {
                        return pItems[i];
                    }
                }
                return null;
            };

            State.prototype.hasRule = function (pRule, iPos) {
                var i = 0;
                var pItemList = this._pItemList;
                var pItem;

                for (i = 0; i < this._nBaseItems; i++) {
                    pItem = pItemList[i];
                    if (pItem.getRule() === pRule && pItem.getPosition() === iPos) {
                        return true;
                    }
                }

                return false;
            };

            State.prototype.isEmpty = function () {
                return !(this._pItemList.length);
            };

            State.prototype.isEqual = function (pState, eType) {
                var pItemsA = this._pItemList;
                var pItemsB = pState.getItems();

                if (this._nBaseItems !== pState.getNumBaseItems()) {
                    return false;
                }
                var nItems = this._nBaseItems;
                var i, j;
                var isEqual;
                for (i = 0; i < nItems; i++) {
                    isEqual = false;
                    for (j = 0; j < nItems; j++) {
                        if (pItemsA[i].isEqual(pItemsB[j], eType)) {
                            isEqual = true;
                            break;
                        }
                    }
                    if (!isEqual) {
                        return false;
                    }
                }
                return true;
            };

            State.prototype.push = function (pItem) {
                if (this._pItemList.length === 0 || pItem.getPosition() > 0) {
                    this._nBaseItems += 1;
                }
                pItem.setState(this);
                this._pItemList.push(pItem);
            };

            State.prototype.tryPush_LR0 = function (pRule, iPos) {
                var i;
                var pItems = this._pItemList;
                for (i = 0; i < pItems.length; i++) {
                    if (pItems[i].getRule() === pRule && pItems[i].getPosition() === iPos) {
                        return false;
                    }
                }
                var pItem = new parser.Item(pRule, iPos);
                this.push(pItem);
                return true;
            };

            State.prototype.tryPush_LR = function (pRule, iPos, sExpectedSymbol) {
                var i;
                var pItems = (this._pItemList);

                for (i = 0; i < pItems.length; i++) {
                    if (pItems[i].getRule() === pRule && pItems[i].getPosition() === iPos) {
                        return pItems[i].addExpected(sExpectedSymbol);
                    }
                }

                var pExpected = {};
                pExpected[sExpectedSymbol] = true;

                var pItem = new parser.Item(pRule, iPos, pExpected);
                this.push(pItem);
                return true;
            };

            State.prototype.getNextStateBySymbol = function (sSymbol) {
                if (akra.isDef(this._pNextStates[sSymbol])) {
                    return this._pNextStates[sSymbol];
                } else {
                    return null;
                }
            };

            State.prototype.addNextState = function (sSymbol, pState) {
                if (akra.isDef(this._pNextStates[sSymbol])) {
                    return false;
                } else {
                    this._pNextStates[sSymbol] = pState;
                    return true;
                }
            };

            State.prototype.deleteNotBase = function () {
                this._pItemList.length = this._nBaseItems;
            };

            State.prototype.toString = function (isBase) {
                if (typeof isBase === "undefined") { isBase = true; }
                var len = 0;
                var sMsg;
                var pItemList = this._pItemList;

                sMsg = "State " + this._iIndex + ":\n";
                len = isBase ? this._nBaseItems : pItemList.length;

                for (var j = 0; j < len; j++) {
                    sMsg += "\t\t";
                    sMsg += pItemList[j].toString();
                    sMsg += "\n";
                }

                return sMsg;
            };
            return State;
        })();
        parser.State = State;
    })(akra.parser || (akra.parser = {}));
    var parser = akra.parser;
})(akra || (akra = {}));
/// <reference path="../idl/parser/IParser.ts" />
/// <reference path="../idl/IMap.ts" />
/// <reference path="../bf/bf.ts" />
/// <reference path="../logger.ts" />
var akra;
(function (akra) {
    /// <reference path="Lexer.ts" />
    /// <reference path="ParseTree.ts" />
    /// <reference path="Item.ts" />
    /// <reference path="State.ts" />
    /// <reference path="symbols.ts" />
    (function (parser) {
        var PARSER_GRAMMAR_ADD_OPERATION = 2001;
        var PARSER_GRAMMAR_ADD_STATE_LINK = 2002;
        var PARSER_GRAMMAR_UNEXPECTED_SYMBOL = 2003;
        var PARSER_GRAMMAR_BAD_ADDITIONAL_FUNC_NAME = 2004;
        var PARSER_GRAMMAR_BAD_KEYWORD = 2005;
        var PARSER_SYNTAX_ERROR = 2051;

        akra.logger.registerCode(PARSER_GRAMMAR_ADD_OPERATION, "Grammar not LALR(1)! Cannot to generate syntax table. Add operation error.\n" + "Conflict in state with index: {stateIndex}. With grammar symbol: \"{grammarSymbol}\"\n" + "Old operation: {oldOperation}\n" + "New operation: {newOperation}\n" + "For more info init parser in debug-mode and see syntax table and list of states.");

        akra.logger.registerCode(PARSER_GRAMMAR_ADD_STATE_LINK, "Grammar not LALR(1)! Cannot to generate syntax table. Add state link error.\n" + "Conflict in state with index: {stateIndex}. With grammar symbol: \"{grammarSymbol}\"\n" + "Old next state: {oldNextStateIndex}\n" + "New next state: {newNextStateIndex}\n" + "For more info init parser in debug-mode and see syntax table and list of states.");

        akra.logger.registerCode(PARSER_GRAMMAR_UNEXPECTED_SYMBOL, "Grammar error. Can`t generate rules from grammar\n" + "Unexpected symbol: {unexpectedSymbol}\n" + "Expected: {expectedSymbol}");

        akra.logger.registerCode(PARSER_GRAMMAR_BAD_ADDITIONAL_FUNC_NAME, "Grammar error. Empty additional function name.");
        akra.logger.registerCode(PARSER_GRAMMAR_BAD_KEYWORD, "Grammar error. Bad keyword: {badKeyword}\n" + "All keyword must be define in lexer rule block.");

        akra.logger.registerCode(PARSER_SYNTAX_ERROR, "Syntax error during parsing. Token: {tokenValue}\n" + "Line: {line}. Column: {column}.");

        function sourceLocationToString(pLocation) {
            var sLocation = "[" + pLocation.file + ":" + pLocation.line.toString() + "]: ";
            return sLocation;
        }

        function syntaxErrorLogRoutine(pLogEntity) {
            var sPosition = sourceLocationToString(pLogEntity.location);
            var sError = "Code: " + pLogEntity.code.toString() + ". ";
            var pParseMessage = pLogEntity.message.split(/\{(\w+)\}/);
            var pInfo = pLogEntity.info;

            for (var i = 0; i < pParseMessage.length; i++) {
                if (akra.isDef(pInfo[pParseMessage[i]])) {
                    pParseMessage[i] = pInfo[pParseMessage[i]];
                }
            }

            var sMessage = sPosition + sError + pParseMessage.join("");

            console.error.call(console, sMessage);
        }

        akra.logger.setCodeFamilyRoutine("ParserSyntaxErrors", syntaxErrorLogRoutine, 8 /* ERROR */);

        var Parser = (function () {
            function Parser() {
                this._sSource = "";
                this._iIndex = 0;

                this._pSyntaxTree = null;
                this._pTypeIdMap = null;

                this._pLexer = null;
                this._pStack = [];
                this._pToken = null;

                this._fnFinishCallback = null;
                this._pCaller = null;

                this._pSymbolMap = { END_SYMBOL: true };
                this._pSyntaxTable = null;
                this._pReduceOperationsMap = null;
                this._pShiftOperationsMap = null;
                this._pSuccessOperation = null;

                this._pFirstTerminalsDMap = null;
                this._pFollowTerminalsDMap = null;
                this._pRulesDMap = null;
                this._pStateList = null;
                this._nRules = 0;
                this._pAdditionalFuncInfoList = null;
                this._pAdditionalFunctionsMap = null;
                this._pAdidtionalFunctByStateDMap = null;

                this._eType = 0 /* k_LR0 */;

                this._pRuleCreationModeMap = null;
                this._eParseMode = 1 /* k_AllNode */;

                // this._isSync = false;
                this._pStatesTempMap = null;
                this._pBaseItemList = null;

                this._pExpectedExtensionDMap = null;

                this._sFileName = "stdin";
            }
            Parser.prototype.isTypeId = function (sValue) {
                return !!(this._pTypeIdMap[sValue]);
            };

            Parser.prototype.returnCode = function (pNode) {
                if (pNode) {
                    if (pNode.value) {
                        return pNode.value + " ";
                    } else if (pNode.children) {
                        var sCode = "";
                        var i = 0;
                        for (i = pNode.children.length - 1; i >= 0; i--) {
                            sCode += this.returnCode(pNode.children[i]);
                        }
                        return sCode;
                    }
                }
                return "";
            };

            Parser.prototype.init = function (sGrammar, eMode, eType) {
                if (typeof eMode === "undefined") { eMode = 1 /* k_AllNode */; }
                if (typeof eType === "undefined") { eType = 2 /* k_LALR */; }
                try  {
                    this._eType = eType;
                    this._pLexer = new parser.Lexer(this);
                    this._eParseMode = eMode;
                    this.generateRules(sGrammar);
                    this.buildSyntaxTable();
                    this.generateFunctionByStateMap();
                    if (!akra.bf.testAll(eMode, 16 /* k_DebugMode */)) {
                        this.clearMem();
                    }
                    return true;
                } catch (e) {
                    akra.logger.log(e.stack);

                    // error("Could`not initialize parser. Error with code has occurred: " + e.message + ". See log for more info.");
                    return false;
                }
            };

            Parser.prototype.parse = function (sSource, fnFinishCallback, pCaller) {
                if (typeof fnFinishCallback === "undefined") { fnFinishCallback = null; }
                if (typeof pCaller === "undefined") { pCaller = null; }
                try  {
                    this.defaultInit();
                    this._sSource = sSource;
                    this._pLexer._init(sSource);

                    //this._isSync = isSync;
                    this._fnFinishCallback = fnFinishCallback;
                    this._pCaller = pCaller;

                    var pTree = this._pSyntaxTree;
                    var pStack = this._pStack;
                    var pSyntaxTable = this._pSyntaxTable;

                    var isStop = false;
                    var isError = false;
                    var isPause = false;
                    var pToken = this.readToken();

                    var pOperation;
                    var iRuleLength;

                    var eAdditionalOperationCode;
                    var iStateIndex = 0;

                    while (!isStop) {
                        pOperation = pSyntaxTable[pStack[pStack.length - 1]][pToken.name];
                        if (akra.isDef(pOperation)) {
                            switch (pOperation.type) {
                                case 103 /* k_Success */:
                                    isStop = true;
                                    break;

                                case 101 /* k_Shift */:
                                    iStateIndex = pOperation.index;
                                    pStack.push(iStateIndex);
                                    pTree.addToken(pToken);

                                    eAdditionalOperationCode = this.operationAdditionalAction(iStateIndex, pToken.name);

                                    if (eAdditionalOperationCode === 100 /* k_Error */) {
                                        isError = true;
                                        isStop = true;
                                    } else if (eAdditionalOperationCode === 104 /* k_Pause */) {
                                        this._pToken = null;
                                        isStop = true;
                                        isPause = true;
                                    } else if (eAdditionalOperationCode === 105 /* k_Ok */) {
                                        pToken = this.readToken();
                                    }

                                    break;

                                case 102 /* k_Reduce */:
                                    iRuleLength = pOperation.rule.right.length;
                                    pStack.length -= iRuleLength;
                                    iStateIndex = pSyntaxTable[pStack[pStack.length - 1]][pOperation.rule.left].index;
                                    pStack.push(iStateIndex);
                                    pTree.reduceByRule(pOperation.rule, this._pRuleCreationModeMap[pOperation.rule.left]);

                                    eAdditionalOperationCode = this.operationAdditionalAction(iStateIndex, pOperation.rule.left);

                                    if (eAdditionalOperationCode === 100 /* k_Error */) {
                                        isError = true;
                                        isStop = true;
                                    } else if (eAdditionalOperationCode === 104 /* k_Pause */) {
                                        this._pToken = pToken;
                                        isStop = true;
                                        isPause = true;
                                    }

                                    break;
                            }
                        } else {
                            isError = true;
                            isStop = true;
                        }
                    }
                } catch (e) {
                    // debug_print(e.stack);
                    this._sFileName = "stdin";
                    return 2 /* k_Error */;
                }

                if (isPause) {
                    return 0 /* k_Pause */;
                }

                if (!isError) {
                    pTree.finishTree();
                    if (!akra.isNull(this._fnFinishCallback)) {
                        this._fnFinishCallback.call(this._pCaller, 1 /* k_Ok */, this.getParseFileName());
                    }
                    this._sFileName = "stdin";
                    return 1 /* k_Ok */;
                } else {
                    this._error(PARSER_SYNTAX_ERROR, pToken);
                    if (!akra.isNull(this._fnFinishCallback)) {
                        this._fnFinishCallback.call(this._pCaller, 2 /* k_Error */, this.getParseFileName());
                    }
                    this._sFileName = "stdin";
                    return 2 /* k_Error */;
                }
            };

            Parser.prototype.setParseFileName = function (sFileName) {
                this._sFileName = sFileName;
            };

            Parser.prototype.getParseFileName = function () {
                return this._sFileName;
            };

            Parser.prototype.pause = function () {
                return 0 /* k_Pause */;
            };

            Parser.prototype.resume = function () {
                return this.resumeParse();
            };

            Parser.prototype.printStates = function (isBaseOnly) {
                if (typeof isBaseOnly === "undefined") { isBaseOnly = true; }
                if (!akra.isDef(this._pStateList)) {
                    akra.logger.log("It`s impossible to print states. You must init parser in debug-mode");
                    return;
                }
                var sMsg = "\n" + this.statesToString(isBaseOnly);
                akra.logger.log(sMsg);
            };

            Parser.prototype.printState = function (iStateIndex, isBaseOnly) {
                if (typeof isBaseOnly === "undefined") { isBaseOnly = true; }
                if (!akra.isDef(this._pStateList)) {
                    akra.logger.log("It`s impossible to print states. You must init parser in debug-mode");
                    return;
                }

                var pState = this._pStateList[iStateIndex];
                if (!akra.isDef(pState)) {
                    akra.logger.log("Can not print stete with index: " + iStateIndex.toString());
                    return;
                }

                var sMsg = "\n" + pState.toString(isBaseOnly);
                akra.logger.log(sMsg);
            };

            Parser.prototype.getGrammarSymbols = function () {
                return this._pGrammarSymbols;
            };

            Parser.prototype.getSyntaxTree = function () {
                return this._pSyntaxTree;
            };

            Parser.prototype._saveState = function () {
                return {
                    source: this._sSource,
                    index: this._pLexer._getIndex(),
                    fileName: this._sFileName,
                    tree: this._pSyntaxTree,
                    types: this._pTypeIdMap,
                    stack: this._pStack,
                    token: this._pToken,
                    fnCallback: this._fnFinishCallback,
                    caller: this._pCaller
                };
            };

            Parser.prototype._loadState = function (pState) {
                this._sSource = pState.source;
                this._iIndex = pState.index;
                this._sFileName = pState.fileName;
                this._pSyntaxTree = pState.tree;
                this._pTypeIdMap = pState.types;
                this._pStack = pState.stack;
                this._pToken = pState.token;
                this._fnFinishCallback = pState.fnCallback;
                this._pCaller = pState.caller;

                this._pLexer._setSource(pState.source);
                this._pLexer._setIndex(pState.index);
            };

            Parser.prototype.addAdditionalFunction = function (sFuncName, fnRuleFunction) {
                if (akra.isNull(this._pAdditionalFunctionsMap)) {
                    this._pAdditionalFunctionsMap = {};
                }
                this._pAdditionalFunctionsMap[sFuncName] = fnRuleFunction;
            };

            Parser.prototype.addTypeId = function (sIdentifier) {
                if (akra.isNull(this._pTypeIdMap)) {
                    this._pTypeIdMap = {};
                }
                this._pTypeIdMap[sIdentifier] = true;
            };

            Parser.prototype.defaultInit = function () {
                this._iIndex = 0;
                this._pStack = [0];
                this._pSyntaxTree = new parser.ParseTree();
                this._pTypeIdMap = {};

                this._pSyntaxTree.setOptimizeMode(akra.bf.testAll(this._eParseMode, 8 /* k_Optimize */));
            };

            Parser.prototype._error = function (eCode, pErrorInfo) {
                var pLocation = {};

                var pInfo = {
                    tokenValue: null,
                    line: null,
                    column: null,
                    stateIndex: null,
                    oldNextStateIndex: null,
                    newNextStateIndex: null,
                    grammarSymbol: null,
                    newOperation: null,
                    oldOperation: null,
                    expectedSymbol: null,
                    unexpectedSymbol: null,
                    badKeyword: null
                };

                var pLogEntity = { code: eCode, info: pInfo, location: pLocation };

                var pToken;
                var iLine;
                var iColumn;
                var iStateIndex;
                var sSymbol;
                var pOldOperation;
                var pNewOperation;
                var iOldNextStateIndex;
                var iNewNextStateIndex;
                var sExpectedSymbol;
                var sUnexpectedSymbol;
                var sBadKeyword;

                if (eCode === PARSER_SYNTAX_ERROR) {
                    pToken = pErrorInfo;
                    iLine = pToken.line;
                    iColumn = pToken.start;

                    pInfo.tokenValue = pToken.value;
                    pInfo.line = iLine;
                    pInfo.column = iColumn;

                    pLocation.file = this.getParseFileName();
                    pLocation.line = iLine;
                } else if (eCode === PARSER_GRAMMAR_ADD_OPERATION) {
                    iStateIndex = pErrorInfo.stateIndex;
                    sSymbol = pErrorInfo.grammarSymbol;
                    pOldOperation = pErrorInfo.oldOperation;
                    pNewOperation = pErrorInfo.newOperation;

                    pInfo.stateIndex = iStateIndex;
                    pInfo.grammarSymbol = sSymbol;
                    pInfo.oldOperation = this.operationToString(pOldOperation);
                    pInfo.newOperation = this.operationToString(pNewOperation);

                    pLocation.file = "GRAMMAR";
                    pLocation.line = 0;
                } else if (eCode === PARSER_GRAMMAR_ADD_STATE_LINK) {
                    iStateIndex = pErrorInfo.stateIndex;
                    sSymbol = pErrorInfo.grammarSymbol;
                    iOldNextStateIndex = pErrorInfo.oldNextStateIndex;
                    iNewNextStateIndex = pErrorInfo.newNextStateIndex;

                    pInfo.stateIndex = iStateIndex;
                    pInfo.grammarSymbol = sSymbol;
                    pInfo.oldNextStateIndex = iOldNextStateIndex;
                    pInfo.newNextStateIndex = iNewNextStateIndex;

                    pLocation.file = "GRAMMAR";
                    pLocation.line = 0;
                } else if (eCode === PARSER_GRAMMAR_UNEXPECTED_SYMBOL) {
                    iLine = pErrorInfo.grammarLine;
                    sExpectedSymbol = pErrorInfo.expectedSymbol;
                    sUnexpectedSymbol = pErrorInfo.unexpectedSymbol;

                    pInfo.expectedSymbol = sExpectedSymbol;
                    pInfo.unexpectedSymbol = sExpectedSymbol;

                    pLocation.file = "GRAMMAR";
                    pLocation.line = iLine || 0;
                } else if (eCode === PARSER_GRAMMAR_BAD_ADDITIONAL_FUNC_NAME) {
                    iLine = pErrorInfo.grammarLine;

                    pLocation.file = "GRAMMAR";
                    pLocation.line = iLine || 0;
                } else if (eCode === PARSER_GRAMMAR_BAD_KEYWORD) {
                    iLine = pErrorInfo.grammarLine;
                    sBadKeyword = pErrorInfo.badKeyword;

                    pInfo.badKeyword = sBadKeyword;

                    pLocation.file = "GRAMMAR";
                    pLocation.line = iLine || 0;
                }

                akra.logger.error(pLogEntity);

                throw new Error(eCode.toString());
            };

            Parser.prototype.clearMem = function () {
                delete this._pFirstTerminalsDMap;
                delete this._pFollowTerminalsDMap;
                delete this._pRulesDMap;
                delete this._pStateList;
                delete this._pReduceOperationsMap;
                delete this._pShiftOperationsMap;
                delete this._pSuccessOperation;
                delete this._pStatesTempMap;
                delete this._pBaseItemList;
                delete this._pExpectedExtensionDMap;
            };

            Parser.prototype.hasState = function (pState, eType) {
                var pStateList = this._pStateList;
                var i = 0;

                for (i = 0; i < pStateList.length; i++) {
                    if (pStateList[i].isEqual(pState, eType)) {
                        return pStateList[i];
                    }
                }

                return null;
            };

            Parser.prototype.isTerminal = function (sSymbol) {
                return !(this._pRulesDMap[sSymbol]);
            };

            Parser.prototype.pushState = function (pState) {
                pState.setIndex(this._pStateList.length);
                this._pStateList.push(pState);
            };

            Parser.prototype.pushBaseItem = function (pItem) {
                pItem.setIndex(this._pBaseItemList.length);
                this._pBaseItemList.push(pItem);
            };

            Parser.prototype.tryAddState = function (pState, eType) {
                var pRes = this.hasState(pState, eType);

                if (akra.isNull(pRes)) {
                    if (eType === 0 /* k_LR0 */) {
                        var pItems = pState.getItems();
                        for (var i = 0; i < pItems.length; i++) {
                            this.pushBaseItem(pItems[i]);
                        }
                    }

                    this.pushState(pState);
                    this.closure(pState, eType);

                    return pState;
                }

                return pRes;
            };

            Parser.prototype.hasEmptyRule = function (sSymbol) {
                if (this.isTerminal(sSymbol)) {
                    return false;
                }

                var pRulesDMap = this._pRulesDMap;
                for (var i in pRulesDMap[sSymbol]) {
                    if (pRulesDMap[sSymbol][i].right.length === 0) {
                        return true;
                    }
                }

                return false;
            };

            Parser.prototype.pushInSyntaxTable = function (iIndex, sSymbol, pOperation) {
                var pSyntaxTable = this._pSyntaxTable;
                if (!pSyntaxTable[iIndex]) {
                    pSyntaxTable[iIndex] = {};
                }
                if (akra.isDef(pSyntaxTable[iIndex][sSymbol])) {
                    this._error(PARSER_GRAMMAR_ADD_OPERATION, {
                        stateIndex: iIndex,
                        grammarSymbol: this.convertGrammarSymbol(sSymbol),
                        oldOperation: this._pSyntaxTable[iIndex][sSymbol],
                        newOperation: pOperation
                    });
                }
                pSyntaxTable[iIndex][sSymbol] = pOperation;
            };

            Parser.prototype.addStateLink = function (pState, pNextState, sSymbol) {
                var isAddState = pState.addNextState(sSymbol, pNextState);
                if (!isAddState) {
                    this._error(PARSER_GRAMMAR_ADD_STATE_LINK, {
                        stateIndex: pState.getIndex(),
                        oldNextStateIndex: pState.getNextStateBySymbol(sSymbol),
                        newNextStateIndex: pNextState.getIndex(),
                        grammarSymbol: this.convertGrammarSymbol(sSymbol)
                    });
                }
            };

            Parser.prototype.firstTerminal = function (sSymbol) {
                if (this.isTerminal(sSymbol)) {
                    return null;
                }

                if (akra.isDef(this._pFirstTerminalsDMap[sSymbol])) {
                    return this._pFirstTerminalsDMap[sSymbol];
                }

                var sRule, sName;
                var pNames;
                var i = 0, j = 0, k = 0;
                var pRulesMap = this._pRulesDMap[sSymbol];

                var pTempRes = {};
                var pRes;

                var pRight;
                var isFinish;

                pRes = this._pFirstTerminalsDMap[sSymbol] = {};

                if (this.hasEmptyRule(sSymbol)) {
                    pRes[parser.T_EMPTY] = true;
                }

                if (akra.isNull(pRulesMap)) {
                    return pRes;
                }

                var pRuleNames = Object.keys(pRulesMap);

                for (i = 0; i < pRuleNames.length; ++i) {
                    sRule = pRuleNames[i];

                    isFinish = false;
                    pRight = pRulesMap[sRule].right;

                    for (j = 0; j < pRight.length; j++) {
                        if (pRight[j] === sSymbol) {
                            if (pRes[parser.T_EMPTY]) {
                                continue;
                            }

                            isFinish = true;
                            break;
                        }

                        pTempRes = this.firstTerminal(pRight[j]);

                        if (akra.isNull(pTempRes)) {
                            pRes[pRight[j]] = true;
                        } else {
                            for (pNames = Object.keys(pTempRes), k = 0; k < pNames.length; ++k) {
                                sName = pNames[k];
                                pRes[sName] = true;
                            }
                        }

                        if (!this.hasEmptyRule(pRight[j])) {
                            isFinish = true;
                            break;
                        }
                    }

                    if (!isFinish) {
                        pRes[parser.T_EMPTY] = true;
                    }
                }

                return pRes;
            };

            Parser.prototype.followTerminal = function (sSymbol) {
                if (akra.isDef(this._pFollowTerminalsDMap[sSymbol])) {
                    return this._pFollowTerminalsDMap[sSymbol];
                }

                var i = 0, j = 0, k = 0, l = 0, m = 0;
                var pRulesDMap = this._pRulesDMap;
                var pRulesDMapKeys, pRulesMapKeys;

                var pRule;
                var pTempRes;
                var pTempKeys;
                var pRes;

                var pRight;
                var isFinish;

                var sFirstKey;
                var sSecondKey;

                pRes = this._pFollowTerminalsDMap[sSymbol] = {};

                if (akra.isNull(pRulesDMap)) {
                    return pRes;
                }

                pRulesDMapKeys = Object.keys(pRulesDMap);
                for (i = 0; i < pRulesDMapKeys.length; i++) {
                    sFirstKey = pRulesDMapKeys[i];

                    if (akra.isNull(pRulesDMap[sFirstKey])) {
                        continue;
                    }

                    pRulesMapKeys = Object.keys(pRulesDMap[sFirstKey]);

                    for (j = 0; j < pRulesMapKeys.length; j++) {
                        pRule = pRulesDMap[sFirstKey][sSecondKey];
                        pRight = pRule.right;

                        for (k = 0; k < pRight.length; k++) {
                            if (pRight[k] === sSymbol) {
                                if (k === pRight.length - 1) {
                                    pTempRes = this.followTerminal(pRule.left);

                                    pTempKeys = Object.keys(pTempRes);
                                    for (m = 0; m < pTempKeys.length; i++) {
                                        pRes[pTempKeys[m]] = true;
                                    }
                                } else {
                                    isFinish = false;

                                    for (l = k + 1; l < pRight.length; l++) {
                                        pTempRes = this.firstTerminal(pRight[l]);

                                        if (akra.isNull(pTempRes)) {
                                            pRes[pRight[l]] = true;
                                            isFinish = true;
                                            break;
                                        } else {
                                            pTempKeys = Object.keys(pTempRes);
                                            for (m = 0; m < pTempKeys.length; i++) {
                                                pRes[pTempKeys[m]] = true;
                                            }
                                        }

                                        if (!pTempRes[parser.T_EMPTY]) {
                                            isFinish = true;
                                            break;
                                        }
                                    }

                                    if (!isFinish) {
                                        pTempRes = this.followTerminal(pRule.left);

                                        pTempKeys = Object.keys(pTempRes);
                                        for (m = 0; m < pTempKeys.length; i++) {
                                            pRes[pTempKeys[m]] = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                return pRes;
            };

            Parser.prototype.firstTerminalForSet = function (pSet, pExpected) {
                var i = 0, j = 0;

                var pTempRes;
                var pRes = {};

                var isEmpty;

                var pKeys;
                var sKey;

                for (i = 0; i < pSet.length; i++) {
                    pTempRes = this.firstTerminal(pSet[i]);

                    if (akra.isNull(pTempRes)) {
                        pRes[pSet[i]] = true;

                        return pRes;
                    }

                    isEmpty = false;

                    pKeys = Object.keys(pTempRes);

                    for (j = 0; j < pKeys.length; j++) {
                        sKey = pKeys[j];

                        if (sKey === parser.T_EMPTY) {
                            isEmpty = true;
                            continue;
                        }
                        pRes[sKey] = true;
                    }

                    if (!isEmpty) {
                        return pRes;
                    }
                }

                if (!akra.isNull(pExpected)) {
                    pKeys = Object.keys(pExpected);
                    for (j = 0; j < pKeys.length; j++) {
                        pRes[pKeys[j]] = true;
                    }
                }

                return pRes;
            };

            Parser.prototype.generateRules = function (sGrammarSource) {
                var pAllRuleList = sGrammarSource.split(/\r?\n/);
                var pTempRule;
                var pRule;
                var isLexerBlock = false;

                this._pRulesDMap = {};
                this._pAdditionalFuncInfoList = [];
                this._pRuleCreationModeMap = {};
                this._pGrammarSymbols = {};

                var i = 0, j = 0;

                var isAllNodeMode = akra.bf.testAll(this._eParseMode, 1 /* k_AllNode */);
                var isNegateMode = akra.bf.testAll(this._eParseMode, 2 /* k_Negate */);
                var isAddMode = akra.bf.testAll(this._eParseMode, 4 /* k_Add */);

                var pSymbolsWithNodeMap = this._pRuleCreationModeMap;

                var sName;

                for (i = 0; i < pAllRuleList.length; i++) {
                    if (pAllRuleList[i] === "" || pAllRuleList[i] === "\r") {
                        continue;
                    }

                    pTempRule = pAllRuleList[i].split(/\s* \s*/);

                    if (isLexerBlock) {
                        if ((pTempRule.length === 3 || (pTempRule.length === 4 && pTempRule[3] === "")) && ((pTempRule[2][0] === "\"" || pTempRule[2][0] === "'") && pTempRule[2].length > 3)) {
                            //TERMINALS
                            if (pTempRule[2][0] !== pTempRule[2][pTempRule[2].length - 1]) {
                                this._error(PARSER_GRAMMAR_UNEXPECTED_SYMBOL, {
                                    unexpectedSymbol: pTempRule[2][pTempRule[2].length - 1],
                                    expectedSymbol: pTempRule[2][0],
                                    grammarLine: i
                                });
                            }

                            pTempRule[2] = pTempRule[2].slice(1, pTempRule[2].length - 1);

                            var ch = pTempRule[2][0];

                            if ((ch === "_") || (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z")) {
                                sName = this._pLexer._addKeyword(pTempRule[2], pTempRule[0]);
                            } else {
                                sName = this._pLexer._addPunctuator(pTempRule[2], pTempRule[0]);
                            }

                            this._pGrammarSymbols[sName] = pTempRule[2];
                        }

                        continue;
                    }

                    if (pTempRule[0] === parser.LEXER_RULES) {
                        isLexerBlock = true;
                        continue;
                    }

                    //NON TERMNINAL RULES
                    if (akra.isDef(this._pRulesDMap[pTempRule[0]]) === false) {
                        this._pRulesDMap[pTempRule[0]] = {};
                    }

                    pRule = {
                        left: pTempRule[0],
                        right: [],
                        index: 0
                    };
                    this._pSymbolMap[pTempRule[0]] = true;
                    this._pGrammarSymbols[pTempRule[0]] = pTempRule[0];

                    if (isAllNodeMode) {
                        pSymbolsWithNodeMap[pTempRule[0]] = 0 /* k_Default */;
                    } else if (isNegateMode && !akra.isDef(pSymbolsWithNodeMap[pTempRule[0]])) {
                        pSymbolsWithNodeMap[pTempRule[0]] = 0 /* k_Default */;
                    } else if (isAddMode && !akra.isDef(pSymbolsWithNodeMap[pTempRule[0]])) {
                        pSymbolsWithNodeMap[pTempRule[0]] = 2 /* k_Not */;
                    }

                    for (j = 2; j < pTempRule.length; j++) {
                        if (pTempRule[j] === "") {
                            continue;
                        }
                        if (pTempRule[j] === parser.FLAG_RULE_CREATE_NODE) {
                            if (isAddMode) {
                                pSymbolsWithNodeMap[pTempRule[0]] = 1 /* k_Necessary */;
                            }
                            continue;
                        }
                        if (pTempRule[j] === parser.FLAG_RULE_NOT_CREATE_NODE) {
                            if (isNegateMode && !isAllNodeMode) {
                                pSymbolsWithNodeMap[pTempRule[0]] = 2 /* k_Not */;
                            }
                            continue;
                        }
                        if (pTempRule[j] === parser.FLAG_RULE_FUNCTION) {
                            if ((!pTempRule[j + 1] || pTempRule[j + 1].length === 0)) {
                                this._error(PARSER_GRAMMAR_BAD_ADDITIONAL_FUNC_NAME, { grammarLine: i });
                            }

                            var pFuncInfo = {
                                name: pTempRule[j + 1],
                                position: pRule.right.length,
                                rule: pRule
                            };
                            this._pAdditionalFuncInfoList.push(pFuncInfo);
                            j++;
                            continue;
                        }
                        if (pTempRule[j][0] === "'" || pTempRule[j][0] === "\"") {
                            if (pTempRule[j].length !== 3) {
                                this._error(PARSER_GRAMMAR_BAD_KEYWORD, {
                                    badKeyword: pTempRule[j],
                                    grammarLine: i
                                });
                            }
                            if (pTempRule[j][0] !== pTempRule[j][2]) {
                                this._error(PARSER_GRAMMAR_UNEXPECTED_SYMBOL, {
                                    unexpectedSymbol: pTempRule[j][2],
                                    expectedSymbol: pTempRule[j][0],
                                    grammarLine: i
                                });
                                //this._error("Can`t generate rules from grammar! Unexpected symbol! Must be");
                            }

                            sName = this._pLexer._addPunctuator(pTempRule[j][1]);
                            pRule.right.push(sName);
                            this._pSymbolMap[sName] = true;
                        } else {
                            pRule.right.push(pTempRule[j]);
                            this._pSymbolMap[pTempRule[j]] = true;
                        }
                    }

                    pRule.index = this._nRules;
                    this._pRulesDMap[pTempRule[0]][pRule.index] = pRule;
                    this._nRules += 1;
                }
            };

            Parser.prototype.generateFunctionByStateMap = function () {
                if (akra.isNull(this._pAdditionalFunctionsMap)) {
                    return;
                }

                var pStateList = this._pStateList;
                var pFuncInfoList = this._pAdditionalFuncInfoList;
                var pFuncInfo;
                var pRule;
                var iPos = 0;
                var pFunc;
                var sGrammarSymbol;

                var i = 0, j = 0;

                var pFuncByStateDMap = {};
                pFuncByStateDMap = this._pAdidtionalFunctByStateDMap = {};

                for (i = 0; i < pFuncInfoList.length; i++) {
                    pFuncInfo = pFuncInfoList[i];

                    pFunc = this._pAdditionalFunctionsMap[pFuncInfo.name];
                    if (!akra.isDef(pFunc)) {
                        continue;
                    }

                    pRule = pFuncInfo.rule;
                    iPos = pFuncInfo.position;
                    sGrammarSymbol = pRule.right[iPos - 1];

                    for (j = 0; j < pStateList.length; j++) {
                        if (pStateList[j].hasRule(pRule, iPos)) {
                            if (!akra.isDef(pFuncByStateDMap[pStateList[j].getIndex()])) {
                                pFuncByStateDMap[pStateList[j].getIndex()] = {};
                            }

                            pFuncByStateDMap[pStateList[j].getIndex()][sGrammarSymbol] = pFunc;
                        }
                    }
                }
            };

            Parser.prototype.generateFirstState = function (eType) {
                if (eType === 0 /* k_LR0 */) {
                    this.generateFirstState_LR0();
                } else {
                    this.generateFirstState_LR();
                }
            };

            Parser.prototype.generateFirstState_LR0 = function () {
                var pState = new parser.State();
                var pItem = new parser.Item(this._pRulesDMap[parser.START_SYMBOL][0], 0);

                this.pushBaseItem(pItem);
                pState.push(pItem);

                this.closure_LR0(pState);
                this.pushState(pState);
            };

            Parser.prototype.generateFirstState_LR = function () {
                var pState = new parser.State();
                var pExpected = {};
                pExpected[parser.END_SYMBOL] = true;

                pState.push(new parser.Item(this._pRulesDMap[parser.START_SYMBOL][0], 0, pExpected));

                this.closure_LR(pState);
                this.pushState(pState);
            };

            Parser.prototype.closure = function (pState, eType) {
                if (eType === 0 /* k_LR0 */) {
                    return this.closure_LR0(pState);
                } else {
                    return this.closure_LR(pState);
                }
            };

            Parser.prototype.closure_LR0 = function (pState) {
                var pItemList = pState.getItems();
                var i = 0, j = 0;
                var sSymbol;
                var pKeys;

                for (i = 0; i < pItemList.length; i++) {
                    sSymbol = pItemList[i].mark();

                    if (sSymbol !== parser.END_POSITION && (!this.isTerminal(sSymbol))) {
                        pKeys = Object.keys(this._pRulesDMap[sSymbol]);
                        for (j = 0; j < pKeys.length; j++) {
                            pState.tryPush_LR0(this._pRulesDMap[sSymbol][pKeys[j]], 0);
                        }
                    }
                }
                return pState;
            };

            Parser.prototype.closure_LR = function (pState) {
                var pItemList = (pState.getItems());
                var i = 0, j = 0, k = 0;
                var sSymbol;
                var pSymbols;
                var pTempSet;
                var isNewExpected = false;

                var pRulesMapKeys, pSymbolsKeys;

                while (true) {
                    if (i === pItemList.length) {
                        if (!isNewExpected) {
                            break;
                        }
                        i = 0;
                        isNewExpected = false;
                    }
                    sSymbol = pItemList[i].mark();

                    if (sSymbol !== parser.END_POSITION && (!this.isTerminal(sSymbol))) {
                        pTempSet = pItemList[i].getRule().right.slice(pItemList[i].getPosition() + 1);
                        pSymbols = this.firstTerminalForSet(pTempSet, pItemList[i].getExpectedSymbols());

                        pRulesMapKeys = Object.keys(this._pRulesDMap[sSymbol]);
                        pSymbolsKeys = Object.keys(pSymbols);

                        for (j = 0; j < pRulesMapKeys.length; j++) {
                            for (k = 0; k < pSymbolsKeys.length; k++) {
                                if (pState.tryPush_LR(this._pRulesDMap[sSymbol][pRulesMapKeys[j]], 0, pSymbolsKeys[k])) {
                                    isNewExpected = true;
                                }
                            }
                        }
                    }

                    i++;
                }

                return pState;
            };

            Parser.prototype.nexeState = function (pState, sSymbol, eType) {
                if (eType === 0 /* k_LR0 */) {
                    return this.nextState_LR0(pState, sSymbol);
                } else {
                    return this.nextState_LR(pState, sSymbol);
                }
            };

            Parser.prototype.nextState_LR0 = function (pState, sSymbol) {
                var pItemList = pState.getItems();
                var i = 0;
                var pNewState = new parser.State();

                for (i = 0; i < pItemList.length; i++) {
                    if (sSymbol === pItemList[i].mark()) {
                        pNewState.push(new parser.Item(pItemList[i].getRule(), pItemList[i].getPosition() + 1));
                    }
                }

                return pNewState;
            };

            Parser.prototype.nextState_LR = function (pState, sSymbol) {
                var pItemList = pState.getItems();
                var i = 0;
                var pNewState = new parser.State();

                for (i = 0; i < pItemList.length; i++) {
                    if (sSymbol === pItemList[i].mark()) {
                        pNewState.push(new parser.Item(pItemList[i].getRule(), pItemList[i].getPosition() + 1, pItemList[i].getExpectedSymbols()));
                    }
                }

                return pNewState;
            };

            Parser.prototype.deleteNotBaseItems = function () {
                var i = 0;
                for (i = 0; i < this._pStateList.length; i++) {
                    this._pStateList[i].deleteNotBase();
                }
            };

            Parser.prototype.closureForItem = function (pRule, iPos) {
                var sIndex = "";
                sIndex += pRule.index + "_" + iPos;

                var pState = this._pStatesTempMap[sIndex];
                if (akra.isDef(pState)) {
                    return pState;
                } else {
                    var pExpected = {};
                    pExpected[parser.UNUSED_SYMBOL] = true;

                    pState = new parser.State();
                    pState.push(new parser.Item(pRule, iPos, pExpected));

                    this.closure_LR(pState);
                    this._pStatesTempMap[sIndex] = pState;

                    return pState;
                }
            };

            Parser.prototype.addLinkExpected = function (pItem, pItemX) {
                var pTable = this._pExpectedExtensionDMap;
                var iIndex = pItem.getIndex();

                if (!akra.isDef(pTable[iIndex])) {
                    pTable[iIndex] = {};
                }

                pTable[iIndex][pItemX.getIndex()] = true;
            };

            Parser.prototype.determineExpected = function (pTestState, sSymbol) {
                var pStateX = pTestState.getNextStateBySymbol(sSymbol);

                if (akra.isNull(pStateX)) {
                    return;
                }

                var pItemListX = pStateX.getItems();
                var pItemList = pTestState.getItems();
                var pState;
                var pItem;
                var i = 0, j = 0, k;

                var nBaseItemTest = pTestState.getNumBaseItems();
                var nBaseItemX = pStateX.getNumBaseItems();

                for (i = 0; i < nBaseItemTest; i++) {
                    pState = this.closureForItem(pItemList[i].getRule(), pItemList[i].getPosition());

                    for (j = 0; j < nBaseItemX; j++) {
                        pItem = pState.hasChildItem(pItemListX[j]);

                        if (pItem) {
                            var pExpected = pItem.getExpectedSymbols();

                            for (k in pExpected) {
                                if (k === parser.UNUSED_SYMBOL) {
                                    this.addLinkExpected(pItemList[i], pItemListX[j]);
                                } else {
                                    pItemListX[j].addExpected(k);
                                }
                            }
                        }
                    }
                }
            };

            Parser.prototype.generateLinksExpected = function () {
                var i = 0, j = 0;
                var pStates = this._pStateList;
                var pKeys;

                for (i = 0; i < pStates.length; i++) {
                    pKeys = Object.keys(this._pSymbolMap);
                    for (j = 0; j < pKeys.length; j++) {
                        this.determineExpected(pStates[i], pKeys[j]);
                    }
                }
            };

            Parser.prototype.expandExpected = function () {
                var pItemList = this._pBaseItemList;
                var pTable = this._pExpectedExtensionDMap;
                var i = 0, j = 0, k = 0;
                var sSymbol = "";
                var isNewExpected = false;

                pItemList[0].addExpected(parser.END_SYMBOL);
                pItemList[0].setIsNewExpected(true);

                while (true) {
                    if (i === pItemList.length) {
                        if (!isNewExpected) {
                            break;
                        }
                        isNewExpected = false;
                        i = 0;
                    }

                    if (pItemList[i].getIsNewExpected() && akra.isDefAndNotNull(pTable[i]) && akra.isDefAndNotNull(pItemList[i].getExpectedSymbols())) {
                        var pExpectedSymbols = Object.keys(pItemList[i].getExpectedSymbols());
                        var pKeys = Object.keys(pTable[i]);

                        for (j = 0; j < pExpectedSymbols.length; j++) {
                            sSymbol = pExpectedSymbols[j];
                            for (k = 0; k < pKeys.length; k++) {
                                if (pItemList[pKeys[k]].addExpected(sSymbol)) {
                                    isNewExpected = true;
                                }
                            }
                        }
                    }

                    pItemList[i].setIsNewExpected(false);
                    i++;
                }
            };

            Parser.prototype.generateStates = function (eType) {
                if (eType === 0 /* k_LR0 */) {
                    this.generateStates_LR0();
                } else if (eType === 1 /* k_LR1 */) {
                    this.generateStates_LR();
                } else if (eType === 2 /* k_LALR */) {
                    this.generateStates_LALR();
                }
            };

            Parser.prototype.generateStates_LR0 = function () {
                this.generateFirstState_LR0();

                var i = 0, j = 0;
                var pStateList = this._pStateList;
                var sSymbol = "";
                var pState;
                var pSymbols = Object.keys(this._pSymbolMap);

                for (i = 0; i < pStateList.length; i++) {
                    for (j = 0; j < pSymbols.length; j++) {
                        sSymbol = pSymbols[j];
                        pState = this.nextState_LR0(pStateList[i], sSymbol);

                        if (!pState.isEmpty()) {
                            pState = this.tryAddState(pState, 0 /* k_LR0 */);
                            this.addStateLink(pStateList[i], pState, sSymbol);
                        }
                    }
                }
            };

            Parser.prototype.generateStates_LR = function () {
                this._pFirstTerminalsDMap = {};
                this.generateFirstState_LR();

                var i = 0, j = 0;
                var pStateList = this._pStateList;
                var sSymbol = "";
                var pState;
                var pSymbols = Object.keys(this._pSymbolMap);

                for (i = 0; i < pStateList.length; i++) {
                    for (j = 0; j < pSymbols.length; j++) {
                        sSymbol = pSymbols[j];
                        pState = this.nextState_LR(pStateList[i], sSymbol);

                        if (!pState.isEmpty()) {
                            pState = this.tryAddState(pState, 1 /* k_LR1 */);
                            this.addStateLink(pStateList[i], pState, sSymbol);
                        }
                    }
                }
            };

            Parser.prototype.generateStates_LALR = function () {
                this._pStatesTempMap = {};
                this._pBaseItemList = [];
                this._pExpectedExtensionDMap = {};
                this._pFirstTerminalsDMap = {};

                this.generateStates_LR0();
                this.deleteNotBaseItems();
                this.generateLinksExpected();
                this.expandExpected();

                var i = 0;
                var pStateList = this._pStateList;

                for (i = 0; i < pStateList.length; i++) {
                    this.closure_LR(pStateList[i]);
                }
            };

            Parser.prototype.calcBaseItem = function () {
                var num = 0;
                var i = 0;

                for (i = 0; i < this._pStateList.length; i++) {
                    num += this._pStateList[i].getNumBaseItems();
                }

                return num;
            };

            Parser.prototype.printExpectedTable = function () {
                var i = 0, j = 0;
                var sMsg = "";

                var pKeys = Object.keys(this._pExpectedExtensionDMap);
                for (i = 0; i < pKeys.length; i++) {
                    sMsg += "State " + this._pBaseItemList[pKeys[i]].getState().getIndex() + ":   ";
                    sMsg += this._pBaseItemList[pKeys[i]].toString() + "  |----->\n";

                    var pExtentions = Object.keys(this._pExpectedExtensionDMap[pKeys[i]]);
                    for (j = 0; j < pExtentions.length; j++) {
                        sMsg += "\t\t\t\t\t" + "State " + this._pBaseItemList[pExtentions[j]].getState().getIndex() + ":   ";
                        sMsg += this._pBaseItemList[pExtentions[j]].toString() + "\n";
                    }

                    sMsg += "\n";
                }

                return sMsg;
            };

            Parser.prototype.addReducing = function (pState) {
                var i = 0, j = 0;
                var pItemList = pState.getItems();

                for (i = 0; i < pItemList.length; i++) {
                    if (pItemList[i].mark() === parser.END_POSITION) {
                        if (pItemList[i].getRule().left === parser.START_SYMBOL) {
                            this.pushInSyntaxTable(pState.getIndex(), parser.END_SYMBOL, this._pSuccessOperation);
                        } else {
                            var pExpected = pItemList[i].getExpectedSymbols();

                            var pKeys = Object.keys(pExpected);
                            for (j = 0; j < pKeys.length; j++) {
                                this.pushInSyntaxTable(pState.getIndex(), pKeys[j], this._pReduceOperationsMap[pItemList[i].getRule().index]);
                            }
                        }
                    }
                }
            };

            Parser.prototype.addShift = function (pState) {
                var i = 0;
                var pStateMap = pState.getNextStates();

                var pStateKeys = Object.keys(pStateMap);

                for (i = 0; i < pStateKeys.length; i++) {
                    var sSymbol = pStateKeys[i];
                    this.pushInSyntaxTable(pState.getIndex(), sSymbol, this._pShiftOperationsMap[pStateMap[sSymbol].getIndex()]);
                }
            };

            Parser.prototype.buildSyntaxTable = function () {
                this._pStateList = [];

                var pStateList = this._pStateList;
                var pState;

                //Generate states
                this.generateStates(this._eType);

                //Init necessary properties
                this._pSyntaxTable = {};
                this._pReduceOperationsMap = {};
                this._pShiftOperationsMap = {};

                this._pSuccessOperation = { type: 103 /* k_Success */ };

                var i = 0, j = 0, k = 0;

                for (i = 0; i < pStateList.length; i++) {
                    this._pShiftOperationsMap[pStateList[i].getIndex()] = {
                        type: 101 /* k_Shift */,
                        index: pStateList[i].getIndex()
                    };
                }

                var pRulesDMapKeys = Object.keys(this._pRulesDMap);
                for (j = 0; j < pRulesDMapKeys.length; j++) {
                    var pRulesMapKeys = Object.keys(this._pRulesDMap[pRulesDMapKeys[j]]);
                    for (k = 0; k < pRulesMapKeys.length; k++) {
                        var sSymbol = pRulesMapKeys[k];
                        var pRule = this._pRulesDMap[pRulesDMapKeys[j]][sSymbol];

                        this._pReduceOperationsMap[sSymbol] = {
                            type: 102 /* k_Reduce */,
                            rule: pRule
                        };
                    }
                }

                for (i = 0; i < pStateList.length; i++) {
                    pState = pStateList[i];
                    this.addReducing(pState);
                    this.addShift(pState);
                }
            };

            Parser.prototype.readToken = function () {
                return this._pLexer._getNextToken();
            };

            Parser.prototype.operationAdditionalAction = function (iStateIndex, sGrammarSymbol) {
                var pFuncDMap = this._pAdidtionalFunctByStateDMap;

                if (!akra.isNull(this._pAdidtionalFunctByStateDMap) && akra.isDef(pFuncDMap[iStateIndex]) && akra.isDef(pFuncDMap[iStateIndex][sGrammarSymbol])) {
                    return pFuncDMap[iStateIndex][sGrammarSymbol].call(this);
                }

                return 105 /* k_Ok */;
            };

            Parser.prototype.resumeParse = function () {
                try  {
                    var pTree = this._pSyntaxTree;
                    var pStack = this._pStack;
                    var pSyntaxTable = this._pSyntaxTable;

                    var isStop = false;
                    var isError = false;
                    var isPause = false;
                    var pToken = akra.isNull(this._pToken) ? this.readToken() : this._pToken;

                    var pOperation;
                    var iRuleLength;

                    var eAdditionalOperationCode;
                    var iStateIndex = 0;

                    while (!isStop) {
                        pOperation = pSyntaxTable[pStack[pStack.length - 1]][pToken.name];
                        if (akra.isDef(pOperation)) {
                            switch (pOperation.type) {
                                case 103 /* k_Success */:
                                    isStop = true;
                                    break;

                                case 101 /* k_Shift */:
                                    iStateIndex = pOperation.index;
                                    pStack.push(iStateIndex);
                                    pTree.addToken(pToken);

                                    eAdditionalOperationCode = this.operationAdditionalAction(iStateIndex, pToken.name);

                                    if (eAdditionalOperationCode === 100 /* k_Error */) {
                                        isError = true;
                                        isStop = true;
                                    } else if (eAdditionalOperationCode === 104 /* k_Pause */) {
                                        this._pToken = null;
                                        isStop = true;
                                        isPause = true;
                                    } else if (eAdditionalOperationCode === 105 /* k_Ok */) {
                                        pToken = this.readToken();
                                    }

                                    break;

                                case 102 /* k_Reduce */:
                                    iRuleLength = pOperation.rule.right.length;
                                    pStack.length -= iRuleLength;
                                    iStateIndex = pSyntaxTable[pStack[pStack.length - 1]][pOperation.rule.left].index;
                                    pStack.push(iStateIndex);
                                    pTree.reduceByRule(pOperation.rule, this._pRuleCreationModeMap[pOperation.rule.left]);

                                    eAdditionalOperationCode = this.operationAdditionalAction(iStateIndex, pOperation.rule.left);

                                    if (eAdditionalOperationCode === 100 /* k_Error */) {
                                        isError = true;
                                        isStop = true;
                                    } else if (eAdditionalOperationCode === 104 /* k_Pause */) {
                                        this._pToken = pToken;
                                        isStop = true;
                                        isPause = true;
                                    }

                                    break;
                            }
                        } else {
                            isError = true;
                            isStop = true;
                        }
                    }
                } catch (e) {
                    this._sFileName = "stdin";
                    return 2 /* k_Error */;
                }
                if (isPause) {
                    return 0 /* k_Pause */;
                }

                if (!isError) {
                    pTree.finishTree();
                    if (akra.isDef(this._fnFinishCallback)) {
                        this._fnFinishCallback.call(this._pCaller, 1 /* k_Ok */, this.getParseFileName());
                    }
                    this._sFileName = "stdin";
                    return 1 /* k_Ok */;
                } else {
                    this._error(PARSER_SYNTAX_ERROR, pToken);
                    if (akra.isDef(this._fnFinishCallback)) {
                        this._fnFinishCallback.call(this._pCaller, 2 /* k_Error */, this.getParseFileName());
                    }
                    this._sFileName = "stdin";
                    return 2 /* k_Error */;
                }
            };

            Parser.prototype.statesToString = function (isBaseOnly) {
                if (typeof isBaseOnly === "undefined") { isBaseOnly = true; }
                if (!akra.isDef(this._pStateList)) {
                    return "";
                }

                var sMsg = "";
                var i = 0;

                for (i = 0; i < this._pStateList.length; i++) {
                    sMsg += this._pStateList[i].toString(isBaseOnly);
                    sMsg += " ";
                }

                return sMsg;
            };

            Parser.prototype.operationToString = function (pOperation) {
                var sOperation = "";

                switch (pOperation.type) {
                    case 101 /* k_Shift */:
                        sOperation = "SHIFT to state " + pOperation.index.toString();
                        break;
                    case 102 /* k_Reduce */:
                        sOperation = "REDUCE by rule { " + this.ruleToString(pOperation.rule) + " }";
                        break;
                    case 103 /* k_Success */:
                        sOperation = "SUCCESS";
                        break;
                }

                return sOperation;
            };

            Parser.prototype.ruleToString = function (pRule) {
                var sRule;

                sRule = pRule.left + " : " + pRule.right.join(" ");

                return sRule;
            };

            Parser.prototype.convertGrammarSymbol = function (sSymbol) {
                if (!this.isTerminal(sSymbol)) {
                    return sSymbol;
                } else {
                    return this._pLexer._getTerminalValueByName(sSymbol);
                }
            };
            return Parser;
        })();
        parser.Parser = Parser;
    })(akra.parser || (akra.parser = {}));
    var parser = akra.parser;
})(akra || (akra = {}));
/// <reference path="../idl/parser/IParser.ts" />
/// <reference path="../idl/IMap.ts" />
/// <reference path="../parser/Parser.ts" />
/// <reference path="../common.ts" />
/// <reference path="../io/io.ts" />
/// <reference path="../uri/uri.ts" />
/// <reference path="../path/path.ts" />
var akra;
(function (akra) {
    (function (fx) {
        var Parser = akra.parser.Parser;

        var EffectParser = (function (_super) {
            __extends(EffectParser, _super);
            function EffectParser() {
                _super.call(this);
                this._pIncludedFilesMap = null;

                this.addAdditionalFunction("addType", this._addType);
                this.addAdditionalFunction("includeCode", this._includeCode);
            }
            EffectParser.prototype.defaultInit = function () {
                _super.prototype.defaultInit.call(this);

                this.addTypeId("float2");
                this.addTypeId("float3");
                this.addTypeId("float4");

                this.addTypeId("float2x2");
                this.addTypeId("float3x3");
                this.addTypeId("float4x4");

                this.addTypeId("int2");
                this.addTypeId("int3");
                this.addTypeId("int4");

                this.addTypeId("bool2");
                this.addTypeId("bool3");
                this.addTypeId("bool4");

                this._pIncludedFilesMap = {};
                this._pIncludedFilesMap[this.getParseFileName()] = true;
            };

            EffectParser.prototype._addIncludedFile = function (sFileName) {
                this._pIncludedFilesMap[sFileName] = true;
            };

            EffectParser.prototype._addType = function () {
                var pTree = this.getSyntaxTree();
                var pNode = pTree.getLastNode();
                var sTypeId;

                sTypeId = pNode.children[pNode.children.length - 2].value;

                this.addTypeId(sTypeId);

                return 105 /* k_Ok */;
            };

            EffectParser.prototype._includeCode = function () {
                var _this = this;
                var pTree = this.getSyntaxTree();
                var pNode = pTree.getLastNode();
                var sFile = pNode.value;

                //cuttin qoutes
                var sIncludeURL = sFile.substr(1, sFile.length - 2);

                if (akra.uri.parse(this.getParseFileName()).getScheme() === "blob:") {
                    sIncludeURL = akra.deps.resolve(sIncludeURL, this.getParseFileName());
                }

                sFile = akra.uri.resolve(sIncludeURL, this.getParseFileName());

                if (this._pIncludedFilesMap[sFile]) {
                    return 105 /* k_Ok */;
                } else {
                    var pParserState = this._saveState();
                    var pFile = akra.io.fopen(sFile, "r+t");

                    pFile.read(function (err, sData) {
                        if (err) {
                            akra.logger.error("Can not read file");
                        } else {
                            pParserState.source = pParserState.source.substr(0, pParserState.index) + sData + pParserState.source.substr(pParserState.index);

                            _this._loadState(pParserState);
                            _this._addIncludedFile(sFile);
                            _this.resume();
                        }
                    });

                    return 104 /* k_Pause */;
                }
            };

            EffectParser.prototype._saveState = function () {
                var pState = _super.prototype._saveState.call(this);
                pState["includeFiles"] = this._pIncludedFilesMap;
                return pState;
            };

            EffectParser.prototype._loadState = function (pState) {
                _super.prototype._loadState.call(this, pState);
                this._pIncludedFilesMap = pState["includeFiles"];
            };
            return EffectParser;
        })(Parser);
        fx.EffectParser = EffectParser;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    /// <reference path="Composer.ts" />
    /// <reference path="Effect.ts" />
    /// <reference path="EffectParser.ts" />
    (function (fx) {
        /** For addComponent/delComponent/hasComponent */
        fx.ALL_PASSES = 0xffffff;

        /** Only for hasComponent */
        fx.ANY_PASS = 0xfffffa;

        /** For addComponent/delComponent/hasComponent */
        fx.ANY_SHIFT = 0xfffffb;

        /** For addComponent/delComponent/hasComponent  */
        fx.DEFAULT_SHIFT = 0xfffffc;

        /** @const */
        fx.effectParser = new fx.EffectParser();

        function initAFXParser(sGrammar) {
            var iMode = 4 /* k_Add */ | 2 /* k_Negate */ | 8 /* k_Optimize */;

            if (akra.config.AFX_DEBUG_PARSER) {
                iMode |= 16 /* k_DebugMode */;
            }

            fx.effectParser.init(sGrammar, iMode);
        }
        fx.initAFXParser = initAFXParser;
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
/// <reference path="../../idl/IRenderMethod.ts" />
/// <reference path="../../idl/IAFXComposer.ts" />
/// <reference path="../../idl/IAFXPassInputBlend.ts" />
/// <reference path="../../common.ts" />
/// <reference path="../../fx/fx.ts" />
var akra;
(function (akra) {
    (function (pool) {
        /// <reference path="../ResourcePoolItem.ts" />
        (function (resources) {
            var RenderMethod = (function (_super) {
                __extends(RenderMethod, _super);
                function RenderMethod() {
                    _super.apply(this, arguments);
                    this._pEffect = null;
                    this._pSurfaceMaterial = null;
                    this._pPassInputList = null;
                    this._nTotalPasses = 0;
                }
                RenderMethod.prototype.isReady = function () {
                    if (this.isResourceDisabled()) {
                        return false;
                    }

                    if (akra.isDefAndNotNull(this._pEffect) || akra.isDefAndNotNull(this._pSurfaceMaterial)) {
                        return this.isResourceLoaded();
                    }

                    return this.isResourceCreated();
                };

                RenderMethod.prototype.createResource = function () {
                    this.notifyCreated();
                    return true;
                };

                RenderMethod.prototype.getEffect = function () {
                    return this._pEffect;
                };

                RenderMethod.prototype.setEffect = function (pEffect) {
                    if (!akra.isNull(this._pEffect)) {
                        this.unsync(this._pEffect, 1 /* LOADED */, 0 /* CREATED */);
                        this._pEffect.altered.disconnect(this, this.updateEffect, 1 /* BROADCAST */);
                        this._pEffect.release();
                    }

                    this._pEffect = pEffect;

                    if (!akra.isNull(pEffect)) {
                        this.sync(this._pEffect, 1 /* LOADED */, 0 /* CREATED */);
                        this._pEffect.altered.connect(this, this.updateEffect, 1 /* BROADCAST */);
                        this._pEffect.addRef();
                    }

                    this.notifyLoaded();
                    this.updateEffect(pEffect);
                };

                RenderMethod.prototype.getSurfaceMaterial = function () {
                    return this._pSurfaceMaterial;
                };

                RenderMethod.prototype.setSurfaceMaterial = function (pMaterial) {
                    if (!akra.isNull(this._pSurfaceMaterial)) {
                        this.unsync(this._pSurfaceMaterial, 1 /* LOADED */, 0 /* CREATED */);
                        this._pSurfaceMaterial.altered.disconnect(this, this.notifyAltered, 1 /* BROADCAST */);
                        this._pSurfaceMaterial.release();
                    }

                    this._pSurfaceMaterial = pMaterial;

                    if (!akra.isNull(pMaterial)) {
                        this.sync(this._pSurfaceMaterial, 1 /* LOADED */, 0 /* CREATED */);
                        this._pSurfaceMaterial.altered.connect(this, this.notifyAltered, 1 /* BROADCAST */);
                        this._pSurfaceMaterial.addRef();
                    }

                    this.notifyAltered();
                    this.notifyLoaded();
                };

                RenderMethod.prototype.getMaterial = function () {
                    return this.getSurfaceMaterial().getMaterial();
                };

                RenderMethod.prototype.isEqual = function (pRenderMethod) {
                    return false;
                };

                RenderMethod.prototype.setForeign = function (sName, pValue, iPass) {
                    if (typeof iPass === "undefined") { iPass = akra.fx.ALL_PASSES; }
                    if (iPass === akra.fx.ALL_PASSES) {
                        for (var i = 0; i < this._nTotalPasses; i++) {
                            this.setForeign(sName, pValue, i);
                        }

                        return;
                    }

                    if (iPass < 0 || iPass >= this._nTotalPasses) {
                        akra.debug.error("RenderMethod::setForeign : wrong number of pass (" + iPass + ")");
                        return;
                    }

                    this._pPassInputList[iPass].setForeign(sName, pValue);
                };

                RenderMethod.prototype.setUniform = function (sName, pValue, iPass) {
                    if (typeof iPass === "undefined") { iPass = akra.fx.ALL_PASSES; }
                    if (iPass === akra.fx.ALL_PASSES) {
                        for (var i = 0; i < this._nTotalPasses; i++) {
                            this.setUniform(sName, pValue, i);
                        }

                        return;
                    }

                    if (iPass < 0 || iPass >= this._nTotalPasses) {
                        akra.debug.error("RenderMethod::setUniform : wrong number of pass (" + iPass + ")");
                        return;
                    }

                    this._pPassInputList[iPass].setUniform(sName, pValue);
                };

                RenderMethod.prototype.setTexture = function (sName, pValue, iPass) {
                    if (typeof iPass === "undefined") { iPass = akra.fx.ALL_PASSES; }
                    if (iPass === akra.fx.ALL_PASSES) {
                        for (var i = 0; i < this._nTotalPasses; i++) {
                            this.setTexture(sName, pValue, i);
                        }

                        return;
                    }

                    if (iPass < 0 || iPass >= this._nTotalPasses) {
                        akra.debug.error("RenderMethod::setTexture : wrong number of pass (" + iPass + ")");
                        return;
                    }

                    this._pPassInputList[iPass].setTexture(sName, pValue);
                };

                RenderMethod.prototype.setRenderState = function (eState, eValue, iPass) {
                    if (typeof iPass === "undefined") { iPass = akra.fx.ALL_PASSES; }
                    if (iPass === akra.fx.ALL_PASSES) {
                        for (var i = 0; i < this._nTotalPasses; i++) {
                            this.setRenderState(eState, eValue, i);
                        }

                        return;
                    }

                    if (iPass < 0 || iPass >= this._nTotalPasses) {
                        akra.debug.error("RenderMethod::setRenderState : wrong number of pass (" + iPass + ")");
                        return;
                    }

                    this._pPassInputList[iPass].setRenderState(eState, eValue);
                };

                RenderMethod.prototype.setSamplerTexture = function (sName, pTexture, iPass) {
                    if (typeof iPass === "undefined") { iPass = akra.fx.ALL_PASSES; }
                    if (iPass === akra.fx.ALL_PASSES) {
                        for (var i = 0; i < this._nTotalPasses; i++) {
                            this.setSamplerTexture(sName, pTexture, i);
                        }

                        return;
                    }

                    if (iPass < 0 || iPass >= this._nTotalPasses) {
                        akra.debug.error("RenderMethod::setSamplerTexture : wrong number of pass (" + iPass + ")");
                        return;
                    }

                    this._pPassInputList[iPass].setSamplerTexture(sName, pTexture);
                };

                RenderMethod.prototype._getPassInput = function (iPass) {
                    return this._pPassInputList[iPass];
                };

                /** Clear previous pass-inputs.*/
                RenderMethod.prototype.updateEffect = function (pEffect) {
                    if (akra.isNull(pEffect)) {
                        for (var i = 0; i < this._nTotalPasses; i++) {
                            var pOldInput = this._pPassInputList[i];

                            if (akra.isDefAndNotNull(pOldInput)) {
                                pOldInput._release();
                                this._pPassInputList[i] = null;
                            }
                        }

                        this._nTotalPasses = 0;
                        this.notifyAltered();
                        return;
                    }

                    var pComposer = this.getManager().getEngine().getComposer();
                    var iTotalPasses = pEffect.getTotalPasses();

                    if (akra.isNull(this._pPassInputList)) {
                        this._pPassInputList = new Array(iTotalPasses);
                        this._nTotalPasses = 0;
                    }

                    for (var i = 0; i < iTotalPasses; i++) {
                        var pNewInput = pComposer.getPassInputBlendForEffect(pEffect, i);
                        var pOldInput = this._pPassInputList[i];

                        if (akra.isDefAndNotNull(pOldInput) && akra.isDefAndNotNull(pNewInput)) {
                            if (pNewInput._isFromSameBlend(pOldInput)) {
                                return;
                            }

                            pNewInput._copyFrom(pOldInput);
                            pOldInput._release();
                        }

                        this._pPassInputList[i] = pNewInput;
                    }

                    if (this._nTotalPasses > iTotalPasses) {
                        for (var i = iTotalPasses; i < this._nTotalPasses; i++) {
                            var pOldInput = this._pPassInputList[i];

                            if (akra.isDefAndNotNull(pOldInput)) {
                                pOldInput._release();
                                this._pPassInputList[i] = null;
                            }
                        }
                    }

                    this._nTotalPasses = iTotalPasses;

                    this.notifyAltered();
                };
                return RenderMethod;
            })(pool.ResourcePoolItem);
            resources.RenderMethod = RenderMethod;
        })(pool.resources || (pool.resources = {}));
        var resources = pool.resources;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="../../idl/IEffect.ts" />
/// <reference path="../ResourcePoolItem.ts" />
/// <reference path="../../idl/IAFXComposer.ts" />
var akra;
(function (akra) {
    (function (pool) {
        /// <reference path="../../debug.ts" />
        /// <reference path="../../fx/fx.ts" />
        (function (resources) {
            var Effect = (function (_super) {
                __extends(Effect, _super);
                function Effect() {
                    _super.apply(this, arguments);
                    this._nTotalPasses = 0;
                    this._nTotalComponents = 0;
                }
                Effect.prototype.getTotalComponents = function () {
                    return this._nTotalComponents;
                };

                Effect.prototype.getTotalPasses = function () {
                    return this._nTotalPasses;
                };

                Effect.prototype.isEqual = function (pEffect) {
                    return false;
                };
                Effect.prototype.isReplicated = function () {
                    return false;
                };
                Effect.prototype.isMixid = function () {
                    return false;
                };
                Effect.prototype.isParameterUsed = function (pParam, iPass) {
                    return false;
                };

                Effect.prototype.createResource = function () {
                    this.notifyCreated();
                    return true;
                };

                Effect.prototype.replicable = function (bValue) {
                    return;
                };
                Effect.prototype.miscible = function (bValue) {
                    return;
                };

                Effect.prototype.addComponent = function (pComponent, iShift, iPass) {
                    if (typeof iShift === "undefined") { iShift = akra.fx.DEFAULT_SHIFT; }
                    if (typeof iPass === "undefined") { iPass = akra.fx.ALL_PASSES; }
                    var pComponentPool = this.getManager().getComponentPool();

                    if (akra.isInt(pComponent)) {
                        pComponent = pComponentPool.getResource(pComponent);
                    } else if (akra.isString(pComponent)) {
                        pComponent = pComponentPool.findResource(pComponent);
                    }

                    if (!akra.isDef(pComponent) || akra.isNull(pComponent)) {
                        akra.debug.error("Bad component for add: ", pComponent);
                        return false;
                    }

                    if (!this.getComposer().addComponentToEffect(this, pComponent, iShift, iPass)) {
                        akra.debug.error("Can not add component '" + pComponent.findResourceName() + "'");
                        return false;
                    }

                    this._nTotalComponents = this.getComposer().getComponentCountForEffect(this);
                    this._nTotalPasses = this.getComposer().getTotalPassesForEffect(this);

                    this.notifyAltered();

                    if (this.getTotalComponents() === 1) {
                        this.notifyRestored();
                    }

                    return true;
                };

                Effect.prototype.delComponent = function (pComponent, iShift, iPass) {
                    if (typeof iShift === "undefined") { iShift = akra.fx.DEFAULT_SHIFT; }
                    if (typeof iPass === "undefined") { iPass = akra.fx.ALL_PASSES; }
                    var pComponentPool = this.getManager().getComponentPool();

                    if (akra.isInt(pComponent)) {
                        pComponent = pComponentPool.getResource(pComponent);
                    } else if (akra.isString(pComponent)) {
                        pComponent = pComponentPool.findResource(pComponent);
                    }

                    if (!akra.isDef(pComponent) || akra.isNull(pComponent)) {
                        akra.debug.error("Bad component for delete: ", pComponent);
                        return false;
                    }

                    if (!this.getComposer().removeComponentFromEffect(this, pComponent, iShift, iPass)) {
                        akra.debug.error("Can not delete component '" + pComponent.findResourceName() + "'");
                        return false;
                    }

                    this._nTotalComponents = this.getComposer().getComponentCountForEffect(this);
                    this._nTotalPasses = this.getComposer().getTotalPassesForEffect(this);

                    this.notifyAltered();

                    if (this.getTotalComponents() === 0) {
                        this.notifyDisabled();
                    }

                    return true;
                };

                Effect.prototype.hasComponent = function (sComponent, iShift, iPass) {
                    if (typeof iShift === "undefined") { iShift = akra.fx.ANY_SHIFT; }
                    if (typeof iPass === "undefined") { iPass = akra.fx.ANY_PASS; }
                    var pComponentPool = this.getManager().getComponentPool();
                    var pComponent = null;

                    pComponent = pComponentPool.findResource(sComponent);

                    if (akra.isNull(pComponent)) {
                        return false;
                    }

                    return this.getComposer().hasComponentForEffect(this, pComponent, iShift, iPass);
                };

                Effect.prototype.activate = function (iShift) {
                    if (typeof iShift === "undefined") { iShift = 0; }
                    return this.getComposer().activateEffectResource(this, iShift);
                };

                Effect.prototype.deactivate = function () {
                    return this.getComposer().deactivateEffectResource(this);
                };

                Effect.prototype.findParameter = function (pParam, iPass) {
                    return null;
                };

                Effect.prototype.getComposer = function () {
                    return this.getManager().getEngine().getComposer();
                };
                return Effect;
            })(pool.ResourcePoolItem);
            resources.Effect = Effect;
        })(pool.resources || (pool.resources = {}));
        var resources = pool.resources;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="../../idl/IAFXComponent.ts" />
/// <reference path="../../common.ts" />
var akra;
(function (akra) {
    (function (pool) {
        /// <reference path="../ResourcePoolItem.ts" />
        /// <reference path="../../fx/fx.ts" />
        (function (resources) {
            var Component = (function (_super) {
                __extends(Component, _super);
                function Component() {
                    _super.apply(this, arguments);
                    this._pTechnique = null;
                    this._pComposer = null;
                }
                Component.prototype.create = function () {
                    this._pComposer = this.getManager().getEngine().getComposer();
                };

                Component.prototype.getTechnique = function () {
                    return this._pTechnique;
                };

                Component.prototype.setTechnique = function (pTechnique) {
                    this._pTechnique = pTechnique;
                    this.notifyLoaded();
                };

                Component.prototype.isPostEffect = function () {
                    return akra.isNull(this._pTechnique) ? false : this._pTechnique._isPostEffect();
                };

                Component.prototype.getName = function () {
                    return this._pTechnique._getName();
                };

                Component.prototype.getTotalPasses = function () {
                    return this._pTechnique._totalOwnPasses();
                };

                Component.prototype.getHash = function (iShift, iPass) {
                    return this.guid.toString() + ">" + iShift.toString() + ">" + (iPass === akra.fx.ALL_PASSES ? "A" : iPass.toString());
                };
                return Component;
            })(pool.ResourcePoolItem);
            resources.Component = Component;
        })(pool.resources || (pool.resources = {}));
        var resources = pool.resources;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="../idl/IAnimationBase.ts" />
/// <reference path="../idl/IAnimationController.ts" />
var akra;
(function (akra) {
    /// <reference path="../guid.ts" />
    /// <reference path="Base.ts" />
    /// <reference path="Container.ts" />
    /// <reference path="Blend.ts" />
    (function (animation) {
        var PlaySignal = (function (_super) {
            __extends(PlaySignal, _super);
            function PlaySignal(pController) {
                _super.call(this, pController, 1 /* BROADCAST */);
            }
            PlaySignal.prototype.emit = function (pAnimation) {
                var pController = this.getSender();
                var pAnimationNext = pController.findAnimation(arguments[0]);
                var pAnimationPrev = pController.getActive();
                var fRealTime = pController.getEngine().getTime();

                if (pAnimationNext && pAnimationNext !== pAnimationPrev) {
                    if (pAnimationPrev) {
                        pAnimationPrev.stop(fRealTime);
                    }

                    pAnimationNext.play(fRealTime);
                    pController._setActiveAnimation(pAnimationNext);

                    _super.prototype.emit.call(this, pAnimationNext, fRealTime);
                }
            };
            return PlaySignal;
        })(akra.Signal);

        var Controller = (function () {
            function Controller(pEngine, sName, iOptions) {
                if (typeof sName === "undefined") { sName = null; }
                if (typeof iOptions === "undefined") { iOptions = 0; }
                this.guid = akra.guid();
                this.name = null;
                this._pAnimations = [];
                this._iOptions = 0;
                this._pActiveAnimation = null;
                this._pTarget = null;
                this.setupSignals();

                this._pEngine = pEngine;
                this.setOptions(iOptions);
                this.name = sName;
            }
            Controller.prototype.getTotalAnimations = function () {
                return this._pAnimations.length;
            };

            Controller.prototype.getActive = function () {
                return this._pActiveAnimation;
            };

            Controller.prototype.getTarget = function () {
                return this._pTarget;
            };

            Controller.prototype.setupSignals = function () {
                this.animationAdded = this.animationAdded || new akra.Signal(this);
                this.play = this.play || new PlaySignal(this);
            };

            Controller.prototype.getEngine = function () {
                return this._pEngine;
            };

            Controller.prototype.setOptions = function (iOptions) {
            };

            Controller.prototype.addAnimation = function (pAnimation) {
                if (this.findAnimation(pAnimation.getName())) {
                    akra.logger.warn("Animation with name <" + pAnimation.getName() + "> already exists in this controller");
                    return false;
                }

                //LOG('animation controller :: add animation >> ', pAnimation.name);
                this._pAnimations.push(pAnimation);
                this._pActiveAnimation = pAnimation;
                if (!akra.isNull(this.getTarget())) {
                    pAnimation.attach(this.getTarget());
                } else {
                    //TODO: detach animation
                }

                this.animationAdded.emit(pAnimation);
            };

            Controller.prototype.removeAnimation = function (pAnimationArg) {
                var pAnimation = this.findAnimation(pAnimationArg);
                var pAnimations = this._pAnimations;

                for (var i = 0; i < pAnimations.length; ++i) {
                    if (pAnimations[i] === pAnimation) {
                        pAnimations.splice(i, 1);
                        akra.logger.log("animation controller :: remove animation >> ", pAnimation.getName());
                        return true;
                    }
                }

                return false;
            };

            Controller.prototype.findAnimation = function (pAnimation) {
                var pAnimations = this._pAnimations;
                var iAnimation;
                var sAnimation;

                if (akra.isString(arguments[0])) {
                    sAnimation = arguments[0];

                    for (var i = 0; i < pAnimations.length; ++i) {
                        if (pAnimations[i].getName() === sAnimation) {
                            return pAnimations[i];
                        }
                    }

                    return null;
                }

                if (typeof arguments[0] === 'number') {
                    iAnimation = arguments[0];
                    return pAnimations[iAnimation] || null;
                }

                return arguments[0];
            };

            Controller.prototype.getAnimation = function (iAnim) {
                return this._pAnimations[iAnim];
            };

            Controller.prototype.setAnimation = function (iAnimation, pAnimation) {
                akra.debug.assert(iAnimation < this._pAnimations.length, 'invalid animation slot');

                this._pAnimations[iAnimation] = pAnimation;
            };

            Controller.prototype.attach = function (pTarget) {
                var pAnimations = this._pAnimations;

                for (var i = 0; i < pAnimations.length; ++i) {
                    if (!pAnimations[i].isAttached() || this.getTarget() !== pTarget) {
                        pAnimations[i].attach(pTarget);
                    }
                }

                if (this.getTarget()) {
                    this.getTarget().getScene().beforeUpdate.disconnect(this, this.update);
                    //this.disconnect(this.target.scene, SIGNAL(postUpdate), SLOT(update));
                }

                this._pTarget = pTarget;
                this.getTarget().getScene().beforeUpdate.connect(this, this.update);
            };

            Controller.prototype.stop = function () {
                if (this._pActiveAnimation) {
                    this._pActiveAnimation.stop(this._pEngine.getTime());
                }

                this._pActiveAnimation = null;
            };

            Controller.prototype.update = function () {
                var pAnim = this._pActiveAnimation;
                if (!akra.isNull(pAnim)) {
                    if (!pAnim.apply(this._pEngine.getTime())) {
                        // this._pActiveAnimation = null;
                        // pAnim.stop(this._pEngine.time);
                    }
                }
            };

            Controller.prototype._setActiveAnimation = function (pAnim) {
                this._pActiveAnimation = pAnim;
            };

            Controller.prototype.toString = function (bFullInfo) {
                if (typeof bFullInfo === "undefined") { bFullInfo = false; }
                if (akra.config.DEBUG) {
                    var s = "\n";
                    s += "ANIMATION CONTROLLER (total: " + this.getTotalAnimations() + " animations)\n";
                    s += "-----------------------------------------------------\n";

                    for (var i = 0; i < this.getTotalAnimations(); ++i) {
                        s += this.getAnimation(i).toString();
                    }

                    return s;
                }

                return null;
            };

            Controller.PlaySignal = PlaySignal;
            return Controller;
        })();

        function createController(pEngine, sName, iOptions) {
            return new Controller(pEngine, sName, iOptions);
        }
        animation.createController = createController;
    })(akra.animation || (akra.animation = {}));
    var animation = akra.animation;
})(akra || (akra = {}));
/// <reference path="../idl/3d-party/es6-promises.d.ts" />
/// <reference path="../idl/3d-party/zip.d.ts" />
var akra;
(function (akra) {
    /// <reference path="../idl/IEngine.ts" />
    /// <reference path="../idl/IDeps.ts" />
    /// <reference path="../idl/EIO.ts" />
    /// <reference path="../logger.ts" />
    /// <reference path="../path/path.ts" />
    /// <reference path="../uri/uri.ts" />
    /// <reference path="../io/io.ts" />
    /// <reference path="../info/info.ts" />
    /// <reference path="../conv/conv.ts" />
    /// <reference path="../config/config.ts" />
    /// <reference path="../crypto/md5.ts" />
    (function (deps) {
        

        var pRegistredDeps = {};

        //blob url ==> archive id
        var pBlobArchiveMap = {};

        //@archive_id ==> map(@local ==> @blob_url)
        var pArchiveBlobMap = {};

        //function _resolve(sBlobPath: string): string;
        //function _resolve(sLocalPath: string, sBlobPath: string): string;
        function resolve(a, b) {
            var sBlobPath, sLocalPath;
            if (arguments.length == 1) {
                sBlobPath = arguments[0];
                sLocalPath = null;
            } else {
                sLocalPath = arguments[0];
                sBlobPath = arguments[1];
            }

            var sArchive = pBlobArchiveMap[sBlobPath] || null;

            if (akra.isNull(sArchive)) {
                akra.debug.error("could not determ archive of this blob");
                return null;
            }

            //@local_url ==> @blob_url
            var pArchiveMap = pArchiveBlobMap[sArchive];

            //local path for @sBlobPath in archive
            var sOriginalLocal = Object.keys(pArchiveMap).filter(function (key) {
                return pArchiveMap[key] === sBlobPath;
            })[0];

            if (akra.isNull(sLocalPath)) {
                return sOriginalLocal;
            }

            sLocalPath = akra.path.normalize(sLocalPath);

            //blob url for @sLocalPath in archive
            var sBlobURL = pArchiveBlobMap[sArchive][akra.uri.resolve(sLocalPath, sOriginalLocal)] || null;

            akra.debug.assert(!akra.isNull(sBlobURL), "could not resolve blob url");

            return sBlobURL;
        }
        deps.resolve = resolve;

        /**
        * @param sType Resource string type.
        * @param isResource Is the resource dependence?
        */
        function addDependenceHandler(pTypes, fnPoolSelector, fnHandler) {
            for (var i = 0; i < pTypes.length; ++i) {
                var sType = pTypes[i].toLowerCase();
                pRegistredDeps[sType] = { type: sType, poolSelector: fnPoolSelector || null, handler: fnHandler };
            }
        }
        deps.addDependenceHandler = addDependenceHandler;

        function findDepHandler(pDep) {
            var sExt = getType(pDep);
            var pDepEngine = pRegistredDeps[sExt];
            return pDepEngine || null;
        }

        /** Get lowest level of deps. */
        function getLowestLevel(pDeps) {
            var c = pDeps;

            while (akra.isDefAndNotNull(c)) {
                if (!akra.isDefAndNotNull(c.deps)) {
                    return c;
                }

                c = c.deps;
            }

            return c;
        }
        deps.getLowestLevel = getLowestLevel;

        function calcDepth(pDeps) {
            var c = pDeps;
            var d = 0;

            while (akra.isDefAndNotNull(c)) {
                d++;
                c = c.deps;
            }

            return d;
        }
        deps.calcDepth = calcDepth;

        function eachLevel(pDeps, fn) {
            var p = null;
            var c = pDeps;

            while (akra.isDefAndNotNull(c)) {
                fn(c, p);
                p = c;
                c = c.deps;
            }
        }
        deps.eachLevel = eachLevel;

        /**
        * Recursive walk
        */
        function walk(pDeps, fn, iDepth, fnEnd, pParentDeps) {
            if (typeof iDepth === "undefined") { iDepth = 0; }
            if (typeof fnEnd === "undefined") { fnEnd = null; }
            if (typeof pParentDeps === "undefined") { pParentDeps = null; }
            var pFiles = pDeps.files;

            if (akra.isDefAndNotNull(pFiles)) {
                for (var i = 0; i < pFiles.length; ++i) {
                    fn(pDeps, i, iDepth, pParentDeps);
                }
            }

            if (akra.isDefAndNotNull(pDeps.deps)) {
                walk(pDeps.deps, fn, ++iDepth, fnEnd, pDeps);
            } else if (akra.isFunction(fnEnd)) {
                fnEnd();
            }
        }
        deps.walk = walk;

        function each(pDeps, fn) {
            walk(pDeps, function (pDeps, i) {
                fn(pDeps.files[i]);
            });
        }
        deps.each = each;

        function countFilesOnLevel(pDeps) {
            return akra.isArray(pDeps.files) ? pDeps.files.length : 0;
        }

        function findNotEmptyLevel(pDeps) {
            if (!akra.isDefAndNotNull(pDeps)) {
                return null;
            }

            if (!countFilesOnLevel(pDeps)) {
                return findNotEmptyLevel(pDeps.deps);
            }

            return pDeps;
        }

        function countFiles(pDeps) {
            var iTotal = 0;

            eachLevel(pDeps, function (pDeps) {
                iTotal += countFilesOnLevel(pDeps);
            });

            return iTotal;
        }
        deps.countFiles = countFiles;

        /**
        * Make the <path> absolute for IDep
        */
        function normalize(pDeps, sRoot, iDepth) {
            if (typeof sRoot === "undefined") { sRoot = null; }
            if (typeof iDepth === "undefined") { iDepth = 0; }
            sRoot = akra.isString(sRoot) ? sRoot : akra.uri.here().toString();

            walk(pDeps, function (pDeps, i, iDepth) {
                var pDep = pDeps.files[i];
                pDep.path = akra.uri.resolve(pDeps.files[i].path, pDeps.root || sRoot);
            });
        }
        deps.normalize = normalize;

        function getType(pDep) {
            return (pDep.type || akra.path.parse(pDep.path).getExt() || "").toLowerCase();
        }
        deps.getType = getType;

        function computeProperties(pDeps, cb) {
            var pAll = [];

            each(pDeps, function (pDep) {
                pAll.push(new Promise(function (fnResolve, fnReject) {
                    var fnSuccess = function (iSize) {
                        var pStats = {
                            status: 0 /* PENDING */,
                            byteLength: iSize,
                            bytesLoaded: 0,
                            unpacked: 0.
                        };

                        pDep.stats = pStats;

                        fnResolve(pStats.byteLength);
                    };

                    if (akra.uri.parse(pDep.path).getScheme() === "data:") {
                        setTimeout(fnSuccess, 1, akra.uri.parseDataURI(pDep.path).data.length);
                        return;
                    }

                    akra.io.fopen(pDep.path).open(function (e, pMeta) {
                        if (e) {
                            return fnReject(e);
                        }

                        //if (config.DEBUG) {
                        if (!akra.isNumber(pMeta.size)) {
                            return fnReject(new Error("could not determ byte length of " + pDep.path));
                        }

                        //}
                        fnSuccess(pMeta.size || 0);
                    });
                }));
            });

            Promise.all(pAll).then(function (pValues) {
                cb(null, pValues.reduce(function (a, b) {
                    return parseInt(a) + parseInt(b);
                }));
            }, cb);
        }

        function createResources(pEngine, pDeps) {
            var pRmgr = pEngine.getResourceManager();
            each(pDeps, function (pDep) {
                var sResource = pDep.name || pDep.path;
                var pDepEngine = findDepHandler(pDep);

                if (!akra.isDefAndNotNull(pDepEngine) || akra.isNull(pDepEngine.poolSelector)) {
                    return null;
                }

                var pPool = pDepEngine.poolSelector(pRmgr);

                if (!pPool.findResource(sResource)) {
                    pPool.createResource(sResource);
                }
            });
        }

        // Resource item 'loaded' event callback.
        function handleResourceEventOnce(pRsc, sSignal, fnHandler) {
            //TODO: collect loading error from resource.
            var fn = function (pItem) {
                fnHandler(pItem);
                pRsc.loaded.disconnect(fn);
            };

            pRsc.loaded.connect(fn);
        }

        function loadFromPool(pPool, pDep, cb) {
            var sResource = pDep.name || pDep.path;
            var pRes = pPool.findResource(sResource);

            cb(pDep, 3 /* LOADING */);

            handleResourceEventOnce(pRes, "loaded", function (pItem) {
                cb(pDep, 7 /* LOADED */, pRes);
            });

            if (!pRes.loadResource(pDep.path)) {
                cb(pDep, 8 /* REJECTED */, new Error("could not load resource: " + pDep.path));
            }
        }

        function loadResource(pEngine, pDep, cb) {
            loadFromPool(findDepHandler(pDep).poolSelector(pEngine.getResourceManager()), pDep, cb);
        }
        deps.loadResource = loadResource;

        //redirect events from load() function to cb() of custom dep.
        function redirectProgress(pDep, cb) {
            return function (e) {
                cb(e.source, 9 /* INTERNAL_UPDATE */);

                switch (e.source.stats.status) {
                    case 2 /* CHECKING */:
                        return cb(pDep, 2 /* CHECKING */);
                    case 5 /* UNPACKING */:
                    case 6 /* EXTRACTION */:
                        return cb(pDep, 5 /* UNPACKING */, e.unpacked);
                    case 4 /* DOWNLOADING */:
                        return cb(pDep, 4 /* DOWNLOADING */, { loaded: e.bytesLoaded, total: e.bytesTotal });
                }
            };
        }

        function loadMap(pEngine, pDep, cb) {
            var pFile = akra.io.fopen(pDep.path, 1 /* IN */ | 128 /* JSON */);

            cb(pDep, 3 /* LOADING */, null);

            pFile.read(function (e, pMap) {
                pFile.close();

                if (!akra.isNull(e)) {
                    return cb(pDep, 8 /* REJECTED */, e);
                }

                load(pEngine, pMap, pDep.path, function (e) {
                    if (e) {
                        return cb(pDep, 8 /* REJECTED */, e);
                    }

                    cb(pDep, 7 /* LOADED */, pMap);
                }, redirectProgress(pDep, cb));
            });
        }
        deps.loadMap = loadMap;

        function loadGrammar(pEngine, pDep, cb) {
            var pGrammar = akra.io.fopen(pDep.path);

            cb(pDep, 3 /* LOADING */);

            pGrammar.read(function (e, sData) {
                pGrammar.close();

                if (!akra.isNull(e)) {
                    return cb(pDep, 8 /* REJECTED */, e);
                }

                //WARNING: only for HLSL grammar files.
                akra.fx.initAFXParser(sData);

                cb(pDep, 7 /* LOADED */, sData);
            });
        }
        deps.loadGrammar = loadGrammar;

        function loadCustom(pEngine, pDep, cb) {
            var pFile = akra.io.fopen(pDep.path);

            cb(pDep, 3 /* LOADING */);

            pFile.read(function (pErr, sData) {
                pFile.close();

                if (!akra.isNull(pErr)) {
                    return cb(pDep, 8 /* REJECTED */, pErr);
                }

                cb(pDep, 7 /* LOADED */, sData);
            });
        }
        deps.loadCustom = loadCustom;

        function loadJSON(pEngine, pDep, cb) {
            var pFile = akra.io.fopen(pDep.path, 1 /* IN */ | 128 /* JSON */);

            cb(pDep, 3 /* LOADING */);

            pFile.read(function (pErr, pData) {
                pFile.close();

                if (!akra.isNull(pErr)) {
                    return cb(pDep, 8 /* REJECTED */, pErr);
                }

                cb(pDep, 7 /* LOADED */, pData);
            });
        }
        deps.loadJSON = loadJSON;

        function loadBSON(pEngine, pDep, cb) {
            var pFile = akra.io.fopen(pDep.path, 1 /* IN */ | 32 /* BINARY */);

            cb(pDep, 3 /* LOADING */);

            pFile.read(function (pErr, pBuffer) {
                pFile.close();

                if (!akra.isNull(pErr)) {
                    return cb(pDep, 8 /* REJECTED */, pErr);
                }

                cb(pDep, 7 /* LOADED */, akra.io.undump(pBuffer));
            });
        }
        deps.loadBSON = loadBSON;

        //load ARA
        /** @const */
        var ARA_INDEX = akra.config.deps.archiveIndex || ".map";

        /** @const */
        var ETAG_FILE = akra.config.deps.etag.file || ".etag";

        /** @const */
        var FORCE_ETAG_CHECKING = akra.config.deps.etag.forceCheck || false;
        var CACHE_SUPPORTED = akra.info.api.getFileSystem();

        function forceExtractARADependence(pEntry, sPath, cb) {
            pEntry.getData(new zip.ArrayBufferWriter(), function (pData) {
                var pCopy = akra.io.fopen(sPath, 1 /* IN */ | 2 /* OUT */ | 16 /* TRUNC */ | 32 /* BIN */);

                pCopy.write(pData, function (e) {
                    if (e) {
                        return cb(e, null);
                    }

                    akra.debug.log("Unpacked to local filesystem " + pEntry.filename + ".");

                    pCopy.close();

                    var pCrc32 = akra.io.fopen(sPath + ".crc32", 1 /* IN */ | 2 /* OUT */ | 16 /* TRUNC */);
                    pCrc32.write(String(pEntry.crc32), function (e) {
                        cb(e, sPath);
                        pCrc32.close();
                    });
                });
            });
        }

        /**
        * @param sHash Unique identifier of archive.
        *
        */
        function fastExtractARADependence(pEntry, sHash, cb) {
            pEntry.getData(new zip.ArrayBufferWriter(), function (pData) {
                var sBlobURL = akra.conv.toURL(pData, "application/octet-stream");

                //@blob_url ===> archive_id
                pBlobArchiveMap[sBlobURL] = sHash;

                //@archive_id ==> map(@local_url ==> @blob_url)
                pArchiveBlobMap[sHash] = pArchiveBlobMap[sHash] || {};
                pArchiveBlobMap[sHash][pEntry.filename] = sBlobURL;

                cb(null, sBlobURL);
            });
        }

        function createARADLocalName(sFilename, sEntry) {
            return "filesystem:" + akra.info.uri.getScheme() + "//" + akra.info.uri.getHost() + "/temporary/" + sEntry + "/" + sFilename;
        }

        function extractARADependence(pEntry, sHash, cb) {
            var sPath = createARADLocalName(pEntry.filename, sHash);

            if (!CACHE_SUPPORTED) {
                fastExtractARADependence(pEntry, sHash, cb);
                return;
            }

            var pCRC32File = akra.io.fopen(sPath + ".crc32");

            pCRC32File.isExists(function (e, bExists) {
                if (e) {
                    return cb(e, null);
                }

                if (bExists) {
                    pCRC32File.read(function (e, data) {
                        if (parseInt(data) === pEntry.crc32) {
                            akra.logger.log("Skip unpacking for " + sPath + ".");
                            cb(null, sPath);
                        } else {
                            forceExtractARADependence(pEntry, sPath, cb);
                        }

                        pCRC32File.close();
                    });

                    return;
                }

                forceExtractARADependence(pEntry, sPath, cb);
            });
        }

        function loadARA(pEngine, pArchiveDep, cb) {
            var sArchivePath = pArchiveDep.path;

            //hash is required to create a unique path for the local file system
            //FIXME: md5 to slow for data URI files...
            var sArchiveHash = akra.crypto.md5(sArchivePath);
            var pArchive = null;

            //binary data obtained immediately from the DATA URI
            var pUri = null;
            var sBase64Data = null;

            if (akra.uri.parse(sArchivePath).getScheme() === "data:") {
                //data URI required cross-origin policy, and cannot be loaded with XMLHTTPRequest :(
                pUri = akra.uri.parseDataURI(sArchivePath);

                akra.logger.assert(pUri.base64, "only base64 decoded ARA resources supported.", sArchivePath);
                sBase64Data = pUri.data;
            } else {
                pArchive = akra.io.fopen(sArchivePath, 1 /* IN */ | 32 /* BIN */);
            }

            cb(pArchiveDep, 2 /* CHECKING */);

            /**
            * @param pARADeps Deps formed from archive.
            */
            var fnArchiveLoaded = function (pARADeps) {
                load(pEngine, pARADeps, null, function (e) {
                    if (e) {
                        return cb(pArchiveDep, 8 /* REJECTED */, e);
                    }

                    cb(pArchiveDep, 7 /* LOADED */, null);
                }, redirectProgress(pArchiveDep, cb));
            };

            var fnLoadArchive = function () {
                cb(pArchiveDep, 3 /* LOADING */);

                var fnZipReadedCallback = function (pZipReader) {
                    pZipReader.getEntries(function (pEntries) {
                        var pEntryMap = {};
                        var nTotal = 0;
                        var nUnpacked = 0;

                        for (var i = 0; i < pEntries.length; ++i) {
                            if (pEntries[i].directory)
                                continue;
                            pEntryMap[pEntries[i].filename] = pEntries[i];
                            nTotal++;
                        }

                        var pMapEntry = pEntryMap[ARA_INDEX];

                        akra.logger.assert(akra.isDefAndNotNull(pMapEntry), "ARA dependences found, but headers corrupted.");

                        pMapEntry.getData(new zip.TextWriter(), function (data) {
                            var pARADeps = JSON.parse(data);

                            var fnSuccesss = function (e, sLocalPath) {
                                if (e) {
                                    return cb(pArchiveDep, 8 /* REJECTED */, e);
                                }

                                nUnpacked++;

                                cb(pArchiveDep, 6 /* EXTRACTION */, { loaded: nUnpacked, total: nTotal });

                                // All .map dependencies unpacked??
                                if (nUnpacked < nTotal) {
                                    return;
                                }

                                //debug.info("%cDependences loaded: ", "color: green;", sArchivePath);
                                pZipReader.close();

                                //id data-uri used, archive is null
                                pArchive && pArchive.close();

                                fnArchiveLoaded(pARADeps);
                            };

                            normalize(pARADeps, "");
                            each(pARADeps, function (pDep) {
                                var sPath = pDep.path;
                                var pEntry = pEntryMap[sPath];

                                akra.logger.assert(akra.isDefAndNotNull(pEntry), "Cannot resolve dependence: " + sPath);
                                delete pEntryMap[sPath];

                                extractARADependence(pEntry, sArchiveHash, function (e, sLocalPath) {
                                    if (!akra.isDef(pDep.type)) {
                                        pDep.type = akra.path.parse(pDep.path).getExt();
                                    }

                                    pDep.path = sLocalPath;
                                    fnSuccesss(e, sLocalPath);
                                });
                            });

                            for (var sPath in pEntryMap) {
                                extractARADependence(pEntryMap[sPath], sArchiveHash, fnSuccesss);
                            }
                        });
                    });
                };

                var fnDataURIReaded = function (sBase64Data) {
                    cb(pArchiveDep, 5 /* UNPACKING */, 0.);

                    zip.createReader(new zip.Data64URIReader(sBase64Data), fnZipReadedCallback, function (e) {
                        cb(pArchiveDep, 8 /* REJECTED */, e);
                    });
                };

                var fnArchiveReadedCallback = function (e, pData) {
                    if (e) {
                        return cb(pArchiveDep, 8 /* REJECTED */, e);
                    }

                    cb(pArchiveDep, 5 /* UNPACKING */, 0.);

                    zip.createReader(new zip.ArrayBufferReader(pData), fnZipReadedCallback, function (e) {
                        cb(pArchiveDep, 8 /* REJECTED */, e);
                    });
                };

                if (pArchive) {
                    pArchive.read(fnArchiveReadedCallback, function (nLoaded, nTotal) {
                        cb(pArchiveDep, 4 /* DOWNLOADING */, { loaded: nLoaded, total: nTotal });
                    });
                } else {
                    cb(pArchiveDep, 4 /* DOWNLOADING */, { loaded: sBase64Data.length, total: sBase64Data.length });
                    fnDataURIReaded(sBase64Data);
                }
            };

            if (!akra.isNull(pArchive)) {
                //non data-uri cases
                pArchive.open(function (err, pMeta) {
                    if (FORCE_ETAG_CHECKING && CACHE_SUPPORTED) {
                        var pETag = akra.io.fopen(createARADLocalName(ETAG_FILE, sArchiveHash), 1 /* IN */ | 2 /* OUT */);

                        pETag.read(function (e, sETag) {
                            if (!akra.isNull(e) || !akra.isString(pMeta.eTag) || sETag !== pMeta.eTag) {
                                akra.logger.log(sArchivePath, "ETAG not verified. (given: " + pMeta.eTag + ") (expected: " + sETag + ")");

                                if (akra.isDefAndNotNull(pMeta.eTag)) {
                                    pETag.clear(function (e) {
                                        if (akra.isNull(e)) {
                                            pETag.write(pMeta.eTag);
                                        }
                                    });
                                }

                                fnLoadArchive();
                                return;
                            }

                            akra.logger.log(sArchivePath, "ETAG verified successfully!", sETag);

                            akra.io.fopen(createARADLocalName(ARA_INDEX, sArchiveHash), 1 /* IN */ | 128 /* JSON */).read(function (e, pMap) {
                                normalize(pMap, "");

                                each(pMap, function (pDep) {
                                    pDep.path = createARADLocalName(pDep.path, sArchiveHash);
                                });

                                fnArchiveLoaded(pMap);
                            });
                        });
                    } else {
                        fnLoadArchive();
                    }
                });
            } else {
                fnLoadArchive();
            }
        }
        deps.loadARA = loadARA;

        function loadDependencesLevel(pEngine, pDeps, fnDep) {
            var cb = fnDep;

            //walk single deps level
            each({ files: pDeps.files }, function (pDep) {
                cb(pDep, 1 /* INITIALIZATION */, null);
                var pDepEngine = findDepHandler(pDep);

                if (!akra.isDefAndNotNull(pDepEngine)) {
                    akra.logger.warn("dependence " + pDep.path + " unknown, and will be skipped.");
                    return;
                }

                pDepEngine.handler(pEngine, pDep, cb);
            });
        }

        addDependenceHandler(["ara"], null, loadARA);
        addDependenceHandler(["gr"], null, loadGrammar);
        addDependenceHandler(["fx", "afx"], function (pRmgr) {
            return pRmgr.getEffectDataPool();
        }, loadResource);
        addDependenceHandler(["jpeg", "jpg", "png", "gif", "bmp", "dds"], function (pRmgr) {
            return pRmgr.getImagePool();
        }, loadResource);
        addDependenceHandler(["dae"], function (pRmgr) {
            return pRmgr.getColladaPool();
        }, loadResource);
        addDependenceHandler(["obj"], function (pRmgr) {
            return pRmgr.getObjPool();
        }, loadResource);
        addDependenceHandler(["json"], null, loadJSON);
        addDependenceHandler(["bson"], null, loadBSON);
        addDependenceHandler(["txt"], null, loadCustom);
        addDependenceHandler(["map"], null, loadMap);

        /**
        * @param pEngine Engine instance.
        * @param pDeps Dependencies list.
        * @param sRoot Default root path for loading resources. (config.data for ex.)
        * @param fnLoaded All loaded?
        * @param fnStatusChanged
        */
        function load(pEngine, pDeps, sRoot, fnLoaded, fnProgress) {
            if (typeof fnProgress === "undefined") { fnProgress = function (e) {
            }; }
            normalize(pDeps, pDeps.root || sRoot);
            createResources(pEngine, pDeps);

            var pDepsPointer = findNotEmptyLevel(pDeps);

            var nTotalFiles = countFiles(pDeps);
            var iBeginTime = akra.time();

            var pProgress = {
                source: null,
                unpacked: 0,
                time: 0,
                loaded: 0,
                total: 0,
                bytesLoaded: 0,
                bytesTotal: 0
            };

            computeProperties(pDepsPointer, function (e, iBytesTotal) {
                if (e)
                    return fnLoaded(e, pDeps);

                if (akra.isNull(pDeps)) {
                    return fnLoaded(null, pDeps);
                }

                function countLoadedOnLevel(pDeps) {
                    var n = 0;
                    each({ files: pDeps.files }, function (pDep) {
                        if (pDep.stats.status === 7 /* LOADED */) {
                            n++;
                        }
                    });

                    return n;
                }

                /** @param pDep Dependence, which generates change in progress. */
                function notifyProgress(pDep) {
                    var nDeps = 0;
                    var nLoadedOnLevel = countLoadedOnLevel(pDeps);
                    var nLoaded = 0;
                    var fUnpacked = 0;
                    var iBytesLoaded = 0;
                    var iBytesTotal = 0;
                    var eStatus = pDep.stats.status;

                    each(pDeps, function (pDep) {
                        var pStats = pDep.stats;
                        iBytesLoaded += pStats.bytesLoaded;
                        fUnpacked += (pStats.unpacked || 0.) * 1.;
                        iBytesTotal += pStats.byteLength;
                        nDeps++;

                        if (pStats.status === 7 /* LOADED */) {
                            nLoaded++;
                        }
                    });

                    ///< Dependence, which generates change in progress.
                    pProgress.source = pDep;

                    pProgress.time = akra.time() - iBeginTime;

                    // prevent similar events
                    if (eStatus === 4 /* DOWNLOADING */ && pProgress.bytesLoaded == iBytesLoaded) {
                        return;
                    }

                    pProgress.bytesLoaded = iBytesLoaded;
                    pProgress.bytesTotal = iBytesTotal;

                    fUnpacked /= nTotalFiles;

                    // prevent similar events
                    if (eStatus === 5 /* UNPACKING */ && pProgress.unpacked == fUnpacked) {
                        return;
                    }

                    pProgress.unpacked = fUnpacked;

                    // prevent similar events
                    if (eStatus === 7 /* LOADED */ && pProgress.loaded == nLoaded) {
                        return;
                    }

                    pProgress.loaded = nLoaded;
                    pProgress.total = nTotalFiles;

                    fnProgress(pProgress);
                }

                function renotifyProgress(pDep) {
                    pProgress.source = pDep;
                    fnProgress(pProgress);
                }

                /** Watch deps states. */
                function depWatcher(pDep, eStatus, pData) {
                    if (eStatus === 9 /* INTERNAL_UPDATE */) {
                        renotifyProgress(pDep);
                        return;
                    }

                    pDep.stats.status = eStatus;

                    switch (eStatus) {
                        case 8 /* REJECTED */:
                            return fnLoaded(arguments[2], pDepsPointer);

                        case 4 /* DOWNLOADING */:
                            pDep.stats.bytesLoaded = arguments[2].loaded;
                            notifyProgress(pDep);
                            return;
                        case 5 /* UNPACKING */:
                            pDep.stats.unpacked = arguments[2] || 0.;
                            notifyProgress(pDep);
                            return;

                        case 6 /* EXTRACTION */:
                            pDep.stats.unpacked = arguments[2].loaded / arguments[2].total;
                            notifyProgress(pDep);
                            return;

                        case 7 /* LOADED */:
                            pDep.stats.bytesLoaded = pDep.stats.byteLength;
                            pDep.stats.unpacked = 1.;
                            pDep.content = arguments[2] || null;

                            notifyProgress(pDep);

                            //all loaded
                            if (countLoadedOnLevel(pDepsPointer) === countFilesOnLevel(pDepsPointer)) {
                                pDepsPointer = findNotEmptyLevel(pDepsPointer.deps);

                                if (pDepsPointer) {
                                    loadDependencesLevel(pEngine, pDepsPointer, depWatcher);
                                } else {
                                    fnLoaded(null, pDeps);
                                }
                            }

                            return;
                    }
                }

                loadDependencesLevel(pEngine, pDepsPointer, depWatcher);
            });
        }
        deps.load = load;

        function link(pParent, pChild) {
            while (akra.isDefAndNotNull(pParent.files)) {
                if (!akra.isDefAndNotNull(pParent.deps)) {
                    pParent.deps = pChild;
                    return pParent;
                }

                pParent = pParent.deps;
            }

            pParent.deps = pChild;
            return pParent;
        }
        deps.link = link;

        function createDependenceByPath(sPath, sType, sRoot) {
            return {
                root: sRoot,
                files: [{ path: sPath, type: sType }]
            };
        }
        deps.createDependenceByPath = createDependenceByPath;
    })(akra.deps || (akra.deps = {}));
    var deps = akra.deps;
})(akra || (akra = {}));
/// <reference path="ResourcePoolItem.ts" />
var akra;
(function (akra) {
    (function (pool) {
        function isVideoResource(pItem) {
            return !akra.isNull(pItem) && pItem.getResourceCode().getFamily() === 0 /* VIDEO_RESOURCE */;
        }
        pool.isVideoResource = isVideoResource;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="../../idl/ICollada.ts" />
var akra;
(function (akra) {
    (function (pool) {
        /// <reference path="../../idl/IMesh.ts" />
        /// <reference path="../../idl/IRenderDataCollection.ts" />
        /// <reference path="../../animation/Track.ts" />
        /// <reference path="../../animation/Animation.ts" />
        /// <reference path="../../animation/Controller.ts" />
        /// <reference path="../../animation/Blend.ts" />
        /// <reference path="../../scene/Node.ts" />
        /// <reference path="../../deps/deps.ts" />
        /// <reference path="../ResourcePoolItem.ts" />
        /// <reference path="../../math/math.ts" />
        /// <reference path="../../io/io.ts" />
        /// <reference path="../../conv/conv.ts" />
        /// <reference path="../../logger.ts" />
        /// <reference path="../../debug.ts" />
        /// <reference path="../pool.ts" />
        (function (resources) {
            var Mat4 = akra.math.Mat4;

            var Vec3 = akra.math.Vec3;
            var Vec4 = akra.math.Vec4;

            var Color = akra.color.Color;
            var VE = akra.data.VertexElement;

            /* COMMON FUNCTIONS
            ------------------------------------------------------
            */
            //function getSupportedFormat(sSemantic: string): IColladaUnknownFormat[];
            //function calcFormatStride(pFormat: IColladaUnknownFormat[]): int;
            // additional
            //function printArray(pArr: any[], nRow: uint, nCol: uint): string;
            //function sortArrayByProperty(pData: any[], sProperty: string): any[];
            //xml
            //function stringData(pXML: Element): string;
            //function attr(pXML: Element, sName: string): string;
            //function firstChild(pXML: Element, sTag?: string): Element;
            // globals
            var pSupportedVertexFormat;
            var pSupportedTextureFormat;
            var pSupportedColorFormat;
            var pSupportedWeightFormat;
            var pSupportedJointFormat;
            var pSupportedInvBindMatrixFormat;
            var pSupportedInterpolationFormat;
            var pSupportedInputFormat;
            var pSupportedOutputFormat;
            var pSupportedTangentFormat;

            var pFormatStrideTable;

            var Collada = (function (_super) {
                __extends(Collada, _super);
                function Collada() {
                    _super.call(this);
                    //=======================================================================================
                    this._pModel = null;
                    this._pOptions = {};
                    this._pLinks = {};
                    this._pLib = {};
                    this._pMeshCache = {};
                    this._pMaterialCache = {};
                    this._pAsset = null;
                    this._pVisualScene = null;
                    this._pAnimations = [];
                    this._sFilename = null;
                    this._pXMLDocument = null;
                    this._pXMLRoot = null;
                    this._iByteLength = 0;
                }
                Collada.prototype.getModelFormat = function () {
                    return 4096 /* COLLADA */;
                };

                // polygon index convertion
                Collada.prototype.getOptions = function () {
                    return this._pOptions;
                };

                Collada.prototype.getByteLength = function () {
                    return this._iByteLength;
                };

                Collada.prototype._setByteLength = function (iByteLength) {
                    this._iByteLength = iByteLength;
                };

                Collada.prototype.isShadowsEnabled = function () {
                    return this._pOptions.shadows;
                };

                Collada.prototype.trifanToTriangles = function (pXML, iStride) {
                    var pFans2Tri = [0, 0, 0];
                    var pData = [];
                    var tmp = new Array(iStride), n;
                    var pIndexes = [];

                    this.eachByTag(pXML, "p", function (pXMLData) {
                        n = akra.conv.stoia(stringData(pXMLData), pData);

                        for (var i = 0; i < 3; i++) {
                            akra.conv.retrieve(pData, tmp, iStride, i, 1);
                            for (var j = 0; j < iStride; ++j) {
                                pIndexes.push(tmp[j]);
                            }
                        }

                        for (var i = 3, m = n / iStride; i < m; i++) {
                            pFans2Tri[1] = i - 1;
                            pFans2Tri[2] = i;
                            for (var j = 0; j < pFans2Tri.length; ++j) {
                                for (var k = 0; k < iStride; ++k) {
                                    pIndexes.push(pData[pFans2Tri[j] * iStride + k]);
                                }
                            }
                        }

                        //filling changes back to COLLADA
                        //removing <p /> elements from <trifan /> element
                        pXML.removeChild(pXMLData);
                    });

                    return pIndexes;
                };

                Collada.prototype.polygonToTriangles = function (pXML, iStride) {
                    //TODO для невыпуклых многоугольников с самоперечечениями работать будет не верно
                    return this.trifanToTriangles(pXML, iStride);
                };

                Collada.prototype.tristripToTriangles = function (pXML, iStride) {
                    var pStrip2Tri = [0, 0, 0];
                    var pData = [];
                    var tmp = new Array(iStride), n;
                    var pIndexes = [];

                    this.eachByTag(pXML, "p", function (pXMLData) {
                        n = akra.conv.stoia(stringData(pXMLData), pData);

                        for (var i = 0; i < 3; i++) {
                            akra.conv.retrieve(pData, tmp, iStride, i, 1);
                            for (var j = 0; j < iStride; ++j) {
                                pIndexes.push(tmp[j]);
                            }
                        }

                        for (var i = 3, m = n / iStride; i < m; i++) {
                            pStrip2Tri[0] = i - 1;
                            pStrip2Tri[1] = i - 2;
                            pStrip2Tri[2] = i;
                            for (var j = 0; j < pStrip2Tri.length; ++j) {
                                for (var k = 0; k < iStride; ++k) {
                                    pIndexes.push(pData[pStrip2Tri[j] * iStride + k]);
                                }
                            }
                        }

                        //filling changes back to COLLADA
                        //removing <p /> elements from <tristrip /> element
                        pXML.removeChild(pXMLData);
                    });

                    return pIndexes;
                };

                Collada.prototype.polylistToTriangles = function (pXML, iStride) {
                    var pXMLvcount = firstChild(pXML, "vcount");
                    var pXMLp = firstChild(pXML, "p");
                    var pVcount = new Array(parseInt(attr(pXML, "count")));
                    var pData, pIndexes;
                    var n, h = 0;
                    var tmp = new Array(128);
                    var buf = new Array(256);
                    var pPoly2Tri = [0, 0, 0];

                    akra.conv.stoia(stringData(pXMLvcount), pVcount);

                    var nElements = 0, nTotalElement = 0;

                    for (var i = 0; i < pVcount.length; i++) {
                        nElements += pVcount[i];
                        nTotalElement += (pVcount[i] - 2) * 3;
                    }

                    pIndexes = new Array(iStride * nTotalElement);
                    pData = new Array(iStride * nElements);

                    akra.conv.stoia(stringData(pXMLp), pData);

                    for (var i = 0, m = 0; i < pVcount.length; i++) {
                        n = akra.conv.retrieve(pData, tmp, iStride, m, pVcount[i]);

                        for (var j = 0; j < 3; j++) {
                            akra.conv.retrieve(tmp, buf, iStride, j, 1);
                            for (var k = 0; k < iStride; ++k) {
                                pIndexes[h++] = buf[k];
                            }
                        }

                        for (var x = 3, t = n / iStride; x < t; x++) {
                            pPoly2Tri[1] = x - 1;
                            pPoly2Tri[2] = x;
                            for (var j = 0; j < pPoly2Tri.length; ++j) {
                                for (var k = 0; k < iStride; ++k) {
                                    pIndexes[h++] = pData[(m + pPoly2Tri[j]) * iStride + k];
                                }
                            }
                        }

                        m += pVcount[i];
                    }

                    //filling changes back to COLLADA
                    //removing <p />, <vcount /> elements from <polylist /> element
                    pXML.removeChild(pXMLvcount);
                    pXML.removeChild(pXMLp);

                    return pIndexes;
                };

                //xml
                Collada.prototype.eachNode = function (pXMLList, fnCallback, nMax) {
                    var n = pXMLList.length, i;
                    nMax = (akra.isNumber(nMax) ? (nMax < n ? nMax : n) : n);

                    n = 0;
                    i = 0;

                    while (n < pXMLList.length) {
                        //skip text nodes
                        if (pXMLList[n++].nodeType === Node.TEXT_NODE) {
                            continue;
                        }

                        var pXMLData = pXMLList[n - 1];
                        fnCallback.call(this, pXMLData, pXMLData.nodeName);

                        i++;

                        if (nMax === i) {
                            break;
                        }
                    }
                };

                Collada.prototype.eachChild = function (pXML, fnCallback) {
                    this.eachNode(pXML.childNodes, fnCallback);
                };

                Collada.prototype.eachByTag = function (pXML, sTag, fnCallback, nMax) {
                    this.eachNode(pXML.getElementsByTagName(sTag), fnCallback, nMax);
                };

                // akra additional functions
                Collada.prototype.findNode = function (pNodes, sNode, fnNodeCallback) {
                    if (typeof sNode === "undefined") { sNode = null; }
                    if (typeof fnNodeCallback === "undefined") { fnNodeCallback = null; }
                    var pNode = null;
                    var pRootJoint = null;

                    for (var i = pNodes.length - 1; i >= 0; i--) {
                        pNode = pNodes[i];

                        if (pNode === null) {
                            continue;
                        }

                        if (sNode && "#" + pNode.id === sNode) {
                            return pNode;
                        }

                        if (!akra.isNull(fnNodeCallback)) {
                            if (fnNodeCallback.call(this, pNode) === false) {
                                break;
                            }
                        }

                        if (pNode.childNodes) {
                            pRootJoint = this.findNode(pNode.childNodes, sNode, fnNodeCallback);

                            if (!akra.isNull(pRootJoint)) {
                                return pRootJoint;
                            }
                        }
                    }

                    return null;
                };

                // helper functions
                Collada.prototype.COLLADATranslateMatrix = function (pXML) {
                    var pData = new Array(3);

                    akra.conv.stofa(stringData(pXML), pData);

                    return (Vec3.temp(pData)).toTranslationMatrix();
                };

                Collada.prototype.COLLADARotateMatrix = function (pXML) {
                    var pData = new Array(4);

                    akra.conv.stofa(stringData(pXML), pData);

                    return (new Mat4(1)).rotateLeft(pData[3] * akra.math.RADIAN_RATIO, Vec3.temp(pData[0], pData[1], pData[2]));
                };

                Collada.prototype.COLLADAScaleMatrix = function (pXML) {
                    var pData = new Array(3);

                    akra.conv.stofa(stringData(pXML), pData);

                    return new Mat4(pData[0], pData[1], pData[2], 1.0);
                };

                Collada.prototype.COLLADAData = function (pXML) {
                    var sName = pXML.nodeName;
                    var sData = stringData(pXML);

                    switch (sName) {
                        case "boolean":
                            return akra.conv.stoa(sData, 1, "boolean");

                        case "int":
                            return akra.conv.stoa(sData, 1, "int");

                        case "float":
                            return akra.conv.stoa(sData, 1, "float");

                        case "float2":
                            return akra.conv.stoa(sData, 2, "float");

                        case "float3":
                            return akra.conv.stoa(sData, 3, "float");

                        case "float4":
                        case "color":
                            return akra.conv.stoa(sData, 4, "float");

                        case "rotate":
                            return this.COLLADARotateMatrix(pXML);

                        case "translate":
                            return this.COLLADATranslateMatrix(pXML);

                        case "scale":
                            return this.COLLADAScaleMatrix(pXML);

                        case "bind_shape_matrix":
                        case "matrix":
                            return (new Mat4(akra.conv.stoa(sData, 16, "float"), true)).transpose();

                        case "float_array":
                            return akra.conv.stoa(sData, parseInt(attr(pXML, "count")), "float", true);

                        case "int_array":
                            return akra.conv.stoa(sData, parseInt(attr(pXML, "count")), "int", true);

                        case "bool_array":
                            return akra.conv.stoa(sData, parseInt(attr(pXML, "count")), "boolean", true);

                        case "Name_array":
                        case "name_array":
                        case "IDREF_array":
                            return akra.conv.stoa(sData, parseInt(attr(pXML, "count")), "string", true);

                        case "sampler2D":
                            return this.COLLADASampler2D(pXML);

                        case "surface":
                            return this.COLLADASurface(pXML);

                        default:
                            akra.debug.error("unsupported COLLADA data type <" + sName + " />");
                    }
                    //return null;
                };

                Collada.prototype.COLLADAGetSourceData = function (pSource, pFormat) {
                    akra.logger.assert(akra.isDefAndNotNull(pSource), "<source /> with expected format ", pFormat, " not founded");

                    var nStride = calcFormatStride(pFormat);
                    var pTech = pSource.techniqueCommon;

                    akra.logger.assert(akra.isDefAndNotNull(pTech), "<source /> with id <" + pSource.id + "> has no <technique_common />");

                    var pAccess = pTech.accessor;
                    var isFormatSupported;

                    akra.debug.assert((pAccess.stride <= nStride), pAccess.stride + " / " + nStride);

                    akra.logger.assert(pAccess.stride <= nStride, "<source /> width id" + pSource.id + " has unsupported stride: " + pAccess.stride);

                    var fnUnsupportedFormatError = function () {
                        akra.logger.log("expected format: ", pFormat);
                        akra.logger.log("given format: ", pAccess.params);
                        akra.logger.error("accessor of <" + pSource.id + "> has unsupported format");
                    };

                    for (var i = 0; i < pAccess.params.length; ++i) {
                        isFormatSupported = false;

                        for (var f = 0; f < pFormat[i].name.length; ++f) {
                            if ((pAccess.params[i].name || "").toLowerCase() == (pFormat[i].name[f] || "").toLowerCase()) {
                                isFormatSupported = true;
                            }
                        }

                        if (!isFormatSupported) {
                            fnUnsupportedFormatError();
                        }

                        isFormatSupported = false;

                        for (var f = 0; f < pFormat[i].type.length; ++f) {
                            if (pAccess.params[i].type.toLowerCase() == pFormat[i].type[f].toLowerCase()) {
                                isFormatSupported = true;
                            }
                        }

                        if (!isFormatSupported) {
                            fnUnsupportedFormatError();
                        }
                    }

                    return pAccess.data;
                };

                // common
                // -----------------------------------------------------------
                Collada.prototype.COLLADATransform = function (pXML, id) {
                    var pTransform = {
                        sid: attr(pXML, "sid"),
                        transform: String(pXML.nodeName),
                        value: null
                    };

                    if (akra.isString(id) && akra.isDefAndNotNull(pTransform.sid)) {
                        this.link(id + "/" + pTransform.sid, pTransform);
                    } else {
                        this.link(id + "/" + pTransform.transform, pTransform);
                    }

                    var v4f, m4f;
                    var pData;

                    switch (pTransform.transform) {
                        case "rotate":
                            pData = new Array(4);
                            akra.conv.stofa(stringData(pXML), pData);
                            v4f = new Vec4(pData);
                            v4f.w *= akra.math.RADIAN_RATIO; /* to radians. */
                            pTransform.value = v4f;

                            break;

                        case "translate":
                        case "scale":
                            pData = new Array(3);
                            akra.conv.stofa(stringData(pXML), pData);
                            pTransform.value = new Vec3(pData);
                            break;

                        case "matrix":
                            m4f = new Mat4;
                            akra.conv.stofa(stringData(pXML), m4f.data);
                            m4f.transpose();
                            pTransform.value = m4f;

                            break;

                        default:
                            akra.logger.error("unsupported transform detected: " + pTransform.transform);
                    }

                    return pTransform;
                };

                Collada.prototype.COLLADANewParam = function (pXML) {
                    var _this = this;
                    var pParam = {
                        sid: attr(pXML, "sid"),
                        annotate: null,
                        semantics: null,
                        modifier: null,
                        value: null,
                        type: null
                    };

                    this.eachChild(pXML, function (pXMLData, sName) {
                        switch (sName) {
                            case "semantic":
                                pParam.semantics = stringData(pXMLData);
                                break;

                            case "modifier":
                                pParam.modifier = stringData(pXMLData);

                            case "annotate":
                                pParam.annotate = {
                                    name: attr(pXMLData, "name"),
                                    value: stringData(pXMLData)
                                };

                            case "float":
                            case "float2":
                            case "float3":
                            case "float4":
                            case "surface":
                            case "sampler2D":
                                pParam.type = sName;
                                pParam.value = _this.COLLADAData(pXMLData);
                                break;

                            default:
                                pParam.value = _this.COLLADAData(pXMLData);
                        }
                    });

                    this.link(pParam.sid, pParam);

                    return pParam;
                };

                Collada.prototype.COLLADAAsset = function (pXML) {
                    if (typeof pXML === "undefined") { pXML = firstChild(this.getXMLRoot(), "asset"); }
                    var pAsset = {
                        unit: {
                            meter: 1.0,
                            name: "meter"
                        },
                        upAxis: "Y_UP",
                        title: null,
                        created: null,
                        modified: null,
                        contributor: {
                            author: null,
                            authoringTool: null,
                            comments: null,
                            copyright: null,
                            sourceData: null
                        }
                    };

                    this.eachChild(pXML, function (pXMLNode, sName) {
                        var sValue = stringData(pXMLNode);

                        switch (sName) {
                            case "up_axis":
                                pAsset.upAxis = sValue;
                                break;

                            case "created":
                                pAsset.created = sValue;
                                break;

                            case "modified":
                                pAsset.modified = sValue;
                                break;

                            case "title":
                                pAsset.title = sValue;
                                break;

                            case "contributor":
                                break;

                            case "unit":
                                pAsset.unit.meter = parseFloat(attr(pXMLNode, "meter"));
                                pAsset.unit.name = attr(pXMLNode, "name");
                                break;
                        }
                    });

                    return this._pAsset = pAsset;
                };

                Collada.prototype.COLLADALibrary = function (pXML, pTemplate) {
                    var _this = this;
                    if (!akra.isDefAndNotNull(pXML)) {
                        return null;
                    }

                    var pLib = {};
                    var pData;
                    var sTag = pTemplate.element;
                    var iAutoId = 0;

                    pLib[sTag] = {};

                    akra.debug.info("read library <" + sTag + "/>");

                    this.eachChild(pXML, function (pXMLData, sName) {
                        if (sTag !== sName) {
                            return;
                        }

                        switch (sTag) {
                            case 'image':
                                pData = _this.COLLADAImage(pXMLData);
                                break;
                            case 'effect':
                                pData = _this.COLLADAEffect(pXMLData);
                                break;
                            case 'material':
                                pData = _this.COLLADAMaterial(pXMLData);
                                break;
                            case 'geometry':
                                pData = _this.COLLADAGeometrie(pXMLData);
                                break;
                            case 'controller':
                                pData = _this.COLLADAController(pXMLData);
                                break;
                            case 'camera':
                                pData = _this.COLLADACamera(pXMLData);
                                break;
                            case 'light':
                                pData = _this.COLLADALight(pXMLData);
                                break;
                            case 'visual_scene':
                                pData = _this.COLLADAVisualScene(pXMLData);
                                break;
                            case 'animation':
                                pData = _this.COLLADAAnimation(pXMLData);
                                break;
                        }

                        if (akra.isNull(pData)) {
                            return;
                        }

                        pLib[sTag][attr(pXMLData, 'id') || (sTag + "_" + (iAutoId++))] = pData;
                    });

                    return pLib;
                };

                // geometry
                Collada.prototype.COLLADAAccessor = function (pXML) {
                    var pAccessor = {
                        data: this.source(attr(pXML, "source")),
                        count: parseInt(attr(pXML, "count")),
                        stride: parseInt(attr(pXML, "stride") || "1"),
                        params: [],
                        xml: pXML
                    };

                    this.eachChild(pXML, function (pXMLData, sName) {
                        pAccessor.params.push({
                            name: attr(pXMLData, "name"),
                            type: attr(pXMLData, "type")
                        });
                    });

                    return pAccessor;
                };

                //dangerous: the default offset is 0, but collada required this attribute
                Collada.prototype.COLLADAInput = function (pXML, iOffset) {
                    if (typeof iOffset === "undefined") { iOffset = 0; }
                    var pInput = {
                        semantics: attr(pXML, "semantic"),
                        source: this.source(attr(pXML, "source")),
                        offset: -1,
                        set: attr(pXML, "set"),
                        xml: pXML
                    };

                    if (!akra.isNull(attr(pXML, "offset"))) {
                        pInput.offset = parseInt(attr(pXML, "offset"));
                    }

                    if (akra.isInt(iOffset) && pInput.offset === -1) {
                        pInput.offset = iOffset;
                    }

                    akra.debug.assert(akra.isInt(pInput.offset) && pInput.offset >= 0, "invalid offset detected");

                    return pInput;
                };

                Collada.prototype.COLLADATechniqueCommon = function (pXML) {
                    var _this = this;
                    var pTechniqueCommon = {
                        accessor: null,
                        perspective: null
                    };

                    this.eachChild(pXML, function (pXMLData, sName) {
                        switch (sName) {
                            case "accessor":
                                pTechniqueCommon.accessor = _this.COLLADAAccessor(pXMLData);
                                break;
                            case "perspective":
                                pTechniqueCommon.perspective = _this.COLLADAPerspective(pXMLData);
                                break;
                        }
                    });

                    return pTechniqueCommon;
                };

                Collada.prototype.COLLADASource = function (pXML) {
                    var _this = this;
                    var pSource = {
                        id: attr(pXML, "id"),
                        name: attr(pXML, "name"),
                        array: {},
                        techniqueCommon: null,
                        xml: pXML
                    };

                    this.link(pSource);

                    this.eachChild(pXML, function (pXMLData, sName) {
                        var pColladaArray;
                        var id;

                        switch (sName.toLowerCase()) {
                            case "int_array":
                            case "bool_array":
                            case "float_array":
                            case "idref_array":
                            case "name_array":
                                pColladaArray = _this.COLLADAData(pXMLData);

                                id = attr(pXMLData, "id");
                                pSource.array[id] = pColladaArray;

                                _this.link(id, pColladaArray);

                                break;
                            case "technique_common":
                                pSource.techniqueCommon = _this.COLLADATechniqueCommon(pXMLData);
                                break;
                        }
                    });

                    return pSource;
                };

                Collada.prototype.COLLADAVertices = function (pXML) {
                    var pVertices = {
                        id: attr(pXML, "id"),
                        inputs: {}
                    };

                    this.eachByTag(pXML, "input", function (pXMLData) {
                        var sSemantic = attr(pXMLData, "semantic");
                        pVertices.inputs[sSemantic] = this.COLLADAInput(pXMLData);
                    });

                    akra.debug.assert(akra.isDefAndNotNull(pVertices.inputs["POSITION"]), "semantics POSITION must be in the <vertices /> tag");

                    this.link(pVertices);

                    return pVertices;
                };

                Collada.prototype.COLLADAJoints = function (pXML) {
                    var _this = this;
                    var pJoints = {
                        inputs: {}
                    };

                    var pMatrixArray;
                    var iCount;
                    var pInvMatrixArray;

                    this.eachByTag(pXML, "input", function (pXMLData) {
                        switch (attr(pXMLData, "semantic")) {
                            case "JOINT":
                                pJoints.inputs["JOINT"] = _this.COLLADAInput(pXMLData);
                                break;

                            case "INV_BIND_MATRIX":
                                pJoints.inputs["INV_BIND_MATRIX"] = _this.COLLADAInput(pXMLData);

                                break;

                            default:
                                akra.logger.error("semantics are different from JOINT/INV_BIND_MATRIX is not supported in the <joints /> tag");
                        }
                    });

                    for (var sInput in pJoints.inputs) {
                        this.prepareInput(pJoints.inputs[sInput]);

                        if (sInput === "INV_BIND_MATRIX") {
                            pInvMatrixArray = new Float32Array(pJoints.inputs[sInput].array);
                            iCount = pInvMatrixArray.length / 16;
                            pMatrixArray = new Array(iCount);

                            for (var j = 0, n = 0; j < pInvMatrixArray.length; j += 16) {
                                pMatrixArray[n++] = (new Mat4(new Float32Array(pInvMatrixArray.buffer, j * Float32Array.BYTES_PER_ELEMENT, 16), true)).transpose();
                            }

                            pJoints.inputs[sInput].array = pMatrixArray;
                        }
                    }

                    return pJoints;
                };

                //this means, that all inputs in polygons tag has same index.
                Collada.isSingleIndexedPolygons = function (pPolygons) {
                    for (var i = 0; i < pPolygons.inputs.length; ++i) {
                        if (i != pPolygons.inputs.length - 1 && pPolygons.inputs[i].offset !== pPolygons.inputs[i + 1].offset) {
                            return false;
                        }
                    }

                    return true;
                };

                Collada.prototype.COLLADAPolygons = function (pXML, sType) {
                    var _this = this;
                    var pPolygons = {
                        inputs: [],
                        p: null,
                        material: attr(pXML, "material"),
                        name: null,
                        count: parseInt(attr(pXML, "count")),
                        xml: pXML
                    };

                    var iOffset = 0, n = 0;
                    var iCount = parseInt(attr(pXML, "count"));
                    var iStride = 0;

                    //filling changes back to COLLADA
                    //preparing origin node
                    var pOriginPolygons = this.isCOLLADAChangesTracingEnabled() ? pXML.cloneNode(true) : null;

                    this.eachByTag(pXML, "input", function (pXMLData) {
                        pPolygons.inputs.push(_this.COLLADAInput(pXMLData, iOffset));
                        iOffset++;
                    });

                    sortArrayByProperty(pPolygons.inputs, "iOffset");

                    for (var i = 0; i < pPolygons.inputs.length; ++i) {
                        var pInput = pPolygons.inputs[i];
                        iStride = akra.math.max(pInput.offset + 1, iStride);
                    }

                    akra.debug.assert(iStride > 0, "Invalid offset detected.");

                    switch (sType) {
                        case "polylist":
                            pPolygons.p = this.polylistToTriangles(pXML, iStride);
                            break;

                        case "polygons":
                            pPolygons.p = this.polygonToTriangles(pXML, iStride);

                            this.eachByTag(pXML, "ph", function (pXMLData) {
                                akra.debug.error("unsupported polygon[polygon] subtype founded: <ph>");
                            });

                            break;

                        case "triangles":
                            pPolygons.p = new Array(3 * iCount * iStride);

                            this.eachByTag(pXML, "p", function (pXMLData) {
                                n += akra.conv.stoia(stringData(pXMLData), pPolygons.p, n);
                            });

                            break;
                        case "trifans":
                            pPolygons.p = this.trifanToTriangles(pXML, iStride);
                            break;

                        case "tristrips":
                            pPolygons.p = this.tristripToTriangles(pXML, iStride);
                            break;

                        default:
                            akra.logger.error("unsupported polygon[" + sType + "] type founded");
                    }

                    if (sType !== "triangles") {
                        //filling changes back to COLLADA
                        pXML.tagName = "triangles";
                        pXML.setAttribute("count", String(pPolygons.p.length / 3));

                        var pXMLp = akra.conv.parseHTML("<p></p>")[0];
                        pXMLp.textContent = pPolygons.p.join(" ");
                        pXMLp.removeAttribute("xmlns"); //to clerify output

                        pXML.appendChild(pXMLp);

                        this.COLLADANodeChanged(pOriginPolygons, pXML);
                        //end of chages
                    }

                    if (!akra.isDef(pPolygons.type)) {
                        pPolygons.type = 4 /* TRIANGLELIST */;
                    }

                    return pPolygons;
                };

                Collada.prototype.COLLADAVertexWeights = function (pXML) {
                    var _this = this;
                    var pVertexWeights = {
                        count: parseInt(attr(pXML, "count")),
                        inputs: [],
                        weightInput: null,
                        vcount: null,
                        v: null
                    };

                    var iOffset = 0;
                    var pInput;

                    this.eachByTag(pXML, "input", function (pXMLData) {
                        pInput = _this.COLLADAInput(pXMLData, iOffset);

                        if (pInput.semantics === "WEIGHT") {
                            pVertexWeights.weightInput = pInput;
                        }

                        pVertexWeights.inputs.push(pInput);
                        iOffset++;
                    });

                    var pVcountData, pVData;

                    pVcountData = new Array(pVertexWeights.count);
                    akra.conv.stoia(stringData(firstChild(pXML, "vcount")), pVcountData);
                    pVertexWeights.vcount = pVcountData;

                    var n = 0;

                    for (var i = 0; i < pVcountData.length; ++i) {
                        n += pVcountData[i];
                    }

                    n *= pVertexWeights.inputs.length;

                    akra.logger.assert(pVertexWeights.inputs.length === 2, "more than 2 inputs in <vertex_weights/> not supported currently");

                    pVData = new Array(n);
                    akra.conv.stoia(stringData(firstChild(pXML, "v")), pVData);
                    pVertexWeights.v = pVData;

                    return pVertexWeights;
                };

                Collada.prototype.COLLADAMesh = function (pXML) {
                    var _this = this;
                    var pMesh = {
                        sources: [],
                        polygons: []
                    };

                    var id;
                    var pPolygons, pVertices, pPos;

                    this.eachChild(pXML, function (pXMLData, sName) {
                        switch (sName) {
                            case "source":
                                pMesh.sources.push(_this.COLLADASource(pXMLData));
                                break;

                            case "vertices":
                                pVertices = _this.COLLADAVertices(pXMLData);
                                break;

                            case "lines":
                            case "linestrips":
                            case "tristrips":
                            case "trifans":
                            case "triangles":
                            case "polygons":
                            case "polylist":
                                pPolygons = _this.COLLADAPolygons(pXMLData, sName);

                                for (var i = 0; i < pPolygons.inputs.length; ++i) {
                                    pPos = null;

                                    if (pPolygons.inputs[i].semantics == "VERTEX") {
                                        if (pPolygons.inputs[i].source.id == pVertices.id) {
                                            pPos = pVertices.inputs["POSITION"];

                                            pPolygons.inputs[i].source = pPos.source;
                                            pPolygons.inputs[i].semantics = pPos.semantics;
                                        } else {
                                            akra.logger.error("<input /> with semantic VERTEX must refer to <vertices /> tag in same mesh.");
                                        }
                                    }

                                    _this.prepareInput(pPolygons.inputs[i]);
                                }

                                pMesh.polygons.push(pPolygons);
                                break;
                        }
                    });

                    return pMesh;
                };

                Collada.isCOLLADAMeshOptimized = function (pMesh) {
                    var pPolyGroup = pMesh.polygons;

                    return !pPolyGroup.some(function (pPolygons) {
                        return !Collada.isSingleIndexedPolygons(pPolygons);
                    });
                };

                Collada.prototype.optimizeCOLLADAMesh = function (pMesh) {
                    var _this = this;
                    var pPolyGroup = pMesh.polygons;

                    var pHashIndices = {};

                    //map: data semantics -> data(any[])
                    var pUnpackedData = {};
                    var pF32UnpackedData = {};
                    var iLastIndex = 0;

                    pPolyGroup.forEach(function (pPolygons, n) {
                        var pUnpackedIndices = [];

                        //number of indexes
                        var iStep = pPolygons.inputs.last.offset + 1;

                        //total sets of indexes
                        var iCount = pPolygons.p.length / iStep;

                        for (var i = 0; i < pPolygons.p.length; i += iStep) {
                            //calculation string hash key for set of indices
                            var sHash = "" + pPolygons.p[i];

                            for (var t = 1; t < iStep; ++t) {
                                sHash += "/" + pPolygons.p[i + t];
                            }

                            //check key in hash map
                            if (sHash in pHashIndices) {
                                pUnpackedIndices.push(pHashIndices[sHash]);
                            } else {
                                for (var j = 0; j < pPolygons.inputs.length; ++j) {
                                    var pInput = pPolygons.inputs[j];

                                    //index value in current set
                                    var iIndex = pPolygons.p[i + pInput.offset];

                                    //semantics of data for current index
                                    //	like: POSITION, NORMAL, ...
                                    var sSemantic = pInput.semantics;

                                    //number of components in data by current index
                                    //	for example: 3(typically) for POSITION, NORMAL
                                    //				 2 for UV
                                    var iStride = pInput.accessor.stride;

                                    if (!akra.isDefAndNotNull(pUnpackedData[sSemantic])) {
                                        pUnpackedData[sSemantic] = [];
                                    }

                                    //original cleaned data of <source /> linked with current <input />
                                    var pSrc = pInput.array;
                                    var pDest = pUnpackedData[sSemantic];

                                    for (var k = 0; k < iStride; ++k) {
                                        pDest.push(pSrc[(iIndex * iStride) + k]);
                                    }
                                }

                                // add the newly created vertex to the list of indices
                                pHashIndices[sHash] = iLastIndex;
                                pUnpackedIndices.push(iLastIndex);

                                // increment the counter
                                iLastIndex += 1;
                            }
                        }

                        //substitude all previous data with unpacked analogue
                        //subst indices
                        pPolygons.p = pUnpackedIndices;

                        //filling changes back to COLLADA
                        var pXMLPolygons = firstChild(pPolygons.xml, "p");
                        var pOriginXMLPolygons = _this.isCOLLADAChangesTracingEnabled() ? pXMLPolygons.cloneNode(true) : null;
                        ;

                        pXMLPolygons.textContent = pUnpackedIndices.join(" ");

                        _this.COLLADANodeChanged(pOriginXMLPolygons, pXMLPolygons);
                    });

                    Object.keys(pUnpackedData).forEach(function (sSemantics) {
                        //TODO: add support for non-float32 arrays
                        pF32UnpackedData[sSemantics] = (new Float32Array(pUnpackedData[sSemantics]));
                    });

                    //after all indexes recalculated, replacing data.
                    pPolyGroup.forEach(function (pPolygons, n) {
                        for (var j = 0; j < pPolygons.inputs.length; ++j) {
                            var pInput = pPolygons.inputs[j];

                            pInput.offset = 0;
                            pInput.array = pF32UnpackedData[pInput.semantics];

                            //filling changes back to COLLADA
                            var pOriginXMLInput = _this.isCOLLADAChangesTracingEnabled() ? pInput.xml.cloneNode(true) : null;

                            pInput.xml.setAttribute("offset", String(0));

                            _this.COLLADANodeChanged(pOriginXMLInput, pInput.xml);

                            var pXMLFloatArray = firstChild(pInput.source.xml, "float_array");

                            var pOriginXMLFloatArray = _this.isCOLLADAChangesTracingEnabled() ? pXMLFloatArray.cloneNode(true) : null;

                            pXMLFloatArray.textContent = pUnpackedData[pInput.semantics].join(" ");

                            var iLength = pUnpackedData[pInput.semantics].length;
                            pXMLFloatArray.setAttribute("count", String(iLength));

                            _this.COLLADANodeChanged(pOriginXMLFloatArray, pXMLFloatArray);

                            var pOriginXMLAccessor = _this.isCOLLADAChangesTracingEnabled() ? pInput.accessor.xml.cloneNode(true) : null;

                            pInput.accessor.xml.setAttribute("count", String(iLength / pInput.accessor.stride));

                            _this.COLLADANodeChanged(pOriginXMLAccessor, pInput.accessor.xml);
                            //pInput.source.xml.parentNode.removeChild(pInput.source.xml);
                        }
                    });

                    return pMesh;
                };

                Collada.prototype.COLLADANodeChanged = function (pBefore, pAfter) {
                    //console.log(pBefore, "==>", pAfter);
                };

                //надо ли отправлять варианты BEFORE и AFTER в функцию COLLADANodeChanged
                //для валидации
                Collada.prototype.isCOLLADAChangesTracingEnabled = function () {
                    return false;
                };

                Collada.prototype.COLLADAGeometrie = function (pXML) {
                    var pGeometrie = {
                        id: attr(pXML, "id"),
                        name: attr(pXML, "name"),
                        mesh: null,
                        convexMesh: null,
                        spline: null
                    };

                    var pXMLData = firstChild(pXML);
                    var sName = pXMLData.nodeName;

                    if (sName == "mesh") {
                        pGeometrie.mesh = this.COLLADAMesh(pXMLData);
                    }

                    this.link(pGeometrie);

                    return pGeometrie;
                };

                Collada.prototype.COLLADASkin = function (pXML) {
                    var _this = this;
                    var pSkin = {
                        shapeMatrix: this.COLLADAData(firstChild(pXML, "bind_shape_matrix")),
                        sources: [],
                        geometry: this.source(attr(pXML, "source")),
                        joints: null,
                        vertexWeights: null
                    };

                    var pVertexWeights, pInput;

                    this.eachChild(pXML, function (pXMLData, sName) {
                        switch (sName) {
                            case "source":
                                pSkin.sources.push(_this.COLLADASource(pXMLData));
                                break;

                            case "joints":
                                pSkin.joints = _this.COLLADAJoints(pXMLData);
                                break;

                            case "vertex_weights":
                                pVertexWeights = _this.COLLADAVertexWeights(pXMLData);

                                for (var i = 0; i < pVertexWeights.inputs.length; ++i) {
                                    pInput = _this.prepareInput(pVertexWeights.inputs[i]);
                                }

                                pSkin.vertexWeights = pVertexWeights;
                                break;
                        }
                    });

                    return pSkin;
                };

                Collada.prototype.COLLADAController = function (pXML) {
                    var pController = {
                        name: attr(pXML, "name"),
                        id: attr(pXML, "id"),
                        skin: null,
                        morph: null
                    };

                    var pXMLData = firstChild(pXML, "skin");

                    if (!akra.isNull(pXMLData)) {
                        pController.skin = this.COLLADASkin(pXMLData);
                    } else {
                        akra.debug.warn("Founded controller without skin element!");
                        return null;
                    }

                    this.link(pController);

                    return pController;
                };

                // images
                Collada.prototype.COLLADAImage = function (pXML) {
                    var pImage = {
                        id: attr(pXML, "id"),
                        name: attr(pXML, "name"),
                        format: attr(pXML, "format"),
                        height: parseInt(attr(pXML, "height") || "-1"),
                        width: parseInt(attr(pXML, "width") || "-1"),
                        depth: 1,
                        data: null,
                        path: null
                    };

                    var sFilename = this.getFilename();
                    var sPath = null;
                    var pXMLInitData = firstChild(pXML, "init_from"), pXMLData;

                    if (akra.isDefAndNotNull(pXMLInitData)) {
                        sPath = stringData(pXMLInitData);

                        if (akra.uri.parse(sFilename).getScheme() === "blob:") {
                            pImage.path = akra.deps.resolve(sPath, sFilename);
                        } else {
                            //modify path to the textures relative to a given file
                            // if (!isNull(sFilename)) {
                            //     if (!path.info(sPath).isAbsolute()) {
                            //         sPath = path.info(sFilename).dirname + "/" + sPath;
                            //     }
                            // }
                            // console.log("collada deps image: ", path.normalize(sPath));
                            // pImage.path = path.normalize(sPath);
                            pImage.path = akra.uri.resolve(sPath, sFilename);
                            // console.log("collada deps image >>> ", pImage.path);
                        }
                    } else if (akra.isDefAndNotNull(pXMLData = firstChild(pXML, "data"))) {
                        akra.logger.error("image loading from <data /> tag unsupported yet.");
                    } else {
                        akra.logger.error("image with id: " + pImage.id + " has no data.");
                    }

                    this.link(pImage);

                    return pImage;
                };

                // effects
                Collada.prototype.COLLADASurface = function (pXML) {
                    var pSurface = {
                        initFrom: stringData(firstChild(pXML, "init_from"))
                    };

                    return pSurface;
                };

                Collada.prototype.COLLADATexture = function (pXML) {
                    if (!akra.isDefAndNotNull(pXML)) {
                        return null;
                    }

                    var pTexture = {
                        texcoord: attr(pXML, "texcoord"),
                        sampler: this.source(attr(pXML, "texture")),
                        surface: null,
                        image: null
                    };

                    if (!akra.isNull(pTexture.sampler) && akra.isDefAndNotNull(pTexture.sampler.value)) {
                        pTexture.surface = this.source(pTexture.sampler.value.source);
                    }

                    if (!akra.isNull(pTexture.surface)) {
                        var pImage = this.source(pTexture.surface.value.initFrom);
                        pTexture.image = pImage;

                        akra.debug.info("Load texture " + pImage.path + ".");

                        var pTex = this.getManager().getTexturePool().loadResource(pImage.path);

                        if (this.findRelatedResources(1 /* LOADED */).indexOf(pTex) === -1) {
                            this.sync(pTex, 1 /* LOADED */);
                        }

                        //FIX THIS
                        pTex.setFilter(10240 /* MAG_FILTER */, 9729 /* LINEAR */);
                        pTex.setFilter(10241 /* MIN_FILTER */, 9987 /* LINEAR_MIPMAP_LINEAR */);

                        pTex.setWrapMode(10242 /* WRAP_S */, 10497 /* REPEAT */);
                        pTex.setWrapMode(10243 /* WRAP_T */, 10497 /* REPEAT */);
                    }

                    return pTexture;
                };

                Collada.prototype.COLLADASampler2D = function (pXML) {
                    var pSampler = {
                        source: stringData(firstChild(pXML, "source")),
                        wrapS: stringData(firstChild(pXML, "wrap_s")),
                        wrapT: stringData(firstChild(pXML, "wrap_t")),
                        minFilter: stringData(firstChild(pXML, "minfilter")),
                        mipFilter: stringData(firstChild(pXML, "mipfilter")),
                        magFilter: stringData(firstChild(pXML, "magfilter"))
                    };

                    return pSampler;
                };

                Collada.prototype.COLLADAPhong = function (pXML) {
                    var _this = this;
                    var pMat = {
                        diffuse: new Color(0.),
                        specular: new Color(0.),
                        ambient: new Color(0.),
                        emissive: new Color(0.),
                        shininess: .5 / 128.,
                        reflective: new Color(0.),
                        reflectivity: 0.0,
                        transparent: new Color(0.),
                        transparency: 1.0,
                        indexOfRefraction: 0.0,
                        textures: {
                            diffuse: null,
                            specular: null,
                            ambient: null,
                            emissive: null,
                            normal: null,
                            shininess: null
                        },
                        material: null,
                        xml: pXML
                    };

                    var pXMLData;
                    var pList = Collada.COLLADA_MATERIAL_NAMES;

                    for (var i = 0; i < pList.length; i++) {
                        var csComponent = pList[i];

                        pXMLData = firstChild(pXML, csComponent);

                        //emission --> emissive
                        //emission does not exists in akra engine materials
                        if (csComponent === "emission") {
                            csComponent = "emissive";
                        }

                        if (pXMLData) {
                            this.eachChild(pXMLData, function (pXMLData, sName) {
                                switch (sName) {
                                    case "float":
                                        pMat[csComponent] = _this.COLLADAData(pXMLData);
                                        break;

                                    case "color":
                                        pMat[csComponent].set(_this.COLLADAData(pXMLData));
                                        break;

                                    case "texture":
                                        pMat.textures[csComponent] = _this.COLLADATexture(pXMLData);
                                }
                            });
                        }
                    }

                    // correct shininess
                    //pMat.shininess *= 10.0;
                    return pMat;
                };

                Collada.prototype.COLLADAEffectTechnique = function (pXML) {
                    var pTech = {
                        sid: attr(pXML, "sid"),
                        type: null,
                        value: null
                    };

                    var pValue = firstChild(pXML);
                    var pMat = null;

                    pTech.type = pValue.nodeName;

                    switch (pTech.type) {
                        case "blinn":
                        case "lambert":

                        case "phong":
                            pMat = this.COLLADAPhong(pValue);
                            break;

                        default:
                            akra.logger.error("unsupported technique <" + pTech.type + " /> founded");
                    }

                    switch (pTech.type) {
                        case "phong":
                            akra.debug.assert(pMat.shininess <= 128. && pMat.shininess >= 0., "Invalid shininess value in collada phong material(" + pMat.name + ") - " + pMat.shininess + ". Expected value in the range from 0. to 128.");
                            pMat.shininess = akra.math.clamp(pMat.shininess, 0., 128.) / 128.;
                            break;
                        case "blinn":
                            if (!(pMat.shininess <= 1. && pMat.shininess >= 0.)) {
                                akra.debug.warn("Invalid shininess value in collada blinn material(" + pMat.name + ") - " + pMat.shininess + ". Expected value in the range from 0. to 1..");
                            }
                            pMat.shininess = akra.math.clamp(pMat.shininess, 0., 1.);
                            break;
                    }

                    pTech.value = pMat;

                    //finding normal maps like this
                    /*
                    <technique profile=​"OpenCOLLADA3dsMax">
                    <bump bumptype=​"HEIGHTFIELD">
                    <texture texture=​"Default_Material_normals2_png-sampler" texcoord=​"CHANNEL1">​</texture>
                    </bump>
                    </technique>
                    */
                    var pXMLExtra = firstChild(pXML, "extra");

                    if (akra.isDefAndNotNull(pXMLExtra)) {
                        var pXMLTech = firstChild(pXMLExtra, "technique");
                        if (akra.isDefAndNotNull(pXMLTech)) {
                            var pXMLBump = firstChild(pXMLTech, "bump");
                            if (akra.isDefAndNotNull(pXMLBump) && attr(pXMLBump, "bumptype") === "HEIGHTFIELD") {
                                pTech.value.textures.normal = this.COLLADATexture(firstChild(pXMLBump, "texture"));
                            }
                        }
                    }

                    this.link(pTech.sid, pTech);

                    return pTech;
                };

                Collada.prototype.COLLADAProfileCommon = function (pXML) {
                    var _this = this;
                    var pProfile = {
                        technique: null,
                        newParam: {}
                    };

                    this.eachByTag(pXML, "newparam", function (pXMLData) {
                        pProfile.newParam[attr(pXMLData, "sid")] = _this.COLLADANewParam(pXMLData);
                    });

                    pProfile.technique = this.COLLADAEffectTechnique(firstChild(pXML, "technique"));

                    return pProfile;
                };

                Collada.prototype.COLLADAEffect = function (pXML) {
                    var _this = this;
                    var pEffect = {
                        id: attr(pXML, "id"),
                        profileCommon: null
                    };

                    this.eachChild(pXML, function (pXMLData, sName) {
                        switch (sName.toLowerCase()) {
                            case "profile_common":
                                pEffect.profileCommon = _this.COLLADAProfileCommon(pXMLData);
                                pEffect.profileCommon.technique.value.name = pEffect.id;
                                break;
                            default:
                                akra.debug.warn("<" + sName + " /> unsupported in effect section");
                        }
                    });

                    this.link(pEffect);

                    return pEffect;
                };

                //materials
                Collada.prototype.COLLADAMaterial = function (pXML) {
                    var pMaterial = {
                        id: attr(pXML, "id"),
                        name: attr(pXML, "name"),
                        instanceEffect: this.COLLADAInstanceEffect(firstChild(pXML, "instance_effect")),
                        xml: pXML
                    };

                    this.link(pMaterial);

                    return pMaterial;
                };

                // scene
                Collada.prototype.COLLADANode = function (pXML, iDepth) {
                    var _this = this;
                    if (typeof iDepth === "undefined") { iDepth = 0; }
                    var pNode = {
                        id: attr(pXML, "id"),
                        sid: attr(pXML, "sid"),
                        name: attr(pXML, "name") || "unknown",
                        type: attr(pXML, "type"),
                        layer: attr(pXML, "layer"),
                        transform: new Mat4(1),
                        geometry: [],
                        controller: [],
                        childNodes: [],
                        camera: [],
                        depth: iDepth,
                        transforms: [],
                        constructedNode: null
                    };

                    var m4fMatrix;
                    var sType;
                    var id, sid;

                    this.link(pNode);

                    this.eachChild(pXML, function (pXMLData, sName) {
                        switch (sName) {
                            case "rotate":
                            case "matrix":
                            case "translate":
                            case "scale":
                                pNode.transforms.push(_this.COLLADATransform(pXMLData, pNode.id));
                                pNode.transform.multiply(_this.COLLADAData(pXMLData));
                                break;

                            case "instance_geometry":
                                pNode.geometry.push(_this.COLLADAInstanceGeometry(pXMLData));
                                break;

                            case "instance_controller":
                                pNode.controller.push(_this.COLLADAInstanceController(pXMLData));
                                break;

                            case "instance_camera":
                                pNode.camera.push(_this.COLLADAInstanceCamera(pXMLData));
                                break;

                            case "node":
                                pNode.childNodes.push(_this.COLLADANode(pXMLData, iDepth + 1));
                                break;
                        }
                    });

                    //TODO: do not load empty nodes..
                    // if (!pNode.pGeometry.length &&
                    //     !pNode.pController.length &&
                    //     !pNode.pChildNodes.length) {
                    //     return null;
                    // }
                    return pNode;
                };

                Collada.prototype.COLLADAVisualScene = function (pXML) {
                    var _this = this;
                    var pNode;
                    var pScene = {
                        id: attr(pXML, "id"),
                        name: attr(pXML, "name"),
                        nodes: []
                    };

                    this.link(pScene);

                    this.eachChild(pXML, function (pXMLData, sName) {
                        switch (sName) {
                            case "node":
                                pNode = _this.COLLADANode(pXMLData);

                                if (akra.isDefAndNotNull(pNode)) {
                                    pScene.nodes.push(pNode);
                                }

                                break;
                        }
                    });

                    akra.debug.info("visual scene loaded.");

                    return pScene;
                };

                Collada.prototype.COLLADABindMaterial = function (pXML) {
                    var _this = this;
                    if (!akra.isDefAndNotNull(pXML)) {
                        return null;
                    }

                    var pMaterials = {};
                    var pMat = null;
                    var pSourceMat = null;
                    var pTech = firstChild(pXML, "technique_common");

                    this.eachByTag(pTech, "instance_material", function (pInstMat) {
                        pSourceMat = _this.source(attr(pInstMat, "target"));

                        pMat = {
                            // url         : pSourceMat.instanceEffect.url,
                            target: attr(pInstMat, "target"),
                            symbol: attr(pInstMat, "symbol"),
                            material: pSourceMat,
                            vertexInput: {}
                        };

                        _this.eachByTag(pInstMat, "bind_vertex_input", function (pXMLVertexInput) {
                            var sInputSemantic = attr(pXMLVertexInput, "input_semantic");

                            if (sInputSemantic !== "TEXCOORD") {
                                akra.logger.error("unsupported vertex input semantics founded: " + sInputSemantic);
                            }

                            var sSemantic = attr(pXMLVertexInput, "semantic");
                            var iInputSet = parseInt(attr(pXMLVertexInput, "input_set"));

                            pMat.vertexInput[sSemantic] = {
                                semantics: sSemantic,
                                inputSet: iInputSet,
                                inputSemantic: sInputSemantic
                            };
                        });

                        pMaterials[pMat.symbol] = pMat;
                    });

                    return pMaterials;
                };

                Collada.prototype.COLLADAInstanceEffect = function (pXML) {
                    var _this = this;
                    var pInstance = {
                        parameters: {},
                        techniqueHint: {},
                        effect: null
                    };

                    /*
                    Exmaple for <instance_effect /> :
                    
                    <instance_effect url="CarPaint">
                    <technique_hint profile="CG" platform="PS3" ref="precalc_texture"/>
                    <setparam ref="diffuse_color">
                    <float3> 0.3 0.25 0.85 </float3>
                    </setparam>
                    </instance_effect>
                    */
                    pInstance.effect = this.source(attr(pXML, "url"));

                    this.eachByTag(pXML, "technique_hint", function (pXMLData) {
                        pInstance.techniqueHint[attr(pXMLData, "platform")] = attr(pXMLData, "ref");
                        akra.debug.warn("<technique_hint /> used, but will be ignored!");
                    });

                    this.eachByTag(pXML, "setparam", function (pXMLData) {
                        //can be any type
                        pInstance.parameters[attr(pXMLData, "ref")] = _this.COLLADAData(pXMLData);
                        akra.debug.warn("<setparam /> used, but will be ignored!");
                    });

                    return pInstance;
                };

                Collada.prototype.COLLADAInstanceController = function (pXML) {
                    var pInst = {
                        controller: this.source(attr(pXML, "url")),
                        material: this.COLLADABindMaterial(firstChild(pXML, "bind_material")),
                        skeletons: []
                    };

                    this.eachByTag(pXML, "skeleton", function (pXMLData) {
                        //cut # symbol from skeleton name
                        pInst.skeletons.push(stringData(pXMLData).substr(1));
                    });

                    return pInst;
                };

                Collada.prototype.COLLADAInstanceGeometry = function (pXML) {
                    var pInst = {
                        geometry: this.source(attr(pXML, "url")),
                        material: this.COLLADABindMaterial(firstChild(pXML, "bind_material"))
                    };

                    return pInst;
                };

                Collada.prototype.COLLADAInstanceCamera = function (pXML) {
                    var pInst = {
                        camera: this.source(attr(pXML, "url"))
                    };

                    return pInst;
                };

                Collada.prototype.COLLADAInstanceLight = function (pXML) {
                    var pInst = {
                        light: this.source(attr(pXML, "url"))
                    };

                    return pInst;
                };

                // directly load <visual_scene> from <instance_visual_scene> from <scene>.
                Collada.prototype.COLLADAScene = function (pXML) {
                    if (typeof pXML === "undefined") { pXML = firstChild(this.getXMLRoot(), "scene"); }
                    var pXMLData = firstChild(pXML, "instance_visual_scene");
                    var pScene = this.source(attr(pXMLData, "url"));

                    if (akra.isNull(pXMLData) || akra.isNull(pScene)) {
                        akra.debug.warn("model has no visual scenes.");
                    }

                    return this._pVisualScene = pScene;
                };

                //camera
                Collada.prototype.COLLADAPerspective = function (pXML) {
                    var pPerspective = {
                        xfov: parseFloat(stringData(firstChild(pXML, "xfov")) || "60.") * akra.math.RADIAN_RATIO,
                        yfov: parseFloat(stringData(firstChild(pXML, "yfov")) || "60.") * akra.math.RADIAN_RATIO,
                        aspect: parseFloat(stringData(firstChild(pXML, "aspect")) || (4. / 3.).toString()),
                        znear: parseFloat(stringData(firstChild(pXML, "znear")) || ".1"),
                        zfar: parseFloat(stringData(firstChild(pXML, "zfar")) || "500.")
                    };

                    return pPerspective;
                };

                Collada.prototype.COLLADAOptics = function (pXML) {
                    var pOptics = {
                        techniqueCommon: this.COLLADATechniqueCommon(firstChild(pXML, "technique_common"))
                    };

                    return pOptics;
                };

                Collada.prototype.COLLADACamera = function (pXML) {
                    var pCamera = {
                        optics: null,
                        id: attr(pXML, "id")
                    };

                    pCamera.optics = this.COLLADAOptics(firstChild(pXML, "optics"));

                    this.link(pCamera);

                    return pCamera;
                };

                //light
                Collada.prototype.COLLADALight = function (pXML) {
                    return null;
                };

                // animation
                Collada.prototype.COLLADAAnimationSampler = function (pXML) {
                    var _this = this;
                    var pSampler = {
                        inputs: {},
                        id: attr(pXML, "id")
                    };

                    var pInput;
                    var sSemantic;

                    this.link(pSampler);

                    this.eachByTag(pXML, "input", function (pXMLData) {
                        sSemantic = attr(pXMLData, "semantic");

                        switch (sSemantic) {
                            case "INPUT":
                            case "OUTPUT":
                            case "INTERPOLATION":
                            case "IN_TANGENT":
                            case "OUT_TANGENT":
                                pInput = _this.prepareInput(_this.COLLADAInput(pXMLData));
                                pSampler.inputs[sSemantic] = pInput;
                                break;

                            default:
                                akra.debug.error("semantics are different from OUTPUT/INTERPOLATION/IN_TANGENT/OUT_TANGENT is not supported in the <sampler /> tag");
                        }
                    });

                    return pSampler;
                };

                Collada.prototype.COLLADAAnimationChannel = function (pXML) {
                    var pChannel = {
                        sampler: this.source(attr(pXML, "source")),
                        target: this.target(attr(pXML, "target"))
                    };

                    if (akra.isNull(pChannel.target) || akra.isNull(pChannel.target.object)) {
                        akra.debug.warn("cound not setup animation channel for <" + attr(pXML, "target") + ">");
                        return null;
                    }

                    return pChannel;
                };

                Collada.prototype.COLLADAAnimation = function (pXML) {
                    var _this = this;
                    var pAnimation = {
                        id: attr(pXML, "id"),
                        name: attr(pXML, "name"),
                        sources: [],
                        samplers: [],
                        channels: [],
                        animations: []
                    };

                    var pChannel;
                    var pSubAnimation;

                    this.link(pAnimation);

                    this.eachChild(pXML, function (pXMLData, sName) {
                        switch (sName) {
                            case "source":
                                pAnimation.sources.push(_this.COLLADASource(pXMLData));
                                break;

                            case "sampler":
                                pAnimation.samplers.push(_this.COLLADAAnimationSampler(pXMLData));
                                break;

                            case "channel":
                                pChannel = _this.COLLADAAnimationChannel(pXMLData);

                                if (akra.isDefAndNotNull(pChannel)) {
                                    //this guard for skipping channels with unknown targets
                                    pAnimation.channels.push(pChannel);
                                }

                                break;
                            case "animation":
                                pSubAnimation = _this.COLLADAAnimation(pXMLData);

                                if (akra.isDefAndNotNull(pSubAnimation)) {
                                    pAnimation.animations.push(pSubAnimation);
                                }
                        }
                    });

                    if (pAnimation.channels.length == 0 && pAnimation.animations.length == 0) {
                        akra.debug.warn("animation with id \"" + pAnimation.id + "\" skipped, because channels/sub animation are empty");
                        return null;
                    }

                    akra.debug.assert(pXML.parentNode === firstChild(this.getXMLRoot(), "library_animations"), "sub animations not supported");

                    this._pAnimations.push(pAnimation);

                    return pAnimation;
                };

                // collada mapping
                Collada.prototype.source = function (sUrl) {
                    if (sUrl.charAt(0) !== "#") {
                        sUrl = "#" + sUrl;
                    }

                    var pElement = this._pLinks[sUrl];

                    if (!akra.isDefAndNotNull(pElement)) {
                        akra.debug.warn("cannot find element with id: " + sUrl + new Error.stack.split("\n").slice(1).join("\n"));
                    }

                    return pElement || null;
                };

                Collada.prototype.link = function (el, pTarget) {
                    var sId;

                    if (!akra.isString(arguments[0])) {
                        pTarget = arguments[0];
                        sId = pTarget.id;
                    } else {
                        sId = arguments[0];
                    }

                    this._pLinks["#" + sId] = pTarget;
                };

                //astroBoy_newSkeleton_root/rotateY.ANGLE
                //pObject.source: IColladaEntry = astroBoy_newSkeleton_root
                //pSource: IColladaTransform = source(astroBoy_newSkeleton_root/rotateY)
                //pSource: IColladaTransform = {
                //    sid: string;  //rotateY
                //    value: IVec4; //<0 1 0 -4.56752>
                //    name: string; //rotate
                //  }
                //
                //sValue: string = "ANGLE"
                //pObject.object: IColladaTransform = pSource;
                //
                Collada.prototype.target = function (sPath) {
                    var pObject = { value: null };
                    var pSource;

                    var pMatches;
                    var sValue;

                    var iPos;
                    var jPos = 0;

                    iPos = sPath.lastIndexOf("/");

                    if (iPos >= 0) {
                        pObject.source = this.source(sPath.substr(0, iPos));
                    }

                    iPos = sPath.lastIndexOf(".");

                    if (iPos < 0) {
                        iPos = sPath.indexOf("(");
                        jPos = -1;
                    }

                    if (iPos < 0) {
                        pObject.object = this.source(sPath);
                        return pObject;
                    }

                    pSource = this.source(sPath.substr(0, iPos));
                    sValue = sPath.substr(iPos + jPos + 1);
                    pObject.object = pSource;

                    if (!pSource) {
                        return null;
                    }

                    switch (sValue) {
                        case "X":
                            pObject.value = pSource.value.x;
                            break;
                        case "Y":
                            pObject.value = pSource.value.y;
                            break;
                        case "Z":
                            pObject.value = pSource.value.z;
                            break;
                        case "W":
                            pObject.value = pSource.value.w;
                            break;
                        case "ANGLE":
                            pObject.value = pSource.value.w;

                            break;
                    }

                    if (akra.isDefAndNotNull(pObject.value)) {
                        return pObject;
                    }

                    pMatches = sValue.match(/^\((\d+)\)$/);

                    if (pMatches) {
                        pObject.value = Number(pMatches[1]);
                    }

                    pMatches = sValue.match(/^\((\d+)\)\((\d+)\)$/);

                    if (pMatches) {
                        //trace(pMatches, '--->',  Number(pMatches[2]) * 4 + Number(pMatches[1]));
                        //pObject.value = Number(pMatches[2]) * 4 + Number(pMatches[1]);
                        pObject.value = Number(pMatches[1]) * 4 + Number(pMatches[2]);
                    }

                    akra.debug.assert(akra.isDefAndNotNull(pObject.value), "unsupported target value founded: " + sValue);

                    return pObject;
                };

                // //animation
                Collada.prototype.buildAnimationTrack = function (pChannel) {
                    var sNodeId = pChannel.target.source.id;
                    var sJoint = this.source(sNodeId).sid || null;
                    var pTrack = null;
                    var pSampler = pChannel.sampler;

                    akra.debug.assert(akra.isDefAndNotNull(pSampler), "could not find sampler for animation channel");

                    var pInput = pSampler.inputs["INPUT"];
                    var pOutput = pSampler.inputs["OUTPUT"];
                    var pInterpolation = pSampler.inputs["INTERPOLATION"];

                    var pTimeMarks = pInput.array;
                    var pOutputValues = pOutput.array;
                    var pFloatArray;

                    var pTransform = pChannel.target.object;
                    var sTransform = pTransform.transform;
                    var v4f;
                    var pValue;
                    var nMatrices;

                    switch (sTransform) {
                        case "translate":
                            // pTrack = new a.AnimationTranslation(sJoint);
                            // for (var i = 0, v3f = new Array(3), n; i < pTimeMarks.length; ++ i) {
                            //     n = i * 3;
                            //     v3f.X = pOutputValues[i * 3];
                            //     v3f.Y = pOutputValues[i * 3 + 1];
                            //     v3f.Z = pOutputValues[i * 3 + 2];
                            //     pTrack.keyFrame(pTimeMarks[i], [v3f.X, v3f.Y, v3f.Z]);
                            // };
                            akra.logger.critical("TODO: implement animation translation");

                            break;
                        case "rotate":
                            // v4f = pTransform.pValue;
                            // pTrack = new a.AnimationRotation(sJoint, [v4f[1], v4f[2], v4f[3]]);
                            // debug.assert(pOutput.pAccessor.iStride === 1,
                            //     "matrix modification supported only for one parameter modification");
                            // for (var i = 0; i < pTimeMarks.length; ++ i) {
                            //     pTrack.keyFrame(pTimeMarks[i], pOutputValues[i] / 180.0 * math.PI);
                            // };
                            akra.logger.critical("TODO: implement animation rotation");

                            break;
                        case "matrix":
                            pValue = pChannel.target.value;
                            if (akra.isNull(pValue)) {
                                pTrack = akra.animation.createTrack(sJoint);
                                nMatrices = pOutputValues.length / 16;
                                pFloatArray = new Float32Array(pOutputValues);

                                akra.debug.assert(nMatrices % 1 === 0.0, "incorrect output length of transformation data (" + pFloatArray.length + ")");

                                for (var i = 0; i < nMatrices; i++) {
                                    var pFrame = new akra.animation.PositionFrame(pTimeMarks[i], (new Mat4(pFloatArray.subarray(i * 16, i * 16 + 16), true)).transpose());
                                    pTrack.keyFrame(pFrame);
                                }
                                // i=0;
                                // var m = (new Mat4(pFloatArray.subarray(i * 16, i * 16 + 16), true));
                                // trace(sFilename,sNodeId,m.toString());
                            } else {
                                // pTrack = new a.AnimationMatrixModification(sJoint, pValue);
                                // for (var i = 0; i < pTimeMarks.length; ++i) {
                                //     pTrack.keyFrame(pTimeMarks[i], pOutputValues[i]);
                                // }
                                akra.logger.critical("TODO: implement animation matrix modification");
                            }
                            break;
                        default:
                            akra.debug.error("unsupported animation typed founeed: " + sTransform);
                    }

                    if (!akra.isNull(pTrack)) {
                        pTrack.setTargetName(sNodeId);
                    }

                    return pTrack;
                };

                Collada.prototype.buildAnimationTrackList = function (pAnimationData) {
                    var pSubAnimations = pAnimationData.animations;
                    var pSubTracks;
                    var pTrackList = [];
                    var pTrack;
                    var pChannels = pAnimationData.channels;

                    for (var i = 0; i < pChannels.length; ++i) {
                        pTrack = this.buildAnimationTrack(pChannels[i]);
                        pTrackList.push(pTrack);
                    }

                    if (akra.isDefAndNotNull(pSubAnimations)) {
                        for (var i = 0; i < pSubAnimations.length; ++i) {
                            pSubTracks = this.buildAnimationTrackList(pSubAnimations[i]);
                            pTrackList = pTrackList.concat(pSubTracks);
                        }
                    }

                    return pTrackList;
                };

                Collada.prototype.buildAnimation = function (pAnimationData) {
                    var pTracks = this.buildAnimationTrackList(pAnimationData);
                    var sAnimation = pAnimationData.name || pAnimationData.id || null;
                    var pAnimation = akra.animation.createAnimation(sAnimation || this.getBasename());

                    for (var i = 0; i < pTracks.length; i++) {
                        pAnimation.push(pTracks[i]);
                    }

                    return pAnimation;
                };

                Collada.prototype.buildAnimations = function (pAnimationsList) {
                    if (typeof pAnimationsList === "undefined") { pAnimationsList = []; }
                    var pAnimations = this.getAnimations();

                    if (akra.isNull(pAnimations)) {
                        return null;
                    }

                    for (var i = 0; i < pAnimations.length; ++i) {
                        var pAnimation = this.buildAnimation(pAnimations[i]);

                        pAnimationsList.push(pAnimation);
                    }

                    return pAnimationsList;
                };

                // common
                Collada.prototype.buildAssetTransform = function (pNode, pAsset) {
                    if (typeof pAsset === "undefined") { pAsset = null; }
                    pAsset = pAsset || this.getAsset();

                    if (akra.isDefAndNotNull(pAsset)) {
                        var fUnit = pAsset.unit.meter;
                        var sUPaxis = pAsset.upAxis;

                        pNode.setLocalScale(Vec3.temp(fUnit));

                        if (sUPaxis.toUpperCase() == "Z_UP") {
                            //pNode.addRelRotation([1, 0, 0], -.5 * math.PI);
                            pNode.addRelRotationByEulerAngles(0, -.5 * akra.math.PI, 0);
                        }
                    }

                    return pNode;
                };

                Collada.prototype.buildDeclarationFromAccessor = function (sSemantic, pAccessor) {
                    var pDecl = [];

                    for (var i = 0; i < pAccessor.params.length; ++i) {
                        var sUsage = pAccessor.params[i].name;
                        var sType = pAccessor.params[i].type;

                        akra.logger.assert(sType === "float", "Only float type supported for construction declaration from accessor");

                        pDecl.push(VE.float(sUsage));
                    }

                    pDecl.push(VE.custom(sSemantic, 5126 /* FLOAT */, pAccessor.params.length, 0));

                    akra.debug.info("Automatically constructed declaration: ", akra.data.VertexDeclaration.normalize(pDecl).toString());

                    return pDecl;
                };

                // materials & meshes
                Collada.prototype.buildDefaultMaterials = function (pMesh) {
                    var pDefaultMaterial = akra.material.create();

                    for (var j = 0; j < pMesh.getLength(); ++j) {
                        var pSubMesh = pMesh.getSubset(j);
                        pSubMesh.getMaterial().set(pDefaultMaterial);
                        pSubMesh.getRenderMethod().getEffect().addComponent("akra.system.mesh_texture");
                    }

                    return pMesh;
                };

                Collada.prototype.buildMaterials = function (pMesh, pGeometryInstance) {
                    var pMaterials = pGeometryInstance.material;
                    var pEffects = this.getLibrary("library_effects");

                    if (akra.isNull(pEffects) || akra.isNull(pMaterials)) {
                        return this.buildDefaultMaterials(pMesh);
                    }

                    for (var sMaterial in pMaterials) {
                        var pMaterialInst = pMaterials[sMaterial];
                        var pInputMap = pMaterialInst.vertexInput;

                        // URL --> ID (#somebody ==> somebody)
                        var sEffectId = pMaterialInst.material.instanceEffect.effect.id;
                        var pEffect = pEffects.effect[sEffectId];
                        var pPhongMaterial = pEffect.profileCommon.technique.value;
                        var pMaterial = pPhongMaterial.material;

                        if (akra.isNull(pMaterial)) {
                            pMaterial = akra.material.create(sEffectId);
                            pMaterial.set(pPhongMaterial);
                            pPhongMaterial.material = pMaterial;
                            this.addMaterial(sEffectId, pPhongMaterial);
                        }

                        for (var j = 0; j < pMesh.getLength(); ++j) {
                            var pSubMesh = pMesh.getSubset(j);

                            if (pSubMesh.getMaterial().name === sMaterial) {
                                //setup materials
                                //pSubMesh.getMaterial().set(pMaterial);
                                pSubMesh.getSurfaceMaterial().setMaterial(pMaterial);
                                pSubMesh.getRenderMethod().getEffect().addComponent("akra.system.mesh_texture");

                                for (var sTextureType in pPhongMaterial.textures) {
                                    var pColladaTexture = pPhongMaterial.textures[sTextureType];

                                    if (akra.isNull(pColladaTexture)) {
                                        continue;
                                    }

                                    var pInput = pInputMap[pColladaTexture.texcoord];

                                    if (!akra.isDefAndNotNull(pInput)) {
                                        continue;
                                    }

                                    var sInputSemantics = pInputMap[pColladaTexture.texcoord].inputSemantic;
                                    var pColladaImage = pColladaTexture.image;

                                    var pSurfaceMaterial = pSubMesh.getSurfaceMaterial();
                                    var pTexture = this.getManager().getTexturePool().findResource(pColladaImage.path);

                                    if (this.getImageOptions().flipY === true) {
                                        akra.logger.error("TODO: flipY for image unsupported!");
                                    }

                                    var pMatches = sInputSemantics.match(/^(.*?\w)(\d+)$/i);
                                    var iTexCoord = (pMatches ? parseInt(pMatches[2]) : 0);

                                    var iTexture = akra.ESurfaceMaterialTextures[sTextureType.toUpperCase()] | 0;

                                    if (!akra.isDef(iTexture)) {
                                        continue;
                                    }

                                    // logger.log(iTexture, sTextureType)
                                    pSurfaceMaterial.setTexture(iTexture, pTexture, iTexCoord);
                                    // logger.log(pSurfaceMaterial);
                                }

                                if (this.isWireframeEnabled()) {
                                    pSubMesh.wireframe(true);
                                }
                            }
                        }
                    }

                    // debug.timeEnd("Build materials #" + pGeometryInstance.geometry.id);
                    return pMesh;
                };

                Collada.prototype.buildSkeleton = function (pSkeletonsList) {
                    var pSkeleton = null;

                    pSkeleton = akra.model.createSkeleton(pSkeletonsList[0]);

                    for (var i = 0; i < pSkeletonsList.length; ++i) {
                        var pJoint = this.source(pSkeletonsList[i]).constructedNode;

                        akra.logger.assert(akra.scene.Joint.isJoint(pJoint), "skeleton node must be joint");

                        pSkeleton.addRootJoint(pJoint);
                    }

                    this.addSkeleton(pSkeleton);
                    return pSkeleton;
                };

                Collada.prototype.buildMesh = function (pGeometryInstance, isSkinned) {
                    if (typeof isSkinned === "undefined") { isSkinned = false; }
                    var pMesh = null;
                    var pGeometry = pGeometryInstance.geometry;
                    var pNodeData;
                    var sMeshName = pGeometry.id;

                    //we cant optimize skinned mesh, because animation can be placed in file differen from current
                    if (!isSkinned && !Collada.isCOLLADAMeshOptimized(pGeometry.mesh)) {
                        pNodeData = this.optimizeCOLLADAMesh(pGeometry.mesh);
                    } else {
                        pNodeData = pGeometry.mesh;
                    }

                    if (akra.isNull(pNodeData)) {
                        return null;
                    }

                    if ((pMesh = this.findMesh(sMeshName))) {
                        //mesh with same geometry data
                        return this.buildMaterials(pMesh.clone(0 /* GEOMETRY_ONLY */ | 1 /* SHARED_GEOMETRY */), pGeometryInstance);
                    }

                    var iBegin = Date.now();

                    pMesh = this.getEngine().createMesh(sMeshName, (akra.EMeshOptions.HB_READABLE), null);

                    var pPolyGroup = pNodeData.polygons;
                    var pMeshData = pMesh.getData();

                    for (var i = 0; i < pPolyGroup.length; ++i) {
                        pMesh.createSubset(pGeometry.id + "-submesh-" + i, pPolyGroup[i].type, Collada.isSingleIndexedPolygons(pPolyGroup[i]) ? akra.ERenderDataBufferOptions.RD_SINGLE_INDEX : 0);
                    }

                    //TODO: correct check, that it is simple mesh.
                    if (Collada.isSingleIndexedPolygons(pPolyGroup[0])) {
                        var pVertexBuffer = this.getManager().createVertexBuffer(sMeshName);

                        var pDataMap = {};
                        var iByteLength = 0;
                        var pDeclElements = [];
                        var pDeclaration = new akra.data.VertexDeclaration();

                        for (var i = 0; i < pPolyGroup.length; ++i) {
                            var pPolygons = pPolyGroup[i];

                            for (var j = 0; j < pPolygons.inputs.length; ++j) {
                                var pInput = pPolygons.inputs[j];
                                var sSemantic = pInput.semantics;

                                if (sSemantic === "TEXCOORD") {
                                    sSemantic = "TEXCOORD0";
                                }

                                if (!akra.isDefAndNotNull(pDataMap[sSemantic])) {
                                    pDataMap[sSemantic] = pInput.array;
                                    iByteLength += pInput.array.byteLength;
                                    pDeclaration.append(VE.custom(sSemantic, 5126 /* FLOAT */, pInput.accessor.params.length));
                                }
                            }
                        }

                        pVertexBuffer.create(iByteLength, 5 /* STATIC_READABLE */);

                        var pVertexData = pVertexBuffer.getEmptyVertexData(iByteLength / pDeclaration.stride, pDeclaration);

                        for (var sSemantic in pDataMap) {
                            if (!pVertexData.setData(pDataMap[sSemantic], sSemantic)) {
                                akra.debug.error("could not load data to buffer: " + sSemantic);
                            }
                        }

                        for (var i = 0; i < pMesh.getLength(); ++i) {
                            pMesh.getSubset(i).getData()._addData(pVertexData);
                        }
                    } else {
                        for (var i = 0, pUsedSemantics = {}; i < pPolyGroup.length; ++i) {
                            var pPolygons = pPolyGroup[i];

                            for (var j = 0; j < pPolygons.inputs.length; ++j) {
                                var pInput = pPolygons.inputs[j];
                                var sSemantic = pInput.semantics;
                                var pData = pInput.array;
                                var pDecl;
                                var pDataExt;

                                //if (pMesh.buffer.getDataLocation(sSemantic) < 0) {
                                if (!pUsedSemantics[sSemantic]) {
                                    pUsedSemantics[sSemantic] = true;

                                    switch (sSemantic) {
                                        case akra.data.Usages.POSITION:
                                        case akra.data.Usages.NORMAL:
                                            /*
                                            Extend POSITION and NORMAL from {x,y,z} --> {x,y,z,w};
                                            */
                                            pDataExt = new Float32Array(pData.length / 3 * 4);

                                            for (var y = 0, n = 0, m = 0, l = pData.length / 3; y < l; y++, n++) {
                                                pDataExt[n++] = pData[m++];
                                                pDataExt[n++] = pData[m++];
                                                pDataExt[n++] = pData[m++];
                                            }

                                            pData = pDataExt;
                                            pDecl = [VE.float3(sSemantic), VE.end(16)];

                                            break;
                                        case akra.data.Usages.TEXCOORD:
                                        case akra.data.Usages.TEXCOORD1:
                                        case akra.data.Usages.TEXCOORD2:
                                        case akra.data.Usages.TEXCOORD3:
                                        case akra.data.Usages.TEXCOORD4:
                                        case akra.data.Usages.TEXCOORD5:
                                            //avoiding semantics collisions
                                            if (sSemantic === "TEXCOORD") {
                                                sSemantic = "TEXCOORD0";
                                            }

                                            pDecl = [VE.custom(sSemantic, 5126 /* FLOAT */, pInput.accessor.stride)];
                                            break;
                                        default:
                                            pDecl = this.buildDeclarationFromAccessor(sSemantic, pInput.accessor);
                                            akra.debug.warn("unsupported semantics used: " + sSemantic);
                                    }

                                    pMeshData.allocateData(pDecl, pData);
                                }
                            }
                        }
                    }

                    for (var i = 0; i < pPolyGroup.length; ++i) {
                        var pPolygons = pPolyGroup[i];

                        //geometries
                        var pSubMesh = pMesh.getSubset(i);
                        var pSubMeshData = pSubMesh.getData();
                        var pIndexDecl = null;

                        //materials
                        var pSurfaceMaterial = null;
                        var pSurfacePool = null;

                        if (pSubMeshData.useMultiIndex()) {
                            pIndexDecl = akra.data.VertexDeclaration.normalize();

                            for (var j = 0; j < pPolygons.inputs.length; ++j) {
                                //number of index
                                var iOffset = pPolygons.inputs[j].offset;

                                //like:
                                //	<input semantic = "VERTEX" offset ="0"/ > has index semantics INDEX0
                                //	<input semantic = "NORMAL" offset ="1"/ > has index semantics INDEX1
                                var sIndexSemantic = akra.data.Usages.INDEX + iOffset;

                                //total number of offsets can be less then number of inputs
                                //for example:
                                //	<input semantic = "VERTEX" offset ="0"/ >
                                //	<input semantic = "VERTEX" offset ="0"/ >
                                //
                                // two <input />'s has same offset
                                if (!pIndexDecl.hasSemantics(sIndexSemantic)) {
                                    pIndexDecl.append(VE.float(sIndexSemantic));
                                }
                            }

                            pSubMeshData.allocateIndex(pIndexDecl, new Float32Array(pPolygons.p));

                            for (var j = 0; j < pPolygons.inputs.length; ++j) {
                                var sSemantic = pPolygons.inputs[j].semantics;
                                var sIndexSemantics = akra.data.Usages.INDEX + pPolygons.inputs[j].offset;

                                pSubMeshData.index(sSemantic, sIndexSemantics);
                            }
                        } else {
                            akra.debug.assert(pPolygons.inputs[0].offset === 0, "Single index with non-zero offset unsupported.");

                            //alocate single index
                            pSubMeshData.allocateIndex(null, new Uint32Array(pPolygons.p));
                        }

                        pSubMesh.getMaterial().name = pPolygons.material;
                    }

                    pMesh.setShadow(this.isShadowsEnabled());

                    //adding all data to cahce data
                    this.addMesh(pMesh);

                    // debug.timeEnd("Build mesh #" + pGeometry.id);
                    return this.buildMaterials(pMesh, pGeometryInstance);
                };

                Collada.prototype.buildSkinMesh = function (pControllerInstance) {
                    var pController = pControllerInstance.controller;
                    var pMaterials = pControllerInstance.material;

                    var pSkinData = pController.skin;

                    //skin data
                    var pBoneList = pSkinData.joints.inputs["JOINT"].array;
                    var pBoneOffsetMatrices = pSkinData.joints.inputs["INV_BIND_MATRIX"].array;

                    var m4fBindMatrix = pSkinData.shapeMatrix;
                    var pVertexWeights = pSkinData.vertexWeights;

                    var pGeometry = pSkinData.geometry;

                    var pMesh;
                    var pSkeleton;
                    var pSkin;

                    pSkeleton = this.buildSkeleton(pControllerInstance.skeletons);
                    pMesh = this.buildMesh({ geometry: pGeometry, material: pMaterials }, true);

                    pSkin = pMesh.createSkin();

                    pSkin.setBindMatrix(m4fBindMatrix);
                    pSkin.setBoneNames(pBoneList);
                    pSkin.setBoneOffsetMatrices(pBoneOffsetMatrices);

                    if (!pSkin.setVertexWeights(pVertexWeights.vcount, new Float32Array(pVertexWeights.v), new Float32Array(pVertexWeights.weightInput.array))) {
                        akra.logger.error("cannot set vertex weight info to skin");
                    }

                    pMesh.setSkin(pSkin);
                    pSkeleton.attachMesh(pMesh);

                    return pMesh;
                };

                Collada.prototype.buildSkinMeshInstance = function (pControllers, pSceneNode) {
                    if (typeof pSceneNode === "undefined") { pSceneNode = null; }
                    var pMesh = null;
                    var pMeshList = [];

                    for (var m = 0; m < pControllers.length; ++m) {
                        pMesh = this.buildSkinMesh(pControllers[m]);
                        pMeshList.push(pMesh);

                        akra.debug.assert(akra.isDefAndNotNull(pMesh), "cannot find instance <" + pControllers[m].url + ">\"s data");

                        if (!akra.isNull(pSceneNode)) {
                            pSceneNode.setMesh(pMesh);
                        }
                    }

                    return pMeshList;
                };

                Collada.prototype.buildMeshInstance = function (pGeometries, pSceneNode) {
                    if (typeof pSceneNode === "undefined") { pSceneNode = null; }
                    var pMesh = null;
                    var pMeshList = [];

                    for (var m = 0; m < pGeometries.length; ++m) {
                        pMesh = this.buildMesh(pGeometries[m]);
                        pMeshList.push(pMesh);

                        akra.debug.assert(akra.isDefAndNotNull(pMesh), "cannot find instance <" + pGeometries[m].url + ">\"s data");

                        if (!akra.isNull(pSceneNode)) {
                            pSceneNode.setMesh(pMesh);
                        }
                    }

                    return pMeshList;
                };

                Collada.prototype.buildMeshByName = function (sName) {
                    var _this = this;
                    var pScene = this.getVisualScene();
                    var pMesh = null;

                    this.findNode(pScene.nodes, null, function (pNode) {
                        var pModelNode;

                        if (pNode.controller.length == 0 && pNode.geometry.length == 0) {
                            return;
                        }

                        for (var i = 0; i < pNode.geometry.length; ++i) {
                            var pInstanceGeometry = pNode.geometry[i];
                            if (akra.isNull(sName) || pInstanceGeometry.geometry.name === sName) {
                                pMesh = _this.buildMesh(pInstanceGeometry);
                                return false;
                            }
                        }
                    });

                    return pMesh;
                };

                Collada.prototype.buildMeshes = function () {
                    var pScene = this.getVisualScene();
                    var pMeshes = [];

                    this.findNode(pScene.nodes, null, function (pNode) {
                        var pModelNode = pNode.constructedNode;

                        if (akra.isNull(pModelNode)) {
                            akra.debug.error("you must call buildScene() before call buildMeshes() or file corrupt");
                            return;
                        }

                        if (pNode.controller.length == 0 && pNode.geometry.length == 0) {
                            return;
                        }

                        if (!akra.scene.SceneModel.isModel(pModelNode) && pNode.geometry.length > 0) {
                            pModelNode = pModelNode.getScene().createModel(".joint-to-model-link-" + akra.guid());
                            pModelNode.attachToParent(pNode.constructedNode);
                        }

                        pMeshes.insert(this.buildSkinMeshInstance(pNode.controller));
                        pMeshes.insert(this.buildMeshInstance(pNode.geometry, pModelNode));
                    });

                    return pMeshes;
                };

                // scene
                Collada.prototype.buildSceneNode = function (pNode, pParentNode) {
                    var pSceneNode = pNode.constructedNode;
                    var pScene = pParentNode.getScene();

                    if (akra.isDefAndNotNull(pSceneNode)) {
                        return pSceneNode;
                    }

                    //FIXME: предпологаем, что мы никогда не аттачим контроллеры к узлам,
                    // где они найдены, а аттачим  их к руту скелета, на который они ссылаются
                    if (pNode.geometry.length > 0) {
                        pSceneNode = pScene.createModel();
                    } else {
                        pSceneNode = pScene.createNode();
                    }

                    akra.logger.assert(pSceneNode.create(), "Can not initialize scene node!");

                    pSceneNode.attachToParent(pParentNode);

                    return pSceneNode;
                };

                Collada.prototype.buildJointNode = function (pNode, pParentNode) {
                    var pJointNode = pNode.constructedNode;
                    var sJointSid = pNode.sid;
                    var sJointName = pNode.id;
                    var pSkeleton;

                    akra.debug.assert(akra.isDefAndNotNull(pParentNode), "parent node is null");

                    if (akra.isDefAndNotNull(pJointNode)) {
                        return pJointNode;
                    }

                    if (akra.isNull(pParentNode)) {
                        return null;
                    }

                    pJointNode = pParentNode.getScene().createJoint();

                    akra.logger.assert(pJointNode.create(), "Can not initialize joint node!");

                    pJointNode.setBoneName(sJointSid);
                    pJointNode.attachToParent(pParentNode);

                    return pJointNode;
                };

                Collada.prototype.buildCamera = function (pColladaInstanceCamera, pParent) {
                    var pColladaCamera = pColladaInstanceCamera.camera;
                    var pCamera = pParent.getScene().createCamera(pColladaCamera.name || pColladaCamera.id || null);

                    pCamera.setInheritance(4 /* ALL */);
                    pCamera.attachToParent(pParent);

                    var pPerspective = pColladaCamera.optics.techniqueCommon.perspective;

                    if (!akra.isNull(pPerspective)) {
                        pCamera.setProjParams(pPerspective.xfov, pPerspective.aspect, pPerspective.znear, pPerspective.zfar * (1 / this.getAsset().unit.meter));
                    }

                    return pCamera;
                };

                Collada.prototype.buildNodes = function (pNodes, pParentNode) {
                    if (typeof pParentNode === "undefined") { pParentNode = null; }
                    if (akra.isNull(pNodes)) {
                        return null;
                    }

                    var pNode = null;
                    var pHierarchyNode = null;
                    var m4fLocalMatrix = null;

                    for (var i = pNodes.length - 1; i >= 0; i--) {
                        pNode = pNodes[i];

                        if (!akra.isDefAndNotNull(pNode)) {
                            continue;
                        }

                        if (pNode.type === "JOINT") {
                            pHierarchyNode = this.buildJointNode(pNode, pParentNode);
                        } else {
                            pHierarchyNode = this.buildSceneNode(pNode, pParentNode);
                        }

                        pHierarchyNode.setName(pNode.id || pNode.name);
                        pHierarchyNode.setInheritance(4 /* ALL */);

                        //cache already constructed nodes
                        pNode.constructedNode = pHierarchyNode;
                        pHierarchyNode.setLocalMatrix(pNode.transform);

                        this.buildNodes(pNode.childNodes, pHierarchyNode);

                        if (pNode.camera.length > 0) {
                            for (var c = 0; c < pNode.camera.length; ++c) {
                                var pColladaCamera = pNode.camera[c];
                                var pCamera = this.buildCamera(pColladaCamera, pHierarchyNode);
                            }
                        }
                    }

                    return pHierarchyNode;
                };

                Collada.prototype.buildScene = function (pRootNode) {
                    var pScene = this.getVisualScene();
                    var pAsset = this.getAsset();

                    var pNodes = [];
                    var pNode = null;

                    for (var i = 0; i < pScene.nodes.length; i++) {
                        pNode = pScene.nodes[i];
                        pNodes.push(this.buildNodes([pNode], pRootNode));
                    }

                    for (var i = 0; i < pNodes.length; i++) {
                        pNodes[i] = this.buildAssetTransform(pNodes[i]);
                    }

                    return pNodes;
                };

                Collada.prototype.buildInititalPose = function (pNodes, pSkeleton) {
                    var sPose = "Pose-" + this.getBasename() + "-" + pSkeleton.getName();
                    var pPose = akra.animation.createAnimation(sPose);
                    var pNodeList = pSkeleton.getNodeList();
                    var pNodeMap = {};
                    var pTrack;

                    for (var i = 0; i < pNodeList.length; ++i) {
                        pNodeMap[pNodeList[i].getName()] = pNodeList[i];
                    }

                    this.findNode(pNodes, null, function (pNode) {
                        var sJoint = pNode.sid;
                        var sNodeId = pNode.id;

                        if (!akra.isDefAndNotNull(pNodeMap[sNodeId])) {
                            return;
                        }

                        pTrack = akra.animation.createTrack(sJoint);
                        pTrack.setTargetName(sNodeId);
                        pTrack.keyFrame(0.0, pNode.transform);

                        pPose.push(pTrack);
                    });

                    return pPose;
                };

                Collada.prototype.buildInitialPoses = function (pPoseSkeletons) {
                    if (typeof pPoseSkeletons === "undefined") { pPoseSkeletons = null; }
                    if (!this.isVisualSceneLoaded()) {
                        this.COLLADAScene();
                    }

                    pPoseSkeletons = pPoseSkeletons || this.getSkeletonsOutput();

                    if (akra.isNull(pPoseSkeletons)) {
                        return null;
                    }

                    var pScene = this.getVisualScene();
                    var pSkeleton;
                    var pPoses = [];

                    for (var i = 0; i < pPoseSkeletons.length; ++i) {
                        pSkeleton = pPoseSkeletons[i];

                        // if (pSkeleton.name === "node-Bip001_Pelvis" || pSkeleton.name === "node-Bip001") {
                        //     trace('skipping <node-Bip001_Pelvis> skeleto, ...', '[' + sBasename + ']');
                        //     trace(pSkeleton.getNodeList()[0].localMatrix().toQuat4().toYawPitchRoll(Vec3()).toString());
                        //     continue;
                        // }
                        pPoses.push(this.buildInititalPose(pScene.nodes, pSkeleton));
                    }

                    // logger.log(pPoses);
                    return pPoses;
                };

                // additional
                Collada.prototype.buildComplete = function () {
                    var pScene = this.getVisualScene();

                    if (akra.isNull(pScene)) {
                        akra.debug.warn("build complete, but visual scene not parsed correctly!");
                        return;
                    }

                    //release all links to constructed nodes
                    this.findNode(pScene.nodes, null, function (pNode) {
                        pNode.constructedNode = null;
                    });
                };

                Collada.prototype.setOptions = function (pOptions) {
                    if (akra.isNull(pOptions)) {
                        pOptions = {};
                    }

                    for (var i in Collada.DEFAULT_OPTIONS) {
                        if (akra.isDef(pOptions[i])) {
                            this._pOptions[i] = pOptions[i];
                        } else {
                            this._pOptions[i] = akra.isDef(this._pOptions[i]) ? this._pOptions[i] : Collada.DEFAULT_OPTIONS[i];
                        }
                    }
                };

                Collada.prototype.setXMLDocument = function (pDocument) {
                    this._pXMLDocument = pDocument;
                };

                Collada.prototype.getXMLDocument = function () {
                    return this._pXMLDocument;
                };

                Collada.prototype.setXMLRoot = function (pXML) {
                    this._pXMLRoot = pXML;
                };

                Collada.prototype.getXMLRoot = function () {
                    return this._pXMLRoot;
                };

                Collada.prototype.findMesh = function (sName) {
                    return this._pMeshCache[sName] || null;
                };

                Collada.prototype.addMesh = function (pMesh) {
                    this._pMeshCache[pMesh.getName()] = pMesh;
                };

                Collada.prototype.findMaterial = function (sName) {
                    return this._pMaterialCache[sName] || null;
                };

                Collada.prototype.addMaterial = function (sName, pMaterial) {
                    this._pMaterialCache[sName] = pMaterial;
                };

                Collada.prototype.prepareInput = function (pInput) {
                    var pSupportedFormat = getSupportedFormat(pInput.semantics);
                    akra.debug.assert(akra.isDefAndNotNull(pSupportedFormat), "unsupported semantic used <" + pInput.semantics + ">");

                    pInput.array = this.COLLADAGetSourceData(pInput.source, pSupportedFormat);
                    pInput.accessor = pInput.source.techniqueCommon.accessor;

                    return pInput;
                };

                Collada.prototype.isVisualSceneLoaded = function () {
                    return akra.isDefAndNotNull(this._pVisualScene);
                };

                Collada.prototype.isAnimationLoaded = function () {
                    return this._pAnimations.length > 0;
                };

                Collada.prototype.isSceneNeeded = function () {
                    return this._pOptions.scene === true;
                };

                Collada.prototype.isAnimationNeeded = function () {
                    return akra.isDefAndNotNull(this._pOptions.animation) && this._pOptions.animation !== false;
                };

                Collada.prototype.isPoseExtractionNeeded = function () {
                    return this._pOptions.extractPoses === true;
                };

                Collada.prototype.isWireframeEnabled = function () {
                    return this._pOptions.wireframe === true;
                };

                Collada.prototype.getSkeletonsOutput = function () {
                    return this._pOptions.skeletons || null;
                };

                Collada.prototype.addSkeleton = function (pSkeleton) {
                    this._pOptions.skeletons.push(pSkeleton);
                };

                Collada.prototype.getImageOptions = function () {
                    return this._pOptions.images;
                };

                Collada.prototype.getVisualScene = function () {
                    return this._pVisualScene;
                };

                Collada.prototype.getAnimations = function () {
                    return this._pAnimations;
                };

                Collada.prototype.getAnimation = function (i) {
                    return this._pAnimations[i] || null;
                };

                Collada.prototype.getAsset = function () {
                    return this._pAsset;
                };

                Collada.prototype.isLibraryLoaded = function (sLib) {
                    return akra.isDefAndNotNull(this._pLib[sLib]);
                };

                Collada.prototype.isLibraryExists = function (sLib) {
                    return !akra.isNull(firstChild(this.getXMLRoot(), "library_animations"));
                };

                Collada.prototype.getLibrary = function (sLib) {
                    return this._pLib[sLib] || null;
                };

                Collada.prototype.getBasename = function () {
                    return akra.path.parse(this._pOptions.name || this._sFilename || "unknown").getBaseName();
                };

                Collada.prototype.getVersion = function () {
                    return this._pXMLRoot.getAttribute("version") || null;
                };

                Collada.prototype.getFilename = function () {
                    return this._sFilename;
                };

                Collada.prototype.setFilename = function (sName) {
                    this._sFilename = sName;
                };

                Collada.prototype.readLibraries = function (pXML, pTemplates) {
                    var pLibraries = this._pLib;

                    for (var i = 0; i < pTemplates.length; i++) {
                        var sLib = pTemplates[i].lib;
                        pLibraries[sLib] = this.COLLADALibrary(firstChild(pXML, sLib), pTemplates[i]);
                    }
                };

                Collada.prototype.checkLibraries = function (pXML, pTemplates) {
                    var pLibraries = this._pLib;

                    for (var i = 0; i < pTemplates.length; i++) {
                        var sLib = pTemplates[i].lib;

                        if (akra.isDefAndNotNull(firstChild(pXML, sLib))) {
                            pLibraries[sLib] = null;
                        }
                    }
                };

                Collada.prototype.parse = function (sXMLData, pOptions) {
                    if (typeof pOptions === "undefined") { pOptions = null; }
                    if (akra.isNull(sXMLData)) {
                        akra.debug.error("must be specified collada content.");
                        return false;
                    }

                    // debug.time("parsed");
                    var pParser = new DOMParser();
                    var pXMLDocument = pParser.parseFromString(sXMLData, "application/xml");
                    var pXMLRoot = pXMLDocument.getElementsByTagName("COLLADA")[0];

                    this.setOptions(pOptions);
                    this.setXMLDocument(pXMLDocument);
                    this.setXMLRoot(pXMLRoot);

                    this.checkLibraries(pXMLRoot, Collada.SCENE_TEMPLATE);
                    this.checkLibraries(pXMLRoot, Collada.ANIMATION_TEMPLATE);

                    this.readLibraries(pXMLRoot, Collada.SCENE_TEMPLATE);

                    this.COLLADAAsset();
                    this.COLLADAScene();

                    if (this.isAnimationNeeded()) {
                        this.readLibraries(pXMLRoot, Collada.ANIMATION_TEMPLATE);
                    }

                    // debug.timeEnd("parsed");
                    return true;
                };

                Collada.prototype.loadResource = function (sFilename, pOptions) {
                    // debug.group("Collada %s", this.findResourceName());
                    // debug.time("loaded " + this.findResourceName());
                    var _this = this;
                    if (typeof sFilename === "undefined") { sFilename = null; }
                    if (typeof pOptions === "undefined") { pOptions = null; }
                    if (akra.isNull(sFilename)) {
                        sFilename = this.findResourceName();
                    }

                    if (this.isResourceLoaded()) {
                        akra.debug.warn("collada model already loaded");
                        return false;
                    }

                    var pModel = this;

                    this.setFilename(sFilename);

                    this.notifyDisabled();
                    this.notifyUnloaded();

                    var pFile = akra.io.fopen(sFilename);

                    pFile.open(function (err, meta) {
                        //FIXME: setuop byteLength correctly..
                        pModel._setByteLength(meta.size || 0);
                    });

                    pFile.read(function (e, sXML) {
                        if (!akra.isNull(e)) {
                            akra.logger.error(e);
                            return;
                        }

                        _this.notifyRestored();

                        if (_this.parse(sXML, pOptions)) {
                            // debug.timeEnd("loaded " + this.findResourceName());
                            _this.notifyLoaded();
                        }
                        //TODO: else....
                    });

                    return true;
                };

                //upload material into collada
                Collada.prototype.uploadMaterial = function (sMaterial) {
                    var pPhongMaterial = this.findMaterial(sMaterial);

                    if (akra.isNull(pPhongMaterial)) {
                        return false;
                    }

                    var pMaterial = pPhongMaterial.material;
                    var pXML = pPhongMaterial.xml;

                    function replaceColor(pXML, pColor) {
                        var pXMLColor = firstChild(pXML, "color");

                        if (!akra.isDefAndNotNull(pXMLColor)) {
                            pXMLColor = akra.conv.parseHTML("<color />")[0];
                            pXML.appendChild(pXMLColor);
                        }

                        pXMLColor.textContent = pColor.r + " " + pColor.g + " " + pColor.b + " " + pColor.a;
                    }

                    function replaceValue(pXML, pValue) {
                        var pXMLColor = firstChild(pXML, "float");

                        if (!akra.isDefAndNotNull(pXMLColor)) {
                            pXMLColor = akra.conv.parseHTML("<float />")[0];
                            pXML.appendChild(pXMLColor);
                        }

                        pXMLColor.textContent = String(pValue);
                    }

                    replaceColor(firstChild(pXML, "specular"), pMaterial.specular);
                    replaceColor(firstChild(pXML, "diffuse"), pMaterial.diffuse);
                    replaceColor(firstChild(pXML, "ambient"), pMaterial.ambient);
                    replaceColor(firstChild(pXML, "emission"), pMaterial.emissive);
                    replaceValue(firstChild(pXML, "transparency"), pMaterial.transparency);
                    replaceValue(firstChild(pXML, "shininess"), pXML.tagName === "phong" ? pMaterial.shininess * 128. : pMaterial.shininess);
                };

                Collada.prototype.syncMaterials = function () {
                    var _this = this;
                    Object.keys(this._pMaterialCache).forEach(function (sMaterial) {
                        _this.uploadMaterial(sMaterial);
                    });
                };

                Collada.prototype.extractUsedMaterials = function () {
                    var _this = this;
                    var pList = [];

                    Object.keys(this._pMaterialCache).forEach(function (sName) {
                        pList.push(_this._pMaterialCache[sName].material);
                    });

                    return pList;
                };

                Collada.prototype.toBlob = function () {
                    this.syncMaterials();

                    return new Blob([
                        '<?xml version="1.0" encoding="utf-8"?>',
                        '<COLLADA xmlns="http://www.collada.org/2008/03/COLLADASchema" version="' + (this.getVersion() || "1.5.0") + '">',
                        this._pXMLRoot.innerHTML,
                        '</COLLADA>'
                    ], { mime: "text/xml" });
                };

                Collada.prototype.extractMesh = function (sMeshName) {
                    if (typeof sMeshName === "undefined") { sMeshName = null; }
                    return this.buildMeshByName(sMeshName);
                };

                Collada.prototype.extractModel = function (parent, name) {
                    var pScene;
                    var pNode;
                    var pModel;
                    var sMeshName = null;

                    if (akra.isString(arguments[0])) {
                        sMeshName = arguments[0];
                        parent = arguments[1];
                    } else {
                        parent = arguments[0];
                        sMeshName = arguments[1] || null;
                    }

                    pNode = this.getNodeByParent(parent);

                    if (akra.isNull(pNode)) {
                        return null;
                    }

                    var pMesh = this.extractMesh(sMeshName);

                    if (!akra.isNull(pMesh)) {
                        pScene = pNode.getScene();
                        pModel = pScene.createModel();
                        pModel.setMesh(pMesh);

                        this.buildAssetTransform(pModel);

                        return pModel;
                    }

                    return null;
                };

                Collada.prototype.extractFullScene = function (parent) {
                    var pScene;
                    var pNode = this.getNodeByParent(parent);
                    var pRoot;

                    var pSceneOutput = null;
                    var pMeshOutput = null;

                    if (akra.isNull(pNode)) {
                        return null;
                    }

                    pScene = pNode.getScene();

                    pRoot = pScene._createModelEntry(this);
                    pRoot.create();
                    pRoot.setName(this.getBasename());
                    pRoot.setInheritance(4 /* ALL */);

                    if (!pRoot.attachToParent(pNode)) {
                        akra.debug.error("could not attach to parent node");
                        return null;
                    }

                    if (this.isVisualSceneLoaded() && this.isSceneNeeded()) {
                        pSceneOutput = this.buildScene(pRoot);
                        pMeshOutput = this.buildMeshes();
                    }

                    //clear all links from collada nodes to scene nodes
                    this.buildComplete();

                    return pRoot;
                };

                Collada.prototype.extractAnimation = function (i) {
                    var pPoses;
                    var pSkeletons, pSkeleton;
                    var pAnimation = null;
                    var pData = this.getAnimation(i);

                    if (!akra.isNull(pData) && this.isAnimationNeeded() && this.isLibraryExists("library_animations")) {
                        pAnimation = this.buildAnimation(pData);

                        //дополним анимации начальными позициями костей
                        if (this.isPoseExtractionNeeded()) {
                            pSkeletons = this.getSkeletonsOutput() || [];

                            pPoses = this.buildInitialPoses(pSkeletons);

                            for (var j = 0; j < pPoses.length; ++j) {
                                pAnimation.extend(pPoses[j]);
                            }
                        }
                    }

                    return pAnimation;
                };

                Collada.prototype.extractAnimations = function () {
                    var pPoses;
                    var pSkeletons, pSkeleton;
                    var pAnimationOutput = null;

                    if (this.isAnimationNeeded() && this.isLibraryExists("library_animations")) {
                        pAnimationOutput = this.buildAnimations();

                        //дополним анимации начальными позициями костей
                        if (this.isPoseExtractionNeeded()) {
                            pSkeletons = this.getSkeletonsOutput() || [];

                            /*
                            
                            // добавим к начальным позам, те, в которых находятся меши
                            // в момент выгрузки
                            if (!isNull(pMeshOutput)) {
                            for (var i = 0; i < pMeshOutput.length; ++ i) {
                            pSkeletons.push(pMeshOutput[i].skeleton);
                            }
                            }
                            else {
                            //необхоимо для посчета ссылочной информации
                            if (isNull(pSceneOutput)) {
                            this.buildScene();
                            }
                            
                            this.eachByTag(pXMLRoot, "skeleton", function (pXML: Node) {
                            pSkeletons.push(this.buildSkeleton([stringData(pXML)]));
                            });
                            }
                            
                            */
                            pPoses = this.buildInitialPoses(pSkeletons);

                            for (var i = 0; i < pAnimationOutput.length; ++i) {
                                for (var j = 0; j < pPoses.length; ++j) {
                                    pAnimationOutput[i].extend(pPoses[j]);
                                }
                            }
                        }
                    }

                    return pAnimationOutput;
                };

                Collada.prototype.attachToScene = function (parent) {
                    return this.extractFullScene(parent);
                };

                Collada.prototype.getNodeByParent = function (parent) {
                    var pScene;
                    var pNode;

                    if (akra.isNull(parent)) {
                        return null;
                    }

                    if (!akra.isDef(parent)) {
                        //get default scene, if parent not present
                        parent = this.getManager().getEngine().getScene();
                    }

                    if (parent instanceof akra.scene.Node) {
                        //attach collada scene to give node
                        pNode = parent;
                    } else {
                        //attaching collada scene to new node, that is child of scene root
                        pScene = parent;
                        pNode = pScene.getRootNode();
                    }

                    return pNode;
                };

                Collada.isColladaResource = function (pItem) {
                    return isModelResource(pItem) && pItem.getModelFormat() === 4096 /* COLLADA */;
                };
                Collada.DEFAULT_OPTIONS = {
                    wireframe: false,
                    shadows: true,
                    animation: { pose: true },
                    scene: true,
                    extractPoses: true,
                    skeletons: [],
                    images: { flipY: false }
                };

                Collada.SCENE_TEMPLATE = [
                    { lib: 'library_images', element: 'image' },
                    { lib: 'library_effects', element: 'effect' },
                    { lib: 'library_materials', element: 'material' },
                    { lib: 'library_geometries', element: 'geometry' },
                    { lib: 'library_controllers', element: 'controller' },
                    { lib: 'library_cameras', element: 'camera' },
                    { lib: 'library_lights', element: 'light' },
                    { lib: 'library_visual_scenes', element: 'visual_scene' }
                ];

                Collada.ANIMATION_TEMPLATE = [
                    { lib: 'library_animations', element: 'animation' }
                ];

                Collada.COLLADA_MATERIAL_NAMES = [
                    "emission",
                    "ambient",
                    "diffuse",
                    "shininess",
                    "reflective",
                    "reflectivity",
                    "transparent",
                    "transparency",
                    "specular"
                ];
                return Collada;
            })(pool.ResourcePoolItem);
            resources.Collada = Collada;

            pSupportedVertexFormat = [
                { name: ["X"], type: ["float"] },
                { name: ["Y"], type: ["float"] },
                { name: ["Z"], type: ["float"] }
            ];

            pSupportedTextureFormat = [
                { name: ["S"], type: ["float"] },
                { name: ["T"], type: ["float"] },
                { name: ["P"], type: ["float"] }
            ];

            pSupportedColorFormat = [
                { name: ["R"], type: ["float"] },
                { name: ["G"], type: ["float"] },
                { name: ["B"], type: ["float"] }
            ];

            pSupportedWeightFormat = [
                { name: ["WEIGHT"], type: ["float"] }
            ];

            pSupportedJointFormat = [
                { name: ["JOINT"], type: ["Name", "IDREF"] }
            ];

            pSupportedInvBindMatrixFormat = [
                { name: ["TRANSFORM"], type: ["float4x4"] }
            ];

            pSupportedInterpolationFormat = [
                { name: ["INTERPOLATION"], type: ["Name"] }
            ];

            pSupportedInputFormat = [
                { name: ["TIME"], type: ["float"] }
            ];

            pSupportedOutputFormat = [
                { name: ["TRANSFORM", "X", "ANGLE", null], type: ["float4x4", "float"] },
                { name: ["Y"], type: ["float"] },
                { name: ["Z"], type: ["float"] }
            ];

            pSupportedTangentFormat = [
                { name: ["X"], type: ["float"] },
                { name: ["Y"], type: ["float"] },
                { name: ["X"], type: ["float"] },
                { name: ["Y"], type: ["float"] },
                { name: ["X"], type: ["float"] },
                { name: ["Y"], type: ["float"] },
                { name: ["X"], type: ["float"] },
                { name: ["Y"], type: ["float"] },
                { name: ["X"], type: ["float"] },
                { name: ["Y"], type: ["float"] }
            ];

            pFormatStrideTable = {
                "float": 1,
                "float2": 2,
                "float3": 3,
                "float4": 4,
                "float3x3": 9,
                "float4x4": 16,
                "int": 1,
                "name": 1,
                "Name": 1,
                "IDREF": 1
            };

            /* COMMON FUNCTIONS
            ------------------------------------------------------
            */
            function getSupportedFormat(sSemantics) {
                switch (sSemantics) {
                    case "TEXTANGENT":
                    case "TEXBINORMAL":
                    case "VERTEX":
                    case "NORMAL":
                    case "TANGENT":
                    case "BINORMAL":
                    case "POSITION":
                        return pSupportedVertexFormat;

                    case "TEXCOORD":
                        return pSupportedTextureFormat;

                    case "WEIGHT":
                        return pSupportedWeightFormat;

                    case "JOINT":
                        return pSupportedJointFormat;

                    case "INV_BIND_MATRIX":
                        return pSupportedInvBindMatrixFormat;

                    case "INTERPOLATION":
                        return pSupportedInterpolationFormat;

                    case "IN_TANGENT":
                        return pSupportedTangentFormat;

                    case "INPUT":
                        return pSupportedInputFormat;

                    case "OUT_TANGENT":
                        return pSupportedTangentFormat;

                    case "OUTPUT":
                        return pSupportedOutputFormat;
                    case "COLOR":
                        return pSupportedColorFormat;
                    case "UV":
                    case "MORPH_WEIGHT":
                    case "MORPH_TARGET":
                    case "LINEAR_STEPS":
                    case "IMAGE":
                    case "CONTINUITY":
                        return null;
                }

                akra.logger.error("unknown semantics founded: " + sSemantics);

                return null;
            }

            function calcFormatStride(pFormat) {
                var iStride = 0;
                var s = null;

                for (var i = 0; i < pFormat.length; ++i) {
                    s = pFormat[i].type[0];
                    iStride += pFormatStrideTable[s];
                }

                return iStride;
            }

            // additional
            function printArray(pArr, nRow, nCol) {
                var s = "\n";

                for (var i = 0; i < pArr.length; ++i) {
                    if (i % nCol == 0) {
                        s += "  ";
                    }

                    s += pArr[i] + ", ";

                    if ((i + 1) % nRow == 0) {
                        s += '\n';
                    }
                }

                return s;
            }

            function sortArrayByProperty(pData, sProperty) {
                var tmp;

                for (var i = pData.length - 1; i > 0; i--) {
                    for (var j = 0; j < i; j++) {
                        if (pData[j][sProperty] > pData[j + 1][sProperty]) {
                            tmp = pData[j];
                            pData[j] = pData[j + 1];
                            pData[j + 1] = tmp;
                        }
                    }
                }

                return pData;
            }

            function stringData(pXML) {
                return (akra.isDefAndNotNull(pXML) ? pXML.textContent : null);
            }

            function attr(pXML, sName) {
                return pXML.getAttribute(sName);
            }

            function firstChild(pXML, sTag) {
                if (akra.isString(sTag)) {
                    return pXML.getElementsByTagName(sTag)[0];
                }

                for (var i = 0; i < pXML.childNodes.length; i++) {
                    if (pXML.childNodes[i].nodeType === Node.ELEMENT_NODE) {
                        return pXML.childNodes[i];
                    }
                }

                return null;
            }

            function isModelResource(pItem) {
                return pool.isVideoResource(pItem) && pItem.getResourceCode().getType() === 6 /* MODEL_RESOURCE */;
            }
            resources.isModelResource = isModelResource;
        })(pool.resources || (pool.resources = {}));
        var resources = pool.resources;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="../../idl/IObj.ts" />
/// <reference path="../ResourcePoolItem.ts" />
/// <reference path="../../debug.ts" />
/// <reference path="../../config/config.ts" />
/// <reference path="../../io/io.ts" />
var akra;
(function (akra) {
    var ExternalGeometry = (function () {
        function ExternalGeometry() {
            this.vertices = [];
            this.normals = [];
            this.uv = [];
        }
        ExternalGeometry.prototype.uploadDataWithMultipleIndex = function (data) {
            return true;
        };

        ExternalGeometry.prototype.uploadDataWithSingleIndex = function (data) {
            return true;
        };
        return ExternalGeometry;
    })();
})(akra || (akra = {}));

var akra;
(function (akra) {
    (function (pool) {
        (function (resources) {
            var Vec3 = akra.math.Vec3;

            var VE = akra.data.VertexElement;
            var Color = akra.color.Color;

            (function (EObjFVF) {
                EObjFVF[EObjFVF["XYZ"] = 0x01] = "XYZ";
                EObjFVF[EObjFVF["NORMAL"] = 0x02] = "NORMAL";
                EObjFVF[EObjFVF["UV"] = 0x04] = "UV";
            })(resources.EObjFVF || (resources.EObjFVF = {}));
            var EObjFVF = resources.EObjFVF;

            function regExpResultToFloatArray(pSrc, ppDest, iFrom) {
                if (typeof iFrom === "undefined") { iFrom = -1; }
                //i = 1 ==> regexp result starts from original value, like: ("1 2 3").match(/([1-9])/i) = ["1 2 3", "1", "2", "3"];
                var j = 0;

                //writing into end of dest array
                if (iFrom < 0) {
                    iFrom = ppDest.length;
                }

                for (var i = 1; i < pSrc.length; ++i) {
                    if (pSrc[i]) {
                        ppDest[iFrom + j] = parseFloat(pSrc[i].replace(/,/g, "."));
                        j++;
                    }
                }

                return j;
            }
            ;

            var Obj = (function (_super) {
                __extends(Obj, _super);
                function Obj() {
                    _super.apply(this, arguments);
                    this._sFilename = null;
                    this._iByteLength = 0;
                    this._pOptions = {};
                    this._pVertices = [];
                    this._pNormals = [];
                    this._pTextureCoords = [];
                    this._pVertexIndexes = [];
                    this._pTexcoordIndexes = [];
                    this._pNormalIndexes = [];
                    //flexible vertex format
                    this._iFVF = 0;
                }
                Obj.prototype.getModelFormat = function () {
                    return 8192 /* OBJ */;
                };

                Obj.prototype.getByteLength = function () {
                    return this._iByteLength;
                };

                Obj.prototype.getOptions = function () {
                    return this._pOptions;
                };

                Obj.prototype.getFilename = function () {
                    return this._sFilename;
                };

                Obj.prototype.getBasename = function () {
                    return akra.path.parse(this._pOptions.name || this._sFilename || "unknown").getBaseName();
                };

                Obj.prototype.setFilename = function (sName) {
                    this._sFilename = sName;
                };

                Obj.prototype.setOptions = function (pOptions) {
                    if (akra.isNull(pOptions)) {
                        pOptions = Obj.DEFAULT_OPTIONS;
                    }

                    for (var i in Obj.DEFAULT_OPTIONS) {
                        this._pOptions[i] = pOptions[i] || this._pOptions[i] || Obj.DEFAULT_OPTIONS[i];
                    }
                };

                Obj.prototype.attachToScene = function (parent) {
                    var pScene;
                    var pNode;
                    var pRoot;

                    if (akra.isNull(parent)) {
                        return null;
                    }

                    if (parent instanceof akra.scene.Node) {
                        //attach collada scene to give node
                        pNode = parent;
                        pScene = pNode.getScene();
                    } else {
                        //attaching collada scene to new node, that is child of scene root
                        pScene = parent;
                        pNode = pScene.getRootNode();
                    }

                    pRoot = pScene._createModelEntry(this);
                    pRoot.create();
                    pRoot.setName(this.getBasename());
                    pRoot.setInheritance(4 /* ALL */);

                    if (!pRoot.attachToParent(pNode)) {
                        return null;
                    }

                    this.buildMesh(pRoot);

                    return pRoot;
                };

                Obj.prototype.buildMesh = function (pRoot) {
                    var pMesh = null, pSubMesh = null;

                    var pVerticesData = new Float32Array(this._pVertices);
                    var pNormalsData = new Float32Array(this._pNormals);
                    var pTexcoordsData = new Float32Array(this._pTextureCoords);

                    // console.log(pVerticesData, pNormalsData)
                    var pVertexIndicesData = new Float32Array(this._pVertexIndexes);
                    var pNormalIndicesData = new Float32Array(this._pNormalIndexes);
                    var pTexcoordIndicesData = new Float32Array(this._pTexcoordIndexes);

                    var iPos = 0, iNorm = 0, iTexcoord = 0;

                    var pEngine = this.getEngine();

                    pMesh = akra.model.createMesh(pEngine, this.getBasename(), akra.EMeshOptions.HB_READABLE);
                    pSubMesh = pMesh.createSubset(this.getBasename(), 4 /* TRIANGLELIST */);

                    iPos = pSubMesh.getData().allocateData([VE.float3('POSITION')], pVerticesData);
                    pSubMesh.getData().allocateIndex([VE.float('INDEX0')], pVertexIndicesData);
                    pSubMesh.getData().index(iPos, 'INDEX0');

                    // console.log(pVerticesData, pVertexIndicesData);
                    if (this.hasNormals()) {
                        iNorm = pSubMesh.getData().allocateData([VE.float3('NORMAL')], pNormalsData);

                        if (this._pNormalIndexes.length > 0) {
                            pSubMesh.getData().allocateIndex([VE.float('INDEX1')], pNormalIndicesData);
                            pSubMesh.getData().index(iNorm, 'INDEX1');
                            // console.log(pNormalsData, pNormalIndicesData);
                        } else {
                            akra.logger.log("[OBJ [" + this.findResourceName() + "]]", "normal index was replaced with vertex index");
                            pSubMesh.getData().allocateIndex([VE.float('INDEX1')], pVertexIndicesData);
                            pSubMesh.getData().index(iNorm, 'INDEX1');
                        }
                    }

                    if (this.hasTexcoords()) {
                        akra.logger.log("[OBJ [" + this.findResourceName() + "]]", "model have texture coordinates");
                        iTexcoord = pSubMesh.getData().allocateData([VE.float2('TEXCOORD0')], pTexcoordsData);
                        pSubMesh.getData().allocateIndex([VE.float('INDEX2')], pTexcoordIndicesData);
                        pSubMesh.getData().index('TEXCOORD0', 'INDEX2');
                        // console.log(pTexcoordsData, pTexcoordIndicesData);
                    } else {
                        akra.logger.log("[OBJ [" + this.findResourceName() + "]]", "model does not have any texture coordinates");
                    }

                    pSubMesh.setShadow(this.getOptions().shadows);
                    pSubMesh.getRenderMethod().getEffect().addComponent("akra.system.mesh_texture");

                    var pMatrial = pSubMesh.getRenderMethod().getSurfaceMaterial().getMaterial();
                    pMatrial.diffuse = new Color(0.7, 0., 0., 1.);
                    pMatrial.ambient = new Color(0., 0., 0., 1.);
                    pMatrial.specular = new Color(0.7, 0., 0., 1);
                    pMatrial.emissive = new Color(0., 0., 0., 1.);
                    pMatrial.shininess = 30.;

                    var pSceneModel = pRoot.getScene().createModel(this.getBasename());
                    pSceneModel.setInheritance(4 /* ALL */);
                    pSceneModel.setMesh(pMesh);

                    pSubMesh.wireframe(true);

                    pSceneModel.attachToParent(pRoot);
                };

                Obj.prototype.uploadVertexes = function (pPositions, pIndexes) {
                    if (typeof pIndexes === "undefined") { pIndexes = null; }
                    for (var i = 0; i < pPositions.length; ++i) {
                        this._pVertices[i] = pPositions[i];
                    }

                    if (!akra.isNull(pIndexes)) {
                        for (var i = 0; i < pIndexes.length; ++i) {
                            this._pVertexIndexes[i] = pIndexes[i];
                        }
                    }

                    this.calcDeps();

                    this.notifyRestored();
                    this.notifyLoaded();
                };

                Obj.prototype.parse = function (sData, pOptions) {
                    if (typeof pOptions === "undefined") { pOptions = null; }
                    if (akra.isNull(sData)) {
                        akra.debug.error("must be specified obj content.");
                        return false;
                    }

                    akra.debug.log("[OBJ [" + this.findResourceName() + "]]", "parsing started...");
                    this.setOptions(pOptions);

                    var pLines = sData.split("\n");

                    for (var i = 0; i < pLines.length; ++i) {
                        //current line
                        var sLine = pLines[i];

                        //first character
                        var c = sLine.charAt(0);

                        switch (c) {
                            case 'v':
                                this.readVertexInfo(sLine);
                                break;
                            case 'f':
                                this.readFaceInfo(sLine);
                                break;
                        }
                    }

                    for (var i = 0; i < this._pVertexIndexes.length; ++i) {
                        this._pVertexIndexes[i]--;
                    }

                    for (var i = 0; i < this._pNormalIndexes.length; ++i) {
                        this._pNormalIndexes[i]--;
                    }

                    for (var i = 0; i < this._pTexcoordIndexes.length; ++i) {
                        this._pTexcoordIndexes[i]--;
                    }

                    //end of index fix
                    this.calcDeps();

                    return true;
                };

                Obj.prototype.calcDeps = function () {
                    //FIXME: crete model with out indices, instead using pseudo indices like 0, 1, 2, 3....
                    //fill indices, if not presented
                    if (this._pVertexIndexes.length === 0) {
                        this.calcVertexIndices();
                    }

                    if (!this._pNormals.length) {
                        akra.debug.log("[OBJ [" + this.findResourceName() + "]]", "calculation normals....");
                        this.calcNormals();
                    }
                };

                Obj.prototype.calcVertexIndices = function () {
                    for (var i = 0; i < this._pVertices.length; ++i) {
                        this._pVertexIndexes[i] = i;
                    }
                };

                Obj.prototype.calcNormals = function (useSmoothing) {
                    if (typeof useSmoothing === "undefined") { useSmoothing = true; }
                    var v = new Array(3), p = new Vec3, q = new Vec3, n = new Vec3;
                    var i, j, k;

                    for (i = 0; i < this._pVertices.length; ++i) {
                        this._pNormals[i] = 0.;
                    }

                    var pNormalsWeights = new Float32Array(this._pNormals.length / 3);

                    for (i = 0; i < this._pVertexIndexes.length; i += 3) {
                        for (k = 0; k < 3; ++k) {
                            j = this._pVertexIndexes[i + k] * 3;
                            v[k] = Vec3.temp([this._pVertices[j], this._pVertices[j + 1], this._pVertices[j + 2]]);
                        }

                        v[1].subtract(v[2], p);
                        v[0].subtract(v[2], q);
                        p.cross(q, n);
                        n.normalize();
                        n.negate();

                        for (k = 0; k < 3; ++k) {
                            var r = this._pVertexIndexes[i + k];
                            pNormalsWeights[r]++;
                            j = r * 3;
                            this._pNormals[j] += n.x;
                            this._pNormals[j + 1] += n.y;
                            this._pNormals[j + 2] += n.z;
                        }
                    }

                    for (i = 0; i < pNormalsWeights.length; i++) {
                        j = i * 3;

                        //console.log(pNormalsWeights[i]);
                        n.set(this._pNormals[j], this._pNormals[j + 1], this._pNormals[j + 2]).scale(1 / pNormalsWeights[i]).normalize();

                        this._pNormals[j] = n.x;
                        this._pNormals[j + 1] = n.y;
                        this._pNormals[j + 2] = n.z;
                    }

                    this._iFVF = akra.bf.setAll(this._iFVF, 2 /* NORMAL */);
                };

                Obj.prototype.readVertexInfo = function (s) {
                    //<s> - current line
                    //second character of line <s>
                    var ch = s.charAt(1);

                    //results of regexp matching
                    var pm;

                    var v;

                    s = s.replace("\r", "");

                    //List of Vertices, with (x,y,z[,w]) coordinates, w is optional.
                    if (ch == ' ') {
                        pm = s.match(Obj.VERTEX_REGEXP);
                        akra.debug.assert(!akra.isNull(pm), "invalid line detected: <" + s + ">");
                        regExpResultToFloatArray(pm, Obj.row, 0);

                        this._pVertices.push(Obj.row[0], Obj.row[1], Obj.row[2]);

                        this._iFVF = akra.bf.setAll(this._iFVF, 1 /* XYZ */);
                    } else if (ch == 't') {
                        pm = s.match(Obj.TEXCOORD_REGEXP);
                        akra.debug.assert(!akra.isNull(pm), "invalid line detected: <" + s + "> (" + Obj.TEXCOORD_REGEXP.toString() + ")");
                        regExpResultToFloatArray(pm, this._pTextureCoords);
                        this._iFVF = akra.bf.setAll(this._iFVF, 4 /* UV */);
                    } else if (ch == 'n') {
                        pm = s.match(Obj.NORMAL_REGEXP);
                        akra.debug.assert(!akra.isNull(pm), "invalid line detected: <" + s + ">");
                        regExpResultToFloatArray(pm, Obj.row, 0);
                        this._pNormals.push(Obj.row[0], Obj.row[1], Obj.row[2]);
                        this._iFVF = akra.bf.setAll(this._iFVF, 2 /* NORMAL */);
                    }
                };

                Obj.prototype.hasTexcoords = function () {
                    return (this._iFVF & 4 /* UV */) != 0;
                };

                Obj.prototype.hasNormals = function () {
                    return (this._iFVF & 2 /* NORMAL */) != 0;
                };

                Obj.prototype.readFaceInfo = function (s) {
                    //results of regexp matching
                    var pm;

                    // vertex / texcoord
                    if (this.hasTexcoords() && !this.hasNormals()) {
                        pm = s.match(Obj.VERTEX_UV_FACE_REGEXP);

                        regExpResultToFloatArray(pm, Obj.row, 0);

                        this._pVertexIndexes.push(Obj.row[0], Obj.row[2], Obj.row[4]);
                        this._pTexcoordIndexes.push(Obj.row[1], Obj.row[3], Obj.row[5]);
                    } else if (!this.hasTexcoords() && this.hasNormals()) {
                        pm = s.match(Obj.VERTEX_NORMAL_FACE_REGEXP);
                        akra.debug.assert(!akra.isNull(pm), "invalid line detected: <" + s + ">");

                        // if (!pm) {
                        //     this._isObjectHasNormals = false;
                        //     this._readFaceInfo(s);
                        //     return;
                        // }
                        regExpResultToFloatArray(pm, Obj.row, 0);
                        this._pVertexIndexes.push(Obj.row[0], Obj.row[2], Obj.row[4]);
                        this._pNormalIndexes.push(Obj.row[1], Obj.row[3], Obj.row[5]);
                    } else if (this.hasTexcoords() && this.hasNormals()) {
                        pm = s.match(Obj.VERTEX_UV_NORMAL_FACE_REGEXP);
                        akra.debug.assert(!akra.isNull(pm), "invalid line detected: <" + s + ">");
                        regExpResultToFloatArray(pm, Obj.row, 0);
                        this._pVertexIndexes.push(Obj.row[0], Obj.row[3], Obj.row[6]);
                        this._pTexcoordIndexes.push(Obj.row[1], Obj.row[4], Obj.row[7]);
                        this._pNormalIndexes.push(Obj.row[2], Obj.row[5], Obj.row[8]);
                    } else {
                        pm = s.match(/^f[\s]+([\d]+)[\s]+([\d]+)[\s]+([\d]+)[\s]*$/i);
                        akra.debug.assert(!akra.isNull(pm), "invalid line detected: <" + s + ">");
                        regExpResultToFloatArray(pm, Obj.row, 0);
                        this._pVertexIndexes.push(Obj.row[0], Obj.row[1], Obj.row[2]);
                    }
                };

                Obj.prototype.loadResource = function (sFilename, pOptions) {
                    var _this = this;
                    if (typeof sFilename === "undefined") { sFilename = null; }
                    if (typeof pOptions === "undefined") { pOptions = null; }
                    if (akra.isNull(sFilename)) {
                        sFilename = this.findResourceName();
                    }

                    if (this.isResourceLoaded()) {
                        akra.debug.warn("[OBJ::" + this.findResourceName() + "]", "obj model already loaded");
                        return false;
                    }

                    this.setFilename(sFilename);

                    this.notifyDisabled();
                    this.notifyUnloaded();

                    var pFile = akra.io.fopen(sFilename);

                    pFile.open(function (err, meta) {
                        //FIXME: setuop byteLength correctly..
                        this["_iByteLength"] = meta.size || 0;
                    });

                    pFile.read(function (pErr, sXML) {
                        if (!akra.isNull(pErr)) {
                            akra.logger.error(pErr);
                        }

                        _this.notifyRestored();

                        if (_this.parse(sXML, pOptions)) {
                            akra.debug.log("[OBJ::" + _this.findResourceName() + "]", "resource loaded");
                            _this.notifyLoaded();
                        }
                    });

                    return true;
                };
                Obj.VERTEX_REGEXP = /^v[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)([\s]+[-+]?[\d]*[\.|\,]?[\de-]*?)?[\s]*$/i;

                Obj.TEXCOORD_REGEXP = /^vt[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)[\s]*.*$/i;

                Obj.NORMAL_REGEXP = /^vn[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)[\s]*$/i;

                Obj.VERTEX_UV_FACE_REGEXP = /^f[\s]+([\d]+)\/([\d]*)[\s]+([\d]+)\/([\d]*)[\s]+([\d]+)\/([\d]*)[\s]*$/i;
                Obj.VERTEX_NORMAL_FACE_REGEXP = /^f[\s]+([\d]+)\/\/([\d]*)[\s]+([\d]+)\/\/([\d]*)[\s]+([\d]+)\/\/([\d]*)[\s]*$/i;
                Obj.VERTEX_UV_NORMAL_FACE_REGEXP = /^f[\s]+([\d]+)\/([\d]*)\/([\d]*)[\s]+([\d]+)\/([\d]*)\/([\d]*)[\s]+([\d]+)\/([\d]*)\/([\d]*)[\s]*$/i;

                Obj.DEFAULT_OPTIONS = {
                    shadows: true
                };

                Obj.row = [0, 0, 0, 0, 0, 0, 0, 0, 0];
                return Obj;
            })(pool.ResourcePoolItem);
            resources.Obj = Obj;
        })(pool.resources || (pool.resources = {}));
        var resources = pool.resources;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="../../idl/IAFXComposer.ts" />
/// <reference path="../../idl/IFile.ts" />
/// <reference path="../../idl/parser/IParser.ts" />
var akra;
(function (akra) {
    (function (pool) {
        /// <reference path="../../io/io.ts" />
        /// <reference path="../../config/config.ts" />
        /// <reference path="../../common.ts" />
        /// <reference path="../../fx/EffectParser.ts" />
        /// <reference path="../ResourcePoolItem.ts" />
        (function (resources) {
            var EffectData = (function (_super) {
                __extends(EffectData, _super);
                function EffectData() {
                    _super.apply(this, arguments);
                    this._pFile = null;
                    this._pSyntaxTree = null;
                }
                EffectData.prototype.createResource = function () {
                    this.notifyCreated();
                    return true;
                };

                EffectData.prototype.getByteLength = function () {
                    return this._pFile ? this._pFile.getByteLength() : 0;
                };

                EffectData.prototype.loadResource = function (sFileName) {
                    var _this = this;
                    //var reExt: RegExp  = /^(.+)(\.afx|\.abf|\.fx)$/;
                    //var pRes:RegExpExecArray = reExt.exec(sFileName);
                    var sExt;

                    if (akra.uri.parse(sFileName).getScheme() === "blob:") {
                        sExt = akra.path.parse(akra.deps.resolve(sFileName)).getExt();
                    } else {
                        sExt = akra.path.parse(sFileName).getExt();
                    }

                    if (["afx", "abf", "fx"].indexOf(sExt) === -1) {
                        akra.logger.error("Bad effect file extension. Only .afx, .fx, .abf are available");
                        return;
                    }

                    var isBinary = sExt === "abf";
                    var pComposer = this.getManager().getEngine().getComposer();

                    if (!akra.config.AFX_ENABLE_TEXT_EFFECTS) {
                        //binary only
                        if (!isBinary) {
                            akra.logger.error("You can load text effect-files only in debug-mode");
                            return;
                        }
                    }

                    if (isBinary) {
                        var pFile = this._pFile = akra.io.fopen(sFileName, "r+b");

                        pFile.read(function (err, pData) {
                            if (err) {
                                akra.logger.error("Can not read file");
                            } else {
                                _this._initFromBinaryData(pData, sFileName);
                            }
                        });

                        return true;
                    }

                    if (akra.config.AFX_ENABLE_TEXT_EFFECTS) {
                        //text only
                        var pFile = this._pFile = akra.io.fopen(sFileName, "r+t");
                        var me = this;

                        pFile.read(function (pErr, sData) {
                            if (!akra.isNull(pErr)) {
                                akra.logger.error("Can not load .afx file: '" + sFileName + "'");
                            } else {
                                akra.fx.effectParser.setParseFileName(sFileName);
                                akra.fx.effectParser.parse(sData, me._initFromParsedEffect, me);
                            }
                        });
                    }

                    return true;
                };

                EffectData.prototype._initFromParsedEffect = function (eCode, sFileName) {
                    if (eCode === 2 /* k_Error */) {
                        return;
                    }

                    this._pSyntaxTree = akra.fx.effectParser.getSyntaxTree();

                    var pComposer = this.getManager().getEngine().getComposer();

                    if (pComposer._loadEffectFromSyntaxTree(this._pSyntaxTree, sFileName)) {
                        this.notifyLoaded();
                    }
                };

                EffectData.prototype._initFromBinaryData = function (pData, sFileName) {
                    akra.debug.error("todo: not implemented.");
                    // var pComposer: IAFXComposer = this.getManager().getEngine().getComposer();
                    // pComposer._loadEffectFromBinary(this._pSyntaxTree, sFileName);
                };
                return EffectData;
            })(pool.ResourcePoolItem);
            resources.EffectData = EffectData;
        })(pool.resources || (pool.resources = {}));
        var resources = pool.resources;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="../idl/IVertexData.ts" />
/// <reference path="../idl/IVertexBuffer.ts" />
/// <reference path="../idl/IVertexElement.ts" />
/// <reference path="../idl/IVertexDeclaration.ts" />
/// <reference path="../idl/IBufferDataModifier.ts" />
var akra;
(function (akra) {
    /// <reference path="../math/math.ts" />
    /// <reference path="../logger.ts" />
    /// <reference path="../events.ts" />
    /// <reference path="../conv/conv.ts" />
    /// <reference path="../config/config.ts" />
    /// <reference path="../guid.ts" />
    /// <reference path="VertexDeclaration.ts" />
    (function (data) {
        var AEVertexDataLimits;
        (function (AEVertexDataLimits) {
            AEVertexDataLimits[AEVertexDataLimits["k_MaxElementsSize"] = 256] = "k_MaxElementsSize";
        })(AEVertexDataLimits || (AEVertexDataLimits = {}));

        var VertexData = (function () {
            function VertexData(pVertexBuffer, id, iOffset, iCount, pDecl) {
                this.guid = akra.guid();
                this.setupSignals();

                this._pVertexBuffer = pVertexBuffer;
                this._iOffset = iOffset;
                this._iLength = iCount;
                this._iId = id;
                this._pVertexDeclaration = null;
                this._iStride = 0;

                if (akra.isInt(pDecl)) {
                    this._iStride = pDecl;
                } else {
                    this._iStride = pDecl.stride;
                    this.setVertexDeclaration(pDecl);
                }

                akra.logger.assert(pVertexBuffer.getByteLength() >= this.getByteLength() + this.getByteOffset(), "vertex data out of array limits");
            }
            VertexData.prototype.getID = function () {
                return this._iId;
            };

            VertexData.prototype.getLength = function () {
                return this._iLength;
            };

            VertexData.prototype.getByteOffset = function () {
                return this._iOffset;
            };

            VertexData.prototype.getByteLength = function () {
                return this._iLength * this._iStride;
            };

            VertexData.prototype.getBuffer = function () {
                return this._pVertexBuffer;
            };

            VertexData.prototype.getStride = function () {
                return this._iStride;
            };

            VertexData.prototype.getStartIndex = function () {
                var iIndex = this.getByteOffset() / this.getStride();
                akra.logger.assert(iIndex % 1 == 0, "cannot calc first element index");
                return iIndex;
            };

            VertexData.prototype.setupSignals = function () {
                this.resized = this.resized || new akra.Signal(this);
                this.relocated = this.relocated || new akra.Signal(this);
                this.declarationChanged = this.declarationChanged || new akra.Signal(this);
                this.updated = this.updated || new akra.Signal(this);
            };

            VertexData.prototype.getVertexDeclaration = function () {
                return this._pVertexDeclaration;
            };

            VertexData.prototype.setVertexDeclaration = function (pDecl) {
                if (this._pVertexDeclaration) {
                    //debug_error("vertex declaration already exists");
                    return false;
                }

                var iStride = pDecl.stride;

                this._pVertexDeclaration = pDecl.clone();

                akra.logger.assert(iStride < 256 /* k_MaxElementsSize */, "stride max is 255 bytes");
                akra.logger.assert(iStride <= this.getStride(), "stride in VertexDeclaration grather than stride in construtor");

                this.declarationChanged.emit(this._pVertexDeclaration);

                return true;
            };

            VertexData.prototype.getVertexElementCount = function () {
                return this._pVertexDeclaration.getLength();
            };

            VertexData.prototype.hasSemantics = function (sUsage) {
                if (this._pVertexDeclaration != null) {
                    return this._pVertexDeclaration.hasSemantics(sUsage);
                }

                return false;
            };

            VertexData.prototype.destroy = function () {
                this._pVertexDeclaration = null;
                this._iLength = 0;
            };

            VertexData.prototype.extend = function (pDecl, pData) {
                if (typeof pData === "undefined") { pData = null; }
                pDecl = data.VertexDeclaration.normalize(pDecl);

                if (akra.isNull(pData)) {
                    pData = new Uint8Array(this.getLength() * pDecl.stride);
                } else {
                    pData = new Uint8Array(pData.buffer);
                }

                akra.logger.assert(this.getLength() === pData.byteLength / pDecl.stride, 'invalid data size for extending');

                var nCount = this._iLength;

                //strides modifications
                var nStrideNew = pDecl.stride;
                var nStridePrev = this.getStride();
                var nStrideNext = nStridePrev + nStrideNew;

                //total bytes after extending
                var nTotalSize = nStrideNext * this.getLength();
                var pDeclNew = this.getVertexDeclaration().clone();

                //data migration
                var pDataPrev = new Uint8Array(this.getData());
                var pDataNext = new Uint8Array(nTotalSize);

                for (var i = 0, iOffset; i < nCount; ++i) {
                    iOffset = i * nStrideNext;
                    pDataNext.set(pDataPrev.subarray(i * nStridePrev, (i + 1) * nStridePrev), iOffset);
                    pDataNext.set(pData.subarray(i * nStrideNew, (i + 1) * nStrideNew), iOffset + nStridePrev);
                }

                if (!pDeclNew.extend(pDecl)) {
                    return false;
                }

                if (!this.resize(nCount, pDeclNew)) {
                    return false;
                }

                return this.setData(pDataNext, 0, nStrideNext);
            };

            VertexData.prototype.resize = function (nCount, pDecl) {
                var iStride = 0;
                var iOldOffset = this.getByteOffset();
                var pOldVertexBuffer;
                var pOldVertexDeclaration;
                var iOldStride;

                //debug_print("VertexData (offset: " + this.byteOffset + ") resized from " + this.byteLength + " to ", arguments);
                if (arguments.length === 2) {
                    if (akra.isInt(pDecl)) {
                        iStride = pDecl;
                    } else {
                        iStride = pDecl.stride;
                    }

                    if (nCount * iStride <= this.getByteLength()) {
                        this._iLength = nCount;
                        this._iStride = iStride;
                        this._pVertexDeclaration = null;

                        if (!akra.isInt(pDecl)) {
                            this.setVertexDeclaration(pDecl);
                        }

                        this.resized.emit(this.getByteLength());
                        return true;
                    } else {
                        //debug.log("before");
                        //debug.log(this.toString());
                        pOldVertexBuffer = this.getBuffer();

                        pOldVertexBuffer.freeVertexData(this);

                        if (pOldVertexBuffer.getEmptyVertexData(nCount, pDecl, this) !== this) {
                            return false;
                        }

                        if (this.getByteOffset() != iOldOffset) {
                            // debug.log("VD 1", (<any>(new Error())).stack);
                            akra.logger.warn("vertex data moved from " + iOldOffset + " ---> " + this.getByteOffset());
                            this.relocated.emit(iOldOffset, this.getByteOffset());
                        }

                        this.resized.emit(this.getByteLength());

                        //debug.log("after");
                        //debug.log(this.toString());
                        return true;
                    }
                } else if (arguments.length == 1) {
                    if (nCount <= this.getLength()) {
                        this._iLength = nCount;
                        this.resized.emit(this.getByteLength());
                        return true;
                    } else {
                        //debug.log("before");
                        //debug.log(this.toString());
                        pOldVertexBuffer = this.getBuffer();
                        pOldVertexDeclaration = this.getVertexDeclaration();
                        iOldStride = this.getStride();

                        pOldVertexBuffer.freeVertexData(this);

                        if (pOldVertexBuffer.getEmptyVertexData(nCount, iOldStride, this) == null) {
                            return false;
                        }

                        this.setVertexDeclaration(pOldVertexDeclaration);

                        if (this.getByteOffset() != iOldOffset) {
                            // debug.log("VD 2", (<any>(new Error())).stack);
                            akra.logger.warn("vertex data moved from " + iOldOffset + " ---> " + this.getByteOffset());
                            this.relocated.emit(iOldOffset, this.getByteOffset());
                        }

                        this.resized.emit(this.getByteLength());

                        //debug.log("after");
                        //debug.log(this.toString());
                        return true;
                    }
                }

                return false;
            };

            VertexData.prototype.applyModifier = function (sUsage, fnModifier) {
                var pData = this.getTypedData(sUsage);
                fnModifier(pData);
                return this.setData(pData, sUsage);
            };

            VertexData.prototype.setData = function (pData) {
                var iOffset;
                var iSize;
                var nCountStart;
                var nCount;

                var iStride;
                var pVertexBuffer = this._pVertexBuffer;
                var pBackupBuf;
                var pDataU8;
                var k;
                var iOffsetBuffer;
                var pDeclaration = this._pVertexDeclaration;
                var pElement;

                switch (arguments.length) {
                    case 5:
                        if (akra.isString(arguments[1])) {
                            iOffset = this._pVertexDeclaration.findElement(arguments[1]).offset;
                        } else {
                            iOffset = arguments[1];
                        }

                        iSize = arguments[2];
                        nCountStart = arguments[3];
                        nCount = arguments[4];

                        iStride = this.getStride();
                        pDataU8 = new Uint8Array(pData.buffer);
                        if (iStride != iSize) {
                            //FIXME: очень тормознутое место, крайне медленно работает...
                            if (pVertexBuffer.isBackupPresent() && nCount > 1) {
                                // console.log(pVertexBuffer.byteLength);
                                pBackupBuf = new Uint8Array(pVertexBuffer.getByteLength());
                                pVertexBuffer.readData(pBackupBuf);

                                iOffsetBuffer = this.getByteOffset();

                                for (var i = nCountStart; i < nCount + nCountStart; i++) {
                                    for (k = 0; k < iSize; k++) {
                                        pBackupBuf[iStride * i + iOffset + iOffsetBuffer + k] = pDataU8[iSize * (i - nCountStart) + k];
                                    }
                                }

                                pVertexBuffer.writeData(pBackupBuf, 0, pVertexBuffer.getByteLength());
                            } else {
                                for (var i = 0; i < nCount; i++) {
                                    var iCurrent = i + nCountStart;

                                    pVertexBuffer.writeData(pDataU8.subarray(iSize * i, iSize * (i + 1)), iStride * iCurrent + iOffset + this.getByteOffset(), iSize);
                                }
                            }
                        } else {
                            pVertexBuffer.writeData(pDataU8.subarray(0, iStride * nCount), this.getByteOffset() + iStride * nCountStart, iStride * nCount);
                        }

                        this.updated.emit();
                        return true;
                    case 4:
                        pElement = null;

                        if (akra.isString(arguments[1])) {
                            pElement = pDeclaration.findElement(arguments[1]);

                            if (pElement) {
                                return this.setData(pData, pElement.offset, pElement.size, arguments[2], arguments[3]);
                            }

                            return false;
                        }

                        iOffset = arguments[1];
                        iSize = arguments[2];
                        nCountStart = arguments[3] || 0;
                        nCount = pData.byteLength / iSize;

                        return this.setData(pData, iOffset, iSize, nCountStart, nCount);

                    case 2:
                    case 3:
                        pDeclaration = this._pVertexDeclaration;
                        pElement = null;

                        if (akra.isString(arguments[1])) {
                            pElement = pDeclaration.findElement(arguments[1]);

                            if (pElement) {
                                //nCountStart = arguments[2] || 0
                                nCountStart = 0;
                                nCount = pData.buffer.byteLength / pElement.size;

                                return this.setData(pData, pElement.offset, pElement.size, nCountStart, nCount);
                            }

                            return false;
                        } else if (arguments.length === 3) {
                            iOffset = arguments[1];
                            iSize = arguments[2];
                            nCountStart = 0;
                            nCount = pData.byteLength / iSize;

                            return this.setData(pData, iOffset, iSize, nCountStart, nCount);
                        }

                        return false;

                    case 1:
                        return this.setData(pData, this._pVertexDeclaration.element(0).usage);
                    default:
                        return false;
                }
            };

            VertexData.prototype.getData = function () {
                switch (arguments.length) {
                    case 4:
                    case 2:
                        if (akra.isString(arguments[0])) {
                            return null;
                        }

                        var iOffset = arguments[0];
                        var iSize = arguments[1];
                        var iFrom = 0;
                        var iCount = this._iLength;

                        if (arguments.length === 4) {
                            iFrom = arguments[2] || 0;
                            iCount = arguments[3] || this._iLength;
                        }

                        iCount = akra.math.min(iCount, this._iLength);

                        var iStride = this.getStride();
                        var pBufferData = new Uint8Array(iSize * iCount);

                        for (var i = 0; i < iCount; i++) {
                            var iCurrent = iFrom + i;
                            var isOk = this._pVertexBuffer.readData(iStride * iCurrent + iOffset + this.getByteOffset(), iSize, pBufferData.subarray(i * iSize, (i + 1) * iSize));
                        }

                        return pBufferData.buffer;

                    case 3:
                    case 1:
                        var pDeclaration = this._pVertexDeclaration, pElement = null;

                        if (akra.isString("string")) {
                            pElement = pDeclaration.findElement(arguments[0]);

                            if (akra.isDefAndNotNull(pElement)) {
                                return this.getData(pElement.offset, pElement.size, arguments.length === 3 ? arguments[1] : 0, arguments.length === 3 ? arguments[2] : this._iLength);
                            }
                            return null;
                        }

                        return null;

                    case 0:
                        return this.getData(0, this._pVertexDeclaration.stride);
                    default:
                        return null;
                }
            };

            VertexData.prototype.getTypedData = function (sUsage, iFrom, iCount) {
                var pVertexElement = this._pVertexDeclaration.findElement(sUsage);

                if (pVertexElement) {
                    return akra.conv.abtota(this.getData(sUsage, iFrom, iCount), pVertexElement.type);
                }

                return null;
            };

            VertexData.prototype.getBufferHandle = function () {
                return this._pVertexBuffer.getResourceHandle();
            };

            VertexData.prototype.toString = function () {
                if (akra.config.DEBUG) {
                    var s = "";

                    s += "		  VERTEX DATA  #" + this.getID() + "\n";
                    s += "---------------+-----------------------\n";
                    s += "		BUFFER : " + this.getBufferHandle() + "\n";
                    s += "		  SIZE : " + this.getByteLength() + " b.\n";
                    s += "		OFFSET : " + this.getByteOffset() + " b.\n";
                    s += "---------------+-----------------------\n";
                    s += " MEMBERS COUNT : " + this.getLength() + " \n";
                    s += "		STRIDE : " + this.getStride() + " \n";
                    s += "---------------+-----------------------\n";
                    s += this.getVertexDeclaration().toString();

                    return s;
                }

                return null;
            };
            return VertexData;
        })();
        data.VertexData = VertexData;
    })(akra.data || (akra.data = {}));
    var data = akra.data;
})(akra || (akra = {}));
/// <reference path="../../bf/bf.ts" />
/// <reference path="../../common.ts" />
/// <reference path="../../mem.ts" />
var akra;
(function (akra) {
    (function (pool) {
        /// <reference path="HardwareBuffer.ts" />
        (function (resources) {
            var MemoryBuffer = (function (_super) {
                __extends(MemoryBuffer, _super);
                function MemoryBuffer() {
                    _super.apply(this, arguments);
                }
                MemoryBuffer.prototype.getByteLength = function () {
                    return this._pData.byteLength;
                };

                MemoryBuffer.prototype.getLength = function () {
                    return this.getByteLength();
                };

                MemoryBuffer.prototype.create = function (iByteSize, iFlags) {
                    if (typeof iFlags === "undefined") { iFlags = 2 /* DYNAMIC */; }
                    iFlags = akra.bf.clearAll(iFlags, 8 /* BACKUP_COPY */ | 64 /* DISCARDABLE */ | 32 /* ALIGNMENT */);

                    var isCreated = _super.prototype.create.call(this, 0, iFlags | 16 /* SOFTWARE */);

                    this._pData = new Uint8Array(iByteSize);

                    return isCreated;
                };

                MemoryBuffer.prototype.destroy = function () {
                    _super.prototype.destroy.call(this);
                    this._pData = null;
                };

                MemoryBuffer.prototype.resize = function (iSize) {
                    var pData = new Uint8Array(iSize);

                    if (iSize >= this.getByteLength()) {
                        pData.set(this._pData);
                    } else {
                        pData.set(this._pData.subarray(0, iSize));
                    }

                    this._pData = pData;
                    this.notifyAltered();

                    return true;
                };

                MemoryBuffer.prototype.lockImpl = function (iOffset, iLength, iLockFlags) {
                    return this._pData.subarray(iOffset, iOffset + iLength);
                };

                MemoryBuffer.prototype.readData = function () {
                    var ppDest;
                    var iOffset;
                    var iSize;

                    if (arguments.length < 3) {
                        ppDest = arguments[0];
                        iOffset = 0;
                        iSize = ppDest.byteLength;
                    } else {
                        iOffset = arguments[0];
                        iSize = arguments[1];
                        ppDest = arguments[2];
                    }

                    akra.logger.assert((iOffset + iSize) <= this.getByteLength());
                    akra.copy(ppDest.buffer, ppDest.byteOffset, this._pData.buffer, iOffset, iSize);

                    return true;
                };

                // writeData(pData: Uint8Array, iOffset?: uint, iSize?: uint, bDiscardWholeBuffer: boolean = false): boolean;
                MemoryBuffer.prototype.writeData = function (pData, iOffset, iSize, bDiscardWholeBuffer) {
                    // writeData(pData: any, iOffset?: uint, iSize?: uint, bDiscardWholeBuffer: boolean = false): boolean {
                    if (typeof iOffset === "undefined") { iOffset = 0; }
                    if (typeof iSize === "undefined") { iSize = pData.byteLength; }
                    if (typeof bDiscardWholeBuffer === "undefined") { bDiscardWholeBuffer = false; }
                    akra.logger.assert((iOffset + iSize) <= this.getByteLength());

                    if (akra.isDefAndNotNull(pData)) {
                        akra.copy(this._pData.buffer, iOffset, pData.buffer, pData.byteOffset, iSize);
                    }

                    this.notifyAltered();

                    return true;
                };
                return MemoryBuffer;
            })(resources.HardwareBuffer);
            resources.MemoryBuffer = MemoryBuffer;
        })(pool.resources || (pool.resources = {}));
        var resources = pool.resources;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="../../idl/IVertexBuffer.ts" />
var akra;
(function (akra) {
    (function (pool) {
        /// <reference path="../../data/VertexData.ts" />
        /// <reference path="../../data/VertexDeclaration.ts" />
        /// <reference path="../../bf/bf.ts" />
        /// <reference path="HardwareBuffer.ts" />
        /// <reference path="MemoryBuffer.ts" />
        (function (resources) {
            var VertexDeclaration = akra.data.VertexDeclaration;

            var VertexBuffer = (function (_super) {
                __extends(VertexBuffer, _super);
                function VertexBuffer() {
                    _super.call(this);
                    this._pVertexDataArray = [];
                    this._iDataCounter = 0;
                }
                VertexBuffer.prototype.getType = function () {
                    return 0 /* UNKNOWN */;
                };

                VertexBuffer.prototype.getLength = function () {
                    return this._pVertexDataArray.length;
                };

                // create(iByteSize: uint, iFlags?: uint, pData?: Uint8Array): boolean;
                VertexBuffer.prototype.create = function (iByteSize, iFlags, pData) {
                    // create(iByteSize: uint, iFlags?: uint, pData?: any): boolean {
                    _super.prototype.create.call(this, 0, iFlags || 0);

                    if (akra.bf.testAny(iFlags, 8 /* BACKUP_COPY */)) {
                        this._pBackupCopy = new resources.MemoryBuffer();
                        this._pBackupCopy.create(iByteSize);
                        this._pBackupCopy.writeData(pData, 0, iByteSize);
                    }

                    return true;
                };

                VertexBuffer.prototype.destroy = function () {
                    _super.prototype.destroy.call(this);

                    this._pBackupCopy.destroy();
                    this.freeVertexData();

                    this._iDataCounter = 0;
                };

                VertexBuffer.prototype.getVertexData = function (iOffset, iCount, pData) {
                    if (arguments.length < 2) {
                        return this._pVertexDataArray[arguments[0]];
                    }

                    var pDecl = VertexDeclaration.normalize(pData);
                    var pVertexData = new akra.data.VertexData(this, this._iDataCounter++, iOffset, iCount, pDecl);

                    this._pVertexDataArray.push(pVertexData);
                    this.notifyAltered();

                    return pVertexData;
                };

                VertexBuffer.prototype.getEmptyVertexData = function (iCount, pDeclData, ppVertexDataIn) {
                    var pDecl = null;
                    var pHole = [];
                    var i;
                    var pVertexData;
                    var iTemp;
                    var iStride = 0;
                    var iAligStart;
                    var iNewSize = 0;

                    while (true) {
                        pHole[0] = { start: 0, end: this.getByteLength() };

                        for (var k = 0; k < this._pVertexDataArray.length; ++k) {
                            pVertexData = this._pVertexDataArray[k];

                            for (i = 0; i < pHole.length; i++) {
                                //Полностью попадает внутрь
                                if (pVertexData.getByteOffset() > pHole[i].start && pVertexData.getByteOffset() + pVertexData.getByteLength() < pHole[i].end) {
                                    iTemp = pHole[i].end;
                                    pHole[i].end = pVertexData.getByteOffset();
                                    pHole.splice(i + 1, 0, { start: pVertexData.getByteOffset() + pVertexData.getByteLength(), end: iTemp });
                                    i--;
                                } else if (pVertexData.getByteOffset() == pHole[i].start && pVertexData.getByteOffset() + pVertexData.getByteLength() < pHole[i].end) {
                                    pHole[i].start = pVertexData.getByteOffset() + pVertexData.getByteLength();
                                } else if (pVertexData.getByteOffset() > pHole[i].start && pVertexData.getByteOffset() + pVertexData.getByteLength() == pHole[i].end) {
                                } else if (pVertexData.getByteOffset() == pHole[i].start && pVertexData.getByteLength() == (pHole[i].end - pHole[i].start)) {
                                    pHole.splice(i, 1);
                                    i--;
                                } else if (pVertexData.getByteOffset() < pHole[i].start && pVertexData.getByteOffset() + pVertexData.getByteLength() > pHole[i].start && pVertexData.getByteOffset() + pVertexData.getByteLength() < pHole[i].end) {
                                    pHole[i].start = pVertexData.getByteOffset() + pVertexData.getByteLength();
                                } else if (pVertexData.getByteOffset() < pHole[i].start && pVertexData.getByteOffset() + pVertexData.getByteLength() > pHole[i].start && pVertexData.getByteOffset() + pVertexData.getByteLength() == pHole[i].end) {
                                    pHole.splice(i, 1);
                                    i--;
                                } else if (pVertexData.getByteOffset() + pVertexData.getByteLength() > pHole[i].end && pVertexData.getByteOffset() > pHole[i].start && pVertexData.getByteOffset() < pHole[i].end) {
                                    pHole[i].end = pVertexData.getByteOffset();
                                } else if (pVertexData.getByteOffset() + pVertexData.getByteLength() > pHole[i].end && pVertexData.getByteOffset() == pHole[i].start && pVertexData.getByteOffset() < pHole[i].end) {
                                    pHole.splice(i, 1);
                                    i--;
                                } else if (pVertexData.getByteOffset() < pHole[i].start && pVertexData.getByteOffset() + pVertexData.getByteLength() > pHole[i].end) {
                                    i--;
                                }
                            }
                        }

                        pHole.sort(function (a, b) {
                            return ((a.end - a.start) - (b.end - b.start));
                        });

                        if (!akra.isInt(pDeclData)) {
                            pDecl = VertexDeclaration.normalize(pDeclData);
                            iStride = pDecl.stride;
                        } else {
                            iStride = pDeclData;
                        }

                        for (i = 0; i < pHole.length; i++) {
                            iAligStart = this.isAligned() ? akra.math.alignUp(pHole[i].start, akra.math.nok(iStride, 4)) : akra.math.alignUp(pHole[i].start, iStride);

                            if ((pHole[i].end - iAligStart) >= iCount * iStride) {
                                if (arguments.length == 2) {
                                    pVertexData = new akra.data.VertexData(this, this._iDataCounter++, iAligStart, iCount, pDeclData);
                                    this._pVertexDataArray.push(pVertexData);

                                    this.notifyAltered();
                                    return pVertexData;
                                } else if (arguments.length == 3) {
                                    (ppVertexDataIn.constructor).call(ppVertexDataIn, this, ppVertexDataIn.getID(), iAligStart, iCount, pDeclData);
                                    this._pVertexDataArray.push(ppVertexDataIn);

                                    this.notifyAltered();
                                    return ppVertexDataIn;
                                }

                                return null;
                            }
                        }

                        iNewSize = akra.math.max(this.getByteLength() * 2, this.getByteLength() + iCount * iStride);

                        if (this.resize(iNewSize) == false) {
                            akra.debug.warn("cannot resize buffer from " + this.getByteLength() + " bytes to " + iNewSize + " bytes ");
                            break;
                        }
                    }

                    return null;
                };

                VertexBuffer.prototype.freeVertexData = function (pVertexData) {
                    if (arguments.length == 0) {
                        for (var i = 0; i < this._pVertexDataArray.length; i++) {
                            this._pVertexDataArray[Number(i)].destroy();
                        }

                        this._pVertexDataArray = null;
                    } else {
                        for (var i = 0; i < this._pVertexDataArray.length; i++) {
                            if (this._pVertexDataArray[i] == pVertexData) {
                                pVertexData.destroy();

                                this._pVertexDataArray.splice(i, 1);
                                this.notifyAltered();
                                return true;
                            }
                        }

                        return false;
                    }

                    this.notifyAltered();
                    return true;
                };

                VertexBuffer.prototype.allocateData = function (pDeclData, pData) {
                    var pDecl = VertexDeclaration.normalize(pDeclData);

                    var pVertexData;
                    var iCount = pData.byteLength / pDecl.stride;

                    akra.debug.assert(iCount === akra.math.floor(iCount), 'Data size should be a multiple of the vertex declaration.');

                    pVertexData = this.getEmptyVertexData(iCount, pDecl);

                    akra.debug.assert(!akra.isNull(pVertexData), "Could not allocate vertex data!");

                    pVertexData.setData(pData, 0, pDecl.stride);

                    return pVertexData;
                };

                VertexBuffer.isVBO = function (pBuffer) {
                    return pBuffer.getType() === 1 /* VBO */;
                };

                VertexBuffer.isTBO = function (pBuffer) {
                    return pBuffer.getType() === 2 /* TBO */;
                };
                return VertexBuffer;
            })(resources.HardwareBuffer);
            resources.VertexBuffer = VertexBuffer;
        })(pool.resources || (pool.resources = {}));
        var resources = pool.resources;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="../idl/IVertexData.ts" />
/// <reference path="../idl/IVertexDeclaration.ts" />
/// <reference path="../idl/IVertexBuffer.ts" />
/// <reference path="../pool/resources/VertexBuffer.ts" />
/// <reference path="webgl.ts" />
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLVertexBuffer = (function (_super) {
            __extends(WebGLVertexBuffer, _super);
            function WebGLVertexBuffer() {
                _super.apply(this, arguments);
                this._pLockData = null;
                this._sCS = null;
            }
            WebGLVertexBuffer.prototype.getType = function () {
                return 1 /* VBO */;
            };

            WebGLVertexBuffer.prototype.getByteLength = function () {
                return this._iByteSize;
            };

            WebGLVertexBuffer.prototype.create = function (iByteSize, iFlags, pData) {
                if (typeof iFlags === "undefined") { iFlags = 1 /* STATIC */; }
                if (typeof pData === "undefined") { pData = null; }
                iByteSize = akra.math.max(iByteSize, akra.config.webgl.vertexbufferMinSize);

                if (akra.bf.testAny(iFlags, 4 /* READABLE */)) {
                    iFlags = akra.bf.setAll(iFlags, 8 /* BACKUP_COPY */);
                }

                _super.prototype.create.call(this, iByteSize, iFlags, pData);

                var pWebGLRenderer = this.getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                var i;

                akra.debug.assert(this._pWebGLBuffer == null, "webgl buffer already allocated");

                this._iByteSize = iByteSize;
                this._iFlags = iFlags;
                pWebGLContext = pWebGLRenderer.getWebGLContext();

                akra.debug.assert(pWebGLContext !== null, "cannot grab webgl context");

                //Софтварного рендеринга буфера у нас нет
                akra.debug.assert(!this.isSoftware(), "no sftware rendering");

                //Если есть локальная копия то буфер можно читать
                if (this.isBackupPresent()) {
                    this._iFlags = akra.bf.setAll(this._iFlags, 4 /* READABLE */);
                }

                akra.debug.assert(!pData || pData.byteLength <= iByteSize, "Размер переданного массива больше переданного размера буфера");

                this._pWebGLBuffer = pWebGLRenderer.createWebGLBuffer();

                if (!this._pWebGLBuffer) {
                    akra.logger.critical("Не удалось создать буфер");

                    this.destroy();
                    return false;
                }

                pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, this._pWebGLBuffer);
                pWebGLContext.bufferData(34962 /* ARRAY_BUFFER */, this._iByteSize, webgl.getWebGLUsage(this._iFlags));

                if (akra.isDefAndNotNull(pData)) {
                    /*pWebGLContext.bufferSubData(
                    gl.ARRAY_BUFFER, 0, isArrayBuffer(pData)? <ArrayBuffer>pData: (<Uint8Array>pData).buffer);*/
                    pWebGLContext.bufferSubData(34962 /* ARRAY_BUFFER */, 0, pData.buffer);
                }

                return true;
            };

            WebGLVertexBuffer.prototype.destroy = function () {
                _super.prototype.destroy.call(this);

                var pWebGLRenderer = this.getEngine().getRenderer();

                pWebGLRenderer.deleteWebGLBuffer(this._pWebGLBuffer);

                this._pWebGLBuffer = null;
                this._iByteSize = 0;
            };

            WebGLVertexBuffer.prototype.readData = function (iOffset, iSize, ppDest) {
                akra.debug.assert(!akra.isNull(this._pWebGLBuffer), "Буффер еще не создан");

                if (!this.isBackupPresent()) {
                    return false;
                }

                if (arguments.length === 1) {
                    this._pBackupCopy.readData(arguments[0]);
                } else {
                    this._pBackupCopy.readData(iOffset, iSize, ppDest);
                }

                return true;
            };

            WebGLVertexBuffer.prototype.writeData = function (pData, iOffset, iSize, bDiscardWholeBuffer) {
                if (typeof bDiscardWholeBuffer === "undefined") { bDiscardWholeBuffer = false; }
                akra.debug.assert(!akra.isNull(this._pWebGLBuffer), "WebGL buffer not exists");

                var pWebGLRenderer = this.getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, this._pWebGLBuffer);

                akra.debug.assert(pData.byteLength <= iSize, "Размер переданного массива больше переданного размера");
                akra.debug.assert(this.getByteLength() >= iOffset + iSize, "Данные выйдут за предел буфера");

                var pU8Data = null;

                if (akra.isArrayBuffer(pData)) {
                    pU8Data = new Uint8Array(pData);
                } else {
                    pU8Data = new Uint8Array(pData.buffer, pData.byteOffset, pData.byteLength);
                }

                pU8Data = pU8Data.subarray(0, iSize);

                pWebGLContext.bufferSubData(34962 /* ARRAY_BUFFER */, iOffset, pU8Data);

                if (this.isBackupPresent()) {
                    this._pBackupCopy.writeData(pU8Data, iOffset);
                }

                this.notifyAltered();

                return true;
            };

            WebGLVertexBuffer.prototype.resize = function (iSize) {
                var eUsage;
                var pData;
                var iMax = 0;
                var pVertexData;

                var pWebGLRenderer = this.getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                if (!this.isBackupPresent()) {
                    akra.debug.log("Not resized, because backup not present!");
                    return false;
                }

                akra.debug.log("WebGLVertexBuffer resized from " + this.getByteLength() + " to " + iSize + "(" + this.guid + ")");

                if (iSize < this.getByteLength()) {
                    for (var k = 0; k < this._pVertexDataArray.length; ++k) {
                        pVertexData = this._pVertexDataArray[k];

                        if (pVertexData.getByteOffset() + pVertexData.getByteLength() > iMax) {
                            iMax = pVertexData.getByteOffset() + pVertexData.getByteLength();
                        }
                    }

                    akra.debug.assert(iMax <= iSize, "Уменьшение невозможно. Страая разметка не укладывается в новый размер");
                }

                if (pWebGLContext.isBuffer(this._pWebGLBuffer)) {
                    pWebGLRenderer.deleteWebGLBuffer(this._pWebGLBuffer);
                }

                eUsage = webgl.getWebGLUsage(this._iFlags);

                this._pWebGLBuffer = pWebGLRenderer.createWebGLBuffer();

                if (!this._pWebGLBuffer) {
                    akra.logger.critical("Не удалось создать буфер");

                    this.destroy();
                    return false;
                }

                pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, this._pWebGLBuffer);
                pWebGLContext.bufferData(34962 /* ARRAY_BUFFER */, iSize, eUsage);

                pData = new Uint8Array(this._iByteSize);

                if (!this.readData(pData)) {
                    akra.debug.warn("cannot read data from buffer");
                    return false;
                }

                this.writeData(pData, 0, this._iByteSize);
                this._pBackupCopy.resize(iSize);
                this._iByteSize = iSize;

                this.notifyAltered();

                return true;
            };

            WebGLVertexBuffer.prototype.getWebGLBuffer = function () {
                return this._pWebGLBuffer;
            };

            WebGLVertexBuffer.prototype.lockImpl = function (iOffset, iSize, iLockFlags) {
                var pRetData = new Uint8Array(iSize);

                this.readData(iOffset, iSize, pRetData);

                this._pLockData = pRetData;

                return pRetData;
            };

            WebGLVertexBuffer.prototype.unlockImpl = function () {
                this.writeData(this._pLockData, this._iLockStart, this._iLockSize);
            };

            WebGLVertexBuffer.prototype.copyBackupToRealImpl = function (pRealData, pBackupData, iLockFlags) {
                pRealData.set(pBackupData);
            };
            return WebGLVertexBuffer;
        })(akra.pool.resources.VertexBuffer);
        webgl.WebGLVertexBuffer = WebGLVertexBuffer;
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
/// <reference path="../idl/IVertexBuffer.ts" />
/// <reference path="../idl/IRenderResource.ts" />
var akra;
(function (akra) {
    /// <reference path="../pool/resources/VertexBuffer.ts" />
    /// <reference path="../pixelUtil/pixelUtil.ts" />
    /// <reference path="webgl.ts" />
    /// <reference path="WebGLShaderProgram.ts"  />
    /// <reference path="WebGLRenderer.ts" />
    (function (webgl) {
        var VE = akra.data.VertexElement;

        /** @const */ var VIDEOBUFFER_HEADER_WIDTH = 0;
        /** @const */ var VIDEOBUFFER_HEADER_HEIGHT = 1;
        /** @const */ var VIDEOBUFFER_HEADER_STEP_X = 2;
        /** @const */ var VIDEOBUFFER_HEADER_STEP_Y = 3;
        /** @const */ var VIDEOBUFFER_HEADER_NUM_PIXELS = 4;
        /** @const */ var VIDEOBUFFER_HEADER_NUM_ELEMENTS = 5;

        var WebGLVertexTexture = (function (_super) {
            __extends(WebGLVertexTexture, _super);
            function WebGLVertexTexture() {
                _super.call(this);
                this._iWidth = 0;
                this._iHeight = 0;
                this._pWebGLTexture = null;
                this._ePixelFormat = 25 /* FLOAT32_RGBA */;
                //переменная нужна, чтобы проигнорировать обновление копии, обычно, это не требуется
                this._bForceUpdateBackupCopy = true;
                /*vertex data for header updating*/
                this._pHeader = null;
                this._pLockData = null;
            }
            WebGLVertexTexture.prototype.getType = function () {
                return 2 /* TBO */;
            };

            WebGLVertexTexture.prototype.getByteLength = function () {
                return akra.pixelUtil.getMemorySize(this._iWidth, this._iHeight, 1, this._ePixelFormat);
            };

            WebGLVertexTexture.prototype.getWebGLTexture = function () {
                return this._pWebGLTexture;
            };

            WebGLVertexTexture.prototype._getWidth = function () {
                return this._iWidth;
            };

            WebGLVertexTexture.prototype._getHeight = function () {
                return this._iHeight;
            };

            WebGLVertexTexture.prototype.create = function (iByteSize, iFlags, pData) {
                if (typeof iFlags === "undefined") { iFlags = 1 /* STATIC */; }
                if (typeof pData === "undefined") { pData = null; }
                var iMinWidth = akra.config.webgl.vertexTextureMinSize;
                var iWidth, iHeight;
                var pTextureData = null;
                var pDataU8 = pData;

                var iAdditionalHeaderSize = 32;

                iByteSize = akra.math.max(iByteSize + iAdditionalHeaderSize, akra.pixelUtil.getMemorySize(iMinWidth, iMinWidth, 1, this._ePixelFormat));

                if (akra.bf.testAny(iFlags, 4 /* READABLE */)) {
                    iFlags = akra.bf.setAll(iFlags, 8 /* BACKUP_COPY */);
                }

                _super.prototype.create.call(this, iByteSize, iFlags, pData);

                var pPOTSize = akra.math.calcPOTtextureSize(akra.math.ceil(iByteSize / akra.pixelUtil.getNumElemBytes(this._ePixelFormat)));
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                var i;

                iWidth = pPOTSize[0];
                iHeight = pPOTSize[1];

                akra.debug.assert(this._pWebGLTexture == null, "webgl texture already allocated");

                this._iWidth = iWidth;
                this._iHeight = iHeight;
                this._iFlags = iFlags;

                akra.debug.assert(pWebGLContext !== null, "cannot grab webgl context");

                //Софтварного рендеринга буфера у нас нет
                akra.debug.assert(!this.isSoftware(), "no software rendering");

                //Если есть локальная копия то буфер можно читать
                if (this.isBackupPresent()) {
                    this._iFlags = akra.bf.setAll(this._iFlags, 4 /* READABLE */);
                }

                akra.debug.assert(!pData || pData.byteLength <= iByteSize, "Размер переданного массива больше переданного размера буфера");

                akra.logger.assert(webgl.loadExtension(pWebGLContext, "OES_texture_float"), "OES_texture_float extension is necessary for correct work.");

                this._pWebGLTexture = pWebGLRenderer.createWebGLTexture();
                this._eWebGLFormat = webgl.getWebGLFormat(this._ePixelFormat);
                this._eWebGLType = webgl.getWebGLDataType(this._ePixelFormat);

                if (!this._pWebGLTexture) {
                    akra.logger.critical("Не удалось создать буфер");

                    this.destroy();
                    return false;
                }

                if (akra.isDefAndNotNull(pData)) {
                    if (pData.BYTES_PER_ELEMENT > 1) {
                        pDataU8 = new Uint8Array(pData, pData.byteOffset, pData.byteLength);
                    }

                    pTextureData = new Uint8Array(this.getByteLength());
                    pTextureData.set(pDataU8);
                }

                pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, this._pWebGLTexture);
                pWebGLContext.texImage2D(3553 /* TEXTURE_2D */, 0, this._eWebGLFormat, this._iWidth, this._iHeight, 0, this._eWebGLFormat, this._eWebGLType, pTextureData);

                pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_MAG_FILTER, pWebGLContext.NEAREST);
                pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_MIN_FILTER, pWebGLContext.NEAREST);
                pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_WRAP_S, pWebGLContext.CLAMP_TO_EDGE);
                pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_WRAP_T, pWebGLContext.CLAMP_TO_EDGE);

                pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, null);

                //create header
                this._pHeader = this.allocateData([VE.float2(akra.data.Usages.TEXTURE_HEADER)], this._header());

                /**
                * update program
                **/
                var pProgram = this.getManager().getShaderProgramPool().findResource("WEBgl.vertex_texture_update");

                if (akra.isNull(pProgram)) {
                    pProgram = this.getManager().getShaderProgramPool().createResource("WEBgl.vertex_texture_update");
                    pProgram.create("																									\n\
				uniform sampler2D sourceTexture;																	\n\
				attribute vec4  VALUE;																				\n\
				attribute float INDEX;																				\n\
				attribute float SHIFT;																				\n\
																													\n\
				uniform vec2 size;																					\n\
				varying vec4 color;																					\n\
																													\n\
				void main(void){																					\n\
					vec4 value = VALUE;																				\n\
					float  serial = INDEX;																			\n\
																													\n\
					int shift = int(SHIFT);																			\n\
					if (shift != 0) {																				\n\
						color = texture2D(sourceTexture,                                        					\n\
							vec2((mod(serial, size.x) +.5 ) / size.x, (floor(serial / size.x) + .5) / size.y)		\n\
							);																						\n\
																													\n\
																													\n\
						if (shift == 1) {																			\n\
							color = vec4(color.r, value.gba);														\n\
						}																							\n\
						else if (shift == 2) {																		\n\
							color = vec4(color.rg, value.ba);														\n\
						}																							\n\
						else if (shift == 3) {																		\n\
							color = vec4(color.rgb, value.a);														\n\
						}																							\n\
						else if (shift == -1) {																		\n\
							color = vec4(value.r, color.gba);														\n\
						}																							\n\
						else if (shift == -2) {																		\n\
							color = vec4(value.rg, color.ba);														\n\
						}																							\n\
						else {																						\n\
							color = vec4(value.rgb, color.a);														\n\
						}																							\n\
					}																								\n\
					else {																							\n\
						color = value;																				\n\
					}																								\n\
					gl_PointSize = 1.;																				\n\
					gl_Position = vec4(2. * (mod(serial, size.x) + .5) / size.x - 1.,								\n\
									2. * (floor(serial / size.x)  + .5) / size.y - 1., 0., 1.);						\n\
				}																									\n\
				", "									\n\
				precision highp float;          	\n\
				varying vec4 color;                 \n\
													\n\
				void main(void) {                   \n\
					gl_FragColor = color;           \n\
				}                                   \n\
				");
                }

                /**
                * resize program
                **/
                pProgram = this.getManager().getShaderProgramPool().findResource("WEBgl.vertex_texture_resize");

                if (akra.isNull(pProgram)) {
                    pProgram = this.getManager().getShaderProgramPool().createResource("WEBgl.vertex_texture_resize");
                    pProgram.create("																									\n\
				attribute float INDEX;																				\n\
																													\n\
				uniform sampler2D sourceTexture;																	\n\
																													\n\
				uniform vec2 v2fSrcTexSize;																			\n\
				uniform vec2 v2fDstTexSize;																			\n\
																													\n\
				varying vec4 v4fValue;																				\n\
																													\n\
				void main(void){																					\n\
																													\n\
					vec2 v2fSrcPosition = vec2((mod(INDEX, v2fSrcTexSize.x) + 0.5)/v2fSrcTexSize.x,					\n\
											   (floor(INDEX/v2fSrcTexSize.x) + 0.5)/v2fSrcTexSize.y);				\n\
																													\n\
					vec2 v2fDstPosition = vec2((mod(INDEX, v2fDstTexSize.x) + 0.5)/v2fDstTexSize.x,					\n\
											   (floor(INDEX/v2fDstTexSize.x) + 0.5)/v2fDstTexSize.y);				\n\
																													\n\
					v4fValue = texture2D(sourceTexture, v2fSrcPosition);											\n\
																													\n\
					gl_PointSize = 1.;																				\n\
					gl_Position = vec4(v2fDstPosition*2. - 1., 0., 1.);												\n\
				}																									\n\
				", "									\n\
				precision highp float;          	\n\
				varying vec4 v4fValue;              \n\
													\n\
				void main(void) {                   \n\
					gl_FragColor = v4fValue;        \n\
				}                                   \n\
				");
                }

                if (akra.isNull(WebGLVertexTexture._pWebGLBuffer1)) {
                    WebGLVertexTexture._pWebGLBuffer1 = pWebGLRenderer.createWebGLBuffer();
                }
                if (akra.isNull(WebGLVertexTexture._pWebGLBuffer2)) {
                    WebGLVertexTexture._pWebGLBuffer2 = pWebGLRenderer.createWebGLBuffer();
                }
                if (akra.isNull(WebGLVertexTexture._pWebGLBuffer3)) {
                    WebGLVertexTexture._pWebGLBuffer3 = pWebGLRenderer.createWebGLBuffer();
                }

                return true;
            };

            WebGLVertexTexture.prototype.destroy = function () {
                _super.prototype.destroy.call(this);

                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                pWebGLRenderer.deleteWebGLTexture(this._pWebGLTexture);

                this._pWebGLTexture = null;
            };

            WebGLVertexTexture.prototype.readData = function (iOffset, iSize, ppDest) {
                akra.debug.assert(!akra.isNull(this._pWebGLTexture), "Буффер еще не создан");

                if (!this.isBackupPresent()) {
                    return false;
                }

                if (arguments.length === 1) {
                    this._pBackupCopy.readData(arguments[0]);
                } else {
                    this._pBackupCopy.readData(iOffset, iSize, ppDest);
                }

                return true;
            };

            WebGLVertexTexture.prototype.writeData = function (pData, iOffset, iSize, bDiscardWholeBuffer) {
                if (typeof bDiscardWholeBuffer === "undefined") { bDiscardWholeBuffer = false; }
                var iTypeSize = akra.pixelUtil.getComponentTypeBits(this._ePixelFormat) / 8, nElementsPerPix = akra.pixelUtil.getComponentCount(this._ePixelFormat), iFrom, iCount;
                var pBufferData;

                var iLeftShift, iRightShift, iBeginPix, iEndPix, nPixels, nElements;

                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                var pDataU8 = pData;

                akra.logger.assert(bDiscardWholeBuffer === false, "Discard option temporary unsupported.");

                if (pData.BYTES_PER_ELEMENT > 1) {
                    pDataU8 = new Uint8Array(pData.buffer, pData.byteOffset, pData.byteLength);
                }

                iOffset = iOffset || 0;
                iSize = iSize || pData.byteLength;

                pDataU8 = pDataU8.subarray(0, iSize);

                if (this.getByteLength() < iOffset + iSize) {
                    this.resize(iOffset + iSize);
                }

                if (this.isBackupPresent() && this._bForceUpdateBackupCopy) {
                    this._pBackupCopy.writeData(pDataU8, iOffset);
                }

                this._bForceUpdateBackupCopy = true;

                akra.debug.assert(iOffset % iTypeSize === 0 && iSize % iTypeSize === 0, "Incorrect data size or offset");

                iFrom = iOffset / iTypeSize;
                iCount = iSize / iTypeSize;

                iLeftShift = iFrom % nElementsPerPix;
                iRightShift = ((iFrom + iCount) % nElementsPerPix);
                iBeginPix = Math.floor(iFrom / nElementsPerPix);
                iEndPix = Math.floor((iFrom + iCount) / nElementsPerPix);
                nPixels = Math.ceil((iFrom + iCount) / nElementsPerPix) - Math.floor(iFrom / nElementsPerPix);
                nElements = nPixels * nElementsPerPix;

                pBufferData = new Float32Array(pDataU8.buffer, pDataU8.byteOffset);

                if (iLeftShift === 0 && iRightShift === 0) {
                    var iWidth = this._iWidth;
                    var iYmin = Math.floor(iBeginPix / iWidth);
                    var iYmax = Math.ceil(iEndPix / iWidth);
                    var iXbegin = iBeginPix % iWidth;
                    var iXend = iEndPix % iWidth;
                    var iHeight = iYmax - iYmin;

                    var iBeginElement = 0, iEndElement = 0;

                    //hack: if iEndPixel is first pixel from next row
                    iXend = (iXend === 0 ? iWidth : iXend);

                    //FIX THIS, move this function from here...
                    var me = this;
                    function updatePixelRect(iX, iY, iW, iH) {
                        iBeginElement = iEndElement;
                        iEndElement = iW * iH * nElementsPerPix + iEndElement;

                        pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, me._pWebGLTexture);

                        pWebGLContext.texSubImage2D(3553 /* TEXTURE_2D */, 0, iX, iY, iW, iH, me._eWebGLFormat, me._eWebGLType, pBufferData.subarray(iBeginElement, iEndElement));

                        pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, null);
                    }
                    ;

                    if (iHeight === 1) {
                        updatePixelRect(iXbegin, iYmin, iXend - iXbegin, 1);
                    } else {
                        updatePixelRect(iXbegin, iYmin, iWidth - iXbegin, 1);

                        if (iHeight > 2) {
                            updatePixelRect(0, iYmin + 1, iWidth, iHeight - 2);
                        }

                        updatePixelRect(0, iYmax - 1, iXend, 1);
                    }
                } else if (this.isBackupPresent()) {
                    var iRealOffset = iBeginPix * nElementsPerPix * iTypeSize;
                    var iRealSize = nElements * iTypeSize;
                    var pTempData = this._pBackupCopy.lock(iRealOffset, iRealSize);

                    //var iTotalSize: uint 	= iRealOffset + iRealSize;
                    //FIX ME:
                    this._pBackupCopy.unlock();

                    this._bForceUpdateBackupCopy = false;

                    return this.writeData(pTempData, iRealOffset, iRealSize);
                } else {
                    //console.error(this);
                    var pMarkupDataIndex = new Float32Array(nPixels);
                    var pMarkupDataShift = new Float32Array(nPixels);
                    var pRealData = new Float32Array(nElements);

                    pMarkupDataIndex[0] = iBeginPix;
                    pMarkupDataShift[0] = iLeftShift;

                    pMarkupDataIndex[nPixels - 1] = iBeginPix + nPixels - 1;
                    pMarkupDataShift[nPixels - 1] = -iRightShift;

                    for (var i = 1; i < nPixels - 1; ++i) {
                        pMarkupDataIndex[i] = iBeginPix + i;
                    }

                    for (var i = 0; i < iCount; i++) {
                        pRealData[iLeftShift + i] = pBufferData[i];
                    }

                    var pOldFrameBuffer = pWebGLRenderer.getParameter(36006 /* FRAMEBUFFER_BINDING */);

                    var pWebGLFramebuffer = pWebGLRenderer.createWebGLFramebuffer();
                    var pWebGLProgram = this.getManager().getShaderProgramPool().findResource("WEBgl.vertex_texture_update");

                    var pValueBuffer = WebGLVertexTexture._pWebGLBuffer1;
                    var pMarkupIndexBuffer = WebGLVertexTexture._pWebGLBuffer2;
                    var pMarkupShiftBuffer = WebGLVertexTexture._pWebGLBuffer3;

                    akra.debug.assert(akra.isDef(pWebGLProgram), "cound not find WEBgl.vertex_texture_update program");

                    pWebGLRenderer.disableAllWebGLVertexAttribs();

                    pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pWebGLFramebuffer);
                    pWebGLRenderer.useWebGLProgram(pWebGLProgram.getWebGLProgram());

                    pWebGLRenderer.disable(2929 /* DEPTH_TEST */);
                    pWebGLRenderer.disable(3089 /* SCISSOR_TEST */);
                    pWebGLRenderer.disable(3042 /* BLEND */);
                    pWebGLRenderer.disable(2884 /* CULL_FACE */);

                    var iValueAttribLocation = pWebGLProgram.getWebGLAttributeLocation("VALUE");
                    var iIndexAttribLocation = pWebGLProgram.getWebGLAttributeLocation("INDEX");
                    var iShiftAttribLocation = pWebGLProgram.getWebGLAttributeLocation("SHIFT");

                    pWebGLContext.enableVertexAttribArray(iValueAttribLocation);
                    pWebGLContext.enableVertexAttribArray(iIndexAttribLocation);
                    pWebGLContext.enableVertexAttribArray(iShiftAttribLocation);

                    pWebGLContext.framebufferTexture2D(36160 /* FRAMEBUFFER */, 36064 /* COLOR_ATTACHMENT0 */, 3553 /* TEXTURE_2D */, this._pWebGLTexture, 0);

                    pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, pValueBuffer);
                    pWebGLContext.bufferData(34962 /* ARRAY_BUFFER */, pRealData, 35040 /* STREAM_DRAW */);
                    pWebGLContext.vertexAttribPointer(iValueAttribLocation, 4, 5126 /* FLOAT */, false, 0, 0);

                    pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, pMarkupIndexBuffer);
                    pWebGLContext.bufferData(34962 /* ARRAY_BUFFER */, pMarkupDataIndex, 35040 /* STREAM_DRAW */);
                    pWebGLContext.vertexAttribPointer(iIndexAttribLocation, 1, 5126 /* FLOAT */, false, 0, 0);

                    pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, pMarkupShiftBuffer);
                    pWebGLContext.bufferData(34962 /* ARRAY_BUFFER */, pMarkupDataShift, 35040 /* STREAM_DRAW */);
                    pWebGLContext.vertexAttribPointer(iShiftAttribLocation, 1, 5126 /* FLOAT */, false, 0, 0);

                    pWebGLRenderer.activateWebGLTexture(33984 /* TEXTURE0 */);
                    pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, this._pWebGLTexture);

                    pWebGLProgram.setInt("sourceTexture", 0);
                    pWebGLProgram.setVec2("size", akra.math.Vec2.temp(this._iWidth, this._iHeight));

                    pWebGLContext.viewport(0, 0, this._iWidth, this._iHeight);
                    pWebGLContext.drawArrays(0 /* POINTS */, 0, nPixels);
                    pWebGLContext.flush();

                    pWebGLContext.framebufferTexture2D(36160 /* FRAMEBUFFER */, 36064 /* COLOR_ATTACHMENT0 */, 3553 /* TEXTURE_2D */, null, 0);

                    pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, null);
                    pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, null);

                    pWebGLContext.disableVertexAttribArray(iValueAttribLocation);
                    pWebGLContext.disableVertexAttribArray(iIndexAttribLocation);
                    pWebGLContext.disableVertexAttribArray(iShiftAttribLocation);

                    //pWebGLRenderer.deleteWebGLBuffer(pValueBuffer);
                    //pWebGLRenderer.deleteWebGLBuffer(pMarkupShiftBuffer);
                    //pWebGLRenderer.deleteWebGLBuffer(pMarkupIndexBuffer);
                    pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pOldFrameBuffer);
                    pWebGLRenderer.deleteWebGLFramebuffer(pWebGLFramebuffer);
                }

                return true;
            };

            WebGLVertexTexture.prototype.resize = function (iSize) {
                var pWebGLRenderer = this.getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                var iMax = 0;
                if (iSize < this.getByteLength()) {
                    for (var k = 0; k < this._pVertexDataArray.length; ++k) {
                        var pVertexData = this._pVertexDataArray[k];

                        if (pVertexData.getByteOffset() + pVertexData.getByteLength() > iMax) {
                            iMax = pVertexData.getByteOffset() + pVertexData.getByteLength();
                        }
                    }

                    if (iMax > iSize) {
                        akra.debug.assert(false, "Уменьшение невозможно. Страая разметка не укладывается в новый размер");
                        return false;
                    }
                }

                var pPOTSize = akra.math.calcPOTtextureSize(akra.math.ceil(iSize / akra.pixelUtil.getNumElemBytes(this._ePixelFormat)));

                pPOTSize[0] = (pPOTSize[0] < akra.config.webgl.vertexTextureMinSize) ? akra.config.webgl.vertexTextureMinSize : pPOTSize[0];
                pPOTSize[1] = (pPOTSize[1] < akra.config.webgl.vertexTextureMinSize) ? akra.config.webgl.vertexTextureMinSize : pPOTSize[1];

                if (pPOTSize[0] !== this._iWidth || pPOTSize[1] !== this._iHeight) {
                    if (this.isBackupPresent()) {
                        this._iWidth = pPOTSize[0];
                        this._iHeight = pPOTSize[1];

                        pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, this._pWebGLTexture);
                        pWebGLContext.texImage2D(3553 /* TEXTURE_2D */, 0, this._eWebGLFormat, this._iWidth, this._iHeight, 0, this._eWebGLFormat, this._eWebGLType, null);

                        pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, null);

                        var iByteLength = this.getByteLength();

                        /*resing backup copy don't cause data loss*/
                        this._pBackupCopy.resize(iByteLength);

                        var pData = new Uint8Array(iByteLength);

                        if (!this.readData(pData)) {
                            akra.debug.warn("cannot read data from buffer");
                            return false;
                        }

                        this.writeData(pData, 0, iByteLength);
                    } else {
                        var pWebGLProgram = this.getManager().getShaderProgramPool().findResource("WEBgl.vertex_texture_resize");

                        akra.debug.assert(akra.isDef(pWebGLProgram), "cound not find WEBgl.vertex_texture_resize program");

                        pWebGLRenderer.useWebGLProgram(pWebGLProgram.getWebGLProgram());

                        //create new texture for resize
                        var pTexture = pWebGLRenderer.createWebGLTexture();
                        pWebGLRenderer.activateWebGLTexture(33985 /* TEXTURE1 */);
                        pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, pTexture);
                        pWebGLContext.texImage2D(3553 /* TEXTURE_2D */, 0, this._eWebGLFormat, pPOTSize[0], pPOTSize[1], 0, this._eWebGLFormat, this._eWebGLType, null);

                        pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_MAG_FILTER, pWebGLContext.NEAREST);
                        pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_MIN_FILTER, pWebGLContext.NEAREST);
                        pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_WRAP_S, pWebGLContext.CLAMP_TO_EDGE);
                        pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_WRAP_T, pWebGLContext.CLAMP_TO_EDGE);

                        var pOldFrameBuffer = pWebGLRenderer.getParameter(36006 /* FRAMEBUFFER_BINDING */);

                        var pWebGLFramebuffer = pWebGLRenderer.createWebGLFramebuffer();
                        pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pWebGLFramebuffer);
                        pWebGLContext.framebufferTexture2D(36160 /* FRAMEBUFFER */, 36064 /* COLOR_ATTACHMENT0 */, 3553 /* TEXTURE_2D */, pTexture, 0);

                        if (iSize >= this.getByteLength()) {
                            for (var k = 0; k < this._pVertexDataArray.length; ++k) {
                                var pVertexData = this._pVertexDataArray[k];

                                if (pVertexData.getByteOffset() + pVertexData.getByteLength() > iMax) {
                                    iMax = pVertexData.getByteOffset() + pVertexData.getByteLength();
                                }
                            }
                        }

                        var iTypeSize = akra.pixelUtil.getComponentTypeBits(this._ePixelFormat) / 8;
                        var nElementsPerPix = akra.pixelUtil.getComponentCount(this._ePixelFormat);
                        var nPixels = akra.math.ceil(iMax / iTypeSize / nElementsPerPix);

                        var pIndexBufferData = new Float32Array(nPixels);
                        for (var i = 0; i < nPixels; i++) {
                            pIndexBufferData[i] = i;
                        }

                        pWebGLRenderer.disableAllWebGLVertexAttribs();

                        var iIndexAttribLocation = pWebGLProgram.getWebGLAttributeLocation("INDEX");

                        pWebGLContext.enableVertexAttribArray(iIndexAttribLocation);

                        if (akra.isNull(WebGLVertexTexture._pWebGLBuffer1)) {
                            WebGLVertexTexture._pWebGLBuffer1 = pWebGLRenderer.createWebGLBuffer();
                        }

                        var pIndexBuffer = WebGLVertexTexture._pWebGLBuffer1;

                        pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, pIndexBuffer);
                        pWebGLContext.bufferData(34962 /* ARRAY_BUFFER */, pIndexBufferData, 35040 /* STREAM_DRAW */);
                        pWebGLContext.vertexAttribPointer(iIndexAttribLocation, 1, 5126 /* FLOAT */, false, 0, 0);

                        pWebGLRenderer.disable(2929 /* DEPTH_TEST */);
                        pWebGLRenderer.disable(3089 /* SCISSOR_TEST */);
                        pWebGLRenderer.disable(3042 /* BLEND */);
                        pWebGLRenderer.disable(2884 /* CULL_FACE */);

                        pWebGLRenderer.activateWebGLTexture(33984 /* TEXTURE0 */);
                        pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, this._pWebGLTexture);

                        pWebGLProgram.setInt("sourceTexture", 0);
                        pWebGLProgram.setVec2("v2fSrcTexSize", akra.math.Vec2.temp(this._iWidth, this._iHeight));
                        pWebGLProgram.setVec2("v2fDstTexSize", akra.math.Vec2.temp(pPOTSize[0], pPOTSize[1]));

                        pWebGLContext.viewport(0, 0, pPOTSize[0], pPOTSize[1]);
                        pWebGLContext.drawArrays(0 /* POINTS */, 0, nPixels);
                        pWebGLContext.flush();

                        pWebGLContext.framebufferTexture2D(36160 /* FRAMEBUFFER */, 36064 /* COLOR_ATTACHMENT0 */, 3553 /* TEXTURE_2D */, null, 0);

                        pWebGLContext.disableVertexAttribArray(iIndexAttribLocation);
                        pWebGLRenderer.bindWebGLBuffer(34962 /* ARRAY_BUFFER */, null);
                        pWebGLRenderer.bindWebGLTexture(3553 /* TEXTURE_2D */, null);

                        //pWebGLRenderer.deleteWebGLBuffer(pIndexBuffer);
                        pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pOldFrameBuffer);
                        pWebGLRenderer.deleteWebGLFramebuffer(pWebGLFramebuffer);

                        pWebGLRenderer.deleteWebGLTexture(this._pWebGLTexture);

                        this._pWebGLTexture = pTexture;
                        this._iWidth = pPOTSize[0];
                        this._iHeight = pPOTSize[1];
                    }
                }

                this._pHeader.setData(this._header());

                this.notifyAltered();

                return true;
            };

            WebGLVertexTexture.prototype.lockImpl = function (iOffset, iSize, iLockFlags) {
                var pRetData = new Uint8Array(iSize);

                this.readData(iOffset, iSize, pRetData);

                this._pLockData = pRetData;

                return pRetData;
            };

            WebGLVertexTexture.prototype.unlockImpl = function () {
                this.writeData(this._pLockData, this._iLockStart, this._iLockSize);
            };

            WebGLVertexTexture.prototype.copyBackupToRealImpl = function (pRealData, pBackupData, iLockFlags) {
                pRealData.set(pBackupData);
            };

            WebGLVertexTexture.prototype._header = function (iTextureSizeX, iTextureSizeY) {
                if (typeof iTextureSizeX === "undefined") { iTextureSizeX = this._iWidth; }
                if (typeof iTextureSizeY === "undefined") { iTextureSizeY = this._iHeight; }
                var pHeader = new Float32Array(8);

                pHeader[VIDEOBUFFER_HEADER_WIDTH] = iTextureSizeX;
                pHeader[VIDEOBUFFER_HEADER_HEIGHT] = iTextureSizeY;
                pHeader[VIDEOBUFFER_HEADER_STEP_X] = 1 / iTextureSizeX;
                pHeader[VIDEOBUFFER_HEADER_STEP_Y] = 1 / iTextureSizeY;
                pHeader[VIDEOBUFFER_HEADER_NUM_PIXELS] = iTextureSizeX * iTextureSizeY;
                pHeader[VIDEOBUFFER_HEADER_NUM_ELEMENTS] = pHeader[VIDEOBUFFER_HEADER_NUM_PIXELS] * akra.pixelUtil.getNumElemBytes(this._ePixelFormat);

                return pHeader;
            };

            WebGLVertexTexture._pWebGLBuffer1 = null;
            WebGLVertexTexture._pWebGLBuffer2 = null;
            WebGLVertexTexture._pWebGLBuffer3 = null;
            return WebGLVertexTexture;
        })(akra.pool.resources.VertexBuffer);
        webgl.WebGLVertexTexture = WebGLVertexTexture;
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
/// <reference path="../idl/IBufferData.ts" />
/// <reference path="../idl/IIndexBuffer.ts" />
/// <reference path="../idl/EPrimitiveTypes.ts" />
var akra;
(function (akra) {
    /// <reference path="../debug.ts" />
    /// <reference path="../types.ts" />
    (function (data) {
        var IndexData = (function () {
            function IndexData(pIndexBuffer, id, iOffset, iCount, ePrimitiveType, eElementsType) {
                if (typeof ePrimitiveType === "undefined") { ePrimitiveType = 4 /* TRIANGLELIST */; }
                if (typeof eElementsType === "undefined") { eElementsType = 5123 /* UNSIGNED_SHORT */; }
                akra.debug.assert(eElementsType == 5123 /* UNSIGNED_SHORT */ || eElementsType == 5121 /* UNSIGNED_BYTE */ || eElementsType == 5125 /* UNSIGNED_INT */, "supported only short, byte, uint data types.");

                this._pIndexBuffer = pIndexBuffer;
                this._iOffset = iOffset;
                this._iLength = iCount;
                this._iId = id;

                this._ePrimitiveType = ePrimitiveType;
                this._eElementsType = eElementsType;

                akra.debug.assert(pIndexBuffer.getByteLength() >= this.getByteLength() + this.getByteOffset(), "out of buffer limits.");
            }
            IndexData.prototype.getID = function () {
                return this._iId;
            };

            IndexData.prototype.getType = function () {
                return this._eElementsType;
            };

            IndexData.prototype.getLength = function () {
                return this._iLength;
            };

            IndexData.prototype.getBytesPerIndex = function () {
                return akra.sizeof(this._eElementsType);
            };

            IndexData.prototype.getByteOffset = function () {
                return this._iOffset;
            };

            IndexData.prototype.getByteLength = function () {
                return this._iLength * this.getBytesPerIndex();
            };

            IndexData.prototype.getBuffer = function () {
                return this._pIndexBuffer;
            };

            IndexData.prototype.getData = function (iOffset, iSize) {
                akra.debug.assert(iOffset + iSize <= this.getByteLength(), "out of buffer limits");
                var pBuffer = new Uint8Array(iSize);

                if (this._pIndexBuffer.readData(this.getByteOffset() + iOffset, iSize, pBuffer)) {
                    return pBuffer.buffer;
                }

                akra.debug.assert(false, "cannot read data from index buffer");

                return null;
            };

            IndexData.prototype.getTypedData = function (iStart, iCount) {
                if (typeof iStart === "undefined") { iStart = 0; }
                if (typeof iCount === "undefined") { iCount = this.getLength(); }
                akra.debug.assert((iStart + iCount) <= this._iLength, "out of buffer limits");

                var iTypeSize = akra.sizeof(this._eElementsType);

                var iOffset = iStart * iTypeSize;
                var iSize = iCount * iTypeSize;

                var pBuffer = new Uint8Array(iSize);

                if (this._pIndexBuffer.readData(this.getByteOffset() + iOffset, iSize, pBuffer)) {
                    switch (this._eElementsType) {
                        case 5121 /* UNSIGNED_BYTE */:
                            return pBuffer;
                        case 5123 /* UNSIGNED_SHORT */:
                            return new Uint16Array(pBuffer.buffer);
                        case 5125 /* UNSIGNED_INT */:
                            return new Uint32Array(pBuffer.buffer);
                        default:
                            return null;
                    }
                }

                return null;
            };

            IndexData.prototype.setData = function (pData, iOffset, iCount) {
                if (typeof iOffset === "undefined") { iOffset = 0; }
                if (typeof iCount === "undefined") { iCount = pData.byteLength / this.getBytesPerIndex(); }
                akra.debug.assert((iOffset + iCount) * this.getBytesPerIndex() <= this.getByteLength(), "out of buffer limits.");

                return this._pIndexBuffer.writeData(pData, this.getByteOffset() + iOffset * this.getBytesPerIndex(), iCount * this.getBytesPerIndex());
            };

            IndexData.prototype.destroy = function () {
                this._pIndexBuffer = null;
                this._iOffset = undefined;
                this._iLength = undefined;
                this._eElementsType = undefined;
                this._eElementsType = undefined;
            };

            IndexData.prototype.getPrimitiveType = function () {
                return this._ePrimitiveType;
            };

            IndexData.prototype.getPrimitiveCount = function (iIndexCount) {
                if (typeof iIndexCount === "undefined") { iIndexCount = this.getLength(); }
                return IndexData.getPrimitiveCount(this._ePrimitiveType, iIndexCount);
            };

            IndexData.prototype.getBufferHandle = function () {
                return this._pIndexBuffer.getResourceHandle();
            };

            IndexData.getPrimitiveCount = function (eType, nVertices) {
                switch (eType) {
                    case 0 /* POINTLIST */:
                        return nVertices;
                    case 1 /* LINELIST */:
                        return nVertices / 2;
                    case 3 /* LINESTRIP */:
                        return nVertices - 1;
                    case 2 /* LINELOOP */:
                        return nVertices;
                    case 4 /* TRIANGLELIST */:
                        return nVertices / 3;
                    case 6 /* TRIANGLEFAN */:
                    case 5 /* TRIANGLESTRIP */:
                        return nVertices - 2;
                }

                akra.debug.log("unhandled case detected..");

                return 0;
            };
            return IndexData;
        })();
        data.IndexData = IndexData;
    })(akra.data || (akra.data = {}));
    var data = akra.data;
})(akra || (akra = {}));
/// <reference path="../../idl/IIndexBuffer.ts" />
/// <reference path="../../idl/IIndexData.ts" />
/// <reference path="HardwareBuffer.ts" />
/// <reference path="../../data/IndexData.ts" />
var akra;
(function (akra) {
    (function (pool) {
        (function (resources) {
            var IndexBuffer = (function (_super) {
                __extends(IndexBuffer, _super);
                function IndexBuffer() {
                    _super.call(this);
                    this._pIndexDataArray = [];
                    this._iDataCounter = 0;
                }
                IndexBuffer.prototype.geLength = function () {
                    return this._pIndexDataArray.length;
                };

                //create(iByteSize: uint, iFlags?: uint, pData?: Uint8Array): boolean;
                IndexBuffer.prototype.create = function (iByteSize, iFlags, pData) {
                    //create(iByteSize: uint, iFlags?: uint, pData?: ArrayBufferView): boolean {
                    _super.prototype.create.call(this, 0, iFlags || 0);

                    if (akra.bf.testAny(iFlags, 8 /* BACKUP_COPY */)) {
                        this._pBackupCopy = new resources.MemoryBuffer();
                        this._pBackupCopy.create(iByteSize);
                        this._pBackupCopy.writeData(pData, 0, iByteSize);
                    }

                    return true;
                };

                IndexBuffer.prototype.destroy = function () {
                    _super.prototype.destroy.call(this);

                    this._pBackupCopy.destroy();
                    this.freeIndexData();

                    this._iDataCounter = 0;
                };

                IndexBuffer.prototype.getIndexData = function (iOffset, iCount, ePrimitiveType, eElementsType) {
                    var pIndexData = new akra.data.IndexData(this, this._iDataCounter++, iOffset, iCount, ePrimitiveType, eElementsType);
                    this._pIndexDataArray.push(pIndexData);
                    return pIndexData;
                };

                IndexBuffer.prototype.getEmptyIndexData = function (iCount, ePrimitiveType, eElementsType) {
                    var pHole = new Array();
                    var i;
                    var pIndexData;

                    pHole[0] = { start: 0, end: this.getByteLength() };

                    for (var k = 0; k < this._pIndexDataArray.length; ++k) {
                        pIndexData = this._pIndexDataArray[k];

                        for (i = 0; i < pHole.length; i++) {
                            //console.log("pHole:",pHole[i].start,pHole[i].end);
                            //Полностью попадает внутрь
                            if (pIndexData.getByteOffset() > pHole[i].start && pIndexData.getByteOffset() + pIndexData.getByteLength() < pHole[i].end) {
                                var iTemp = pHole[i].end;

                                pHole[i].end = pIndexData.getByteOffset();
                                pHole.splice(i + 1, 0, { start: pIndexData.getByteOffset() + pIndexData.getByteLength(), end: iTemp });

                                i--;
                            } else if (pIndexData.getByteOffset() == pHole[i].start && pIndexData.getByteOffset() + pIndexData.getByteLength() < pHole[i].end) {
                                pHole[i].start = pIndexData.getByteOffset() + pIndexData.getByteLength();
                            } else if (pIndexData.getByteOffset() > pHole[i].start && pIndexData.getByteOffset() + pIndexData.getByteLength() == pHole[i].end) {
                            } else if (pIndexData.getByteOffset() == pHole[i].start && pIndexData.getByteLength() == (pHole[i].end - pHole[i].start)) {
                                pHole.splice(i, 1);
                                i--;
                            } else if (pIndexData.getByteOffset() < pHole[i].start && pIndexData.getByteOffset() + pIndexData.getByteLength() > pHole[i].start && pIndexData.getByteOffset() + pIndexData.getByteLength() < pHole[i].end) {
                                pHole[i].start = pIndexData.getByteOffset() + pIndexData.getByteLength();
                            } else if (pIndexData.getByteOffset() < pHole[i].start && pIndexData.getByteOffset() + pIndexData.getByteLength() > pHole[i].start && pIndexData.getByteOffset() + pIndexData.getByteLength() == pHole[i].end) {
                                pHole.splice(i, 1);
                                i--;
                            } else if (pIndexData.getByteOffset() + pIndexData.getByteLength() > pHole[i].end && pIndexData.getByteOffset() > pHole[i].start && pIndexData.getByteOffset() < pHole[i].end) {
                                pHole[i].end = pIndexData.getByteOffset();
                            } else if (pIndexData.getByteOffset() + pIndexData.getByteLength() > pHole[i].end && pIndexData.getByteOffset() == pHole[i].start && pIndexData.getByteOffset() < pHole[i].end) {
                                pHole.splice(i, 1);
                                i--;
                            } else if (pIndexData.getByteOffset() < pHole[i].start && pIndexData.getByteOffset() + pIndexData.getByteLength() > pHole[i].end) {
                                i--;
                            }
                        }
                    }

                    pHole.sort(function (a, b) {
                        return ((a.end - a.start) - (b.end - b.start));
                    });

                    for (i = 0; i < pHole.length; i++) {
                        if ((pHole[i].end - pHole[i].start) >= iCount * akra.sizeof(eElementsType)) {
                            pIndexData = new akra.data.IndexData(this, this._iDataCounter++, pHole[i].start, iCount, ePrimitiveType, eElementsType);

                            this._pIndexDataArray.push(pIndexData);

                            return pIndexData;
                        }
                    }

                    return null;
                };

                IndexBuffer.prototype.freeIndexData = function (pIndexData) {
                    if (arguments.length == 0) {
                        for (var i = 0; i < this._pIndexDataArray.length; i++) {
                            this._pIndexDataArray[Number(i)].destroy();
                        }

                        this._pIndexDataArray = null;
                    } else {
                        for (var i = 0; i < this._pIndexDataArray.length; i++) {
                            if (this._pIndexDataArray[i] == pIndexData) {
                                pIndexData.destroy();

                                this._pIndexDataArray.splice(i, 1);
                                this.notifyAltered();
                                return true;
                            }
                        }

                        return false;
                    }

                    this.notifyAltered();
                    return true;
                };

                IndexBuffer.prototype.allocateData = function (ePrimitiveType, eElementsType, pData) {
                    var pIndexData;
                    var iCount = pData.byteLength / akra.sizeof(eElementsType);

                    akra.debug.assert(iCount === akra.math.floor(iCount), "data size should be a multiple of the vertex declaration");

                    pIndexData = this.getEmptyIndexData(iCount, ePrimitiveType, eElementsType);
                    pIndexData.setData(pData);

                    return pIndexData;
                };
                return IndexBuffer;
            })(resources.HardwareBuffer);
            resources.IndexBuffer = IndexBuffer;
        })(pool.resources || (pool.resources = {}));
        var resources = pool.resources;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="../idl/IIndexData.ts" />
/// <reference path="../pool/resources/IndexBuffer.ts" />
/// <reference path="webgl.ts" />
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLIndexBuffer = (function (_super) {
            __extends(WebGLIndexBuffer, _super);
            function WebGLIndexBuffer() {
                _super.call(this);
                this._pLockData = null;
            }
            WebGLIndexBuffer.prototype.getByteLength = function () {
                return this._iByteSize;
            };

            WebGLIndexBuffer.prototype.create = function (iByteSize, iFlags, pData) {
                if (typeof iFlags === "undefined") { iFlags = 1 /* STATIC */; }
                if (typeof pData === "undefined") { pData = null; }
                iByteSize = akra.math.max(iByteSize, akra.config.webgl.indexbufferMinSize);

                if (akra.bf.testAny(iFlags, 4 /* READABLE */)) {
                    iFlags = akra.bf.setAll(iFlags, 8 /* BACKUP_COPY */);
                }

                _super.prototype.create.call(this, iByteSize, iFlags, pData);

                var pWebGLRenderer = this.getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                var i;

                akra.debug.assert(this._pWebGLBuffer == null, "webgl buffer already allocated");

                this._iByteSize = iByteSize;
                this._iFlags = iFlags;
                pWebGLContext = pWebGLRenderer.getWebGLContext();

                akra.debug.assert(pWebGLContext !== null, "cannot grab webgl context");

                //Софтварного рендеринга буфера у нас нет
                akra.debug.assert(!this.isSoftware(), "no sftware rendering");

                //Если есть локальная копия то буфер можно читать
                if (this.isBackupPresent()) {
                    this._iFlags = akra.bf.setAll(this._iFlags, 4 /* READABLE */);
                }

                akra.debug.assert(!pData || pData.byteLength <= iByteSize, "Размер переданного массива больше переданного размера буфера");

                this._pWebGLBuffer = pWebGLRenderer.createWebGLBuffer();

                if (!this._pWebGLBuffer) {
                    akra.logger.critical("cannot create WebGL index buffer");

                    this.destroy();
                    return false;
                }

                pWebGLRenderer.bindWebGLBuffer(34963 /* ELEMENT_ARRAY_BUFFER */, this._pWebGLBuffer);
                pWebGLContext.bufferData(34963 /* ELEMENT_ARRAY_BUFFER */, this._iByteSize, webgl.getWebGLUsage(this._iFlags));

                if (pData) {
                    pWebGLContext.bufferSubData(34963 /* ELEMENT_ARRAY_BUFFER */, 0, (akra.isArrayBuffer(pData) ? pData : (pData).buffer));
                }

                return true;
            };

            WebGLIndexBuffer.prototype.destroy = function () {
                _super.prototype.destroy.call(this);

                var pWebGLRenderer = this.getEngine().getRenderer();

                pWebGLRenderer.deleteWebGLBuffer(this._pWebGLBuffer);

                this._pWebGLBuffer = null;
                this._iByteSize = 0;
            };

            WebGLIndexBuffer.prototype.readData = function (iOffset, iSize, ppDest) {
                akra.debug.assert(!akra.isNull(this._pWebGLBuffer), "WebGL buffer not exists");

                if (!this.isBackupPresent()) {
                    return false;
                }

                if (arguments.length === 1) {
                    this._pBackupCopy.readData(arguments[0]);
                } else {
                    this._pBackupCopy.readData(iOffset, iSize, ppDest);
                }

                return true;
            };

            WebGLIndexBuffer.prototype.writeData = function (pData, iOffset, iSize, bDiscardWholeBuffer) {
                if (typeof bDiscardWholeBuffer === "undefined") { bDiscardWholeBuffer = false; }
                akra.debug.assert(!akra.isNull(this._pWebGLBuffer), "WebGL buffer not exists");

                var pWebGLRenderer = this.getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                pWebGLRenderer.bindWebGLBuffer(34963 /* ELEMENT_ARRAY_BUFFER */, this._pWebGLBuffer);

                akra.debug.assert(pData.byteLength <= iSize, "Размер переданного массива больше переданного размера");
                akra.debug.assert(this.getByteLength() >= iOffset + iSize, "Данные выйдут за предел буфера");

                var pU8Data = null;

                if (akra.isArrayBuffer(pData)) {
                    pU8Data = new Uint8Array(pData);
                } else {
                    pU8Data = new Uint8Array(pData.buffer, pData.byteOffset, pData.byteLength);
                }

                pU8Data = pU8Data.subarray(0, iSize);

                //if ((pU8Data.byteLength + iOffset) / )
                pWebGLContext.bufferSubData(34963 /* ELEMENT_ARRAY_BUFFER */, iOffset, pU8Data);

                if (this.isBackupPresent()) {
                    this._pBackupCopy.writeData(pU8Data, iOffset);
                }

                this.notifyAltered();

                return true;
            };

            WebGLIndexBuffer.prototype.getIndexData = function (iOffset, iCount, ePrimitiveType, eElementsTyps) {
                if (eElementsTyps === 5125 /* UNSIGNED_INT */) {
                    webgl.loadExtension(this.getEngine().getRenderer().getWebGLContext(), webgl.OES_ELEMENT_INDEX_UINT);
                }

                return _super.prototype.getIndexData.call(this, iOffset, iCount, ePrimitiveType, eElementsTyps);
            };

            WebGLIndexBuffer.prototype.getEmptyIndexData = function (iCount, ePrimitiveType, eElementsTyps) {
                if (eElementsTyps === 5125 /* UNSIGNED_INT */) {
                    webgl.loadExtension(this.getEngine().getRenderer().getWebGLContext(), webgl.OES_ELEMENT_INDEX_UINT);
                }

                return _super.prototype.getEmptyIndexData.call(this, iCount, ePrimitiveType, eElementsTyps);
            };

            WebGLIndexBuffer.prototype.resize = function (iSize) {
                var eUsage;
                var pData;
                var iMax = 0;
                var pIndexData;

                var pWebGLRenderer = this.getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                if (this.isBackupPresent()) {
                    return false;
                }

                if (iSize < this.getByteLength()) {
                    for (var k = 0; k < this._pIndexDataArray.length; ++k) {
                        pIndexData = this._pIndexDataArray[k];

                        if (pIndexData.getByteOffset() + pIndexData.getByteLength() > iMax) {
                            iMax = pIndexData.getByteOffset() + pIndexData.getByteLength();
                        }
                    }

                    akra.debug.assert(iMax <= iSize, "Уменьшение невозможно. Страая разметка не укладывается в новый размер");
                }

                if (pWebGLContext.isBuffer(this._pWebGLBuffer)) {
                    pWebGLRenderer.deleteWebGLBuffer(this._pWebGLBuffer);
                }

                eUsage = webgl.getWebGLUsage(this._iFlags);

                this._pWebGLBuffer = pWebGLRenderer.createWebGLBuffer();

                if (!this._pWebGLBuffer) {
                    akra.logger.critical("cannot create WebGL index buffer");

                    this.destroy();
                    return false;
                }

                pWebGLRenderer.bindWebGLBuffer(34963 /* ELEMENT_ARRAY_BUFFER */, this._pWebGLBuffer);
                pWebGLContext.bufferData(34963 /* ELEMENT_ARRAY_BUFFER */, iSize, eUsage);

                pData = new Uint8Array(this._iByteSize);

                if (this.readData(pData)) {
                    akra.debug.warn("cannot read data from buffer");
                    return false;
                }

                this.writeData(pData, 0, this._iByteSize);
                this._pBackupCopy.resize(iSize);
                this._iByteSize = iSize;

                this.notifyAltered();

                return true;
            };

            WebGLIndexBuffer.prototype.getWebGLBuffer = function () {
                return this._pWebGLBuffer;
            };

            WebGLIndexBuffer.prototype.lockImpl = function (iOffset, iSize, iLockFlags) {
                var pRetData = new Uint8Array(iSize);

                this.readData(iOffset, iSize, pRetData);

                this._pLockData = pRetData;

                return pRetData;
            };

            WebGLIndexBuffer.prototype.unlockImpl = function () {
                this.writeData(this._pLockData, this._iLockStart, this._iLockSize);
            };

            WebGLIndexBuffer.prototype.copyBackupToRealImpl = function (pRealData, pBackupData, iLockFlags) {
                pRealData.set(pBackupData);
            };
            return WebGLIndexBuffer;
        })(akra.pool.resources.IndexBuffer);
        webgl.WebGLIndexBuffer = WebGLIndexBuffer;
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
/// <reference path="../pixelUtil/pixelUtil.ts" />
var akra;
(function (akra) {
    /// <reference path="WebGLPixelBuffer.ts" />
    /// <reference path="webgl.ts" />
    (function (webgl) {
        var WebGLInternalRenderBuffer = (function (_super) {
            __extends(WebGLInternalRenderBuffer, _super);
            function WebGLInternalRenderBuffer() {
                _super.call(this);
                this._pWebGLRenderbuffer = null;
            }
            WebGLInternalRenderBuffer.prototype.create = function () {
                if (arguments.length !== 4) {
                    akra.logger.critical("Invalid number of arguments. For PixelBuffer it must be four");
                }

                var iWebGLFormat = arguments[0];
                var iWidth = arguments[1];
                var iHeight = arguments[2];
                var bCreateStorage = arguments[3];

                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                _super.prototype.create.call(this, iWidth, iHeight, 1, webgl.getClosestAkraFormat(iWebGLFormat, 12 /* A8R8G8B8 */), 0);

                this._iWebGLInternalFormat = iWebGLFormat;
                this._pWebGLRenderbuffer = pWebGLRenderer.createWebGLRenderbuffer();

                pWebGLRenderer.bindWebGLRenderbuffer(36161 /* RENDERBUFFER */, this._pWebGLRenderbuffer);

                if (bCreateStorage) {
                    pWebGLContext.renderbufferStorage(36161 /* RENDERBUFFER */, iWebGLFormat, iWidth, iHeight);
                }

                this.notifyCreated();
                return true;
            };

            WebGLInternalRenderBuffer.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();

                pWebGLRenderer.deleteWebGLRenderbuffer(this._pWebGLRenderbuffer);
                this._pWebGLRenderbuffer = null;
            };

            WebGLInternalRenderBuffer.prototype._bindToFramebuffer = function (iAttachment, iZOffset) {
                akra.logger.assert(iZOffset < this._iDepth);

                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();

                pWebGLContext.framebufferRenderbuffer(36160 /* FRAMEBUFFER */, iAttachment, 36161 /* RENDERBUFFER */, this._pWebGLRenderbuffer);
            };
            return WebGLInternalRenderBuffer;
        })(webgl.WebGLPixelBuffer);
        webgl.WebGLInternalRenderBuffer = WebGLInternalRenderBuffer;
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
/// <reference path="../../idl/IDepthBuffer.ts" />
/// <reference path="../../idl/IRenderTarget.ts" />
var akra;
(function (akra) {
    (function (pool) {
        /// <reference path="../ResourcePoolItem.ts" />
        (function (resources) {
            var DepthBuffer = (function (_super) {
                __extends(DepthBuffer, _super);
                function DepthBuffer() {
                    _super.call(this);
                    this._iBitDepth = 0;
                    this._iWidth = 0;
                    this._iHeight = 0;
                    this._isManual = false;
                    this._pAttachedRenderTargetsList = null;
                }
                DepthBuffer.prototype.getBitDepth = function () {
                    return this._iBitDepth;
                };

                DepthBuffer.prototype.getWidth = function () {
                    return this._iWidth;
                };

                DepthBuffer.prototype.getHeight = function () {
                    return this._iHeight;
                };

                DepthBuffer.prototype.create = function (iBitDepth, iWidth, iHeight, isManual) {
                    this._iBitDepth = iBitDepth;
                    this._iWidth = iWidth;
                    this._iHeight = iHeight;
                    this._isManual = isManual;
                    this._pAttachedRenderTargetsList = [];

                    this.notifyCreated();

                    return true;
                };

                DepthBuffer.prototype.destroy = function () {
                    this.detachFromAllRenderTargets();
                    this._pAttachedRenderTargetsList = null;
                };

                DepthBuffer.prototype.destroyResource = function () {
                    this.destroy();
                    this.notifyDestroyed();
                    return true;
                };

                DepthBuffer.prototype.isManual = function () {
                    return this._isManual;
                };

                DepthBuffer.prototype.isCompatible = function (pTarget) {
                    if (this._iWidth >= pTarget.getWidth() && this._iHeight >= pTarget.getHeight()) {
                        return true;
                    }

                    return false;
                };

                DepthBuffer.prototype._notifyRenderTargetAttached = function (pTarget) {
                    akra.logger.assert(this._pAttachedRenderTargetsList.indexOf(pTarget) === -1, "RenderTarget alrady has been attached to this DepthBuffer");

                    this._pAttachedRenderTargetsList.push(pTarget);
                };

                DepthBuffer.prototype._notifyRenderTargetDetached = function (pTarget) {
                    var index = this._pAttachedRenderTargetsList.indexOf(pTarget);
                    akra.logger.assert(index !== -1, "Can not detach RenderTarget from DepthBuffer beacuse it hasn`t been attached to it");

                    this._pAttachedRenderTargetsList.splice(index, 1);
                };

                DepthBuffer.prototype.detachFromAllRenderTargets = function () {
                    var i = 0;
                    for (i = 0; i < this._pAttachedRenderTargetsList.length; i++) {
                        //If we call, detachDepthBuffer, we'll invalidate the iterators
                        this._pAttachedRenderTargetsList[i].detachDepthBuffer();
                    }

                    this._pAttachedRenderTargetsList.clear();
                };
                return DepthBuffer;
            })(pool.ResourcePoolItem);
            resources.DepthBuffer = DepthBuffer;
        })(pool.resources || (pool.resources = {}));
        var resources = pool.resources;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="../idl/IRenderTarget.ts" />
/// <reference path="../idl/IPixelBuffer.ts" />
/// <reference path="../idl/IRenderer.ts" />
/// <reference path="../idl/IPixelBox.ts" />
/// <reference path="../idl/IRenderTexture.ts" />
var akra;
(function (akra) {
    /// <reference path="../pixelUtil/pixelUtil.ts" />
    /// <reference path="RenderTarget.ts" />
    (function (render) {
        var RenderTexture = (function (_super) {
            __extends(RenderTexture, _super);
            function RenderTexture(pRenderer, pBuffer, iZOffset) {
                _super.call(this, pRenderer);
                this._pBuffer = null;
                this._iZOffset = 0;
                this._pBuffer = pBuffer;
                this._iZOffset = iZOffset;
                this._iWidth = pBuffer.getWidth();
                this._iHeight = pBuffer.getHeight();
                this._iColorDepth = akra.pixelUtil.getNumElemBits(pBuffer.getFormat());
            }
            RenderTexture.prototype.enableSupportFor3DEvent = function (iType) {
                return 0;
            };

            RenderTexture.prototype.getPixelBuffer = function () {
                return this._pBuffer;
            };

            RenderTexture.prototype.destroy = function () {
                this._pBuffer._clearRTT(this._iZOffset);
                this._pBuffer = null;
            };

            RenderTexture.prototype.suggestPixelFormat = function () {
                return this._pBuffer.getFormat();
            };

            RenderTexture.prototype.copyContentsToMemory = function (pDest, eBuffer) {
                if (eBuffer === 2 /* AUTO */) {
                    eBuffer = 0 /* FRONT */;
                }

                if (eBuffer !== 0 /* FRONT */) {
                    akra.logger.critical("Invalid buffer.");
                }

                this._pBuffer.blitToMemory(pDest);
            };

            RenderTexture.prototype.readPixels = function (ppDest, eFramebuffer) {
                if (akra.isNull(ppDest)) {
                    var ePixelFormat = 10 /* BYTE_RGB */;

                    ppDest = new akra.pixelUtil.PixelBox(this._iWidth, this._iHeight, 1, ePixelFormat, new Uint8Array(akra.pixelUtil.getMemorySize(this._iWidth, this._iHeight, 1, ePixelFormat)));
                }

                if ((ppDest.right > this._iWidth) || (ppDest.bottom > this._iHeight) || (ppDest.front != 0) || (ppDest.back != 1)) {
                    akra.logger.critical("Invalid box.", "RenderTexture::readPixels");
                }

                this._pBuffer.readPixels(ppDest);

                return ppDest;
            };
            return RenderTexture;
        })(render.RenderTarget);
        render.RenderTexture = RenderTexture;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
/// <reference path="../idl/IRenderer.ts" />
/// <reference path="../idl/IDepthBuffer.ts" />
var akra;
(function (akra) {
    /// <reference path="WebGLInternalFrameBuffer.ts" />
    /// <reference path="WebGLPixelBuffer.ts" />
    /// <reference path="../render/RenderTexture.ts" />
    (function (webgl) {
        var WebGLRenderTexture = (function (_super) {
            __extends(WebGLRenderTexture, _super);
            function WebGLRenderTexture(pRenderer, pTarget) {
                _super.call(this, pRenderer, pTarget, 0);
                this._pFrameBuffer = null;
                this._pFrameBuffer = new webgl.WebGLInternalFrameBuffer(pRenderer);

                this._pFrameBuffer.bindSurface(36064 /* COLOR_ATTACHMENT0 */, pTarget);

                this._iWidth = this._pFrameBuffer.getWidth();
                this._iHeight = this._pFrameBuffer.getHeight();
            }
            WebGLRenderTexture.prototype.getWidth = function () {
                return this._iWidth = this._pFrameBuffer.getWidth();
            };

            WebGLRenderTexture.prototype.getHeight = function () {
                return this._iHeight = this._pFrameBuffer.getHeight();
            };

            WebGLRenderTexture.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
            };

            WebGLRenderTexture.prototype.requiresTextureFlipping = function () {
                return true;
            };

            WebGLRenderTexture.prototype.getCustomAttribute = function (sName) {
                if (sName === "FBO") {
                    return this._pFrameBuffer;
                }

                return null;
            };

            WebGLRenderTexture.prototype.swapBuffers = function () {
                this._pFrameBuffer.swapBuffers();
            };

            WebGLRenderTexture.prototype.attachDepthBuffer = function (pDepthBuffer) {
                var bResult = false;
                bResult = _super.prototype.attachDepthBuffer.call(this, pDepthBuffer);

                if (bResult) {
                    this._pFrameBuffer.attachDepthBuffer(pDepthBuffer);
                }

                return bResult;
            };

            WebGLRenderTexture.prototype.attachDepthPixelBuffer = function (pBuffer) {
                var bResult = false;

                bResult = _super.prototype.attachDepthPixelBuffer.call(this, pBuffer);
                if (bResult) {
                    if (pBuffer.getFormat() !== 44 /* DEPTH8 */) {
                        this.detachDepthPixelBuffer();
                        return false;
                    }

                    this._pFrameBuffer.bindSurface(36096 /* DEPTH_ATTACHMENT */, pBuffer);
                    pBuffer.addRef();
                }

                return bResult;
            };

            WebGLRenderTexture.prototype.attachDepthTexture = function (pTexture) {
                this._pFrameBuffer.attachDepthTexture(pTexture);
                return true;
            };

            WebGLRenderTexture.prototype.detachDepthPixelBuffer = function () {
                this._pFrameBuffer.unbindSurface(36096 /* DEPTH_ATTACHMENT */);
                this._pDepthPixelBuffer.release();
                _super.prototype.detachDepthPixelBuffer.call(this);
            };

            WebGLRenderTexture.prototype.detachDepthBuffer = function () {
                this._pFrameBuffer.detachDepthBuffer();
                _super.prototype.detachDepthBuffer.call(this);
            };

            WebGLRenderTexture.prototype.detachDepthTexture = function () {
                this._pFrameBuffer.detachDepthTexture();
            };
            return WebGLRenderTexture;
        })(akra.render.RenderTexture);
        webgl.WebGLRenderTexture = WebGLRenderTexture;
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
/// <reference path="../idl/IRenderer.ts" />
/// <reference path="../idl/IDepthBuffer.ts" />
/// <reference path="../idl/IPixelBuffer.ts" />
var akra;
(function (akra) {
    /// <reference path="WebGLRenderer.ts" />
    /// <reference path="WebGLRenderTexture.ts" />
    /// <reference path="webgl.ts" />
    /// <reference path="WebGLInternalRenderBuffer.ts" />
    /// <reference path="WebGLPixelBuffer.ts" />
    /// <reference path="WebGLDepthBuffer.ts" />
    (function (webgl) {
        var WebGLInternalFrameBuffer = (function () {
            function WebGLInternalFrameBuffer(pWebGLRenderer) {
                this._pWebGLRenderer = null;
                this._pWebGLFramebuffer = null;
                this._pAttachments = null;
                this._iWebglActiveAttachment = 0;
                this._pWebGLRenderer = pWebGLRenderer;

                this._pWebGLFramebuffer = this._pWebGLRenderer.createWebGLFramebuffer();
                this._pAttachments = {};

                for (var i = 0; i < webgl.maxColorAttachments; i++) {
                    this._pAttachments[36064 /* COLOR_ATTACHMENT0 */ + i] = null;
                }

                this._pAttachments[36096 /* DEPTH_ATTACHMENT */] = null;
                this._pAttachments[36128 /* STENCIL_ATTACHMENT */] = null;
                this._pAttachments[33306 /* DEPTH_STENCIL_ATTACHMENT */] = null;
            }
            WebGLInternalFrameBuffer.prototype.destroy = function () {
                this._pWebGLRenderer.deleteWebGLFramebuffer(this._pWebGLFramebuffer);
                this._pWebGLFramebuffer = null;
            };

            WebGLInternalFrameBuffer.prototype.getWidth = function () {
                return this._pAttachments[36064 /* COLOR_ATTACHMENT0 */].getWidth();
            };

            WebGLInternalFrameBuffer.prototype.getHeight = function () {
                return this._pAttachments[36064 /* COLOR_ATTACHMENT0 */].getHeight();
            };

            WebGLInternalFrameBuffer.prototype.getFormat = function () {
                return this._pAttachments[36064 /* COLOR_ATTACHMENT0 */].getFormat();
            };

            WebGLInternalFrameBuffer.prototype.getColorAttachment = function (iAttachment) {
                return this._pAttachments[36064 /* COLOR_ATTACHMENT0 */ + iAttachment];
            };

            WebGLInternalFrameBuffer.prototype.getAttachment = function (iWebGLAttachment) {
                return this._pAttachments[iWebGLAttachment];
            };

            WebGLInternalFrameBuffer.prototype.bindSurface = function (iWebGLAttachment, pSurface) {
                if (!akra.isDef(this._pAttachments[iWebGLAttachment])) {
                    return;
                }

                this.releaseAttachment(iWebGLAttachment);
                this._pAttachments[iWebGLAttachment] = pSurface;
                if (this.checkAttachment(iWebGLAttachment)) {
                    this._bind();
                    pSurface._bindToFramebuffer(iWebGLAttachment, 0);
                    pSurface.addRef();
                }
            };

            WebGLInternalFrameBuffer.prototype.unbindSurface = function (iWebGLAttachment) {
                if (!akra.isDef(this._pAttachments[iWebGLAttachment])) {
                    return;
                }
                var pWebGLContext = this._pWebGLRenderer.getWebGLContext();
                this.releaseAttachment(iWebGLAttachment);
                this._pAttachments[iWebGLAttachment] = null;
                pWebGLContext.framebufferRenderbuffer(36160 /* FRAMEBUFFER */, iWebGLAttachment, 36161 /* RENDERBUFFER */, null);
            };

            WebGLInternalFrameBuffer.prototype.bindColorSurface = function (iAttachment, pSurface) {
                this.bindSurface(36064 /* COLOR_ATTACHMENT0 */ + iAttachment, pSurface);
            };

            WebGLInternalFrameBuffer.prototype._bind = function () {
                this._pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, this._pWebGLFramebuffer);
            };

            WebGLInternalFrameBuffer.prototype.attachDepthBuffer = function (pDepthBuffer) {
                var pWebGLContext = this._pWebGLRenderer.getWebGLContext();
                var pOldFramebuffer = this._pWebGLRenderer.getParameter(36006 /* FRAMEBUFFER_BINDING */);

                this._pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, this._pWebGLFramebuffer);

                if (!akra.isNull(pDepthBuffer)) {
                    var pDepthRenderBuffer = pDepthBuffer.getDepthBuffer();
                    var pStencilRenderBuffer = pDepthBuffer.getStencilBuffer();

                    if (!akra.isNull(pDepthRenderBuffer)) {
                        pDepthRenderBuffer._bindToFramebuffer(36096 /* DEPTH_ATTACHMENT */, 0);
                        this.releaseAttachment(36096 /* DEPTH_ATTACHMENT */);
                        this._pAttachments[36096 /* DEPTH_ATTACHMENT */] = pDepthRenderBuffer;
                        pDepthRenderBuffer.addRef();
                    }

                    if (!akra.isNull(pStencilRenderBuffer)) {
                        pStencilRenderBuffer._bindToFramebuffer(36128 /* STENCIL_ATTACHMENT */, 0);
                        this.releaseAttachment(36128 /* STENCIL_ATTACHMENT */);
                        this._pAttachments[36128 /* STENCIL_ATTACHMENT */] = pStencilRenderBuffer;
                        pDepthRenderBuffer.addRef();
                    }

                    if (!this.checkAttachment(36096 /* DEPTH_ATTACHMENT */) || !this.checkAttachment(36128 /* STENCIL_ATTACHMENT */)) {
                        akra.logger.error("Invalid frame buffer depthbuffer attachment. Wrong size.");
                        return;
                    }
                } else {
                    pWebGLContext.framebufferRenderbuffer(36160 /* FRAMEBUFFER */, 36096 /* DEPTH_ATTACHMENT */, 36161 /* RENDERBUFFER */, null);

                    pWebGLContext.framebufferRenderbuffer(36160 /* FRAMEBUFFER */, 36128 /* STENCIL_ATTACHMENT */, 36161 /* RENDERBUFFER */, null);

                    this.releaseAttachment(36096 /* DEPTH_ATTACHMENT */);
                    this.releaseAttachment(36128 /* STENCIL_ATTACHMENT */);
                    this._pAttachments[36096 /* DEPTH_ATTACHMENT */] = null;
                    this._pAttachments[36128 /* STENCIL_ATTACHMENT */] = null;
                }

                this._pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pOldFramebuffer);
            };

            WebGLInternalFrameBuffer.prototype.attachDepthTexture = function (pDepthTexture) {
                var pTextureBuffer = pDepthTexture.getBuffer();
                this._bind();
                this.bindSurface(36096 /* DEPTH_ATTACHMENT */, pTextureBuffer);
            };

            WebGLInternalFrameBuffer.prototype.detachDepthTexture = function () {
                this._bind();
                this.unbindSurface(36096 /* DEPTH_ATTACHMENT */);
            };

            WebGLInternalFrameBuffer.prototype.detachDepthBuffer = function () {
                var pWebGLContext = this._pWebGLRenderer.getWebGLContext();
                var pOldFramebuffer = this._pWebGLRenderer.getParameter(36006 /* FRAMEBUFFER_BINDING */);

                this._pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, this._pWebGLFramebuffer);

                pWebGLContext.framebufferRenderbuffer(36160 /* FRAMEBUFFER */, 36096 /* DEPTH_ATTACHMENT */, 36161 /* RENDERBUFFER */, null);

                pWebGLContext.framebufferRenderbuffer(36160 /* FRAMEBUFFER */, 36128 /* STENCIL_ATTACHMENT */, 36161 /* RENDERBUFFER */, null);

                this.releaseAttachment(36096 /* DEPTH_ATTACHMENT */);
                this.releaseAttachment(36128 /* STENCIL_ATTACHMENT */);
                this._pAttachments[36096 /* DEPTH_ATTACHMENT */] = null;
                this._pAttachments[36128 /* STENCIL_ATTACHMENT */] = null;

                this._pWebGLRenderer.bindWebGLFramebuffer(36160 /* FRAMEBUFFER */, pOldFramebuffer);
            };

            WebGLInternalFrameBuffer.prototype.swapBuffers = function () {
            };

            WebGLInternalFrameBuffer.prototype.checkAttachment = function (iWebGLAttachment) {
                if (iWebGLAttachment === 36064 /* COLOR_ATTACHMENT0 */) {
                    var isOk = true;

                    for (var i = 1; i < webgl.maxColorAttachments; i++) {
                        isOk = this.checkAttachment(36064 /* COLOR_ATTACHMENT0 */ + i);
                        if (!isOk)
                            return false;
                    }

                    isOk = this.checkAttachment(36096 /* DEPTH_ATTACHMENT */);
                    if (!isOk)
                        return false;
                    isOk = this.checkAttachment(36128 /* STENCIL_ATTACHMENT */);
                    if (!isOk)
                        return false;
                    isOk = this.checkAttachment(33306 /* DEPTH_STENCIL_ATTACHMENT */);
                    if (!isOk)
                        return false;

                    return true;
                } else {
                    var pBuffer = this._pAttachments[iWebGLAttachment];
                    if (akra.isNull(pBuffer))
                        return true;

                    if (this.getWidth() === 0 && this.getHeight() === 0)
                        return true;

                    if (this.getWidth() !== pBuffer.getWidth() && this.getHeight() !== pBuffer.getHeight())
                        return false;

                    if (iWebGLAttachment > 36064 /* COLOR_ATTACHMENT0 */ && iWebGLAttachment < 36064 /* COLOR_ATTACHMENT0 */ + webgl.maxColorAttachments) {
                        if (!akra.isNull(this._pAttachments[36064 /* COLOR_ATTACHMENT0 */]) && this.getFormat() !== pBuffer.getFormat())
                            return false;
                    }

                    return true;
                }
            };

            WebGLInternalFrameBuffer.prototype.releaseAttachment = function (iWebGLAttachment) {
                if (!akra.isNull(this._pAttachments[iWebGLAttachment])) {
                    this._pAttachments[iWebGLAttachment].release();
                }
            };
            return WebGLInternalFrameBuffer;
        })();
        webgl.WebGLInternalFrameBuffer = WebGLInternalFrameBuffer;
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
/// <reference path="../pool/resources/DepthBuffer.ts" />
/// <reference path="WebGLInternalRenderBuffer.ts" />
/// <reference path="WebGLInternalFrameBuffer.ts" />
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLDepthBuffer = (function (_super) {
            __extends(WebGLDepthBuffer, _super);
            function WebGLDepthBuffer() {
                _super.call(this);
                this._pDepthBuffer = null;
                this._pStencilBuffer = null;
            }
            WebGLDepthBuffer.prototype.getDepthBuffer = function () {
                return this._pDepthBuffer;
            };

            WebGLDepthBuffer.prototype.getStencilBuffer = function () {
                return this._pStencilBuffer;
            };

            WebGLDepthBuffer.prototype.create = function () {
                if (arguments.length !== 5) {
                    akra.logger.critical("Invalid number of arguments. For WebGLDepthBuffer it must be five");
                }

                _super.prototype.create.call(this, 0, arguments[2], arguments[3], arguments[4]);
                var pDepth = arguments[0];
                var pStencil = arguments[1];

                this._pDepthBuffer = pDepth;
                this._pStencilBuffer = pStencil;

                if (!akra.isNull(pDepth)) {
                    switch (pDepth._getWebGLFormat()) {
                        case 33189 /* DEPTH_COMPONENT16 */:
                            this._iBitDepth = 16;
                            break;
                        case 33190 /* DEPTH_COMPONENT24_OES */:
                        case 33191 /* DEPTH_COMPONENT32_OES */:
                        case 35056 /* DEPTH24_STENCIL8_OES */:
                            if (webgl.hasExtension(webgl.OES_DEPTH24) || webgl.hasExtension(webgl.OES_DEPTH32) || webgl.hasExtension(webgl.OES_PACKED_DEPTH_STENCIL)) {
                                this._iBitDepth = 32;
                            }
                            break;
                    }
                }

                return true;
            };

            WebGLDepthBuffer.prototype.destroy = function () {
                _super.prototype.destroy.call(this);

                if (!akra.isNull(this._pStencilBuffer) && this._pStencilBuffer !== this._pDepthBuffer) {
                    this._pStencilBuffer.release();
                }

                if (!akra.isNull(this._pDepthBuffer)) {
                    this._pDepthBuffer.release();
                }

                this._pStencilBuffer = null;
                this._pDepthBuffer = null;
            };

            WebGLDepthBuffer.prototype.isCompatible = function (pTarget) {
                if (this._iWidth >= pTarget.getWidth() && this._iHeight >= pTarget.getHeight()) {
                    return true;
                }

                return false;
            };
            return WebGLDepthBuffer;
        })(akra.pool.resources.DepthBuffer);
        webgl.WebGLDepthBuffer = WebGLDepthBuffer;
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
/// <reference path="../idl/IEngine.ts" />
/// <reference path="../idl/IResourcePoolManager.ts" />
/// <reference path="../idl/IResourcePool.ts" />
/// <reference path="../idl/IResourcePoolItem.ts" />
/// <reference path="../idl/IResourceWatcherFunc.ts" />
/// <reference path="../idl/IModel.ts" />
var akra;
(function (akra) {
    /// <reference path="../bf/bf.ts" />
    /// <reference path="../logger.ts" />
    /// <reference path="../debug.ts" />
    /// <reference path="../config/config.ts" />
    /// <reference path="../path/path.ts" />
    /// <reference path="ResourceCode.ts" />
    /// <reference path="ResourcePool.ts" />
    /// <reference path="ResourcePoolItem.ts" />
    /// <reference path="DataPool.ts" />
    /// <reference path="resources/RenderMethod.ts" />
    /// <reference path="resources/SurfaceMaterial.ts" />
    /// <reference path="resources/Effect.ts" />
    /// <reference path="resources/Img.ts" />
    /// <reference path="resources/Component.ts" />
    /// <reference path="resources/Collada.ts" />
    /// <reference path="resources/Obj.ts" />
    /// <reference path="resources/EffectData.ts" />
    /// <reference path="../webgl/WebGLPixelBuffer.ts" />
    /// <reference path="../webgl/WebGLInternalTexture.ts" />
    /// <reference path="../webgl/WebGLVertexBuffer.ts" />
    /// <reference path="../webgl/WebGLVertexTexture.ts" />
    /// <reference path="../webgl/WebGLTextureBuffer.ts" />
    /// <reference path="../webgl/WebGLShaderProgram.ts" />
    /// <reference path="../webgl/WebGLIndexBuffer.ts" />
    /// <reference path="../webgl/WebGLInternalRenderBuffer.ts" />
    /// <reference path="../webgl/WebGLDepthBuffer.ts" />
    (function (pool) {
        function determModelFormat(sPath) {
            switch ((akra.path.parse(sPath).getExt() || "").toLowerCase()) {
                case "obj":
                    return 8192 /* OBJ */;
                case "dae":
                    return 4096 /* COLLADA */;
            }

            return 0 /* UNKNOWN */;
        }

        //is this class really singleton??
        var ResourcePoolManager = (function () {
            function ResourcePoolManager(pEngine) {
                /** Списки пулов по семействам ресурсов */
                this.pResourceFamilyList = null;
                /** Карта пулов по коду ресурса */
                this.pResourceTypeMap = null;
                //super();
                this.pEngine = pEngine;

                this.pResourceFamilyList = new Array(3 /* TOTAL_RESOURCE_FAMILIES */);

                for (var i = 0; i < 3 /* TOTAL_RESOURCE_FAMILIES */; i++) {
                    this.pResourceFamilyList[i] = new Array();
                }

                this.pResourceTypeMap = new Array();

                this.createDeviceResource();
            }
            ResourcePoolManager.prototype.getSurfaceMaterialPool = function () {
                return this.pSurfaceMaterialPool;
            };

            ResourcePoolManager.prototype.getEffectPool = function () {
                return this.pEffectPool;
            };

            ResourcePoolManager.prototype.getRenderMethodPool = function () {
                return this.pRenderMethodPool;
            };

            ResourcePoolManager.prototype.getVertexBufferPool = function () {
                return this.pVertexBufferPool;
            };

            ResourcePoolManager.prototype.getIndexBufferPool = function () {
                return this.pIndexBufferPool;
            };

            ResourcePoolManager.prototype.getColladaPool = function () {
                return this.pColladaPool;
            };

            ResourcePoolManager.prototype.getObjPool = function () {
                return this.pObjPool;
            };

            ResourcePoolManager.prototype.getImagePool = function () {
                return this.pImagePool;
            };

            ResourcePoolManager.prototype.getTexturePool = function () {
                return this.pTexturePool;
            };

            ResourcePoolManager.prototype.getVideoBufferPool = function () {
                return this.pVideoBufferPool;
            };

            ResourcePoolManager.prototype.getShaderProgramPool = function () {
                return this.pShaderProgramPool;
            };

            ResourcePoolManager.prototype.getComponentPool = function () {
                return this.pComponentPool;
            };

            ResourcePoolManager.prototype.getTextureBufferPool = function () {
                return this.pTextureBufferPool;
            };

            ResourcePoolManager.prototype.getRenderBufferPool = function () {
                return this.pRenderBufferPool;
            };

            ResourcePoolManager.prototype.getDepthBufferPool = function () {
                return this.pDepthBufferPool;
            };

            ResourcePoolManager.prototype.getEffectDataPool = function () {
                return this.pEffectDataPool;
            };

            ResourcePoolManager.prototype.initialize = function () {
                this.registerDeviceResources();
                return true;
            };

            ResourcePoolManager.prototype.destroy = function () {
                this.unregisterDeviceResources();
            };

            ResourcePoolManager.prototype.registerResourcePool = function (pCode, pPool) {
                akra.debug.assert(pCode.getFamily() >= 0 && pCode.getFamily() < 3 /* TOTAL_RESOURCE_FAMILIES */, "invalid code familyi index");

                akra.debug.assert(!akra.isDef(this.pResourceTypeMap[pCode.toNumber()]), "Resource type code already registered");

                this.pResourceTypeMap[pCode.toNumber()] = pPool;
                this.pResourceFamilyList[pCode.getFamily()].push(pPool);
            };

            ResourcePoolManager.prototype.unregisterResourcePool = function (pCode) {
                akra.debug.assert(pCode.getFamily() >= 0, "invalid family index");
                akra.debug.assert(pCode.getFamily() < 3 /* TOTAL_RESOURCE_FAMILIES */, "invalid family index");

                var iCode = pCode.toNumber();
                var pPool = null;
                if (this.pResourceTypeMap[iCode] != undefined) {
                    pPool = this.pResourceTypeMap[iCode];
                    delete this.pResourceTypeMap[iCode];
                }

                if (pPool != null) {
                    for (var i in this.pResourceFamilyList[pCode.getFamily()]) {
                        if (this.pResourceFamilyList[pCode.getFamily()][i] == pPool) {
                            delete this.pResourceFamilyList[pCode.getFamily()][i];
                            return pPool;
                        }
                    }
                }

                return pPool;
            };

            ResourcePoolManager.prototype.destroyResourceFamily = function (eFamily) {
                akra.debug.assert(eFamily < 3 /* TOTAL_RESOURCE_FAMILIES */, "invalid family index");

                for (var i in this.pResourceFamilyList[eFamily]) {
                    this.pResourceFamilyList[eFamily][i].destroyAll();
                }
            };

            ResourcePoolManager.prototype.restoreResourceFamily = function (eFamily) {
                akra.debug.assert(eFamily >= 0, "invalid family index");
                akra.debug.assert(eFamily < 3 /* TOTAL_RESOURCE_FAMILIES */, "invalid family index");

                for (var i in this.pResourceFamilyList[eFamily]) {
                    this.pResourceFamilyList[eFamily][i].restoreAll();
                }
            };

            ResourcePoolManager.prototype.disableResourceFamily = function (eFamily) {
                akra.debug.assert(eFamily >= 0, "invalid family index");
                akra.debug.assert(eFamily < 3 /* TOTAL_RESOURCE_FAMILIES */, "invalid family index");

                for (var i in this.pResourceFamilyList[eFamily]) {
                    this.pResourceFamilyList[eFamily][i].disableAll();
                }
            };

            ResourcePoolManager.prototype.cleanResourceFamily = function (eFamily) {
                akra.debug.assert(eFamily >= 0, "invalid family index");
                akra.debug.assert(eFamily < 3 /* TOTAL_RESOURCE_FAMILIES */, "invalid family index");

                for (var i in this.pResourceFamilyList[eFamily]) {
                    this.pResourceFamilyList[eFamily][i].clean();
                }
            };

            ResourcePoolManager.prototype.destroyResourceType = function (pCode) {
                if (akra.isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                    this.pResourceTypeMap[pCode.toNumber()].destroyAll();
                }
            };

            ResourcePoolManager.prototype.restoreResourceType = function (pCode) {
                if (akra.isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                    this.pResourceTypeMap[pCode.toNumber()].restoreAll();
                }
            };

            ResourcePoolManager.prototype.disableResourceType = function (pCode) {
                if (akra.isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                    this.pResourceTypeMap[pCode.toNumber()].disableAll();
                }
            };

            ResourcePoolManager.prototype.cleanResourceType = function (pCode) {
                if (akra.isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                    this.pResourceTypeMap[pCode.toNumber()].clean();
                }
            };

            ResourcePoolManager.prototype.findResourcePool = function (pCode) {
                if (akra.isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                    return this.pResourceTypeMap[pCode.toNumber()];
                }

                return null;
            };

            ResourcePoolManager.prototype.findResourceHandle = function (pCode, sName) {
                var pPool = this.findResourcePool(pCode);
                var iHandle = pool.PoolGroup.INVALID_INDEX;

                if (!akra.isNull(pPool)) {
                    iHandle = pPool.findResourceHandle(sName);
                }

                return iHandle;
            };

            ResourcePoolManager.prototype.findResource = function (pCode, sName) {
                var pPool = this.findResourcePool(pCode);
                var pResult = null;
                var iHandle = 0;

                if (akra.isString(arguments[1])) {
                    iHandle = pPool.findResourceHandle(sName);
                } else if (akra.isInt(arguments[1])) {
                    iHandle = arguments[1];
                }

                if (pPool != null && iHandle != pool.PoolGroup.INVALID_INDEX) {
                    pResult = pPool.getResource(iHandle);
                }

                return pResult;
            };

            ResourcePoolManager.prototype.destroyAll = function () {
                for (var i = 0; i < 3 /* TOTAL_RESOURCE_FAMILIES */; i++) {
                    this.destroyResourceFamily(i);
                }
            };

            ResourcePoolManager.prototype.restoreAll = function () {
                for (var i = 0; i < 3 /* TOTAL_RESOURCE_FAMILIES */; i++) {
                    this.restoreResourceFamily(i);
                }
            };

            ResourcePoolManager.prototype.disableAll = function () {
                for (var i = 0; i < 3 /* TOTAL_RESOURCE_FAMILIES */; i++) {
                    this.disableResourceFamily(i);
                }
            };

            ResourcePoolManager.prototype.clean = function () {
                for (var i = 0; i < 3 /* TOTAL_RESOURCE_FAMILIES */; i++) {
                    this.cleanResourceFamily(i);
                }
            };

            ResourcePoolManager.prototype.createDeviceResources = function () {
                return true;
            };

            ResourcePoolManager.prototype.destroyDeviceResources = function () {
                this.disableDeviceResources();

                // then destroy...
                akra.debug.log("Destroying Video Device Resources\n");

                this.destroyResourceFamily(0 /* VIDEO_RESOURCE */);

                return true;
            };

            ResourcePoolManager.prototype.restoreDeviceResources = function () {
                akra.debug.log("Restoring Video Device Resources\n");
                this.restoreResourceFamily(0 /* VIDEO_RESOURCE */);
                return true;
            };

            ResourcePoolManager.prototype.disableDeviceResources = function () {
                akra.debug.log("Disabling Video Device Resources\n");
                this.disableResourceFamily(0 /* VIDEO_RESOURCE */);
                return true;
            };

            ResourcePoolManager.prototype.getEngine = function () {
                return this.pEngine;
            };

            ResourcePoolManager.prototype.createRenderMethod = function (sResourceName) {
                return this.getRenderMethodPool().createResource(sResourceName);
            };

            ResourcePoolManager.prototype.createTexture = function (sResourceName) {
                return this.getTexturePool().createResource(sResourceName);
            };

            ResourcePoolManager.prototype.createEffect = function (sResourceName) {
                return this.getEffectPool().createResource(sResourceName);
            };

            ResourcePoolManager.prototype.createSurfaceMaterial = function (sResourceName) {
                return this.getSurfaceMaterialPool().createResource(sResourceName);
            };

            ResourcePoolManager.prototype.createVertexBuffer = function (sResourceName) {
                return this.getVertexBufferPool().createResource(sResourceName);
            };

            ResourcePoolManager.prototype.createVideoBuffer = function (sResourceName) {
                return this.getVideoBufferPool().createResource(sResourceName);
            };

            ResourcePoolManager.prototype.createIndexBuffer = function (sResourceName) {
                return this.getIndexBufferPool().createResource(sResourceName);
            };

            ResourcePoolManager.prototype.createShaderProgram = function (sResourceName) {
                return this.getShaderProgramPool().createResource(sResourceName);
            };

            ResourcePoolManager.prototype.createModel = function (sResourceName, eFormat) {
                var pPool = this.getModelPoolByFormat(eFormat || determModelFormat(sResourceName));

                if (!akra.isNull(pPool)) {
                    return pPool.createResource(sResourceName);
                }

                return null;
            };

            ResourcePoolManager.prototype.getModelPoolByFormat = function (eFormat) {
                switch (eFormat) {
                    case 8192 /* OBJ */:
                        return this.getObjPool();
                    case 4096 /* COLLADA */:
                    default:
                        return this.getColladaPool();
                }

                return null;
            };

            ResourcePoolManager.prototype.loadModel = function (sFilename, pOptions) {
                if (typeof pOptions === "undefined") { pOptions = null; }
                var eFormat = determModelFormat(sFilename);
                var pPool = this.getModelPoolByFormat(eFormat);
                var pModel = null;

                if (!akra.isNull(pPool)) {
                    pModel = pPool.findResource(sFilename);

                    if (akra.isNull(pModel)) {
                        pModel = pPool.createResource(sFilename);
                    }

                    if (!pModel.isResourceLoaded()) {
                        pModel.loadResource(sFilename, pOptions);
                    }

                    return pModel;
                }

                return null;
            };

            ResourcePoolManager.prototype.createImg = function (sResourceName) {
                return this.getImagePool().createResource(sResourceName);
            };

            ResourcePoolManager.prototype.loadImage = function (sFilename) {
                var pImg = this.getImagePool().findResource(sFilename);

                if (akra.isNull(pImg)) {
                    pImg = this.getImagePool().createResource(sFilename);

                    if (!pImg.isResourceLoaded()) {
                        pImg.loadResource(sFilename);
                    }
                }

                return pImg;
            };

            ResourcePoolManager.prototype.createDeviceResource = function () {
                this.pSurfaceMaterialPool = new pool.ResourcePool(this, pool.resources.SurfaceMaterial);
                this.pSurfaceMaterialPool.initialize(16);

                this.pEffectPool = new pool.ResourcePool(this, pool.resources.Effect);
                this.pEffectPool.initialize(16);

                this.pRenderMethodPool = new pool.ResourcePool(this, pool.resources.RenderMethod);
                this.pRenderMethodPool.initialize(16);

                this.pColladaPool = new pool.ResourcePool(this, pool.resources.Collada);
                this.pColladaPool.initialize(0);

                this.pObjPool = new pool.ResourcePool(this, pool.resources.Obj);
                this.pObjPool.initialize(0);

                this.pImagePool = new pool.ResourcePool(this, pool.resources.Img);
                this.pImagePool.initialize(16);

                if (akra.config.WEBGL) {
                    this.pTexturePool = new pool.ResourcePool(this, akra.webgl.WebGLInternalTexture);
                    this.pTexturePool.initialize(16);

                    this.pIndexBufferPool = new pool.ResourcePool(this, akra.webgl.WebGLIndexBuffer);
                    this.pIndexBufferPool.initialize(16);

                    this.pVertexBufferPool = new pool.ResourcePool(this, akra.webgl.WebGLVertexBuffer);
                    this.pVertexBufferPool.initialize(16);

                    this.pVideoBufferPool = new pool.ResourcePool(this, akra.webgl.WebGLVertexTexture);
                    this.pVideoBufferPool.initialize(16);

                    this.pTextureBufferPool = new pool.ResourcePool(this, akra.webgl.WebGLTextureBuffer);
                    this.pTextureBufferPool.initialize(16);

                    this.pShaderProgramPool = new pool.ResourcePool(this, akra.webgl.WebGLShaderProgram);
                    this.pShaderProgramPool.initialize(16);

                    this.pRenderBufferPool = new pool.ResourcePool(this, akra.webgl.WebGLInternalRenderBuffer);
                    this.pRenderBufferPool.initialize(16);

                    this.pDepthBufferPool = new pool.ResourcePool(this, akra.webgl.WebGLDepthBuffer);
                    this.pDepthBufferPool.initialize(16);
                } else {
                    akra.logger.critical("Render system not specified");
                }

                this.pEffectDataPool = new pool.ResourcePool(this, pool.resources.EffectData);
                this.pEffectDataPool.initialize(8);

                this.pComponentPool = new pool.ResourcePool(this, pool.resources.Component);
                this.pComponentPool.initialize(16);
            };

            ResourcePoolManager.prototype.registerDeviceResources = function () {
                //debug.log("Registering Video Device Resources\n");
                this.pTexturePool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */, 0 /* TEXTURE_RESOURCE */));
                this.pVertexBufferPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */, 2 /* VERTEXBUFFER_RESOURCE */));
                this.pIndexBufferPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */, 3 /* INDEXBUFFER_RESOURCE */));
                this.pEffectPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */, 4 /* EFFECT_RESOURCE */));
                this.pRenderMethodPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */, 5 /* RENDERMETHOD_RESOURCE */));
                this.pColladaPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */, 6 /* MODEL_RESOURCE */ | 4096 /* COLLADA */));
                this.pObjPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */, 6 /* MODEL_RESOURCE */ | 8192 /* OBJ */));
                this.pImagePool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */, 8 /* IMAGE_RESOURCE */));
                this.pSurfaceMaterialPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */, 9 /* SURFACEMATERIAL_RESOURCE */));
                this.pVideoBufferPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */, 1 /* VIDEOBUFFER_RESOURCE */));
                this.pShaderProgramPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */, 10 /* SHADERPROGRAM_RESOURCE */));
                this.pComponentPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */, 11 /* COMPONENT_RESOURCE */));
                this.pEffectDataPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */, 12 /* EFFECTDATA_RESOURCE */));
            };

            ResourcePoolManager.prototype.unregisterDeviceResources = function () {
                akra.debug.log("Unregistering Video Device Resources");

                this.pTexturePool.unregisterResourcePool();
                this.pVertexBufferPool.unregisterResourcePool();
                this.pIndexBufferPool.unregisterResourcePool();
                this.pEffectPool.unregisterResourcePool();
                this.pRenderMethodPool.unregisterResourcePool();
                this.pColladaPool.unregisterResourcePool();
                this.pObjPool.unregisterResourcePool();
                this.pImagePool.unregisterResourcePool();
                this.pSurfaceMaterialPool.unregisterResourcePool();
                this.pVideoBufferPool.unregisterResourcePool();
                this.pShaderProgramPool.unregisterResourcePool();
                this.pComponentPool.unregisterResourcePool();
            };

            ResourcePoolManager.pTypedResourseTotal = [
                13 /* TOTAL_VIDEO_RESOURCES */,
                0 /* TOTAL_AUDIO_RESOURCES */,
                0 /* TOTAL_GAME_RESOURCES */
            ];
            return ResourcePoolManager;
        })();
        pool.ResourcePoolManager = ResourcePoolManager;
    })(akra.pool || (akra.pool = {}));
    var pool = akra.pool;
})(akra || (akra = {}));
/// <reference path="../idl/IEngine.ts" />
/// <reference path="../idl/ISceneManager.ts" />
/// <reference path="../idl/IScene.ts" />
/// <reference path="../idl/IScene2d.ts" />
/// <reference path="../idl/IScene3d.ts" />
var akra;
(function (akra) {
    /// <reference path="Scene3d.ts" />
    (function (_scene) {
        var SceneManager = (function () {
            function SceneManager(pEngine) {
                this._pEngine = null;
                this._pSceneList = [];
                this._fUpdateTimeCount = 0.;
                this._fMillisecondsPerTick = 0.01666;
                this._pEngine = pEngine;
            }
            SceneManager.prototype.getEngine = function () {
                return this._pEngine;
            };

            SceneManager.prototype.update = function () {
                var isSceneUpdated = false;

                // add the real time elapsed to our
                // internal delay counter
                this._fUpdateTimeCount += this._pEngine.getElapsedTime();

                // is there an update ready to happen?
                var fUpdateTime = this._fUpdateTimeCount;

                while (this._fUpdateTimeCount > this._fMillisecondsPerTick) {
                    // update the scene
                    this.notifyUpdateScene();

                    // subtract the time interval
                    // emulated with each tick
                    this._fUpdateTimeCount -= this._fMillisecondsPerTick;
                }

                if (fUpdateTime !== this._fUpdateTimeCount) {
                    this.notifyPreUpdateScene();
                }
            };

            //  preUpdate(): void {
            //     this.notifyPreUpdateScene();
            // }
            SceneManager.prototype.notifyUpdateScene = function () {
                for (var i = 0; i < this._pSceneList.length; ++i) {
                    var pScene = this._pSceneList[i];

                    if (pScene.getType() !== 0 /* TYPE_3D */) {
                        continue;
                    }

                    pScene.recursiveUpdate();
                }
            };

            SceneManager.prototype.notifyPreUpdateScene = function () {
                for (var i = 0; i < this._pSceneList.length; ++i) {
                    var pScene = this._pSceneList[i];

                    if (pScene.getType() !== 0 /* TYPE_3D */) {
                        continue;
                    }

                    pScene.recursivePreUpdate();
                }
            };

            SceneManager.prototype.createScene3D = function (sName) {
                if (typeof sName === "undefined") { sName = null; }
                var pScene = new _scene.Scene3d(this, sName);
                this._pSceneList.push(pScene);

                return pScene;
            };

            SceneManager.prototype.createScene2D = function (sName) {
                if (typeof sName === "undefined") { sName = null; }
                return null;
            };

            SceneManager.prototype.createUI = function () {
                if (akra.config.UI) {
                    return akra["ui"].createUI(this);
                } else {
                    return null;
                }
            };

            SceneManager.prototype.getScene3D = function (scene) {
                if (akra.isNumber(arguments[0]) || !akra.isDef(arguments[0])) {
                    var iScene = arguments[0] || 0;
                    var pScene;

                    if (iScene === 0 && this._pSceneList.length === 0) {
                        this.createScene3D();
                        akra.debug.log("Default scene automatically created.");
                    }

                    pScene = this._pSceneList[iScene];

                    if (pScene && pScene.getType() === 0 /* TYPE_3D */) {
                        return pScene;
                    }

                    return null;
                } else if (akra.isString(arguments[0])) {
                    for (var i = 0; i < this._pSceneList.length; ++i) {
                        if (this._pSceneList[i].getName() === arguments[0]) {
                            return this._pSceneList[i];
                        }
                    }
                }

                return null;
            };

            SceneManager.prototype.getScene2D = function (scene) {
                if (akra.isNumber(arguments[0]) || !akra.isDef(arguments[0])) {
                    var iScene = arguments[0] || 0;
                    var pScene = this._pSceneList[iScene];

                    if (pScene && pScene.getType() === 1 /* TYPE_2D */) {
                        return pScene;
                    }
                }

                return null;
            };

            SceneManager.prototype.getScene = function (IScene, eType) {
                return this._pSceneList[IScene] || null;
            };

            SceneManager.prototype.initialize = function () {
                //this.initText2Dlayer();
                return true;
            };

            SceneManager.prototype.destroy = function () {
            };
            return SceneManager;
        })();
        _scene.SceneManager = SceneManager;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
/// <reference path="IImgCodec.ts" />
/// <reference path="../idl/IColor.ts" />
/// <reference path="../idl/IDDSCodec.ts" />
/// <reference path="../idl/IImgCodec.ts" />
/// <reference path="../logger.ts" />
var akra;
(function (akra) {
    /// <reference path="Codec.ts" />
    /// <reference path="ImgCodec.ts" />
    /// <reference path="pixelUtil.ts" />
    /// <reference path="../pool/resources/Img.ts" />
    (function (pixelUtil) {
        /** @const */
        var DDS_MAGIC = 0x20534444;

        //  DDS_header.dwFlags
        /** @const */
        var DDSD_CAPS = 0x00000001;

        /** @const */
        var DDSD_HEIGHT = 0x00000002;

        /** @const */
        var DDSD_WIDTH = 0x00000004;

        /** @const */
        var DDSD_PITCH = 0x00000008;

        /** @const */
        var DDSD_PIXELFORMAT = 0x00001000;

        /** @const */
        var DDSD_MIPMAPCOUNT = 0x00020000;

        /** @const */
        var DDSD_LINEARSIZE = 0x00080000;

        /** @const */
        var DDSD_DEPTH = 0x00800000;

        //  DDS_header.ddspf.dwFlags
        /** @const */
        var DDPF_ALPHAPIXELS = 0x00000001;

        /** @const */
        var DDPF_ALPHA = 0x00000002;

        /** @const */
        var DDPF_FOURCC = 0x00000004;

        /** @const */
        var DDPF_PALETTEINDEXED4 = 0x00000008;

        /** @const */
        var DDPF_PALETTEINDEXEDTO8 = 0x00000010;

        /** @const */
        var DDPF_PALETTEINDEXED8 = 0x00000020;

        /** @const */
        var DDPF_RGB = 0x00000040;

        /** @const */
        var DDPF_COMPRESSED = 0x00000080;

        /** @const */
        var DDPF_RGBTOYUV = 0x00000100;

        /** @const */
        var DDPF_YUV = 0x00000200;

        /** @const */
        var DDPF_ZBUFFER = 0x00000400;

        /** @const */
        var DDPF_PALETTEINDEXED1 = 0x00000800;

        /** @const */
        var DDPF_PALETTEINDEXED2 = 0x00001000;

        /** @const */
        var DDPF_ZPIXELS = 0x00002000;

        /** @const */
        var DDPF_STENCILBUFFER = 0x00004000;

        /** @const */
        var DDPF_ALPHAPREMULT = 0x00008000;

        /** @const */
        var DDPF_LUMINANCE = 0x00020000;

        /** @const */
        var DDPF_BUMPLUMINANCE = 0x00040000;

        /** @const */
        var DDPF_BUMPDUDV = 0x00080000;

        //  DDS_header.dwCaps2
        /** @const */
        var DDSCAPS2_CUBEMAP = 0x200;

        /** @const */
        var DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;

        /** @const */
        var DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;

        /** @const */
        var DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;

        /** @const */
        var DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;

        /** @const */
        var DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;

        /** @const */
        var DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000;

        /** @const */
        var DDSCAPS2_VOLUME = 0x200000;

        //DDS_header10.dwMiscFlag
        /** @const */
        var RESOURCE_MISC_GENERATE_MIPS = 0x1;

        /** @const */
        var RESOURCE_MISC_SHARED = 0x2;

        /** @const */
        var RESOURCE_MISC_TEXTURECUBE = 0x4;

        /** @const */
        var RESOURCE_MISC_DRAWINDIRECT_ARGS = 0x10;

        /** @const */
        var RESOURCE_MISC_BUFFER_ALLOW_RAW_VIEWS = 0x20;

        /** @const */
        var RESOURCE_MISC_BUFFER_STRUCTURED = 0x40;

        /** @const */
        var RESOURCE_MISC_RESOURCE_CLAMP = 0x80;

        /** @const */
        var RESOURCE_MISC_SHARED_KEYEDMUTEX = 0x100;

        /** @const */
        var RESOURCE_MISC_GDI_COMPATIBLE = 0x200;

        /** @const */
        var RESOURCE_MISC_SHARED_NTHANDLE = 0x800;

        /** @const */
        var RESOURCE_MISC_RESTRICTED_CONTENT = 0x1000;

        /** @const */
        var RESOURCE_MISC_RESTRICT_SHARED_RESOURCE = 0x2000;

        /** @const */
        var RESOURCE_MISC_RESTRICT_SHARED_RESOURCE_DRIVER = 0x4000;

        /** @const */
        var DDS_FOURCC = DDPF_FOURCC;

        /** @const */
        var DDS_RGB = DDPF_RGB;

        /** @const */
        var DDS_RGBA = DDPF_RGB | DDPF_ALPHAPIXELS;

        //  DD_Sheader.ddspf.dwFourCC
        /** @const */
        var D3DFMT_DX10 = 0x30315844;

        /** @const */
        var D3DFMT_DXT1 = 0x31545844;

        /** @const */
        var D3DFMT_DXT2 = 0x32545844;

        /** @const */
        var D3DFMT_DXT3 = 0x33545844;

        /** @const */
        var D3DFMT_DXT4 = 0x34545844;

        /** @const */
        var D3DFMT_DXT5 = 0x35545844;

        /** @const */
        var D3DFMT_R8G8_B8G8 = 0x47424752;

        /** @const */
        var D3DFMT_G8R8_G8B8 = 0x42475247;

        /** @const */
        var D3DFMT_A16B16G16R16 = 0x00000024;

        /** @const */
        var D3DFMT_Q16W16V16U16 = 0x0000006E;

        /** @const */
        var D3DFMT_R16F = 0x0000006F;

        /** @const */
        var D3DFMT_G16R16F = 0x00000070;

        /** @const */
        var D3DFMT_A16B16G16R16F = 0x00000071;

        /** @const */
        var D3DFMT_R32F = 0x00000072;

        /** @const */
        var D3DFMT_G32R32F = 0x00000073;

        /** @const */
        var D3DFMT_A32B32G32R32F = 0x00000074;

        /** @const */
        var D3DFMT_UYVY = 0x59565955;

        /** @const */
        var D3DFMT_YUY2 = 0x32595559;

        /** @const */
        var D3DFMT_CxV8U8 = 0x00000075;

        var DDSCodec = (function (_super) {
            __extends(DDSCodec, _super);
            function DDSCodec() {
                _super.apply(this, arguments);
                this._sType = "dds";
            }
            DDSCodec.prototype.magicNumberToFileExt = function (pMagicNumber) {
                var dwMagic4 = (new Uint32Array(pMagicNumber.buffer, 0, 1))[0];
                if (DDS_MAGIC == dwMagic4) {
                    return "dds";
                }

                return null;
            };

            /// Static method to startup and register the DDS codec
            DDSCodec.startup = function () {
                if (!akra.isDefAndNotNull(this._pInstance)) {
                    this._pInstance = new DDSCodec();
                    pixelUtil.Codec.registerCodec(this._pInstance);
                    akra.debug.log("DDS coded registred.");
                }
            };

            /// Static method to shutdown and unregister the DDS codec
            DDSCodec.shutdown = function () {
                if (akra.isDef(this._pInstance)) {
                    pixelUtil.Codec.unRegisterCodec(this._pInstance);
                    this._pInstance = undefined;
                }
            };

            DDSCodec.prototype.getType = function () {
                return this._sType;
            };

            DDSCodec.prototype.decode = function (pData, pImgData) {
                var iOffset = 0;
                var dwMagic4 = (new Uint32Array(pData.buffer, pData.byteOffset, 1))[0];

                if (dwMagic4 !== DDS_MAGIC) {
                    akra.logger.critical("This is not a DDS file! DDSCodec.decode");
                }

                //Считываем dds header
                /*typedef struct {
                DWORD		   dwSize;
                DWORD		   dwFlags;
                DWORD		   dwHeight;
                DWORD		   dwWidth;
                DWORD		   dwPitchOrLinearSize;
                DWORD		   dwDepth;
                DWORD		   dwMipMapCount;
                DWORD		   dwReserved1[11];
                DDS_PIXELFORMAT ddspf;
                DWORD		   dwCaps;
                DWORD		   dwCaps2;
                DWORD		   dwCaps3;
                DWORD		   dwCaps4;
                DWORD		   dwReserved2;
                } DDS_HEADER;*/
                var pDDSHeader = new Uint32Array(pData.buffer, pData.byteOffset + 4, 31);

                var pHeader = {};

                pHeader.dwSize = pDDSHeader[0];
                pHeader.dwFlags = pDDSHeader[1];
                pHeader.dwHeight = pDDSHeader[2];
                pHeader.dwWidth = pDDSHeader[3];
                pHeader.dwPitchOrLinearSize = pDDSHeader[4];
                pHeader.dwDepth = pDDSHeader[5];
                pHeader.dwMipMapCount = pDDSHeader[6];
                pHeader.dwReserved1 = [];
                pHeader.dwReserved1[0] = pDDSHeader[7];
                pHeader.dwReserved1[1] = pDDSHeader[8];
                pHeader.dwReserved1[2] = pDDSHeader[9];
                pHeader.dwReserved1[3] = pDDSHeader[10];
                pHeader.dwReserved1[4] = pDDSHeader[11];
                pHeader.dwReserved1[5] = pDDSHeader[12];
                pHeader.dwReserved1[6] = pDDSHeader[13];
                pHeader.dwReserved1[7] = pDDSHeader[14];
                pHeader.dwReserved1[8] = pDDSHeader[15];
                pHeader.dwReserved1[9] = pDDSHeader[16];
                pHeader.dwReserved1[10] = pDDSHeader[17];

                /*struct DDS_PIXELFORMAT {
                DWORD dwSize;
                DWORD dwFlags;
                DWORD dwFourCC;
                DWORD dwRGBBitCount;
                DWORD dwRBitMask;
                DWORD dwGBitMask;
                DWORD dwBBitMask;
                DWORD dwABitMask;
                };*/
                pHeader.ddspf = {};
                pHeader.ddspf.dwSize = pDDSHeader[18];
                pHeader.ddspf.dwFlags = pDDSHeader[19];
                pHeader.ddspf.dwFourCC = pDDSHeader[20];
                pHeader.ddspf.dwRGBBitCount = pDDSHeader[21];
                pHeader.ddspf.dwRBitMask = pDDSHeader[22];
                pHeader.ddspf.dwGBitMask = pDDSHeader[23];
                pHeader.ddspf.dwBBitMask = pDDSHeader[24];
                pHeader.ddspf.dwABitMask = pDDSHeader[25];
                pHeader.dwCaps = pDDSHeader[26];
                pHeader.dwCaps2 = pDDSHeader[27];
                pHeader.dwCaps3 = pDDSHeader[28];
                pHeader.dwCaps4 = pDDSHeader[29];
                pHeader.dwReserved2 = pDDSHeader[30];
                iOffset += 128;
                if (pHeader.dwSize != 124) {
                    akra.logger.error("Размер заголовка DDS всегда должэен равняться 124");
                }
                if (pHeader.ddspf.dwSize != 32) {
                    akra.logger.error("Размер DDS_PIXELFORMAT всегда должен равняться 32");
                }
                if (!(pHeader.dwFlags & DDSD_CAPS)) {
                    akra.logger.error("Флаг DDSD_CAPS в заголовке DDS всегда должен быть");
                }
                if (!(pHeader.dwFlags & DDSD_HEIGHT)) {
                    akra.logger.error("Флаг DDSD_HEIGHT в заголовке DDS всегда должен быть");
                }
                if (!(pHeader.dwFlags & DDSD_WIDTH)) {
                    akra.logger.error("Флаг DDSD_WIDTH в заголовке DDS всегда должен быть");
                }
                if (!(pHeader.dwFlags & DDSD_PIXELFORMAT)) {
                    akra.logger.error("Флаг DDSD_PIXELFORMAT в заголовке DDS всегда должен быть");
                }

                pImgData.setWidth(pHeader.dwWidth);
                pImgData.setHeight(pHeader.dwHeight);
                pImgData.setDepth(1);
                var nFace = 1;

                pImgData.setFlags(0);

                if (pHeader.dwCaps2 & DDSCAPS2_CUBEMAP) {
                    pImgData.setFlags(pImgData.getFlags() | 2 /* CUBEMAP */);
                    nFace = 0;
                    if (pHeader.dwCaps2 & DDSCAPS2_CUBEMAP_POSITIVEX) {
                        nFace++;
                        pImgData.setCubeFlags(pImgData.getCubeFlags() | 1 /* POSITIVE_X */);
                    }
                    if (pHeader.dwCaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) {
                        nFace++;
                        pImgData.setCubeFlags(pImgData.getCubeFlags() | 2 /* NEGATIVE_X */);
                    }
                    if (pHeader.dwCaps2 & DDSCAPS2_CUBEMAP_POSITIVEY) {
                        nFace++;
                        pImgData.setCubeFlags(pImgData.getCubeFlags() | 4 /* POSITIVE_Y */);
                    }
                    if (pHeader.dwCaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) {
                        nFace++;
                        pImgData.setCubeFlags(pImgData.getCubeFlags() | 8 /* NEGATIVE_Y */);
                    }
                    if (pHeader.dwCaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) {
                        nFace++;
                        pImgData.setCubeFlags(pImgData.getCubeFlags() | 16 /* POSITIVE_Z */);
                    }
                    if (pHeader.dwCaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ) {
                        nFace++;
                        pImgData.setCubeFlags(pImgData.getCubeFlags() | 32 /* NEGATIVE_Z */);
                    }

                    if (nFace == 0) {
                        akra.logger.warn("Выставлен фдлаг с кубической текстурой, а самих текстур нету");
                    }
                }

                if (pHeader.dwCaps2 & DDSCAPS2_VOLUME) {
                    pImgData.setFlags(pImgData.getFlags() | 4 /* TEXTURE_3D */);
                    pImgData.setDepth(pHeader.dwDepth);
                }

                var eSourceFormat = 0 /* UNKNOWN */;

                if (pHeader.ddspf.dwFlags & DDPF_FOURCC) {
                    if (pHeader.ddspf.dwFourCC == D3DFMT_DXT1) {
                        eSourceFormat = 17 /* DXT1 */;
                    } else if (pHeader.ddspf.dwFourCC == D3DFMT_DXT2) {
                        eSourceFormat = 17 /* DXT1 */;
                    } else if (pHeader.ddspf.dwFourCC == D3DFMT_DXT3) {
                        eSourceFormat = 19 /* DXT3 */;
                    } else if (pHeader.ddspf.dwFourCC == D3DFMT_DXT4) {
                        eSourceFormat = 20 /* DXT4 */;
                    } else if (pHeader.ddspf.dwFourCC == D3DFMT_DXT5) {
                        eSourceFormat = 21 /* DXT5 */;
                    } else if (pHeader.ddspf.dwFourCC == D3DFMT_DX10) {
                        var pDDS10Header = new Uint32Array(pData.buffer, pData.byteOffset + 128, 5);
                        var header10 = {};
                        header10.dxgiFormat = pDDS10Header[0];
                        header10.resourceDimension = pDDS10Header[1];
                        header10.miscFlag = pDDS10Header[2];
                        header10.arraySize = pDDS10Header[3];
                        header10.reserved = pDDS10Header[4];

                        akra.logger.critical("Формат D3DFMT_DX10 не поддерживается");

                        /*console.log("dxgiFormat",header10.dxgiFormat);
                        console.log("resourceDimension",header10.resourceDimension);
                        nCubeMap=1;
                        if(header10.miscFlag&RESOURCE_MISC_TEXTURECUBE)
                        {
                        nCubeMap=header10.arraySize;
                        }
                        
                        if(nCubeMap!=6)
                        {
                        warning("Количество частей кубической текстуру не равно 6",nCubeMap);
                        }*/
                        iOffset += 20;
                    } else if (pHeader.ddspf.dwFourCC == D3DFMT_R16F) {
                        eSourceFormat = 32 /* FLOAT16_R */;
                    } else if (pHeader.ddspf.dwFourCC == D3DFMT_G16R16F) {
                        eSourceFormat = 35 /* FLOAT16_GR */;
                    } else if (pHeader.ddspf.dwFourCC == D3DFMT_A16B16G16R16F) {
                        eSourceFormat = 23 /* FLOAT16_RGBA */;
                    } else if (pHeader.ddspf.dwFourCC == D3DFMT_R32F) {
                        eSourceFormat = 33 /* FLOAT32_R */;
                    } else if (pHeader.ddspf.dwFourCC == D3DFMT_G32R32F) {
                        eSourceFormat = 36 /* FLOAT32_GR */;
                    } else if (pHeader.ddspf.dwFourCC == D3DFMT_A32B32G32R32F) {
                        eSourceFormat = 25 /* FLOAT32_RGBA */;
                    } else {
                        akra.logger.critical("Флаг DDPF_FOURCC стоит, а подходящего dwFourCC нет");
                    }
                } else {
                    var iAMask = pHeader.ddspf.dwFlags & DDPF_ALPHAPIXELS ? pHeader.ddspf.dwABitMask : 0;
                    var ePF;
                    for (ePF = 0 /* UNKNOWN */ + 1; ePF < 48 /* TOTAL */; ePF++) {
                        if ((!!(pHeader.ddspf.dwFlags & DDPF_LUMINANCE)) != pixelUtil.isLuminance(ePF)) {
                            continue;
                        }
                        if ((!!(pHeader.ddspf.dwFlags & DDPF_ALPHAPIXELS)) != pixelUtil.hasAlpha(ePF)) {
                            continue;
                        }

                        if (pixelUtil.getNumElemBits(ePF) == pHeader.ddspf.dwRGBBitCount) {
                            var pTestMasks = pixelUtil.getBitMasks(ePF);
                            var pTestBits = pixelUtil.getBitDepths(ePF);

                            if (pTestMasks[0] == pHeader.ddspf.dwRBitMask && pTestMasks[1] == pHeader.ddspf.dwGBitMask && pTestMasks[2] == pHeader.ddspf.dwBBitMask && (pTestMasks[3] == iAMask || (iAMask == 0 && pTestBits[3] == 0))) {
                                break;
                            }
                        }
                    }

                    if (ePF == 48 /* TOTAL */) {
                        akra.logger.critical("Cannot determine pixel format. DDSCodec.decode");
                    } else {
                        eSourceFormat = ePF;
                    }
                }

                /*if (pixelUtil.isCompressed(eSourceFormat))
                {
                pImgData.flags |= EImageFlags.COMPRESSED;
                if (!(pHeader.dwFlags & DDSD_LINEARSIZE)) {
                logger.critical("У сжатой текстуры не выставлен флаг DDS_HEADER_FLAGS_LINEARSIZE в заголовке");
                }
                }
                else
                {
                if (pHeader.dwFlags & DDSD_LINEARSIZE) {
                logger.critical("У несжатой текстуры выставлен флаг DDS_HEADER_FLAGS_LINEARSIZE в заголовке");
                }
                }*/
                pImgData.setFormat(eSourceFormat);

                if (pHeader.dwFlags & DDSD_MIPMAPCOUNT) {
                    pImgData.setNumMipMaps(pHeader.dwMipMapCount - 1);
                    if (pImgData.getNumMipMaps() != akra.pool.resources.Img.getMaxMipmaps(pImgData.getWidth(), pImgData.getHeight(), pImgData.getDepth(), pImgData.getFormat())) {
                        akra.logger.warn("Number of mipmaps are not to degrease image size to 1x1 " + pHeader.dwMipMapCount + "," + pHeader.dwWidth + "x" + pHeader.dwHeight + ")");
                    }
                } else {
                    pImgData.setNumMipMaps(0);
                }

                var pOutput = new Uint8Array(pImgData.getSize());
                var iOutputOffset = 0;

                for (var i = 0; i < nFace; i++) {
                    var iWidth = pImgData.getWidth();
                    var iHeight = pImgData.getHeight();
                    var iDepth = pImgData.getDepth();

                    for (var iMip = 0; iMip <= pImgData.getNumMipMaps(); iMip++) {
                        if (pixelUtil.isCompressed(pImgData.getFormat())) {
                            var iDXTSize = pixelUtil.getMemorySize(iWidth, iHeight, iDepth, pImgData.getFormat());
                            for (var a = 0; a < iDXTSize; a++) {
                                pOutput[a + iOutputOffset] = pData[iOffset + a];
                            }
                            iOffset += iDXTSize;
                            iOutputOffset += iDXTSize;
                        } else {
                            var iDstPitch = iWidth * pixelUtil.getNumElemBytes(pImgData.getFormat());
                            var iSrcPitch = 0;
                            if (pHeader.dwFlags & DDSD_PITCH) {
                                iSrcPitch = pHeader.dwPitchOrLinearSize / Math.max(1, iMip * 2);
                            } else {
                                // assume same as final pitch
                                iSrcPitch = iDstPitch;
                            }
                            if (iSrcPitch < iDstPitch) {
                                akra.logger.warn("Странный размер питча у картинки");
                            }

                            for (var z = 0; z < pImgData.getDepth(); z++) {
                                for (var y = 0; y < pImgData.getHeight(); y++) {
                                    for (var a = 0; a < iDstPitch; a++) {
                                        pOutput[a + iOutputOffset] = pData[iOffset + a];
                                    }
                                    iOutputOffset = iOutputOffset + iDstPitch;
                                    iOffset = iOffset + iSrcPitch;
                                }
                            }
                        }
                        if (iWidth != 1) {
                            iWidth = Math.floor(iWidth / 2);
                        }
                        if (iHeight != 1) {
                            iHeight = Math.floor(iHeight / 2);
                        }
                        if (iDepth != 1) {
                            iDepth = Math.floor(iDepth / 2);
                        }
                    }
                }
                return pOutput;
            };
            DDSCodec._pInstance = null;
            return DDSCodec;
        })(pixelUtil.ImgCodec);
        pixelUtil.DDSCodec = DDSCodec;
    })(akra.pixelUtil || (akra.pixelUtil = {}));
    var pixelUtil = akra.pixelUtil;
})(akra || (akra = {}));
/// <reference path="../idl/IBufferMap.ts" />
/// <reference path="../idl/IVertexBuffer.ts" />
/// <reference path="../idl/IEngine.ts" />
/// <reference path="../idl/IVertexDeclaration.ts" />
var akra;
(function (akra) {
    /// <reference path="../util/ReferenceCounter.ts" />
    /// <reference path="IndexData.ts" />
    /// <reference path="Usage.ts" />
    /// <reference path="../pool/resources/VertexBuffer.ts" />
    /// <reference path="../events.ts" />
    /// <reference path="../debug.ts" />
    /// <reference path="../guid.ts" />
    /// <reference path="../config/config.ts" />
    //#ifdef WEBGL
    //	#include "webgl/webgl.ts"
    //	#include "webgl/WebGLRenderer.ts"
    //#endif
    (function (_data) {
        var DeclUsages = akra.data.Usages;

        var BufferMap = (function (_super) {
            __extends(BufferMap, _super);
            function BufferMap(pEngine) {
                var _this = this;
                _super.call(this);
                this.guid = akra.guid();
                this._pFlows = null;
                this._pMappers = null;
                this._pIndex = null;
                this._nLength = 0;
                this._pCompleteFlows = null;
                this._nCompleteFlows = 0;
                this._nCompleteVideoBuffers = 0;
                this._pCompleteVideoBuffers = null;
                this._nUsedFlows = 0;
                this._pEngine = null;
                this._nStartIndex = 0;
                this._pBuffersCompatibleMap = null;
                this._pSemanticsMap = null;
                this._nUpdates = 0;
                this.setupSignals();

                this._pEngine = pEngine;
                this.reset();

                this.modified.connect(function () {
                    _this._nUpdates++;
                });
            }
            BufferMap.prototype.setupSignals = function () {
                this.modified = this.modified || new akra.Signal(this);
            };

            BufferMap.prototype.getPrimType = function () {
                return this._pIndex ? this._pIndex.getPrimitiveType() : this._ePrimitiveType;
            };

            BufferMap.prototype.setPrimType = function (eType) {
                this._ePrimitiveType = eType;
                this.modified.emit();
            };

            BufferMap.prototype.getIndex = function () {
                return this._pIndex;
            };

            BufferMap.prototype.setIndex = function (pIndexData) {
                if (this._pIndex === pIndexData) {
                    return;
                }

                this._pIndex = pIndexData;
                this.update();
            };

            BufferMap.prototype.getLength = function () {
                return (this._pIndex ? this._pIndex.getLength() : this._nLength);
            };

            BufferMap.prototype.setLength = function (nLength) {
                this._nLength = Math.min(this._nLength, nLength);
                this.modified.emit();
            };

            BufferMap.prototype._setLengthForce = function (nLength) {
                this._nLength = nLength;
                this.modified.emit();
            };

            BufferMap.prototype.getTotalUpdates = function () {
                return this._nUpdates;
            };

            BufferMap.prototype.getPrimCount = function () {
                return _data.IndexData.getPrimitiveCount(this.getPrimType(), this.getLength());
            };

            BufferMap.prototype.getLimit = function () {
                return this._pFlows.length;
            };

            BufferMap.prototype.getStartIndex = function () {
                return this._nStartIndex;
            };

            BufferMap.prototype.getSize = function () {
                return this._nCompleteFlows;
            };

            BufferMap.prototype.getFlows = function () {
                return this._pCompleteFlows;
            };

            BufferMap.prototype.getMappers = function () {
                return this._pMappers;
            };

            BufferMap.prototype.getOffset = function () {
                return (this._pIndex ? this._pIndex.getByteOffset() : 0);
            };

            BufferMap.prototype._draw = function () {
                // this._pEngine.getComposer().applyBufferMap(this);
                // this._pEngine.getRenderer().getActiveProgram().applyBufferMap(this);
                akra.isNull(this._pIndex) ? this.drawArrays() : this.drawElements();
            };

            //TODO: move to WebGL namespace
            BufferMap.prototype.drawArrays = function () {
                if (akra.config.WEBGL) {
                    this._pEngine.getRenderer().getWebGLContext().drawArrays(akra.webgl.getWebGLPrimitiveType(this._ePrimitiveType), this._nStartIndex, this._nLength);
                } else {
                    akra.logger.critical("BufferMap::drawElements() unsupported for unknown API.");
                }
            };

            //TODO: move to WebGL namespace
            BufferMap.prototype.drawElements = function () {
                if (akra.config.WEBGL) {
                    this._pEngine.getRenderer().getWebGLContext().drawElements(akra.webgl.getWebGLPrimitiveType(this._pIndex.getPrimitiveType()), this._pIndex.getLength(), akra.webgl.getWebglElementType(this._pIndex.getType()), this._pIndex.getByteOffset() / 4);
                    //FIXME: offset of drawElement() in Glintptr = long long = 32 byte???
                } else {
                    akra.logger.critical("BufferMap::drawElements() unsupported for unknown API.");
                }
            };

            BufferMap.prototype.getFlow = function (iFlow, bComplete) {
                if (typeof bComplete === "undefined") { bComplete = true; }
                if (akra.isString(arguments[0])) {
                    var nTotal;
                    var pFlows;

                    if (bComplete) {
                        pFlows = this._pCompleteFlows;
                        nTotal = this._nCompleteFlows;
                    } else {
                        pFlows = this._pFlows;
                        nTotal = this._pFlows.length;
                    }

                    for (var i = 0; i < nTotal; ++i) {
                        if (!pFlows[i].data) {
                            continue;
                        }
                        if (pFlows[i].data.hasSemantics(arguments[0])) {
                            return pFlows[i];
                        }
                    }

                    return null;
                }

                if (bComplete) {
                    for (var i = 0, pFlows = this._pCompleteFlows; i < this._nCompleteFlows; ++i) {
                        if (pFlows[i].flow == iFlow) {
                            return pFlows[i];
                        }
                    }

                    return null;
                }

                return this._pFlows[iFlow];
            };

            //TODO: It is temp method for test deoptimozation of code
            BufferMap.prototype.getFlowBySemantic = function (sSemantics) {
                for (var i = 0; i < this._nCompleteFlows; ++i) {
                    if (this._pCompleteFlows[i].data.hasSemantics(sSemantics)) {
                        return this._pCompleteFlows[i];
                    }
                }

                return null;
            };

            BufferMap.prototype.reset = function (nFlowLimit) {
                if (typeof nFlowLimit === "undefined") { nFlowLimit = 16; }
                this._pIndex = null;
                this._ePrimitiveType = 4 /* TRIANGLELIST */;

                //#ifdef WEBGL
                //			nFlowLimit = Math.min(16/*webgl.maxVertexTextureImageUnits*/, webgl.maxVertexAttributes);
                //#endif
                this._pMappers = [];
                this._pFlows = new Array(nFlowLimit);
                for (var i = 0; i < nFlowLimit; i++) {
                    this._pFlows[i] = {
                        flow: i,
                        data: null,
                        type: 0 /* UNMAPPABLE */,
                        mapper: null
                    };
                }

                this._nLength = akra.MAX_INT32;
                this._pCompleteFlows = new Array(nFlowLimit);
                this._nCompleteFlows = 0;
                this._nStartIndex = akra.MAX_INT32;
                this._pBuffersCompatibleMap = {};

                this._pCompleteVideoBuffers = new Array(nFlowLimit);
                this._nCompleteVideoBuffers = 0;
                this._nUsedFlows = 0;

                this._pSemanticsMap = {};
                this._nUpdates = 0;

                this.modified.emit();
            };

            BufferMap.prototype.flow = function (iFlow, pData) {
                var pFlow = null;
                var pVertexData = null;
                var isOk;

                if (arguments.length < 2) {
                    pVertexData = arguments[0];
                    iFlow = (this._nUsedFlows++);
                } else {
                    iFlow = arguments[0];
                    pVertexData = arguments[1];
                }

                pFlow = this._pFlows[iFlow];

                akra.debug.assert(iFlow < this.getLimit(), 'Invalid strem. Maximum allowable number of stream ' + this.getLimit() + '.');

                if (!pVertexData || pFlow.data === pVertexData) {
                    akra.debug.warn("BufferMap::flow(", iFlow, pVertexData, ") failed.", akra.isNull(pVertexData) ? "vertex data is null" : "flow.data alreay has same vertex data");
                    return -1;
                }

                if (akra.pool.resources.VertexBuffer.isVBO(pVertexData.getBuffer())) {
                    pFlow.type = 0 /* UNMAPPABLE */;
                    this.setLength(pVertexData.getLength());

                    //this.startIndex = pVertexData.getStartIndex();
                    isOk = this.checkData(pVertexData);
                    akra.debug.assert(isOk, "You can use several unmappable data flows from one buffer.");
                    this.trackData(pVertexData);
                } else {
                    pFlow.type = 1 /* MAPPABLE */;
                }

                if (akra.isDefAndNotNull(pFlow.data)) {
                    this.untrackData(pVertexData);
                }

                pFlow.data = pVertexData;

                return this.update() ? iFlow : -1;
            };

            BufferMap.prototype.clearLinks = function () {
                for (var sSemantics in this._pSemanticsMap) {
                    this._pSemanticsMap[sSemantics] = null;
                }
            };

            BufferMap.prototype.linkFlow = function (pFlow) {
                var pDecl = pFlow.data.getVertexDeclaration();

                for (var i = 0; i < pDecl.getLength(); ++i) {
                    var pElement = pDecl.element(i);
                    var sSemantics = pElement.semantics;

                    if (pElement.isEnd()) {
                        continue;
                    }

                    var isSemanticsExists = akra.isDefAndNotNull(this._pSemanticsMap[sSemantics]);

                    akra.debug.assert(!isSemanticsExists, "overwrited semantics: " + sSemantics);

                    if (!isSemanticsExists) {
                        this._pSemanticsMap[sSemantics] = pFlow;
                    }
                }

                if (pFlow.type === 1 /* MAPPABLE */) {
                    var sSemantics = pFlow.mapper.semantics;
                    var isSemanticsExists = akra.isDefAndNotNull(this._pSemanticsMap[sSemantics]);

                    akra.debug.assert(!isSemanticsExists, "overwrited semantics(MAPPER!): " + sSemantics);

                    if (!isSemanticsExists) {
                        this._pSemanticsMap[sSemantics] = pFlow;
                    }
                }
            };

            BufferMap.prototype.checkData = function (pData) {
                var pEtalon = this._pBuffersCompatibleMap[pData.getBufferHandle()];

                if (!pEtalon || pEtalon.getByteOffset() === pData.getByteOffset()) {
                    return true;
                }

                return false;
            };

            BufferMap.prototype.findMapping = function (pMap, eSemantics, iAddition) {
                var isOk = this.checkData(pMap);
                akra.debug.assert(isOk, 'You can use several different maps from one buffer.');

                for (var i = 0, pMappers = this._pMappers, pExistsMap; i < pMappers.length; i++) {
                    pExistsMap = pMappers[i].data;
                    if (pExistsMap === pMap) {
                        //если уже заданные маппинг менял свой стартовый индекс(например при расширении)
                        //то необходимо сменить стартовый индекс на новый
                        if (pMappers[i].semantics === eSemantics && pMappers[i].addition == iAddition) {
                            return pMappers[i];
                        }
                    } else {
                        akra.debug.assert(pExistsMap.getStartIndex() === pMap.getStartIndex(), 'You can not use maps with different indexing');
                    }
                }
                return null;
            };

            BufferMap.prototype.mapping = function (iFlow, pMap, eSemantics, iAddition) {
                if (typeof iAddition === "undefined") { iAddition = 0; }
                var pMapper = this.findMapping(pMap, eSemantics, iAddition);
                var pFlow = this._pFlows[iFlow];

                akra.debug.assert(akra.isDefAndNotNull(pFlow.data) && (pFlow.type === 1 /* MAPPABLE */), 'Cannot mapping empty/unmappable flow.');
                akra.debug.assert(akra.isDef(pMap), 'Passed empty mapper.');

                if (!eSemantics) {
                    eSemantics = pMap.getVertexDeclaration()[0].eUsage;
                } else if (pMap.hasSemantics(eSemantics) === false) {
                    akra.debug.error('Passed mapper does not have semantics: ' + eSemantics + '.');
                    return false;
                }

                if (pMapper) {
                    if (pFlow.mapper === pMapper) {
                        return pMapper.semantics === eSemantics && pMapper.addition === iAddition ? true : false;
                    }
                } else {
                    pMapper = {
                        data: pMap,
                        semantics: eSemantics,
                        addition: iAddition
                    };

                    this._pMappers.push(pMapper);
                    this.setLength(pMap.getLength());
                    this.trackData(pMap);
                }

                pFlow.mapper = pMapper;

                return this.update();
            };

            BufferMap.prototype.trackData = function (pData) {
                var iHandle = pData.getBufferHandle();

                if (akra.isDefAndNotNull(this._pBuffersCompatibleMap[iHandle])) {
                    return;
                }

                //only one vertex data may be used in one veretex buffer
                //случаи, когда выделяются 2 vertex data'ы в одной области памяти не рассматриваются
                this._pBuffersCompatibleMap[iHandle] = pData;
                pData.declarationChanged.connect(this.modified);
            };

            BufferMap.prototype.untrackData = function (pData) {
                delete this._pBuffersCompatibleMap[pData.getBufferHandle()];

                pData.declarationChanged.disconnect(this.modified);
            };

            BufferMap.prototype.update = function () {
                var pFlows = this._pFlows;
                var pFlow;
                var pMapper;
                var isMappable = false;
                var pCompleteFlows = this._pCompleteFlows;
                var nCompleteFlows = 0;
                var pCompleteVideoBuffers = this._pCompleteVideoBuffers;
                var nCompleteVideoBuffers = 0;
                var nUsedFlows = 0;
                var pVideoBuffer;
                var isVideoBufferAdded = false;
                var nStartIndex = akra.MAX_INT32, nCurStartIndex;

                this.clearLinks();

                for (var i = 0; i < pFlows.length; i++) {
                    pFlow = pFlows[i];
                    pMapper = pFlow.mapper;
                    isMappable = (pFlow.type === 1 /* MAPPABLE */);

                    if (pFlow.data) {
                        nUsedFlows++;
                    }

                    if (pFlow.data === null || (isMappable && pMapper === null)) {
                        continue;
                    }

                    pCompleteFlows[nCompleteFlows++] = pFlow;
                    this.linkFlow(pFlow);

                    if (isMappable) {
                        nCurStartIndex = pMapper.data.getStartIndex();
                        pVideoBuffer = pFlow.data.getBuffer();
                        for (var j = 0; j < nCompleteVideoBuffers; j++) {
                            if (pCompleteVideoBuffers[j] === pVideoBuffer) {
                                isVideoBufferAdded = true;
                                break;
                            }
                        }
                        if (!isVideoBufferAdded) {
                            pCompleteVideoBuffers[nCompleteVideoBuffers++] = pVideoBuffer;
                        }
                    } else {
                        nCurStartIndex = pFlow.data.getStartIndex();
                    }

                    if (nStartIndex === akra.MAX_INT32) {
                        nStartIndex = nCurStartIndex;
                        continue;
                    }

                    akra.debug.assert(nStartIndex == nCurStartIndex, 'You can not use a maps or unmappable buffers having different starting index.');
                }

                this._nStartIndex = nStartIndex;
                this._nCompleteFlows = nCompleteFlows;
                this._nCompleteVideoBuffers = nCompleteVideoBuffers;
                this._nUsedFlows = nUsedFlows;

                this.modified.emit();

                return true;
            };

            BufferMap.prototype.findFlow = function (sSemantics) {
                return !akra.isDef(this._pSemanticsMap[sSemantics]) ? (this._pSemanticsMap[sSemantics] = null) : this._pSemanticsMap[sSemantics];
            };

            BufferMap.prototype.clone = function (bWithMapping) {
                if (typeof bWithMapping === "undefined") { bWithMapping = true; }
                var pMap = this._pEngine.createBufferMap();

                for (var i = 0, pFlows = this._pFlows; i < pFlows.length; ++i) {
                    if (pFlows[i].data === null) {
                        continue;
                    }

                    if (pMap.flow(pFlows[i].flow, pFlows[i].data) < 0) {
                        pMap = null;
                        akra.debug.log("BufferMap::clone() failed on", pFlows[i].flow, pFlows[i].data);
                        return null;
                    }

                    if (!bWithMapping) {
                        continue;
                    }

                    if (pFlows[i].mapper) {
                        pMap.mapping(pFlows[i].flow, pFlows[i].mapper.data, pFlows[i].mapper.semantics, pFlows[i].mapper.addition);
                    }
                }

                return pMap;
            };

            BufferMap.prototype.toString = function (bListAll) {
                if (typeof bListAll === "undefined") { bListAll = false; }
                if (akra.config.DEBUG) {
                    function _an(sValue, n, bBackward) {
                        sValue = String(sValue);
                        bBackward = bBackward || false;

                        if (sValue.length < n) {
                            for (var i = 0, l = sValue.length; i < n - l; ++i) {
                                if (!bBackward) {
                                    sValue += ' ';
                                } else {
                                    sValue = ' ' + sValue;
                                }
                            }
                        }

                        return sValue;
                    }

                    var s = '\n\n', t;
                    s += '      $1 Flows     : OFFSET / SIZE   |   BUFFER / OFFSET   :      Mapping  / Shift    : OFFSET |    Additional    \n';
                    s = s.replace("$1", bListAll ? "   Total" : "Complete");
                    t = '-------------------------:-----------------+---------------------:--------------------------:--------+------------------\n';

                    // = '#%1 [ %2 ]           :     %6 / %7     |       %3 / %4       :         %5       :        |                  \n';
                    // = '#%1 [ %2 ]           :     %6 / %7     |       %3 / %4       :         %5       :        |                  \n';
                    s += t;

                    var pFlows = bListAll ? this._pFlows : this._pCompleteFlows;
                    var nFlows = bListAll ? this._nUsedFlows : this._nCompleteFlows;
                    for (var i = 0; i < nFlows; ++i) {
                        var pFlow = pFlows[i];
                        var pMapper = pFlow.mapper;
                        var pVertexData = pFlow.data;
                        var pDecl = pVertexData.getVertexDeclaration();

                        //trace(pMapper); window['pMapper'] = pMapper;
                        s += '#' + _an(pFlow.flow, 2) + ' ' + _an('[ ' + (pDecl.element(0).usage !== DeclUsages.END ? pDecl.element(0).usage : '<end>') + ' ]', 20) + ' : ' + _an(pDecl.element(0).offset, 6, true) + ' / ' + _an(pDecl.element(0).size, 6) + ' | ' + _an(pVertexData.getBufferHandle(), 8, true) + ' / ' + _an(pVertexData.getByteOffset(), 8) + ' : ' + (pMapper ? _an(pMapper.semantics, 15, true) + ' / ' + _an(pMapper.addition, 7) + ': ' + _an(pMapper.data.getVertexDeclaration().findElement(pMapper.semantics).offset, 6) : _an('-----', 25) + ': ' + _an('-----', 6)) + ' |                  \n';

                        for (var j = 1; j < pDecl.getLength(); ++j) {
                            s += '    ' + _an('[ ' + (pDecl.element(j).usage !== DeclUsages.END ? pDecl.element(j).usage : '<end>') + ' ]', 20) + ' : ' + _an(pDecl.element(j).offset, 6, true) + ' / ' + _an(pDecl.element(j).size, 6) + ' |                     :                          :        |                  \n';
                        }
                        s += t;
                    }
                    s += '=================================================================\n';
                    s += '      PRIMITIVE TYPE : ' + '0x' + Number(this.getPrimType()).toString(16) + '\n';
                    s += '     PRIMITIVE COUNT : ' + this.getPrimCount() + '\n';
                    s += '         START INDEX : ' + this.getStartIndex() + '\n';
                    s += '              LENGTH : ' + this.getLength() + '\n';
                    s += '  USING INDEX BUFFER : ' + (this.getIndex() ? 'TRUE' : 'FALSE') + '\n';
                    s += '=================================================================\n';

                    return s + '\n\n';
                }

                return null;
            };
            return BufferMap;
        })(akra.util.ReferenceCounter);
        _data.BufferMap = BufferMap;

        function createBufferMap(pEngine) {
            return new BufferMap(pEngine);
        }
        _data.createBufferMap = createBufferMap;
    })(akra.data || (akra.data = {}));
    var data = akra.data;
})(akra || (akra = {}));
/// <reference path="../idl/ISkeleton.ts" />
/// <reference path="../idl/ISceneNode.ts" />
var akra;
(function (akra) {
    /// <reference path="../scene/Joint.ts" />
    (function (model) {
        var Skeleton = (function () {
            function Skeleton(sName) {
                if (typeof sName === "undefined") { sName = null; }
                this._pRootJoints = [];
                this._pJointMap = null;
                this._pNodeList = null;
                this._pMeshNode = null;
                this._sName = sName;
            }
            // private _iFlags: boolean = false;
            Skeleton.prototype.getTotalBones = function () {
                return Object.keys(this._pJointMap).length;
            };

            Skeleton.prototype.getTotalNodes = function () {
                return this._pNodeList.length;
            };

            Skeleton.prototype.getName = function () {
                return this._sName;
            };

            Skeleton.prototype.getRoot = function () {
                return this._pRootJoints[0] || null;
            };

            Skeleton.prototype.getRootJoint = function () {
                return this.getRootJoints()[0];
            };

            Skeleton.prototype.getRootJoints = function () {
                return this._pRootJoints;
            };

            Skeleton.prototype.getJointMap = function () {
                return this._pJointMap;
            };

            Skeleton.prototype.getNodeList = function () {
                return this._pNodeList;
            };

            Skeleton.prototype.addRootJoint = function (pJoint) {
                akra.debug.assert(pJoint instanceof akra.scene.Joint, 'node must be joint');

                var pRootJoints = this._pRootJoints;

                for (var i = 0; i < pRootJoints.length; i++) {
                    if (pJoint.childOf(pRootJoints[i])) {
                        return false;
                    } else if (pRootJoints[i].childOf(pJoint)) {
                        pRootJoints.splice(i, 1);
                    }
                }
                ;

                this._pRootJoints.push(pJoint);

                return this.update();
            };

            Skeleton.prototype.update = function () {
                var pRootJoints = this.getRootJoints();
                var pJointMap = this._pJointMap = {};
                var pNodeList = this._pNodeList = [];

                //var pNotificationJoints = this._pNotificationJoints = [];
                function findNodes(pNode) {
                    var sJoint = null;

                    if (!akra.isNull(pNode)) {
                        if (akra.scene.Joint.isJoint(pNode)) {
                            sJoint = pNode.getBoneName();
                        }

                        if (!akra.isNull(sJoint)) {
                            akra.debug.assert(!pJointMap[sJoint], 'joint with name<' + sJoint + '> already exists in skeleton <' + this._sName + '>');

                            pJointMap[sJoint] = pNode;
                        }

                        pNodeList.push(pNode);

                        findNodes(pNode.getSibling());
                        findNodes(pNode.getChild());
                    }
                }

                for (var i = 0; i < pRootJoints.length; i++) {
                    findNodes(pRootJoints[i]);
                }
                ;

                // for (var sJoint in pJointMap) {
                // 	var pJoint = pJointMap[sJoint];
                //    	if (pJoint.sibling() == null && pJoint.child() == null) {
                //    		pNotificationJoints.push(pJoint);
                //    	}
                //    };
                return true;
            };

            Skeleton.prototype.findJoint = function (sName) {
                return this._pJointMap[sName];
            };

            Skeleton.prototype.findJointByName = function (sName) {
                for (var s in this._pJointMap) {
                    if (this._pJointMap[s].getName() === sName) {
                        return this._pJointMap[s];
                    }
                }

                return null;
            };

            Skeleton.prototype.attachMesh = function (pMesh) {
                if (akra.isNull(this.getRoot())) {
                    return false;
                }

                for (var i = 0; i < pMesh.getLength(); ++i) {
                    akra.logger.assert(pMesh.getSubset(i).getSkin().setSkeleton(this), "Could not set skeleton to skin.");
                }

                if (this._pMeshNode == null) {
                    this._pMeshNode = this.getRoot().getScene().createModel();
                    this._pMeshNode.setInheritance(4 /* ALL */);
                    this._pMeshNode.attachToParent(this.getRoot());
                }

                this._pMeshNode.setName(this.getName() + "[mesh-container]");
                this._pMeshNode.setMesh(pMesh);

                return true;
            };

            Skeleton.prototype.detachMesh = function () {
                //TODO: write detach method.
            };
            return Skeleton;
        })();

        function createSkeleton(sName) {
            if (typeof sName === "undefined") { sName = null; }
            return new Skeleton(sName);
        }
        model.createSkeleton = createSkeleton;
    })(akra.model || (akra.model = {}));
    var model = akra.model;
})(akra || (akra = {}));
/// <reference path="../idl/3d-party/gamepad.d.ts" />
/// <reference path="../idl/IGamepadMap.ts" />
var akra;
(function (akra) {
    //export var TYPICAL_BUTTON_COUNT = 16;
    //export var TYPICAL_AXIS_COUNT = 4;
    /// <reference path="../logger.ts" />
    /// <reference path="../debug.ts" />
    /// <reference path="../info/info.ts" />
    /// <reference path="../util/ObjectArray.ts" />
    /// <reference path="../events.ts" />
    /// <reference path="../guid.ts" />
    (function (control) {
        var ObjectArray = akra.util.ObjectArray;

        navigator["getGamepads"] = (navigator["getGamepads"] || navigator["webkitGetGamepads"]);

        var GamepadMap = (function () {
            function GamepadMap() {
                this.guid = akra.guid();
                this._bTicking = false;
                this._pCollection = new ObjectArray();
                this._pPrevRawGamepadTypes = [null, null, null, null];
                this._pPrevTimestamps = [0, 0, 0, 0];
                this.setupSignals();
            }
            GamepadMap.prototype.setupSignals = function () {
                this.connected = this.connected || new akra.Signal(this);
                this.disconnected = this.disconnected || new akra.Signal(this);
                this.updated = this.updated || new akra.Signal(this);
            };

            GamepadMap.prototype.init = function () {
                var _this = this;
                if (!akra.info.api.getGamepad()) {
                    akra.logger.warn("Gamepad API is unsupported.");
                    return false;
                }

                var pCollection = this._pCollection;

                window.addEventListener('MozGamepadConnected', function (e) {
                    pCollection.push(e.gamepad);
                    _this.connected.emit(e.gamepad);
                    _this.startPolling();
                }, false);

                window.addEventListener('MozGamepadDisconnected', function (e) {
                    for (var i = 0; i < pCollection.getLength(); ++i) {
                        if (pCollection.value(i).index == e.gamepad.index) {
                            _this.disconnected.emit(pCollection.takeAt(i));
                            break;
                        }
                    }

                    if (pCollection.getLength() === 0) {
                        _this.stopPolling();
                    }
                }, false);

                if (!!navigator["gamepads"] || !!navigator["getGamepads"]) {
                    this.startPolling();
                    return true;
                }

                return false;
            };

            GamepadMap.prototype.isActive = function () {
                return this._bTicking;
            };

            GamepadMap.prototype.find = function (id) {
                var sID = null;
                var i = 0;

                if (arguments.length) {
                    if (akra.isString(arguments[0])) {
                        sID = arguments[0];
                    } else if (akra.isInt(arguments[0])) {
                        i = arguments[0];
                    }
                }

                if (!akra.isNull(sID)) {
                    for (i = 0; i < this._pCollection.getLength(); ++i) {
                        if (this._pCollection.value(i).id == sID) {
                            return this._pCollection.value(i);
                        }
                    }
                }

                return this._pCollection.value(i);
            };

            GamepadMap.prototype.startPolling = function () {
                if (!this._bTicking) {
                    this._bTicking = true;
                    this.update();
                }
            };

            GamepadMap.prototype.stopPolling = function () {
                this._bTicking = false;
            };

            GamepadMap.prototype.update = function () {
                this.pollStatus();
            };

            GamepadMap.prototype.pollStatus = function () {
                if (!this._bTicking) {
                    return;
                }

                this.pollGamepads();

                for (var i = 0; i < this._pCollection.getLength(); ++i) {
                    var pGamepad = this._pCollection.value(i);

                    if (pGamepad.timestamp && (pGamepad.timestamp == this._pPrevTimestamps[i])) {
                        continue;
                    }

                    this._pPrevTimestamps[i] = pGamepad.timestamp;
                }
            };

            GamepadMap.prototype.pollGamepads = function () {
                var pRawGamepads = (navigator.getGamepads && navigator.getGamepads()) || navigator.gamepads;
                if (akra.isDefAndNotNull(pRawGamepads)) {
                    this._pCollection.clear();

                    var isGamepadsChanged = false;

                    for (var i = 0; i < pRawGamepads.length; i++) {
                        if (typeof pRawGamepads[i] != this._pPrevRawGamepadTypes[i]) {
                            isGamepadsChanged = true;
                            this._pPrevRawGamepadTypes[i] = typeof pRawGamepads[i];

                            if (akra.isDefAndNotNull(pRawGamepads[i])) {
                                akra.debug.log("gamepad " + i + " updated: " + pRawGamepads[i].id);
                                this.updated.emit(pRawGamepads[i]);
                            }
                        }

                        if (akra.isDefAndNotNull(pRawGamepads[i])) {
                            this._pCollection.push(pRawGamepads[i]);
                        }
                    }
                    //if (isGamepadsChanged) {
                    //todo: collection changed...
                    //}
                }
            };
            return GamepadMap;
        })();
        control.GamepadMap = GamepadMap;
    })(akra.control || (akra.control = {}));
    var control = akra.control;
})(akra || (akra = {}));
/// <reference path="../idl/IKeyMap.ts" />
/// <reference path="../math/Vec2.ts" />
var akra;
(function (akra) {
    (function (control) {
        var Vec2 = akra.math.Vec2;

        var KeyMap = (function () {
            function KeyMap(pTarget) {
                this._pMap = new Array(256 /* TOTAL */);
                this._pCallbackMap = {};
                this._bMouseDown = false;
                this._v2iMousePosition = new Vec2;
                this._v2iMousePrevPosition = new Vec2;
                this._v2iMouseShift = new Vec2;
                for (var i = 256 /* TOTAL */; i--;) {
                    this._pMap[i] = false;
                }

                if (akra.isDefAndNotNull(pTarget)) {
                    this.capture(pTarget);
                }
            }
            KeyMap.prototype.bind = function (sCombination, fn) {
                var pKeys = sCombination.replace(/[\s]+/g, "").split("+");
                var pCodes = [];

                for (var i = 0; i < pKeys.length; ++i) {
                    var iCode = akra.EKeyCodes[pKeys[i].toUpperCase()];

                    if (!akra.isDef(iCode)) {
                        return false;
                    }

                    pCodes.push(iCode);
                }

                var sHash = " " + pCodes.sort().join(' ');
                var pFuncList = this._pCallbackMap[sHash];

                if (!akra.isDefAndNotNull(pFuncList)) {
                    pFuncList = this._pCallbackMap[sHash] = [];
                }

                if (pFuncList.indexOf(fn) === -1) {
                    pFuncList.push(fn);
                }

                return true;
            };

            KeyMap.prototype.capture = function (pTarget) {
                this.captureMouse(pTarget);
                this.captureKeyboard(pTarget);
            };

            KeyMap.prototype.captureMouse = function (pTarget) {
                var pKeys = this;
                var fn = function (e) {
                    pKeys.dispatch(e);
                };

                if (pTarget.addEventListener) {
                    pTarget.addEventListener("mousemove", fn, true);
                    pTarget.addEventListener("mouseup", fn, true);
                    pTarget.addEventListener("mousedown", fn, true);
                } else if (pTarget.attachEvent) {
                    pTarget.attachEvent("onmousemove", fn);
                    pTarget.attachEvent("onmouseup", fn);
                    pTarget.attachEvent("onmousedown", fn);
                } else {
                    pTarget.onmousemove = pTarget.onmouseup = pTarget.onmousedown = fn;
                }
            };

            KeyMap.prototype.captureKeyboard = function (pTarget) {
                var pKeys = this;
                var fn = function (e) {
                    pKeys.dispatch(e);
                };

                if (pTarget.addEventListener) {
                    pTarget.addEventListener("keydown", fn, false);
                    pTarget.addEventListener("keyup", fn, false);
                } else if (pTarget.attachEvent) {
                    pTarget.attachEvent("onkeydown", fn);
                    pTarget.attachEvent("onkeyup", fn);
                } else {
                    pTarget.onkeydown = pTarget.onkeyup = fn;
                }
            };

            KeyMap.prototype.dispatch = function (e) {
                if (typeof e === "undefined") { e = window.event; }
                var iCode = e.keyCode;

                if (e.type == "keydown") {
                    this._pMap[iCode] = true;

                    if (e.altKey) {
                        this._pMap[18 /* ALT */] = true;
                    }
                    if (e.ctrlKey) {
                        this._pMap[17 /* CTRL */] = true;
                    }
                    if (e.shiftKey) {
                        this._pMap[16 /* SHIFT */] = true;
                    }
                    // if (e.altKey || e.ctrlKey || e.shiftKey) {
                    //	 this._pMap.splice(0);
                    // }
                } else if (e.type == "keyup") {
                    this.callListeners();

                    this._pMap[iCode] = false;

                    if (iCode == 18 /* ALT */) {
                        this._pMap[18 /* ALT */] = false;
                    }
                    if (iCode == 17 /* CTRL */) {
                        this._pMap[17 /* CTRL */] = false;
                    }
                    if (iCode == 16 /* SHIFT */) {
                        this._pMap[16 /* SHIFT */] = false;
                    }
                }

                if (e.type == "mousemove") {
                    this._v2iMousePosition.x = e.offsetX === undefined ? e.layerX : e.offsetX;
                    this._v2iMousePosition.y = e.offsetY === undefined ? e.layerY : e.offsetY;
                } else if (e.type == "mouseup") {
                    // LOG(e);
                    this._bMouseDown = false;
                } else if (e.type == "mousedown") {
                    e.preventDefault();
                    this._v2iMousePrevPosition.x = e.offsetX === undefined ? e.layerX : e.offsetX;
                    this._v2iMousePrevPosition.y = e.offsetY === undefined ? e.layerY : e.offsetY;
                    this._bMouseDown = true;
                }
            };

            KeyMap.prototype.callListeners = function () {
                var sHash = "";

                for (var i = 0; i < this._pMap.length; ++i) {
                    if (this._pMap[i]) {
                        sHash += " " + i;
                    }
                }

                var pFuncList = this._pCallbackMap[sHash];

                if (akra.isDefAndNotNull(pFuncList)) {
                    for (var i = 0; i < pFuncList.length; ++i) {
                        pFuncList[i]();
                    }
                }
            };

            /**  */ KeyMap.prototype.isKeyPress = function (iCode) {
                return this._pMap[iCode];
            };

            /**  */ KeyMap.prototype.getMouse = function () {
                return this._v2iMousePosition;
            };

            /**  */ KeyMap.prototype.getMouseShift = function () {
                return this._v2iMouseShift.set(this._v2iMousePosition.x - this._v2iMousePrevPosition.x, this._v2iMousePosition.y - this._v2iMousePrevPosition.y);
            };

            KeyMap.prototype.isMouseMoved = function () {
                return this._v2iMousePosition.x != this._v2iMousePrevPosition.x || this._v2iMousePosition.y != this._v2iMousePrevPosition.y;
            };

            KeyMap.prototype.isMousePress = function () {
                return this._bMouseDown;
            };

            KeyMap.prototype.update = function () {
                this._v2iMousePrevPosition.set(this._v2iMousePosition);
            };
            return KeyMap;
        })();
        control.KeyMap = KeyMap;
    })(akra.control || (akra.control = {}));
    var control = akra.control;
})(akra || (akra = {}));
/// <reference path="GamepadMap.ts" />
/// <reference path="KeyMap.ts" />
var akra;
(function (akra) {
    (function (control) {
        function createGamepadMap() {
            return new control.GamepadMap;
        }
        control.createGamepadMap = createGamepadMap;

        function createKeymap(target) {
            return new control.KeyMap(target);
        }
        control.createKeymap = createKeymap;
    })(akra.control || (akra.control = {}));
    var control = akra.control;
})(akra || (akra = {}));
/// <reference path="../common.ts" />
/// <reference path="../idl/ISunLight.ts" />
/// <reference path="../core/Engine.ts" />
/// <reference path="../scene/light/SunLight.ts" />
/// <reference path="../render/Screen.ts" />
/// <reference path="../color/colors.ts" />
var akra;
(function (akra) {
    //#define SKY_GPU
    (function (model) {
        var Vec2 = akra.math.Vec2;
        var Vec3 = akra.math.Vec3;
        var Mat4 = akra.math.Mat4;
        var VE = akra.data.VertexElement;

        var Color = akra.color.Color;

        // core.Engine.depends("effects/sky.fx");
        var Sky = (function () {
            function Sky(_pEngine, nCols, nRows, fR) {
                this._pEngine = _pEngine;
                this.guid = akra.guid();
                this.skyDome = null;
                this.sun = null;
                /*private*/ this._nHorinLevel = 13;
                this.time = 0.0;
                this._v3fSunDir = new Vec3;
                this._v3fInvWavelength4 = new Vec3;
                this._v3fHG = new Vec3;
                this._v3fEye = new Vec3;
                this._v3fGroundc0 = new Vec3;
                this._v3fGroundc1 = new Vec3;
                this._v2fTex = new Vec2;
                this._pSkyBlitBox = null;
                this._pScreen = null;
                this._pSkyDomeViewport = null;
                this.k = 1;
                this.setupSignals();

                akra.logger.assert(nCols > 2);
                akra.logger.assert(nRows > 1);
                akra.logger.assert(nCols * nRows < 65535);

                this._fInnerRadius = fR;
                this._init();
                this.init();
                this.createBuffers();

                var pDomeMesh = this.createDome(nCols, nRows);

                var pSceneModel = _pEngine.getScene().createModel("dome" + this.guid);

                pSceneModel.setMesh(pDomeMesh);
                pSceneModel.accessLocalBounds().set(akra.MAX_UINT32, akra.MAX_UINT32, akra.MAX_UINT32);

                // pSceneModel.scale(this._fOuterRadius);
                this.skyDome = pSceneModel;

                this.sun = _pEngine.getScene().createLightPoint(3 /* SUN */, true, 2048);

                this.sun.attachToParent(this.skyDome);
                this.sun.setSkyDome(this.skyDome);
            }
            /** Number of sample rays to use in integral equation */
            Sky.prototype.getSize = function () {
                return this._nSize;
            };

            Sky.prototype.getSampler = function () {
                return this._nSamples;
            };

            Sky.prototype.setWaveLength = function (x, y, z) {
                var v = arguments.length > 1 ? Vec3.temp(x, y, z) : arguments[0];
                this._v3fInvWavelength4.x = 1.0 / akra.math.pow(v.x, 4.0);
                this._v3fInvWavelength4.y = 1.0 / akra.math.pow(v.y, 4.0);
                this._v3fInvWavelength4.z = 1.0 / akra.math.pow(v.z, 4.0);

                return this;
            };

            Sky.prototype.getWaveLength = function (v3fDest) {
                v3fDest = akra.isDefAndNotNull(v3fDest) ? v3fDest : Vec3.temp();
                v3fDest.x = akra.math.pow(1 / this._v3fInvWavelength4.x, 1. / 4.);
                v3fDest.y = akra.math.pow(1 / this._v3fInvWavelength4.y, 1. / 4.);
                v3fDest.z = akra.math.pow(1 / this._v3fInvWavelength4.z, 1. / 4.);
                return v3fDest;
            };

            Sky.prototype.setupSignals = function () {
            };

            Sky.prototype.getEngine = function () {
                return this._pEngine;
            };

            Sky.prototype.getSunDirection = function () {
                return this._v3fSunDir;
            };

            Sky.prototype.scale = function (fCos) {
                var x = 1.0 - fCos;
                return this._fRayleighScaleDepth * akra.math.exp(-0.00287 + x * (0.459 + x * (3.83 + x * (-6.80 + x * 5.25))));
            };

            Sky.prototype.expv = function (v) {
                return Vec3.temp(akra.math.exp(v.x), akra.math.exp(v.y), akra.math.exp(v.z));
            };

            Sky.prototype._init = function () {
                this._nSize = 32; /*Higher, Better, More CPU/GPU*/
                this._nSamples = 5; /*Higher, Better, More CPU/GPU*/
                this._fKr = 0.0025;
                this._fKm = 0.0010;
                this._fESun = 20.0;
                this._fg = -0.990;
                this._fExposure = -2.0;

                this._fRayleighScaleDepth = 0.25;
                this._fMieScaleDepth = 0.1;
                this.setWaveLength(0.650, 0.570, 0.475);
            };

            Sky.prototype.init = function () {
                // this._nSize = 32;
                // this._nSamples = 5;
                // this._fKr = 0.0025;
                this._fKr4PI = this._fKr * 4.0 * akra.math.PI;

                // this._fKm = 0.0010;
                this._fKm4PI = this._fKm * 4.0 * akra.math.PI;

                // this._fESun = 20.0;
                this._fKrESun = this._fESun * this._fKr;
                this._fKmESun = this._fESun * this._fKm;

                // this._fg = -0.990;
                this._fg2 = this._fg * this._fg;

                // this._fExposure = -2.0;
                this._fInnerRadius2 = this._fInnerRadius * this._fInnerRadius;
                this._fOuterRadius = this._fInnerRadius * 1.025;
                this._fOuterRadius2 = this._fOuterRadius * this._fOuterRadius;
                this._fScale = 1.0 / (this._fOuterRadius - this._fInnerRadius);

                // this._fRayleighScaleDepth = 0.25;
                // this._fMieScaleDepth = 0.1;
                this._fScaleOverScaleDepth = this._fScale / this._fRayleighScaleDepth;

                this._v3fHG.x = 1.5 * ((1.0 - this._fg2) / (2.0 + this._fg2));
                this._v3fHG.y = 1.0 + this._fg2;
                this._v3fHG.z = 2.0 * this._fg;
                this._v3fEye.x = 0.0;
                this._v3fEye.y = this._fInnerRadius + 1.0e-6;
                this._v3fEye.z = 0.0;
                // this._bSkyBuffer = false;
            };

            Sky.prototype.updateSunLight = function () {
                this.sun.updateSunDirection(this._v3fSunDir);
            };

            Sky.prototype.createBuffers = function () {
                var pEngine = this.getEngine();
                var pRsmgr = pEngine.getResourceManager();

                this._pSkyBuffer = pRsmgr.createTexture("sky_buffer" + this.guid);

                // this._pSkyBackBuffer = pRsmgr.createTexture("sky_back_buffer" + this.getGuid());
                this._pSkyBuffer.create(this._nSize, this._nSize, 1, null, 512 /* RENDERTARGET */, 0, 0, 3553 /* TEXTURE_2D */, 25 /* FLOAT32_RGBA */);

                // this._pSkyBackBuffer.create(this._nSize, this._nSize, 1, null, ETextureFlags.RENDERTARGET, 0, 0, ETextureTypes.TEXTURE_2D, EPixelFormats.FLOAT32_RGBA);
                this._pSkyBlitBox = new akra.pixelUtil.PixelBox(this._nSize, this._nSize, 1, 25 /* FLOAT32_RGBA */, new Uint8Array(this._pSkyBuffer.getByteLength()));

                if (akra.config.USE_ATMOSPHERIC_SCATTERING_GPU_MODE) {
                    var pScreen = this._pScreen = new akra.render.Screen(pEngine.getRenderer());

                    var pSkyDomeUpdateMethod = pRsmgr.createRenderMethod(".skydomeupdate");
                    var pSkyDomeUpdateEffect = pRsmgr.createEffect(".skydomeupdate");

                    pSkyDomeUpdateEffect.addComponent("akra.system.SkyDomeUpdate");

                    pSkyDomeUpdateMethod.setEffect(pSkyDomeUpdateEffect);
                    pScreen.getTechnique().setMethod(pSkyDomeUpdateMethod);

                    var pSkyDomeTarget = this._pSkyBuffer.getBuffer().getRenderTarget();
                    pSkyDomeTarget.setAutoUpdated(false);

                    //var pViewport: IViewport = pSkyDomeTarget.addViewport(null, ".skydomeupdate", 0, 0, 0, 1, 1);
                    var pViewport = pSkyDomeTarget.addViewport(new akra.render.Viewport(null, ".skydomeupdate", 0, 0, 0, 1, 1));
                    pViewport.setDepthParams(false, false, 0);
                    pViewport.setClearEveryFrame(false);

                    pScreen.getTechnique(".skydomeupdate").render.connect(this, this._onSkyDomeTexRender);

                    //this.connect(pScreen.getTechnique(".skydomeupdate"), SIGNAL(render), SLOT(_onSkyDomeTexRender));
                    this._pSkyDomeViewport = pViewport;
                }
            };

            Sky.prototype._onSkyDomeTexRender = function (pTechnique, iPass) {
                if (akra.config.USE_ATMOSPHERIC_SCATTERING_GPU_MODE) {
                    akra.debug.assert(iPass === 0, "invalid pass");

                    var pPass = pTechnique.getPass(iPass);

                    pPass.setUniform("nSamples", this._nSamples);
                    pPass.setUniform("fSamples", this._nSamples);
                    pPass.setUniform("fOuterRadius", this._fOuterRadius);
                    pPass.setUniform("fInnerRadius", this._fInnerRadius);
                    pPass.setUniform("fKr4PI", this._fKr4PI);
                    pPass.setUniform("fKm4PI", this._fKm4PI);
                    pPass.setUniform("fScale", this._fScale);
                    pPass.setUniform("fScaleDepth", this._fRayleighScaleDepth);
                    pPass.setUniform("fScaleOverScaleDepth", this._fScaleOverScaleDepth);
                    pPass.setUniform("fCameraHeight", this._v3fEye.y);
                    pPass.setUniform("fCameraHeight2", this._v3fEye.y * this._v3fEye.y);
                    pPass.setUniform("vSunPos", this._v3fSunDir);
                    pPass.setUniform("vEye", this._v3fEye);
                }
            };

            Sky.prototype.getWrite = function () {
                /*if (this._bSkyBuffer)*/ return this._pSkyBuffer;
                /*return this._pSkyBackBuffer;*/
            };

            Sky.prototype.getRead = function () {
                /*if (!this._bSkyBuffer) */ return this._pSkyBuffer;
                /*return this._pSkyBackBuffer;*/
            };

            Sky.prototype.updateSkyBuffer = function (pPass) {
                if (!akra.config.USE_ATMOSPHERIC_SCATTERING_GPU_MODE) {
                    var pPixelBuffer = this.getWrite().getBuffer();

                    // var pBox: IBox = geometry.box(0, 0, 0, this._nSize, this._nSize, 1);
                    // var pRect: IPixelBox = pPixelBuffer.lock(pBox, ELockFlags.WRITE);
                    // debug.assert(!isNull(pRect), "cannot lock texture");
                    // var pBuffer: Float32Array = new Float32Array(pRect.data.buffer);
                    var pBuffer = new Float32Array(this._pSkyBlitBox.data.buffer);
                    var nIndex = 0;

                    for (var x = 0; x < this._nSize; x++) {
                        var fCosxz = akra.math.cos(1.0) * x / (this._nSize - 1.0);

                        for (var y = 0; y < this._nSize; y++) {
                            var fCosy = (akra.math.PI * 2.0) * y / (this._nSize - 1.0);

                            var vVecPos = Vec3.temp();
                            var vEye = Vec3.temp(0.0, this._fInnerRadius + 1e-6, 0.0);

                            vVecPos.x = akra.math.sin(fCosxz) * akra.math.cos(fCosy) * this._fOuterRadius;
                            vVecPos.y = akra.math.cos(fCosxz) * this._fOuterRadius;
                            vVecPos.z = akra.math.sin(fCosxz) * akra.math.sin(fCosy) * this._fOuterRadius;

                            var v3Pos = Vec3.temp(vVecPos);
                            var v3Ray = v3Pos.subtract(vEye, Vec3.temp());
                            var fFar = v3Ray.length();

                            v3Ray.scale(1. / fFar);

                            // Calculate the ray's starting position, then calculate its scattering offset
                            var v3Start = Vec3.temp(vEye);
                            var fHeight = v3Start.length();
                            var fDepth = akra.math.exp(this._fScaleOverScaleDepth * (this._fInnerRadius - vEye.y));
                            var fStartAngle = v3Ray.dot(v3Start) / fHeight;
                            var fStartOffset = fDepth * this.scale(fStartAngle);

                            // Initialize the scattering loop variables
                            var fSampleLength = fFar / this._nSamples;
                            var fScaledLength = fSampleLength * this._fScale;
                            var v3SampleRay = v3Ray.scale(fSampleLength, Vec3.temp());
                            var v3SamplePoint = v3SampleRay.scale(0.5, Vec3.temp()).add(v3Start);

                            // Now loop through the sample rays
                            var v3FrontColor = Vec3.temp(0.0);

                            for (var i = 0; i < this._nSamples; i++) {
                                var fHeight = v3SamplePoint.length();
                                var fDepth = akra.math.exp(this._fScaleOverScaleDepth * (this._fInnerRadius - fHeight));
                                var fLightAngle = this._v3fSunDir.dot(v3SamplePoint) / fHeight;
                                var fCameraAngle = v3Ray.dot(v3SamplePoint) / fHeight;
                                var fScatter = (fStartOffset + fDepth * (this.scale(fLightAngle) - this.scale(fCameraAngle)));

                                var v3Attenuate = this.expv((this._v3fInvWavelength4.scale(this._fKr4PI, Vec3.temp()).add(Vec3.temp(this._fKm4PI))).scale(-fScatter));

                                v3FrontColor.add(v3Attenuate.scale(fDepth * fScaledLength, Vec3.temp()));
                                v3SamplePoint.add(v3SampleRay);
                            }

                            //D3DXVECTOR3 V = vEye - vVecPos;
                            //D3DXVec3Normalize( &V, &V );
                            pBuffer[nIndex * 4 + 0] = akra.math.min(v3FrontColor.x, 6.5519996e4);
                            pBuffer[nIndex * 4 + 1] = akra.math.min(v3FrontColor.y, 6.5519996e4);
                            pBuffer[nIndex * 4 + 2] = akra.math.min(v3FrontColor.z, 6.5519996e4);
                            pBuffer[nIndex * 4 + 3] = 0.0;

                            nIndex++;
                        }
                    }

                    var HorizonSamples = Vec3.temp(0.);

                    for (var x = 0; x < this._nSize; x++) {
                        HorizonSamples.add(Vec3.temp(pBuffer[((this._nSize - this._nHorinLevel) * this._nSize + x) * 4 + 0], pBuffer[((this._nSize - this._nHorinLevel) * this._nSize + x) * 4 + 1], pBuffer[((this._nSize - this._nHorinLevel) * this._nSize + x) * 4 + 2]));
                    }

                    HorizonSamples.scale(1. / this._nSize);

                    this._v3fGroundc0.set(HorizonSamples);
                    this._v3fGroundc1.set(HorizonSamples);

                    this._v3fGroundc0.x *= this._v3fInvWavelength4.x * this._fKrESun;
                    this._v3fGroundc0.y *= this._v3fInvWavelength4.y * this._fKrESun;
                    this._v3fGroundc0.z *= this._v3fInvWavelength4.z * this._fKrESun;
                    this._v3fGroundc1.scale(this._fKmESun);

                    pPixelBuffer.blitFromMemory(this._pSkyBlitBox);

                    // pPixelBuffer.unlock();
                    // this._bSkyBuffer = !this._bSkyBuffer;
                    if (this.sun) {
                        this.sun.getParams().groundC0.set(this._v3fGroundc0);
                        this.sun.getParams().groundC1.set(this._v3fGroundc1);
                        this.sun.getParams().eyePosition.set(this._v3fEye);
                        this.sun.getParams().sunDir.set(this._v3fSunDir);
                        this.sun.getParams().hg.set(this._v3fHG);
                        // LOG(this._v3fGroundc0.toString(), this._v3fGroundc1.toString())
                    }
                } else {
                    //pViewport.startFrame();
                    //pViewport.renderObject(this._pScreen);
                    //pViewport.endFrame();
                    //// Horizon fog color
                    //D3DXVECTOR3 HorizonSamples = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
                    //float fCosxz = (D3DX_PI * 0.5f);
                    //for(UINT y = 0; y < m_nSize; y++)
                    //{
                    //	float fCosy = (D3DX_PI * 2.0f) * y / (float)(m_nSize - 1);
                    //	D3DXVECTOR3 vVecPos, vEye = D3DXVECTOR3(0.0f, m_fInnerRadius + 1e-6f, 0.0f);
                    //		vVecPos.x = m_fOuterRadius * sin(fCosxz) * cos(fCosy);
                    //		vVecPos.z = m_fOuterRadius * sin(fCosxz) * sin(fCosy);
                    //		vVecPos.y = m_fOuterRadius * cos(fCosxz);
                    //	D3DXVECTOR3 v3Pos = vVecPos;
                    //	D3DXVECTOR3 v3Ray = v3Pos - vEye;
                    //	float fFar = D3DXVec3Length(&v3Ray);
                    //		v3Ray /= fFar;
                    //	// Calculate the ray's starting position, then calculate its scattering offset
                    //	D3DXVECTOR3 v3Start = vEye;
                    //	float fHeight = D3DXVec3Length(&v3Start);
                    //	float fDepth = exp(m_fScaleOverScaleDepth * (m_fInnerRadius - vEye.y));
                    //	float fStartAngle = D3DXVec3Dot(&v3Ray, &v3Start) / fHeight;
                    //	float fStartOffset = fDepth * scale(fStartAngle);
                    //	// Initialize the scattering loop variables
                    //	float fSampleLength = fFar / m_nSamples;
                    //	float fScaledLength = fSampleLength * m_fScale;
                    //	D3DXVECTOR3 v3SampleRay = v3Ray * fSampleLength;
                    //	D3DXVECTOR3 v3SamplePoint = v3Start + v3SampleRay * 0.5f;
                    //	// Now loop through the sample rays
                    //	D3DXVECTOR3 v3Attenuate;
                    //	for(unsigned int i = 0; i < m_nSamples; i++)
                    //	{
                    //		float fHeight = D3DXVec3Length(&v3SamplePoint);
                    //		float fDepth = exp(m_fScaleOverScaleDepth * (m_fInnerRadius - fHeight));
                    //		float fLightAngle = D3DXVec3Dot(&this._v3fSunDir, &v3SamplePoint) / fHeight;
                    //		float fCameraAngle = D3DXVec3Dot(&v3Ray, &v3SamplePoint) / fHeight;
                    //		float fScatter = (fStartOffset + fDepth * (scale(fLightAngle) - scale(fCameraAngle)));
                    //			v3Attenuate = expv(-fScatter * (m_v3fInvWavelength4 * m_fKr4PI + D3DXVECTOR3(m_fKm4PI, m_fKm4PI, m_fKm4PI)));
                    //			HorizonSamples += v3Attenuate * (fDepth * fScaledLength);
                    //			v3SamplePoint += v3SampleRay;
                    //		}
                    //	}
                    //	HorizonSamples /= (float) m_nSize;
                    //	m_v3fGroundc0 = m_v3fGroundc1 = HorizonSamples;
                    //	m_v3fGroundc0.x *= (m_v3fInvWavelength4.x * m_fKrESun);
                    //	m_v3fGroundc0.y *= (m_v3fInvWavelength4.y * m_fKrESun);
                    //	m_v3fGroundc0.z *= (m_v3fInvWavelength4.z * m_fKrESun);
                    //	m_v3fGroundc1 *= m_fKmESun;
                }
            };

            Sky.prototype.createDome = function (Cols, Rows) {
                var DVSize = Cols * Rows;
                var DISize = (Cols - 1) * (Rows - 1) * 2;

                var pDome = this.getEngine().createMesh("dome", akra.EMeshOptions.HB_READABLE);

                // Fill the Vertices Buffer
                var pVertices = new Float32Array(DVSize * 3 + DVSize * 2);

                var DomeIndex = 0;

                for (var i = 0; i < Cols; i++) {
                    var MoveXZ = akra.math.cos(1.0) * i / (Cols - 1);
                    for (var j = 0; j < Rows; j++) {
                        var MoveY = (akra.math.PI * 2.0) * j / (Rows - 1);

                        pVertices[DomeIndex * 5 + 0] = akra.math.sin(MoveXZ) * akra.math.cos(MoveY);
                        pVertices[DomeIndex * 5 + 1] = akra.math.cos(MoveXZ);
                        pVertices[DomeIndex * 5 + 2] = akra.math.sin(MoveXZ) * akra.math.sin(MoveY);

                        pVertices[DomeIndex * 5 + 3] = j / (Rows - 1.0);
                        pVertices[DomeIndex * 5 + 4] = i / (Cols - 1.0);

                        DomeIndex++;
                    }
                }

                // console.log(pVertices);
                // Fill the Indices Buffer
                var pIndices = new Uint16Array(DISize * 3);
                DomeIndex = 0;

                for (var i = 0; i < Rows - 1; i++) {
                    for (var j = 0; j < Cols - 1; j++) {
                        pIndices[DomeIndex++] = i * Rows + j;
                        pIndices[DomeIndex++] = (i + 1) * Rows + j;
                        pIndices[DomeIndex++] = (i + 1) * Rows + j + 1;

                        pIndices[DomeIndex++] = (i + 1) * Rows + j + 1;
                        pIndices[DomeIndex++] = i * Rows + j + 1;
                        pIndices[DomeIndex++] = i * Rows + j;
                    }
                }

                var pSubMesh = pDome.createSubset("main", 4 /* TRIANGLELIST */, akra.ERenderDataBufferOptions.RD_SINGLE_INDEX);

                var e = pSubMesh.getData().allocateData([VE.float3("POSITION"), VE.float2("TEXCOORD0")], pVertices);
                pSubMesh.getData().allocateIndex([VE.float("INDEX0")], pIndices);
                pSubMesh.setShadow(false);

                var pMatrial = pSubMesh.getRenderMethod().getSurfaceMaterial().getMaterial();
                pMatrial.diffuse = akra.color.LIGHT_GRAY;
                pMatrial.ambient = new Color(0.7, 0.7, 0.7, 1.);
                pMatrial.specular = new Color(0.7, 0.7, 0.7, 1);
                pMatrial.emissive = new Color(0., 0., 0., 1.);
                pMatrial.shininess = 30.;

                if (this.getEngine().isLoaded()) {
                    pSubMesh.getRenderMethod().getEffect().addComponent("akra.system.sky");
                } else {
                    //this.getEngine().bind(SIGNAL(depsLoaded), () => {
                    //	pSubMesh.renderMethod.effect.addComponent("akra.system.sky");
                    //});
                    this.getEngine().depsLoaded.connect(function () {
                        pSubMesh.getRenderMethod().getEffect().addComponent("akra.system.sky");
                    });
                }

                pSubMesh.getTechnique().render.connect(this, this._onDomeRender);

                //this.connect(pSubMesh.getTechnique(), SIGNAL(render), SLOT(_onDomeRender));
                return pDome;
            };

            // update(pModelView: IMat4, pProjection: IMat4, pPass: IRenderPass): void {
            Sky.prototype.update = function (pSceneObject, pCamera, pPass) {
                var pProjection = pCamera.getProjectionMatrix();
                var m4fModel = Mat4.temp(pSceneObject.getWorldMatrix());

                // pModelView.data[__41] = 0.0;
                // pModelView.data[__42] = 0.0;
                // pModelView.data[__43] = 0.0;
                m4fModel.setTranslation(Vec3.temp(0.0, -this._fInnerRadius - 1.0e-6, 0.0).add(pCamera.getWorldPosition()));
                m4fModel.scaleRight(Vec3.temp(this._fOuterRadius * this.k));

                var pModelView = pCamera.getViewMatrix().multiply(m4fModel, Mat4.temp());

                // var m4fTranslation: IMat4 = Mat4.temp(1.).setTranslation(Vec3.temp(0.0, -this._fInnerRadius - 1.0e-6, 0.0));
                // pModelView.multiply(m4fTranslation);
                var MP = pProjection.multiply(pModelView, Mat4.temp());

                this._v2fTex.set(this._nSize, 1.0 / this._nSize);

                pPass.setUniform("WorldViewProjection", MP);
                pPass.setUniform("WorldView", pModelView);
                pPass.setUniform("fKrESun", this._fKrESun);
                pPass.setUniform("fKmESun", this._fKmESun);
                pPass.setUniform("Tex", this._v2fTex);
                pPass.setUniform("vSunPos", this._v3fSunDir);
                pPass.setUniform("vHG", this._v3fHG);
                pPass.setUniform("vInvWavelength", this._v3fInvWavelength4);
                pPass.setUniform("vEye", this._v3fEye);
                pPass.setUniform("fOuterRadius", this._fOuterRadius);

                pPass.setTexture("tSkyBuffer", this.getRead());
            };

            Sky.prototype.setTime = function (T) {
                var time = this.time = T;
                var meridian = 56.48 * akra.math.RADIAN_RATIO;
                var longitude = 105.5 * akra.math.RADIAN_RATIO;
                var latitude = 0.762127107;
                var day = 172;

                var t, delta;
                var A, B, C, D, E, F;

                A = 4 * akra.math.PI * (day - 80) / 373;
                B = 2 * akra.math.PI * (day - 8) / 355;
                C = 2 * akra.math.PI * (day - 81) / 368;

                t = time + 0.170 * akra.math.sin(A) - 0.129 * akra.math.sin(B) + 12 * (meridian - longitude) / akra.math.PI;

                delta = 0.4093 * akra.math.sin(C);

                D = akra.math.PI * t / 12;

                E = akra.math.sin(latitude) * akra.math.sin(delta) - akra.math.cos(latitude) * akra.math.cos(delta) * akra.math.cos(D);

                F = (-akra.math.cos(delta) * akra.math.sin(D)) / (akra.math.cos(latitude) * akra.math.sin(delta) - akra.math.sin(latitude) * akra.math.cos(delta) * akra.math.cos(D));

                this._fSunTheta = akra.math.PI * 0.5 - akra.math.asin(E);
                this._fSunPhi = akra.math.atan(F);

                /*
                vSunDir.x = math.cos(this._fSunPhi) * math.sin(this._fSunTheta);
                vSunDir.y = math.sin(this._fSunPhi) * math.sin(this._fSunTheta);
                vSunDir.z = math.cos(this._fSunTheta);
                */
                this._v3fSunDir.x = 0.0;
                this._v3fSunDir.y = akra.math.cos(T * 0.1);
                this._v3fSunDir.z = akra.math.sin(T * 0.1);

                var Zenith = Vec3.temp(0, 1, 0);
                this._fSunTheta = akra.math.acos(this._v3fSunDir.dot(Zenith));

                this._v3fSunDir.normalize();

                this.updateSkyBuffer(null);
                this.updateSunLight();
            };

            Sky.prototype._onDomeRender = function (pTechnique, iPass, pRenderable, pSceneObject, pViewport) {
                var pPass = pTechnique.getPass(iPass);
                var pCamera = pViewport.getCamera();
                this.update(pSceneObject, pCamera, pPass);
            };
            return Sky;
        })();
        model.Sky = Sky;
    })(akra.model || (akra.model = {}));
    var model = akra.model;
})(akra || (akra = {}));
/// <reference path="../common.ts" />
/// <reference path="../idl/IEngine.ts" />
/// <reference path="../idl/ISceneManager.ts" />
/// <reference path="../idl/IParticleManager.ts" />
/// <reference path="../idl/IResourcePoolManager.ts" />
/// <reference path="../idl/IRenderer.ts" />
/// <reference path="../idl/IUtilTimer.ts" />
/// <reference path="../idl/IScene3d.ts" />
/// <reference path="../idl/IAFXComposer.ts" />
/// <reference path="../idl/ISpriteManager.ts" />
/// <reference path="../pool/ResourcePoolManager.ts" />
/// <reference path="../scene/SceneManager.ts" />
/// <reference path="../util/UtilTimer.ts" />
/// <reference path="../fx/Composer.ts" />
/// <reference path="../pixelUtil/DDSCodec.ts" />
/// <reference path="../data/RenderDataCollection.ts" />
/// <reference path="../data/BufferMap.ts" />
/// <reference path="../model/Mesh.ts" />
/// <reference path="../animation/Controller.ts" />
/// <reference path="../model/Skeleton.ts" />
/// <reference path="../deps/deps.ts" />
/// <reference path="../control/control.ts" />
/// <reference path="../webgl/WebGLRenderer.ts" />
/// <reference path="../model/Sky.ts" />

var akra;
(function (akra) {
    (function (core) {
        akra.debug.log("config['data'] = " + akra.config.data);

        var EEngineStatus;
        (function (EEngineStatus) {
            EEngineStatus[EEngineStatus["PAUSED"] = 0x1] = "PAUSED";
            EEngineStatus[EEngineStatus["FROZEN"] = 0x2] = "FROZEN";
            EEngineStatus[EEngineStatus["LOADED"] = 0x4] = "LOADED";
            EEngineStatus[EEngineStatus["HIDDEN"] = 0x8] = "HIDDEN";
            EEngineStatus[EEngineStatus["LAUNCHED"] = 0x10] = "LAUNCHED";
        })(EEngineStatus || (EEngineStatus = {}));

        var Engine = (function () {
            function Engine(pOptions) {
                if (typeof pOptions === "undefined") { pOptions = null; }
                var _this = this;
                this.guid = akra.guid();
                this._iStatus = 0;
                this._pGamepads = null;
                this._fElapsedAppTime = 0.0;
                this.setupSignals();

                this._pResourceManager = new akra.pool.ResourcePoolManager(this);

                akra.debug.assert(this._pResourceManager.initialize(), 'cannot initialize ResourcePoolManager');

                this._pSceneManager = new akra.scene.SceneManager(this);

                akra.debug.assert(this._pSceneManager.initialize(), "cannot initialize SceneManager");

                this._pParticleManager = null;
                this._pSpriteManager = new akra.scene.SpriteManager(this);
                this._pTimer = akra.util.UtilTimer.start();

                if (akra.config.WEBGL) {
                    var pRendererOptions = pOptions ? pOptions.renderer : null;
                    this._pRenderer = new akra.webgl.WebGLRenderer(this, pRendererOptions);
                } else {
                    akra.logger.critical("render system not specified");
                }

                this._pComposer = new akra.fx.Composer(this);

                akra.info.visibility.visibilityChanged.connect(function (pInfo, bVisible) {
                    _this._setHidden(!bVisible);
                });

                this.play();
                this.parseOptions(pOptions);
            }
            Engine.prototype.setupSignals = function () {
                this.frameStarted = this.frameStarted || new akra.Signal(this);
                this.frameEnded = this.frameEnded || new akra.Signal(this);
                this.depsLoaded = this.depsLoaded || new akra.Signal(this);
                this.inactive = this.inactive || new akra.Signal(this);
                this.active = this.active || new akra.Signal(this);
            };

            /** Get app time */
            Engine.prototype.getTime = function () {
                return this._pTimer.getAppTime();
            };

            Engine.prototype.getElapsedTime = function () {
                return this._fElapsedAppTime;
            };

            Engine.prototype.enableGamepads = function () {
                if (!akra.isNull(this._pGamepads)) {
                    return true;
                }

                var pGamepads = akra.control.createGamepadMap();

                if (pGamepads.init()) {
                    this._pGamepads = pGamepads;
                    return true;
                }

                return false;
            };

            Engine.prototype.getGamepads = function () {
                if (this.enableGamepads()) {
                    return this._pGamepads;
                }

                return null;
            };

            Engine.prototype.parseOptions = function (pOptions) {
                var _this = this;
                //== Depends Managment ====================================
                var pDeps = akra.config.coreDeps;

                //read options
                if (!akra.isNull(pOptions)) {
                    var sDepsRoot = pOptions.path || akra.config.data;

                    //default deps has higher priority!
                    if (akra.isDefAndNotNull(pOptions.deps)) {
                        pDeps = akra.deps.link(pDeps, pOptions.deps);
                    }

                    if (pOptions.gamepads) {
                        this.enableGamepads();
                    }
                }

                akra.deps.load(this, pDeps, sDepsRoot, function (e, pDep) {
                    if (!akra.isNull(e)) {
                        akra.logger.critical(e);
                    }

                    akra.debug.log("\t\tloaded / ", arguments);

                    _this._iStatus = akra.bf.setAll(_this._iStatus, 4 /* LOADED */);

                    akra.debug.info("%cEngine dependecies loaded.", "color: green;");
                    _this.depsLoaded.emit(pDep);
                }, pOptions.progress || null);
            };

            Engine.prototype.getSpriteManager = function () {
                return this._pSpriteManager;
            };

            Engine.prototype.getScene = function () {
                return this._pSceneManager.getScene3D(0);
            };

            Engine.prototype.getSceneManager = function () {
                return this._pSceneManager;
            };

            Engine.prototype.getParticleManager = function () {
                return null;
            };

            Engine.prototype.getResourceManager = function () {
                return this._pResourceManager;
            };

            Engine.prototype.getRenderer = function () {
                return this._pRenderer;
            };

            Engine.prototype.getComposer = function () {
                return this._pComposer;
            };

            Engine.prototype.isActive = function () {
                return this.isLaunched() && !this.isPaused() && !this.isHidden() && this.isLoaded();
            };

            Engine.prototype.isPaused = function () {
                return (this._iStatus & 1 /* PAUSED */) > 0;
            };

            Engine.prototype.isLoaded = function () {
                return (this._iStatus & 4 /* LOADED */) > 0;
            };

            Engine.prototype.isHidden = function () {
                return (this._iStatus & 8 /* HIDDEN */) > 0;
            };

            Engine.prototype.isFrozen = function () {
                return (this._iStatus & 2 /* FROZEN */) > 0;
            };

            Engine.prototype.isLaunched = function () {
                return (this._iStatus & 16 /* LAUNCHED */) > 0;
            };

            Engine.prototype.exec = function (bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                if (bValue == this.isLaunched()) {
                    return;
                }

                var pRenderer = this._pRenderer;
                var pEngine = this;

                akra.logger.assert(!akra.isNull(pRenderer));

                pRenderer._initRenderTargets();

                this._setLaunched(bValue);

                // Infinite loop, until broken out of by frame listeners
                // or break out by calling queueEndRendering()
                function render(iTime) {
                    akra.debug.assert(!akra.config.DEBUG || pRenderer.isValid(), pRenderer.getError());

                    if (pEngine.isActive() && pEngine.isLoaded()) {
                        if (!pEngine.renderFrame()) {
                            akra.debug.error("Engine::exec() error.");
                            return;
                        }
                    }

                    requestAnimationFrame(render);
                }

                render(0);
            };

            Engine.prototype.renderFrame = function () {
                this._fElapsedAppTime = this._pTimer.getElapsedTime();

                // FrameMove (animate) the scene
                if (!this.isFrozen()) {
                    if (!akra.isNull(this._pGamepads)) {
                        this._pGamepads.update();
                    }
                    this._pSceneManager.update();
                }

                // Render the scene as normal
                this.frameStarted.emit();
                this._pRenderer._updateAllRenderTargets();
                this.frameEnded.emit();

                // this._pSceneManager.preUpdate();
                return true;
            };

            Engine.prototype.play = function () {
                if (this.isPaused()) {
                    this._setPaused(false);
                }
            };

            Engine.prototype.pause = function () {
                if (!this.isPaused()) {
                    this._setPaused(true);
                }
            };

            Engine.prototype._stop = function () {
                if (!this.isActive() && !this._pTimer.isStopped()) {
                    this._pTimer.stop();
                    this.inactive.emit();
                }
            };

            Engine.prototype._start = function () {
                if (this.isActive() && this._pTimer.isStopped()) {
                    this._pTimer.start();
                    this.active.emit();
                }
            };

            Engine.prototype._setPaused = function (bValue) {
                this._iStatus = akra.bf.setAll(this._iStatus, 1 /* PAUSED */, bValue);

                if (bValue) {
                    this._stop();
                } else {
                    this._start();
                }
            };

            //callback for visibility api
            Engine.prototype._setHidden = function (bValue) {
                this._iStatus = akra.bf.setAll(this._iStatus, 8 /* HIDDEN */, bValue);

                if (bValue) {
                    this._stop();
                } else {
                    this._start();
                }
            };

            Engine.prototype._setLaunched = function (bValue) {
                this._iStatus = akra.bf.setAll(this._iStatus, 16 /* LAUNCHED */, bValue);

                if (bValue) {
                    this._start();
                } else {
                    this._stop();
                }
            };

            Engine.prototype.createMesh = function (sName, eOptions, pDataBuffer) {
                if (typeof sName === "undefined") { sName = null; }
                if (typeof eOptions === "undefined") { eOptions = 0; }
                if (typeof pDataBuffer === "undefined") { pDataBuffer = null; }
                return akra.model.createMesh(this, sName, eOptions, pDataBuffer);
            };

            Engine.prototype.createRenderDataCollection = function (iOptions) {
                if (typeof iOptions === "undefined") { iOptions = 0; }
                return akra.data.createRenderDataCollection(this, iOptions);
            };

            Engine.prototype.createBufferMap = function () {
                return akra.data.createBufferMap(this);
            };

            Engine.prototype.createAnimationController = function (sName, iOptions) {
                return akra.animation.createController(this, sName, iOptions);
            };

            Engine.prototype.ready = function (cb) {
                if (this.isLoaded()) {
                    if (cb) {
                        cb(this);
                    }

                    return true;
                }

                this.depsLoaded.connect(cb);

                return false;
            };
            return Engine;
        })();
        core.Engine = Engine;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
/// <reference path="ajax.ts" />
/// <reference path="exchange/Exporter.ts" />
/// <reference path="exchange/Importer.ts" />
/// <reference path="core/Engine.ts" />
var akra;
(function (akra) {
    console.log("\
                                                                                                                              \n\
                7732522331177                                                                                                 \n\
             34577    77117771262                                                                                             \n\
          727             77377                                                                                               \n\
         7               77                                                                                                   \n\
                     737              7                                                                                       \n\
                  737      7747       0           77777          777        777     777777777777             77777            \n\
              717      77    27       31         31171717       7771     7541       2777       7172         3737373           \n\
      217      77            5        13        371   1777      7777   717          177         7777       371   371          \n\
      1777377     77     5   2       773       177     7777     7777 76177          171   77    111       177     7717        \n\
      777777 717      7  3   5       173      1771     77777    7777    137         171     3437         3777     71717       \n\
       37777     737     1   2      1717    7371  77777  7713   7771      1557      273       737      7371   7777  1737      \n\
        1777        737  3   5    77777    7777           7777  7777        7717    777         737   7777           7777     \n\
         3771           74   177177717                                                                                        \n\
          7373               3777711                                                                                          \n\
            7143             37737                                                                                            \n\
               7347          57                                                                                               \n\
                                                                                                                              \n\
                                                                                                                              \n\
");

    // Register image codecs
    akra.pixelUtil.DDSCodec.startup();

    var _Vec2 = akra.math.Vec2;
    var _Vec3 = akra.math.Vec3;
    var _Vec4 = akra.math.Vec4;
    var _Mat3 = akra.math.Mat3;
    var _Mat4 = akra.math.Mat4;
    var _Quat4 = akra.math.Quat4;
    var _Color = akra.color.Color;

    akra.Vec2 = _Vec2;
    akra.Vec3 = _Vec3;
    akra.Vec4 = _Vec4;

    akra.Mat3 = _Mat3;
    akra.Mat4 = _Mat4;

    akra.Quat4 = _Quat4;

    akra.Color = _Color;

    function createEngine(pOtions) {
        return new akra.core.Engine(pOtions);
    }
    akra.createEngine = createEngine;
})(akra || (akra = {}));
